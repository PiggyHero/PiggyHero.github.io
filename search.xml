<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【C++1】头文件-库文件-命名空间的关系</title>
    <url>/2021/10/21/%E3%80%90C++1%E3%80%91%E5%A4%B4%E6%96%87%E4%BB%B6-%E5%BA%93%E6%96%87%E4%BB%B6-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>介绍了头文件，库文件，命名空间之间的关系</p>
<span id="more"></span>
<p>头文件是一个文本文件。里面包括了变量声明，数据结构定义，库文件中函数的使用方法和接口(函数具体的实现都在库文件中)。<br>库文件是二进制文件。<br>命名空间是为了避免不同库中有命名相同的函数，相当于给这些函数加上了姓氏。</p>
<p>以C为例，最早的时候，只有一个C文件，然后需要编译为可执行的二进制文件。但是后来发现，实现复杂功能的时候，代码行数太多了，于是便把这个文件分割一下，分别来看。</p>
<p>于是，就把方法(函数)和声明单独放在同一个文件中，然后把这个文件加进来，放在头部，这样就可以在C文件中随意的摆放函数了，整理起来比较方便。久而久之，这个文件都是通常放在C文件的头部，因此就有了头文件的名字。头文件就是把一些常量的定义、数据结构的定义、函数的功能实现啥的放在里面，本质上就是一个文本文件，和写在C文件里是一样的，并没有什么特别的。<code>#include</code>进来的头文件都是原封不动的在编译阶段直接插入到C源文件中。</p>
<p>而库文件是已经编译好的二进制文件，因为没有<code>main()</code>这个入口函数，所以没有办法直接启动，但是里面是实实在在的二进制代码。那么它有什么用呢？</p>
<p>以前编译一个程序，就是输入C源文件，然后输出一个可执行的二进制文件。但是当C源文件的代码越写越多，越来越复杂，编译的时间特别长。这样一来，只要是修改了代码，就需要整体的重新编译一遍，消耗很多不必要的时间。于是人们为了避免反复的编译未改动的代码，就产生了库文件。</p>
<p>把一个完整的C文件分开，分成不同功能的文件，然后只要把这些文件编译成一个二进制的软件包，最后把它们拼在一起，就是库文件。这样一来基本不会被改动的代码就不需要再一次编译了，只需要编译改动的文件就可以啦。</p>
<p>库文件出现了，有的人灵光一闪，我可以只发布库文件啊，源代码还是在我这里，这样不就可以卖钱了吗？真是一个伟大的想法！但是光卖库文件不行啊，都被编译成二进制文件了，里面有哪些方法，有哪些常量别人没法知道啊！没关系我可以写文档啊。但是编译器不知道，而且也不懂读文档怎么办？好办，不是有头文件么，反正头文件只有声明，没有实现代码，就用头文件当编译器的文档好了。就这样人类读文档，编译器读头文件，然后有人卖库文件，一条产业链就此形成。</p>
<p>后来发现一个问题，有两个聪明人编写了两个库，两个库里面居然有相同的方法名称，这下编译器就糊涂了，后来发现一个问题，有两个聪明人编写了两个库，两个库里面居然有相同的方法名称，这下编译器就糊涂了，在自己写的库中，所有的函数名、常量名、解构名都带上自己的姓名做前缀名，这样就算方法名是一样的，但是有不同的前缀名，这样就能区分到底该链接哪个方法了。后来又来一个聪明人，觉得你们这样在每个方法、常量、结构体中都写上你们的姓名累不累啊，这样，我给你们设计一套规则，只要在库的最前面写上你们的姓名不就行了么，用的时候编译器先去找找你们的姓名，然后再你们的姓名下面找方法，这不就多快好省了么。那这样吧我们就给这个姓名取名字<code>namespace</code>吧。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++2】侯捷大气编程(上)</title>
    <url>/2021/11/10/%E3%80%90C++2%E3%80%91%E4%BE%AF%E6%8D%B7%E5%A4%A7%E6%B0%94%E7%BC%96%E7%A8%8B(%E4%B8%8A)/</url>
    <content><![CDATA[<p>本课程要有一点点C或C++的基础，学习效果会更好哦。<br>侯捷老师讲的特别通透，听完收获很大。<br><span id="more"></span></p>
<h1 id="Lesson1-简介"><a href="#Lesson1-简介" class="headerlink" title="Lesson1 简介"></a>Lesson1 简介</h1><p><strong>课程基础：</strong></p>
<ul>
<li>曾经学过某种面向过程的编程语言(procedural language)</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215004928.png" alt="image-20211110062021618"></p>
<ul>
<li><p>知道程序的编译链接过程</p>
</li>
<li><p>知道如何编译链接，如何建立一个可执行程序</p>
</li>
</ul>
<p><strong>课程目标：</strong></p>
<ul>
<li>培养正规大气的编程习惯</li>
<li><p>以良好的方式编写C++ Class（对于单一的类，我们叫做基于对象的编程）</p>
<ul>
<li>有指针的Class</li>
<li>没有指针的Class</li>
</ul>
</li>
<li><p>学习Class之间的关系（对于多个Class之间的关系，称为面向对象的编程）</p>
<ul>
<li>继承(inheritance)</li>
<li>复合(composition)</li>
<li>委托(deligation)</li>
</ul>
</li>
</ul>
<blockquote>
<p>学会了一种语言，编程思想掌握了，除了具体语法有一些差异，其他语言也就学会了。</p>
</blockquote>
<p>C++包括：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215004935.png" alt="image-20211110064133887" style="zoom: 25%;" /></p>
<p>标准库很重要，一个C++程序员一定会用标准库。</p>
<p><strong>C++推荐书籍：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005323.png" alt="image-20211215005323692" style="zoom:33%;" /></p>
<p>还有Effective C++ ，STL源码剖析。</p>
<p>本课程有两个例子，一个是写一个复数complex，另一个是写字符串string。后面都是用到这两个例子，就不再多说明了。</p>
<h1 id="Lesson2-头文件与类声明文件"><a href="#Lesson2-头文件与类声明文件" class="headerlink" title="Lesson2 头文件与类声明文件"></a>Lesson2 头文件与类声明文件</h1><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005345.png" alt="image-20211110064729929" style="zoom: 25%;" /></p>
<p>一个程序中，包括数据和函数，函数是用来处理数据的，但是在C中，数据是全局的，各个函数都可以去处理它们，C++的思想就是把数据和处理这种数据的函数包在一起，这就是类。类是C语言中的Structure的升级，带有一些新的特性。</p>
<h2 id="带指针的class和不带指针的class"><a href="#带指针的class和不带指针的class" class="headerlink" title="带指针的class和不带指针的class"></a>带指针的class和不带指针的class</h2><p>不带指针的class，如复数，class创建了多个对象，这些对象中的数据部分占用的大小是一样的，然后用class中的函数可以处理这些数据，注意这里的函数只有一份，不是每个对象里都有一个函数。</p>
<p>而带指针的class，如字符串，每个字符串的长度不同，所以大小也是不同的，class中的数据类型是固定的，大小不可以变化，所以class中定义了指针，用指针指向字符串，然后每个指针占用的大小是相同的。</p>
<h2 id="代码的基本形式"><a href="#代码的基本形式" class="headerlink" title="代码的基本形式"></a>代码的基本形式</h2><p> 包括：</p>
<ul>
<li>头文件</li>
<li>主程序</li>
</ul>
<p>其实是一样的，只不过有角色的区分，所以分为头文件和主程序。</p>
<p>引用标准库的头文件用<code>&lt;&gt;</code> ，自己写的用<code>&quot;&quot;</code></p>
<p>而且，头文件的延伸文件名不一定是<code>.h</code> <code>.cpp</code>，也可能是<code>.hpp</code>或其他的扩展名 。</p>
<p>Eg. <code>complex.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLEX__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上述的代码是一个防卫式声明，防止头文件被反复的包含。</p>
<h2 id="头文件布局"><a href="#头文件布局" class="headerlink" title="头文件布局"></a>头文件布局</h2><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005426.png" alt="image-20211215005426587" style="zoom:50%;" /></p>
<p>头文件最主要的是上图中的1和2，1是类的声明，就是声明一下类中有哪些变量，哪些函数。2是类中函数的具体定义。但有时在做1和2时，一些东西应该先声明过，所以这就有了0前置声明。</p>
<h2 id="class语法部分"><a href="#class语法部分" class="headerlink" title="class语法部分"></a>class语法部分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>		//<span class="keyword">class</span> <span class="title">head</span></span></span><br><span class="line"><span class="class">&#123;</span>								<span class="comment">//class body</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span> (<span class="keyword">double</span> r=<span class="number">0</span>,<span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，类的声明部分，要有class head，也就是类的名字，然后下面的大括号里面是class body。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>下面我们慢慢发展我们的代码。</p>
<p>看上面类中的数据部分，re和im是double类型的，但是如果我们想要写成别的类型时，也不能反复的写好多个类呀，所以这时候就可以用到模板，这样我们就可以在定义对象的时候再制定里面数据的类型了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//使用模板，要在类前加上这句话,这里的T是一个符号，任何符号都行。这就是告诉编译器T是一个模板。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>		</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	T re，im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在用的时候，我们就可以把T替换成我们制定的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex&lt;<span class="keyword">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">1.5</span>)</span></span>;</span><br><span class="line"><span class="function">complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="Lesson3-构造函数"><a href="#Lesson3-构造函数" class="headerlink" title="Lesson3 构造函数"></a>Lesson3 构造函数</h1><p>我们现在不再介绍模板，回到我们的代码继续发展。</p>
<h2 id="内联-inline-函数"><a href="#内联-inline-函数" class="headerlink" title="内联(inline)函数"></a>内联(inline)函数</h2><p>在声明类的时候，我们也可以直接在类中定义函数，这种定义就叫做内联函数。</p>
<p>内联函数的好处就是调用的时候很快，但是是否是内联函数还要由编译器决定。编译器会根据函数的复杂程度自行决定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>		</span></span><br><span class="line"><span class="class">&#123;</span>								</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span> (<span class="keyword">double</span> r=<span class="number">0</span>,<span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> re;&#125;<span class="comment">//这个函数很简单，很有可能被编译器编程内联函数。</span></span><br><span class="line">  	<span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码是直接在类的声明的时候定义了函数。我们也可以在后面具体定义函数的时候定义内联函数，此时就要加上关键字<code>inline</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">complex::imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>在class body中，定义了访问级别。主要有public，private和protect。</p>
<p>主要介绍public和private。</p>
<p>public就是公开的，外部可以看的到。</p>
<p>private就是只有该class里可以看的到，一般数据部分会放到private里。</p>
<p>函数也分为类自己的函数还有给外部用的函数。</p>
<p>在写代码时，各个段落是可以互相交错的。先public再private然后再public。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建一个对象，构造函数会被自动调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;<span class="comment">//赋初始值</span></span><br><span class="line">complex c2;<span class="comment">//不赋值，默认创建</span></span><br><span class="line">complex* p = <span class="keyword">new</span> <span class="built_in">complex</span>(<span class="number">3</span>,<span class="number">1</span>);<span class="comment">//动态创建，创建了一个该类的指针</span></span><br></pre></td></tr></table></figure>
<p>构造函数名一定要和类的名字相同。</p>
<p>函数的参数是可以有默认值的，在创建对象的时候没有指明参数，就使用默认值。</p>
<p>构造函数是没有返回类型的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>		</span></span><br><span class="line"><span class="class">&#123;</span>								</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span> (<span class="keyword">double</span> r=<span class="number">0</span>,<span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的写法是一种大气规范的写法。只有构造函数有这种写法。</p>
<p><code>re(r)</code> 和 <code>im(i)</code> 就是把r和i的值赋值给class的数据。当然也可以写到大括号里，但是这样的写法不好。</p>
<blockquote>
<p>不带指针的类一般不用写析构函数。</p>
</blockquote>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>构造函数可以有多个重载。因为要被初始化，可能有很多种情况的设定，所以需要不同方法的构造函数。</p>
<blockquote>
<p>当然一般的函数也可以重载，事实上，在我们写代码的时候，函数名是一样的，但是当进行编译的时候，由于传入的参数类型，个数还有返回值的类型不同，编译器编译后的代码显示的函数名是不一样的。只是我们人类在看的时候是一样的。</p>
</blockquote>
<p>下面这种重载是不允许的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span>(<span class="keyword">double</span> r=<span class="number">0</span> , <span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">  	<span class="built_in">complex</span>():<span class="built_in">re</span>(<span class="number">0</span>),<span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;<span class="comment">//这两种写法是不行的，编译后的代码是一样的，这时编译器就不知道调用哪个函数了。</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Lesson4-参数传递与返回值"><a href="#Lesson4-参数传递与返回值" class="headerlink" title="Lesson4 参数传递与返回值"></a>Lesson4 参数传递与返回值</h1><p>构造函数一般不可以被放在private，如果放在private里，就说明外界不可以创建对象。</p>
<p>有一种设计模式叫做singleton就是把构造函数写到private里。</p>
<h2 id="常数成员函数"><a href="#常数成员函数" class="headerlink" title="常数成员函数"></a>常数成员函数</h2><p>class中的函数有两种，会改变数据内容的和不会改变数据内容的。</p>
<p>不改变数据内容的函数一定要加 <code>const</code> ，这是大气的编程习惯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span>(<span class="keyword">double</span> r=<span class="number">0</span> , <span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">double</span> <span class="title">real</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数名后加 <code>const</code> 说明该函数一定不会改变class的数据。如果不加，就说明可以改动。</p>
<p>那么不加会有什么后果呢？</p>
<p>看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;c1.<span class="built_in">real</span>();</span><br><span class="line">cout&lt;&lt;c1.<span class="built_in">imag</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> complex <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;<span class="comment">//这里说明该对象是一个常量，内部的数据一定不会改</span></span><br><span class="line">cout&lt;&lt;c2.<span class="built_in">real</span>();<span class="comment">//那么在调用该函数的时候，如果函数没有加const，就说明内部的数据可以该，这就与定义时相矛盾</span></span><br><span class="line">cout&lt;&lt;c2.<span class="built_in">imag</span>();</span><br></pre></td></tr></table></figure>
<h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><h3 id="1-pass-by-value"><a href="#1-pass-by-value" class="headerlink" title="1.pass by value"></a>1.pass by value</h3><p>pass by value就是把要传入的变量的值整包传过去，这个变量有多少个字节，就传多少个。这样的效率很低。</p>
<h3 id="2-pass-by-reference"><a href="#2-pass-by-reference" class="headerlink" title="2.pass by reference"></a>2.pass by reference</h3><p>在C中，可以用指针来传递，就是把这个变量的地址传进去。在C++中，可以用reference(引用)来进行传递。</p>
<p>其实引用的底层就是传指针。引用的形式很漂亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span>(<span class="keyword">double</span> &amp;r=<span class="number">0</span>,<span class="keyword">double</span> &amp;i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;<span class="comment">//这就是传引用</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上面的例子，传引用就相当于 <code>double &amp; r = varies</code> ，这时，就相当于为varies变量起了一个别名r，当改变r的时候，varies也会改变。r的地址和varies的地址一样。</p>
<p>当不想让varies改变时，就可以在r前面加上 <code>const</code> 关键字。此时改变r的值时，编译就会出错。</p>
<blockquote>
<p>参数传递尽量都传引用。</p>
</blockquote>
<h2 id="返回值的传递"><a href="#返回值的传递" class="headerlink" title="返回值的传递"></a>返回值的传递</h2><h3 id="1-return-by-value"><a href="#1-return-by-value" class="headerlink" title="1.return by value"></a>1.return by value</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">function</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-return-by-reference"><a href="#2-return-by-reference" class="headerlink" title="2.return by reference"></a>2.return by reference</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span>&amp; <span class="title">function</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong>什么时候不可以return by reference呢？</strong></p>
<p>当返回的东西是函数内创建的，这是一个local变量，当函数运行完之后，就直接消失了，所以此时renturn by reference，指向到一个消失的东西。这就不可以了。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>class中的数据在private下，外界不可以获取。但是想让一些函数可以直接获取，就可以加上 <code>friend</code>  关键字，表明这个函数是该class的朋友，可以直接获取class中的数据。</p>
<p>定义友元函数，要在class中声明一下子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">friend</span> complex&amp; __doap1(complex*,<span class="keyword">const</span> comp1ex)<span class="comment">//在class中声明一下子，该函数是该class的友元，写在哪个标签下都无所谓</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp; __doap1(complex* ths,<span class="keyword">const</span> comp1ex&amp; r)<span class="comment">//定义函数</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要注意：相同class的各个object互为友元</strong>，这就是说对象1中的函数可以直接处理对象2中的数据。</p>
<h1 id="Lesson5-操作符重载与临时对象"><a href="#Lesson5-操作符重载与临时对象" class="headerlink" title="Lesson5 操作符重载与临时对象"></a>Lesson5 操作符重载与临时对象</h1><p>事实上，在C++中，操作符就是一种函数，是可以重新定义的。也就是操作符重载。</p>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>操作符重载的函数可以写成成员函数的形式，也可以写成非成员函数的形式</p>
<h3 id="1-成员函数的形式"><a href="#1-成员函数的形式" class="headerlink" title="1.成员函数的形式"></a>1.成员函数的形式</h3><p>这就是把操作符重载函数写在class内，对该class的object进行操作。</p>
<p>首先我们来看一下编译器是如何看待操作符的。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005449.png" alt="image-20211110090019793" style="zoom:25%;" /></p>
<p><code>+=</code> 这是一个二元操作符，就是有两个操作数的。</p>
<p>编译器看待这个符号，就是把这个符号作用在左边身上，如果左边对这个符号进行了定义，那么编译器就找到了这个函数。</p>
<p>所有的操作符重载都有一个隐藏的参数，就是<code>this</code>，谁调用这个函数，那个谁就是this，this是那个谁的指针。这里就是c2的指针。</p>
<p>在写重载的时候，这个this就不写在形参列表里（也不能写，写出来就错了），但是是有的，如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; complex::<span class="keyword">operator</span> +=(<span class="keyword">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __doap1(<span class="keyword">this</span>,r);<span class="comment">//这个函数的功能是修改this指向变量的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的二元操作符都是这种规则。</p>
<blockquote>
<p>在这里补充一下by reference传递的另一个好处，就是传递者不需要知道接收者的形式，如果要用指针进行传递，一定要搞清楚，接收者接收的是指针还是value，因为接收者如果是一个指针，那么它只能接收指针，所以传递的时候要取地址。</p>
</blockquote>
<p>注意上面代码，操作符重载函数有一个返回值类型，<code>complex&amp;</code> 。虽然该函数可以直接通过this为操作符前面的变量赋值，有没有这个都无关紧要。但是下面这种形式，就需要有返回值了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c3+=c2+=c1</span><br></pre></td></tr></table></figure>
<h3 id="2-非成员函数的写法"><a href="#2-非成员函数的写法" class="headerlink" title="2.非成员函数的写法"></a>2.非成员函数的写法</h3><p>之前的+=操作符重载成员函数写法，函数的形参里面自动包含了一个隐藏的this指针，可以直接操作this，从而改变操作符左边的变量。</p>
<p>但是有的时候，不是改变操作符左边的变量。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c3=c1+c2;</span><br><span class="line">c2=c1+<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>此时，就需要使用非成员函数的写法。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005524.png" alt="image-20211215005524527" style="zoom:50%;" /></p>
<p>这里是没有this的存在的。</p>
<blockquote>
<p>这种情况必是return by value ，因为返回的必定是local object。</p>
</blockquote>
<h2 id="临时对象-typename"><a href="#临时对象-typename" class="headerlink" title="临时对象 typename()"></a>临时对象 typename()</h2><p>在上面的return中，我们可以看见，<code>complex (,)</code> ，这就是一个临时对象。</p>
<p>这种形如 <code>typename ()</code> ，是临时对象。它的声明到下一行就结束了。</p>
<p>例如熟悉的int类型，临时对象就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);<span class="comment">//这并不是一个函数，就是一个值为5的int型的临时变量，当运行到下一句话时，这个变量就消失了。</span></span><br></pre></td></tr></table></figure>
<h1 id="Lesson6-复习complex"><a href="#Lesson6-复习complex" class="headerlink" title="Lesson6 复习complex"></a>Lesson6 复习complex</h1><p>本节课是复习课，回顾了complex类的创建过程。</p>
<h1 id="Lesson7-三大函数"><a href="#Lesson7-三大函数" class="headerlink" title="Lesson7 三大函数"></a>Lesson7 三大函数</h1><p>介绍完complex类之后，我们现在继续学习带指针的类的写法。以string字符串这个类为例子。</p>
<p>在创建一个新的字符串时，我们会遇到以下的几个情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">s1</span><span class="params">()</span></span>;<span class="comment">//创建一个没有初值的对象</span></span><br><span class="line">	<span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;<span class="comment">//创建有初值的对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;<span class="comment">//创建一个新的对象，以另一个对象为初值，是一个拷贝的动作</span></span><br><span class="line">	s3=s2;<span class="comment">//赋值，也是一个拷贝的动作，这里与上一句的区别就是这里的s3不是第一次出现</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的complex的例子，我们没有写，但是编译器会自己制定一个规则，就是一项一项的对应，去拷贝和赋值。但是复数是很规则的，有实部和虚部，默认的拷贝和赋值完全可以满足。</p>
<p>但是字符串创建的是指针，两个指针不能指向同一个地方，这样会弄乱，所以带指针的类一定要自己写拷贝和赋值。</p>
<p>下面我们来看String类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>);</span><br><span class="line">  	<span class="built_in">String</span>(<span class="keyword">const</span> String&amp; str);</span><br><span class="line">  	String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp; str);</span><br><span class="line">  	~<span class="built_in">String</span>();</span><br><span class="line">  	<span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> m_data;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字符串就是指针指着头，最后有一个结束符号。</p>
<p>我们先来看第一个构造函数，是没有初始值得构造函数。函数的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cstr)</span><br><span class="line">  &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];<span class="comment">//如果指针不是空，那么运行这段话，分配一个空间，大小为字符串的长度再加上1，因为后面还有一个结束符。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,cstr);<span class="comment">//然后调用这个函数，把指针地址拷贝到数据中。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_data=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];<span class="comment">//如果是空指针，那么就在该空间放一个结束符。</span></span><br><span class="line">    *m_data=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数应对下面这两句话，会被调用</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">String <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">  String*p = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//这里也会调用上面的构造函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>当这个对象被清理的时候，会自动调用析构函数，需要把这块的内存给释放，否则就内存泄漏了。</p>
<p>析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p><strong>三大函数有拷贝构造，拷贝赋值，析构函数</strong>。析构函数我们上面说了。下面说前两个。</p>
<p>只要是带有指针的类，就要有这三大函数。</p>
<p>如果没有拷贝构造函数，用编译器自动生成的拷贝构造，就会发生<strong>浅拷贝</strong>。</p>
<p>浅拷贝就是，自动生成的拷贝构造函数，只会把指针本身拷贝过去，这样就会造成两个指针指向同一个东西。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="keyword">const</span> String&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_data=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data)+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data,str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造适用的条件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">String <span class="title">s1</span><span class="params">(s2)</span></span>;</span><br><span class="line">  String s3=s1;<span class="comment">//这个虽然是赋值符，但是s3是新建立的，此时也是调用拷贝构造函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h2><p>拷贝赋值的过程：</p>
<ul>
<li>先将原来的东西清空</li>
<li>然后再拷贝字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>==&amp;str)<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//自我检查，看是不是自己赋值自己。</span></span><br><span class="line">  <span class="keyword">delete</span>[] m_data;<span class="comment">//删除原来的空间内容</span></span><br><span class="line">  m_data=<span class="keyword">new</span>[<span class="built_in">strlen</span>(str.m_data)+<span class="number">1</span>];<span class="comment">//重新指向一个空间</span></span><br><span class="line">  <span class="built_in">sctrcpy</span>(m_data,str.m_data);<span class="comment">//拷贝内容</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回自己，这样可以连=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>上面的自我检查很重要，如果是自己赋值自己，没有自我检查，会先把原空间的内容删掉，结果赋值后字符串的内容变成空了。</p>
<h1 id="Lesson8-内存管理"><a href="#Lesson8-内存管理" class="headerlink" title="Lesson8 内存管理"></a>Lesson8 内存管理</h1><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><p>是存在某作用域的一块内存空间，例如调用的函数，函数本身会形成一个栈来放置它所接收的参数，以及返回地址。</p>
<p>在函数本体（function body）内声明的变量所使用的内存块都取自上述的栈。</p>
<p>该空间中的变量会被自动清理掉。</p>
<h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h2><p>是操作系统提供的一块全局（global）的内存空间，程序可动态分配（dynamic allocated）该空间。</p>
<p>所以我们需要手动开辟出一块空间，并且手动清理该空间。</p>
<h2 id="生命期"><a href="#生命期" class="headerlink" title="生命期"></a>生命期</h2><ol>
<li>stack object：其生命在作用域结束之后结束。</li>
<li>static object：其生命在作用域结束之后仍然存在，直到整个程序结束。</li>
<li>global object：其生命也是在程序结束之后才结束，也可以把它当成是一个static object。</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="1-new"><a href="#1-new" class="headerlink" title="1.new"></a>1.new</h3><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005540.png" alt="image-20211110140453980" style="zoom:25%;" /></p>
<p>如果不delete，那么随着程序的运行，指针p会消亡，那剩下所指的空间就没人管了。所以称为内存泄漏。</p>
<p>分配内存的分解动作：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005626.png" alt="image-20211215005626031" style="zoom: 50%;" /></p>
<ol>
<li>先调用一个叫operator new的函数，分配内存，得到一个指针。</li>
<li>然后将这个指针转型。</li>
<li>然后通过指针调用该类的构造函数。</li>
</ol>
<h3 id="2-delete"><a href="#2-delete" class="headerlink" title="2.delete"></a>2.delete</h3><p>再来分解delete的动作：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005657.png" alt="image-20211110141305647" style="zoom: 33%;" /></p>
<ol>
<li>首先调用析构函数。</li>
<li>释放内存。</li>
</ol>
<p><strong>良好的编程习惯：</strong></p>
<p><code>new[]</code> 要搭配 <code>delete[]</code>使用。</p>
<h1 id="Lesson9-复习String"><a href="#Lesson9-复习String" class="headerlink" title="Lesson9 复习String"></a>Lesson9 复习String</h1><p>本节课主要是复习之前的String类。</p>
<h1 id="Lesson10-类模板-函数模板-及其他补充"><a href="#Lesson10-类模板-函数模板-及其他补充" class="headerlink" title="Lesson10 类模板 函数模板 及其他补充"></a>Lesson10 类模板 函数模板 及其他补充</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>每创建一个对象，对象中的非静态数据都会被创建一份。</p>
<p>而函数只有一份，不同的对象调用成员函数，其实就是给函数传入不同的地址，让成员函数来处理该地址对应对象的数据。这靠的就是this pointer。</p>
<p>可能有点绕，好好想一下。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005802.png" alt="image-20211215005802555"></p>
<p>函数的参数列表中一定不要写this，编译器会自动加，否则就会报错。黄色的地方呢就是可加可不加。 </p>
<p>当成员变量加上<code>static</code>关键字，就和对象脱离了，在内存中只有一份。</p>
<p>而静态成员函数和一般的成员函数几乎一样，都只有一份。但是唯一的区别是，<strong>静态成员函数没有this pointer</strong>。所以它不能直接去处理对象中的数据，而是去处理静态成员变量。</p>
<p><strong>静态变量的使用：</strong></p>
<p>静态变量在类中声明，但是在使用的时候，需要在类外进行定义。</p>
<blockquote>
<p>这里辨析一下声明和定义。无论是变量还是函数。声明是告诉编译器有该东西存在，但是不分配内存。</p>
<p>而分配内存，就称为定义。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">  	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span></span>&#123;m_rate=x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">double</span> Account::m_rate=<span class="number">1</span>;<span class="comment">//这里是定义，可以赋初值也可以不赋值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Account::<span class="built_in">set_rate</span>(<span class="number">5</span>);<span class="comment">//调用静态函数可以直接调用，不通过对象。</span></span><br><span class="line">  Account a;</span><br><span class="line">  a.<span class="built_in">set_rate</span>(<span class="number">7</span>);<span class="comment">//也可以通过对象来调用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：凡是类里面的一切东西，无论是变量还是函数，拿到外面的名字都要加上类名。就是在家里可以直接叫名字，但是到外面，就必须要加上姓氏。</p>
<p>就像上面的 <code>static double m_date</code>，在外面的名字就是 <code>Account::m_date</code>。</p>
</blockquote>
<p><strong>静态函数的使用：</strong></p>
<ul>
<li>通过对象调用。</li>
<li>通过类名调用，也就是直接用函数的全名调用。</li>
</ul>
<h2 id="Singleton设计模式"><a href="#Singleton设计模式" class="headerlink" title="Singleton设计模式"></a>Singleton设计模式</h2><p>只能创建一个对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">static</span> A&amp; <span class="title">getinstance</span><span class="params">(<span class="keyword">return</span> a;)</span></span>;</span><br><span class="line">  	<span class="built_in">setup</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="built_in">A</span>();</span><br><span class="line">  	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; rhs);<span class="comment">//构造函数都写在私有里，外界不能创建。</span></span><br><span class="line">  	<span class="keyword">static</span> A a;<span class="comment">//这里创建了一个静态变量，没有任何人创建A的对象时，就已经存在一个了。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果要使用这个对象，就通过静态函数来获取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A::getinstance.<span class="built_in">setup</span>()；<span class="comment">//通过静态函数便可以操作这个对象的所有成员函数。</span></span><br></pre></td></tr></table></figure>
<p>这样写呢也有一个弊端，就是在没有使用这个对象的时候，它已经出现了。</p>
<p>所以有下面这种改进：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">static</span> A&amp; <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">  	<span class="built_in">A</span>();</span><br><span class="line">  	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">A::getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> A a;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进后，在静态成员函数内声明了这个对象，这样的好处就是当使用这个静态成员函数一次，该对象就会被创建，并且会一直存在到程序结束。</p>
<h2 id="函数模板-function-template"><a href="#函数模板-function-template" class="headerlink" title="函数模板(function template)"></a>函数模板(function template)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b&lt;a?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在使用时，与类模板不同，不用再指出具体的类型</span></span><br><span class="line">r3=<span class="built_in">min</span>(r1,r2);</span><br></pre></td></tr></table></figure>
<p>编译器会做实参推导，自动推导出类型。</p>
<p>例如上面的比大小，编译器会自动推导，a和b的类型，然后在下面有&lt;，编译器会根据该类型寻找是否有重载。那么定义该类的人就需要写好重载&lt;的函数。这样职责分开，是特别好的。在C++中标准库中，有很多这样的模板函数，称为算法。</p>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子是把所有的东西都包在std里面，这样可以避免同名的函数混淆。</p>
<p>在使用的时候，就要打开这种包裹。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//全开 using directive</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;<span class="comment">//就开这一个 using declaration</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cin&lt;&lt;...;</span><br><span class="line">  cout&lt;&lt;...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Lesson11-组合与继承"><a href="#Lesson11-组合与继承" class="headerlink" title="Lesson11 组合与继承"></a>Lesson11 组合与继承</h1><p>前面我们学的是写一个单一的class，这种叫基于对象设计。</p>
<p>下面我们要学习，类和类之间的关系。也就是面向对象编程。</p>
<p>类与类的关系大致上可以分为三种：组合，委托，继承。</p>
<h2 id="Composition组合-表示has-a"><a href="#Composition组合-表示has-a" class="headerlink" title="Composition组合(表示has-a)"></a>Composition组合(表示has-a)</h2><p>一个class里面包含了另一个class的对象。</p>
<p>对于复杂的程序，通常会使用图来表示。组合关系的表示方法如下：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005817.png" alt="image-20211110162419332" style="zoom: 33%;" /></p>
<p>下面讨论这种组合关系时的构造函数和析构函数。</p>
<p><strong>构造函数</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005824.png" alt="img" style="zoom:33%;" /></p>
<p>构造函数规则，由内而外，先调用内部包含class的默认构造函数。如果想调用别的构造函数，需要自己写明。</p>
<p>放一个慢动作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>():<span class="built_in">Component</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>内部的构造函数可以不用自己写，编译器会帮我们自动完成。</p>
<p><strong>析构函数</strong></p>
<p>由外而内，先调用Container的析构函数。再放一个慢动作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Container::~<span class="built_in">Container</span>()&#123;~Component&#125;</span><br></pre></td></tr></table></figure>
<p>这也是编译器自动帮我们完成的。</p>
<h2 id="Delegation委托-composition-by-reference"><a href="#Delegation委托-composition-by-reference" class="headerlink" title="Delegation委托(composition by reference)"></a>Delegation委托(composition by reference)</h2><p>类中包含另一个类的指针。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005832.png" alt="image-20211110164453307" style="zoom:33%;" /></p>
<p> 在这里有一个很有名的设计模式，就是一个类中包含了另一个类的指针，而这个指针所指的类中包含了要实现的所有功能，这种模式称为 <strong>pimpl</strong> 。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005930.png" alt="image-20211215005930376"></p>
<h2 id="Inheritance继承-表示is-a"><a href="#Inheritance继承-表示is-a" class="headerlink" title="Inheritance继承(表示is-a)"></a>Inheritance继承(表示is-a)</h2><p>继承的关系，子类可以包含父类的数据。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> B<span class="comment">//public公有继承，还可以是private protect</span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>用图表示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215005944.png" alt="image-20211110165524489" style="zoom:33%;" /></p>
<p>下面是子类，上面的是父类，由儿子指向父亲。</p>
<p>就如同生物学的那样，界门纲目科属种。一直往下分，每一个门都是一个界的一种。所以是is-a。</p>
<blockquote>
<p>继承最有价值的地方是和虚函数搭配使用。</p>
</blockquote>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215010208.png" alt="image-20211215010208419" style="zoom:50%;" /></p>
<blockquote>
<p>父类的析构函数要是virtual</p>
</blockquote>
<p>在这里我们只探讨public继承。</p>
<h1 id="Lesson12-虚函数与多态"><a href="#Lesson12-虚函数与多态" class="headerlink" title="Lesson12 虚函数与多态"></a>Lesson12 虚函数与多态</h1><p>使用继承的时候，要搭配虚函数使用，效果最佳。</p>
<p>继承的时候，数据会被继承下来，在创建子类对象的时候，会分配内存空间。</p>
<p>成员函数也会被继承下来，但是函数是不会被分配内存空间的。函数的继承是<strong>继承函数的调用权。</strong></p>
<p>什么事虚函数呢？就是在成员函数的声明钱加上<code>virtual</code>。</p>
<p>成员函数可以分为三类：</p>
<ol>
<li>non-virtual函数：不希望子类重新定义(override)</li>
<li>virtual函数：希望子类重新定义 <code>virtual void function()</code></li>
<li>pure virtual函数：子类必须重新定义 <code>virtual void function()=0</code></li>
</ol>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215010237.png" alt="image-20211110171243449" style="zoom: 33%;" /></p>
<p>例如，定义一个形状的类。世界上并没有叫形状的形状，所以该类一定会有子类。</p>
<p>上面就会定义一个画出形状的函数，这个函数一定要被子类override。</p>
<p>我们还会给每个形状都附一个编号，这个和具体的形状无关，所以用non-virtual函数。</p>
<p>我们还要打出操作各种形状的一些信息，如果子类不特别说明，就用父类定义的内容。如果子类想单独说明，也可以重写，所以这里用virtual函数。</p>
<h1 id="Lesson13-委托相关设计"><a href="#Lesson13-委托相关设计" class="headerlink" title="Lesson13 委托相关设计"></a>Lesson13 委托相关设计</h1><p>本节课介绍了一些设计模式。</p>
<p>就用到composition, delegation,inheritance这三种模式，进行组合，来解决现实的问题。</p>
<p>其中delegation+inheritance的功能最强大。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++3】侯捷大气编程(下)</title>
    <url>/2021/11/10/%E3%80%90C++3%E3%80%91%E4%BE%AF%E6%8D%B7%E5%A4%A7%E6%B0%94%E7%BC%96%E7%A8%8B(%E4%B8%8B)/</url>
    <content><![CDATA[<p>侯捷老师C++课程下半部分。本课程是对之前课程中所提的一些东西的补充，以及C++11新特性的一些讲解。</p>
<span id="more"></span>
<h1 id="Lesson1-介绍"><a href="#Lesson1-介绍" class="headerlink" title="Lesson1 介绍"></a>Lesson1 介绍</h1><p>本课程会讲的内容：</p>
<ul>
<li>泛型编程</li>
<li>深入探索面向对象继承关系所形成的的对象模型，包括隐藏在底层的this指针，虚指针，虚表等。</li>
</ul>
<h1 id="Lesson2-转换函数-conversion-function"><a href="#Lesson2-转换函数-conversion-function" class="headerlink" title="Lesson2 转换函数 conversion function"></a>Lesson2 转换函数 conversion function</h1><p>转换有两个方向，一个是我这个类型转换成那个，也可以是那个转换成这个。</p>
<p>现在有一个分数class：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014552.png" alt="image-20211110201213702" style="zoom:33%;" /></p>
<p>黄色的部分就是转换函数。转换肯定不会改变数据的值，所以要加上const。</p>
<p>不需要返回值类型，因为很明确，函数名就表示了要转换的那个类型。</p>
<p>调用的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d=<span class="number">3</span>+f;<span class="comment">//调用operator double()将f转为0.6</span></span><br></pre></td></tr></table></figure>
<p>在这里，编译器会首先找一个全局函数，看是不是有<code>+</code>运算符重载函数，如果没有，就去找转换函数，此时再调用转换函数。</p>
<p>只要你认为合理，可以有很多个转换函数。</p>
<h2 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h2><p>再来看下面这种情况，构造函数前可以加 <code>explicit</code> 关键字。现在是不加这个关键字的情况。</p>
<p>首先构造函数有两个形参，其中一个给了初值。其实调用的时候，只要给一个实参即可。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014604.png" alt="image-20211110202233538" style="zoom:33%;" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d=f+<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这时在执行上述代码时，类中的运算符重载函数并没有分数加整型数这种情况，只有分数加分数。当看到没有这种重载<code>+</code> 这种函数，所以就想着可不可以把整型数3变为Fraction，那就看其构造函数，如果满足构造函数的参数，那么就会调用构造函数来进行类型的转换。这是让其他类型的数据转化成本类型。</p>
<p>但是当有下面这种情况时，既可以用构造函数，又可以用类型转换函数。此时编译器会报错，因为它不知道调用哪个函数。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014615.png" alt="image-20211110203235669" style="zoom:33%;" /></p>
<h2 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h2><p>当在构造函数加上关键字<code>explicit</code>后，就可以避免上述问题发生。expilcit意思为明白的，明确的。在该关键字的限制下，构造函数就是创建新对象的时候调用，告诉编译器，不要在隐形转换的时候调用。</p>
<p>看下面的例子：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014637.png" alt="image-20211111065659372" style="zoom: 25%;" /></p>
<p>这里出错显示：<code>[Error]conversion from &#39;double&#39; to &#39;Fraction&#39; request</code> ，在一开始看到<code>f+4</code>时，编译器会先找重载运算符函数，发现只有分数加分数，所以要把4转化成分数，但是该构造函数前加上了explict，所以不能走这条路。于是又找到类型转换函数，这条路可以走通，最终得到结果4.6，但是要把4.6赋值给d2，没有这种类型转换函数。</p>
<h1 id="Lesson3-pointer-like-classes"><a href="#Lesson3-pointer-like-classes" class="headerlink" title="Lesson3 pointer-like classes"></a>Lesson3 pointer-like classes</h1><p>设计一个class，让它像指针。为什么这么做呢，就是想设计一个比指针功能更强大的东西。</p>
<h2 id="关于智能指针"><a href="#关于智能指针" class="headerlink" title="关于智能指针"></a>关于智能指针</h2><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014631.png" alt="image-20211111072414463" style="zoom: 25%;" /></p>
<p>shared_ptr是一个智能指针的模板类。我们写了一个Foo类，然后创建一个智能指针sp，这个过程中<code>shared_ptr&lt;Foo&gt; sp(new Foo)</code> 会调用构造函数，向智能指针中传入指针的值。</p>
<p><code>*sp</code>调用了重载运算符*函数。返回值为该对象。</p>
<p>这里要注意<code>sp-&gt;method()</code>，这句话会调用重载运算符函数，返回值是一个指针，虽然<code>-&gt;</code>在调用函数后就已经“消耗了”，返回的是一个指针，相当于已经没有了<code>-&gt;</code> ，但是为了保证符号的一致性，总不能写成<code>sp-&gt;-&gt;method()</code>，所以它就相当于<code>px-&gt;method()</code> ，就不用再写一遍了。</p>
<h2 id="关于迭代器"><a href="#关于迭代器" class="headerlink" title="关于迭代器"></a>关于迭代器</h2><p>迭代器也是一种智能指针，指向容器中的一个元素。但是和上面说的智能指针略有不同。</p>
<p>它不但要处理<code>* -&gt;</code> ，还要处理 <code>++ -- == !=</code> 等。</p>
<h1 id="Lesson4-function-like-classes"><a href="#Lesson4-function-like-classes" class="headerlink" title="Lesson4 function-like classes"></a>Lesson4 function-like classes</h1><p>写一个class，让它像一个函数。即仿函数。</p>
<p>形式为<code>typername()()</code>，前面的括号是创建一个临时对象，然后再加一个括号，是调用运算符重载函数。</p>
<h1 id="Lesson5-member-template-成员模板"><a href="#Lesson5-member-template-成员模板" class="headerlink" title="Lesson5 member template 成员模板"></a>Lesson5 member template 成员模板</h1><p>模板主要分三大类：</p>
<ul>
<li>class template</li>
<li>function template</li>
<li>member template</li>
</ul>
<p>下面是member template的代码：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014652.png" alt="image-20211111080704918" style="zoom:33%;" /></p>
<p>在类中，构造函数为一个模板函数，这样在初始化的时候，会有更大的弹性。 因为模板函数不需要特别指定具体的类型，会自动推导。所以只在外面写好要创建的类，待传入初始化值时，类中的模板函数会自动推导出初始化值得类型。</p>
<h1 id="Lesson6-模板特化-specialization"><a href="#Lesson6-模板特化-specialization" class="headerlink" title="Lesson6 模板特化(specialization)"></a>Lesson6 模板特化(specialization)</h1><p>在使用模板的时候，我们可以随机指定任何的类型，然后把该类型放到模板中。这就是泛化的概念。</p>
<p>但是有时候，我们想在一些特定的类型时，不使用泛化的模板，而是有一些特别之处。这就是模板特化。</p>
<p><strong>语法：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014659.png" alt="image-20211111082640173" style="zoom:33%;" /></p>
<p>在使用的时候，例如上面的例子，编译器会找，泛化也可以，特化也可以，正如代码所写，特别指定的类型是long，所以就找到对应的模板。</p>
<h1 id="Lesson7-偏特化-partial-specialization"><a href="#Lesson7-偏特化-partial-specialization" class="headerlink" title="Lesson7 偏特化(partial specialization)"></a>Lesson7 偏特化(partial specialization)</h1><h2 id="个数上的偏"><a href="#个数上的偏" class="headerlink" title="个数上的偏"></a>个数上的偏</h2><p><strong>语法：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014718.png" alt="image-20211111083230419" style="zoom:33%;" /></p>
<p>在这里，我们只想让模板中的某几个类型特化，如上，我们想让T特化，而且Alloc有默认类型。</p>
<p>那么语法就是，在下面写上不特化的类型（特化的类型那块还是空着，对比全特化，尖括号里全是空）。</p>
<h2 id="范围上的偏"><a href="#范围上的偏" class="headerlink" title="范围上的偏"></a>范围上的偏</h2><p>泛化的模板输入的类型可以是任意的，当我们想缩小一下范围，指定具体的某几个类型，例如，是指针类型，但是没有说明是什么的指针。</p>
<p><strong>语法：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014725.png" alt="image-20211111083910643" style="zoom:33%;" /></p>
<p>这是后，obj1用的就是泛化的模板。obj2用的是特化的模板。</p>
<h1 id="Lesson8-template-template-parameter-模板模板参数"><a href="#Lesson8-template-template-parameter-模板模板参数" class="headerlink" title="Lesson8 template template parameter 模板模板参数"></a>Lesson8 template template parameter 模板模板参数</h1><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014731.png" alt="image-20211111084146414" style="zoom: 25%;" /></p>
<p>Container可以是任意的字。模板模板参数就是，尖括号内第一项的模板参数，告诉有T这个模板类型存在。然后第二项模板参数是一个模板类，该模板类还需要模板参数，这样就形成了模板模板参数。</p>
<p>模板类的名字我们可以指定（因为类就可以当做是一个数据类型）</p>
<p>就是很绕，但其实不难的。</p>
<p>然后我们使用的时候，是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">XCLs&lt;string,list&gt; mylst1;</span><br></pre></td></tr></table></figure>
<p>这句话虽然是报错的，但是我们写的模板模板参数啥的都没有问题，报错的主要原因是<code>list</code>这个容器的模板参数有好几个，虽然模板参数是有默认值的，但是在模板中使用必须要指出。所以得加上中间那两句话。</p>
<blockquote>
<p>模板中参数前面的关键字，有时候是typename，有时也可以是class，有什么区别呢。注意这里只有在 <code>&lt;&gt;</code>中，定义模板参数的时候，是共通的。如<code>template&lt;typename T,class U&gt;</code> ，这是共通的。但是当像上面写模板模板参数的时候，用到的class，这是不能共通的，这里的class表示是一个类，而不是一个模板参数。</p>
</blockquote>
<h1 id="Lesson9-关于标准库"><a href="#Lesson9-关于标准库" class="headerlink" title="Lesson9 关于标准库"></a>Lesson9 关于标准库</h1><p>任何语言的标准库都十分重要，应该能熟练的使用。</p>
<p>C++的标准库主要有以下几个部分：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014737.png" alt="image-20211111093957659" style="zoom:33%;" /></p>
<ul>
<li>容器：就是数据结构。</li>
<li>算法：实现一些功能的方法。</li>
</ul>
<blockquote>
<p>程序就是靠算法和数据搭建起来的，algorithms+data=program。</p>
</blockquote>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【Markdown1】Markdown常用语法</title>
    <url>/2021/10/18/%E3%80%90Markdown1%E3%80%91Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown常用语法，方便使用时查阅。<br><span id="more"></span></p>
<h2 id="锚点和目录"><a href="#锚点和目录" class="headerlink" title="锚点和目录"></a>锚点和目录</h2><p>目录在前面用 <code>[toc]</code> 即可。</p>
<p>锚点: <code>[说明文字](#jump)</code>，然后在要跳跃的位置处写 <code>&lt;span id=&quot;jump&quot;&gt;跳转位置的名字&lt;/span&gt;</code></p>
<p>例如：<a href="#希腊字母">希腊字母</a> </p>
<p>超链接：<code>[网页名字](地址)</code>，如<a href="https://github.com/">github</a></p>
<h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol>
<li>行内公式：将公式插入到本行内，符号：<script type="math/tex">公式内容</script>，如：$xyz$</li>
<li>独行公式：将公式插入到新的一行内，并且居中，符号：<script type="math/tex">$公式内容$$$，如：</script>xyz$$</li>
</ol>
<h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol>
<li>上标符号，符号：<code>^</code>，如：$x^4$</li>
<li>下标符号，符号：<code>_</code>，如：$x_1$</li>
<li>组合符号，符号：<code>&#123;&#125;</code>，如：${16}_{8}O{2+}_{2}$</li>
</ol>
<h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol>
<li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：$V_{\mbox{初始}}$</li>
<li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li>
<li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li>
<li>标签，符号<code>\tag&#123;数字&#125;</code>，如：$\tag{11}$</li>
<li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li>
<li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li>
<li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li>
</ol>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol>
<li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li>
<li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li>
<li>大空格，符号<code>\</code>，如：$x \  y$ </li>
<li>中空格，符号<code>\:</code>，如：$x \: y$</li>
<li>小空格，符号<code>\,</code>，如：$x \, y$</li>
<li>没有空格，符号``，如：$xy$</li>
<li>紧贴，符号<code>\!</code>，如：$x ! y$</li>
</ol>
<h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol>
<li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li>
<li>中括号，符号：<code>[]</code>，如：$[x+y]$</li>
<li>大括号，符号：<code>\&#123; \&#125;</code>，如: $\{\}$</li>
<li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li>
<li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li>
<li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</li>
</ol>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol>
<li>加法运算，符号：<code>+</code>，如：$x+y=z$</li>
<li>减法运算，符号：<code>-</code>，如：$x-y=z$</li>
<li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li>
<li>减加运算，符号：<code>\mp</code>，如：$x \mp y=z$</li>
<li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li>
<li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li>
<li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li>
<li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li>
<li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li>
<li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：$\frac{x+y}{y+z}$</li>
<li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：${x+y} \over {y+z}$</li>
<li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li>
</ol>
<h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol>
<li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：$\overline{xyz}$</li>
<li>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li>
<li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：$\sqrt[3]{x+y}$</li>
<li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li>
<li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li>
<li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li>
<li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li>
<li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;5 &amp;6 &amp;\cdots &amp;8\\\vdots &amp;\vdots &amp;\ddots &amp;\vdots&amp; \vdots&amp;\cdots &amp;16\end{matrix} \right]$</li>
</ol>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol>
<li>等于运算，符号：<code>=</code>，如：$x+y=z$</li>
<li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li>
<li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li>
<li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li>
<li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li>
<li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li>
<li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li>
<li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li>
<li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li>
<li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li>
<li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li>
<li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li>
</ol>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol>
<li>属于运算，符号：<code>\in</code>，如：$x \in y$</li>
<li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li>
<li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li>
<li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li>
<li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li>
<li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li>
<li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li>
<li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li>
<li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li>
<li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li>
<li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li>
<li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li>
<li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li>
<li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li>
<li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li>
<li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li>
<li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li>
<li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li>
<li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li>
</ol>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol>
<li>无穷，符号：<code>\infty</code>，如：$\infty$</li>
<li>虚数，符号：<code>\imath</code>，如：$\imath$</li>
<li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li>
<li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</li>
<li>数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</li>
<li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</li>
<li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</li>
<li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</li>
<li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</li>
<li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</li>
<li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</li>
<li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</li>
<li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</li>
<li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</li>
<li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li>
<li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li>
<li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li>
<li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li>
<li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li>
<li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li>
<li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li>
<li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li>
<li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li>
<li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li>
<li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li>
<li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li>
</ol>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a><span id="希腊字母">希腊字母</span></h2><div class="table-container">
<table>
<thead>
<tr>
<th>字母</th>
<th>实现</th>
<th>字母</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td><code>A</code></td>
<td>α</td>
<td><code>\alhpa</code></td>
</tr>
<tr>
<td>B</td>
<td><code>B</code></td>
<td>β</td>
<td><code>\beta</code></td>
</tr>
<tr>
<td>Γ</td>
<td><code>\Gamma</code></td>
<td>γ</td>
<td><code>\gamma</code></td>
</tr>
<tr>
<td>Δ</td>
<td><code>\Delta</code></td>
<td>δ</td>
<td><code>\delta</code></td>
</tr>
<tr>
<td>E</td>
<td><code>E</code></td>
<td>ϵ</td>
<td><code>\epsilon</code></td>
</tr>
<tr>
<td>Z</td>
<td><code>Z</code></td>
<td>ζ</td>
<td><code>\zeta</code></td>
</tr>
<tr>
<td>H</td>
<td><code>H</code></td>
<td>η</td>
<td><code>\eta</code></td>
</tr>
<tr>
<td>Θ</td>
<td><code>\Theta</code></td>
<td>θ</td>
<td><code>\theta</code></td>
</tr>
<tr>
<td>I</td>
<td><code>I</code></td>
<td>ι</td>
<td><code>\iota</code></td>
</tr>
<tr>
<td>K</td>
<td><code>K</code></td>
<td>κ</td>
<td><code>\kappa</code></td>
</tr>
<tr>
<td>Λ</td>
<td><code>\Lambda</code></td>
<td>λ</td>
<td><code>\lambda</code></td>
</tr>
<tr>
<td>M</td>
<td><code>M</code></td>
<td>μ</td>
<td><code>\mu</code></td>
</tr>
<tr>
<td>N</td>
<td><code>N</code></td>
<td>ν</td>
<td><code>\nu</code></td>
</tr>
<tr>
<td>Ξ</td>
<td><code>\Xi</code></td>
<td>ξ</td>
<td><code>\xi</code></td>
</tr>
<tr>
<td>O</td>
<td><code>O</code></td>
<td>ο</td>
<td><code>\omicron</code></td>
</tr>
<tr>
<td>Π</td>
<td><code>\Pi</code></td>
<td>π</td>
<td><code>\pi</code></td>
</tr>
<tr>
<td>P</td>
<td><code>P</code></td>
<td>ρ</td>
<td><code>\rho</code></td>
</tr>
<tr>
<td>Σ</td>
<td><code>\Sigma</code></td>
<td>σ</td>
<td><code>\sigma</code></td>
</tr>
<tr>
<td>T</td>
<td><code>T</code></td>
<td>τ</td>
<td><code>\tau</code></td>
</tr>
<tr>
<td>Υ</td>
<td><code>\Upsilon</code></td>
<td>υ</td>
<td><code>\upsilon</code></td>
</tr>
<tr>
<td>Φ</td>
<td><code>\Phi</code></td>
<td>ϕ</td>
<td><code>\phi</code></td>
</tr>
<tr>
<td>X</td>
<td><code>X</code></td>
<td>χ</td>
<td><code>\chi</code></td>
</tr>
<tr>
<td>Ψ</td>
<td><code>\Psi</code></td>
<td>ψ</td>
<td><code>\psi</code></td>
</tr>
<tr>
<td>Ω</td>
<td><code>\v</code></td>
<td>ω</td>
<td><code>\omega</code></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++4】计算机如何存数</title>
    <url>/2022/06/16/%E3%80%90C++4%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A6%82%E4%BD%95%E5%AD%98%E6%95%B0/</url>
    <content><![CDATA[<p>计算机咋存数呢？</p>
<span id="more"></span>
<h2 id="I-十进制与二进制数间的转换"><a href="#I-十进制与二进制数间的转换" class="headerlink" title="I. 十进制与二进制数间的转换"></a>I. 十进制与二进制数间的转换</h2><h3 id="1-十进制-gt-二进制数"><a href="#1-十进制-gt-二进制数" class="headerlink" title="1. 十进制-&gt;二进制数"></a>1. 十进制-&gt;二进制数</h3><p>如十进制数173，使用短除法可转换为二进制数</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220616142305.png" alt="img"></p>
<p>再如十进制的小数0.8125，用乘法转换为二进制数</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220616142354.png" alt="img"></p>
<h3 id="2-二进制-gt-十进制数"><a href="#2-二进制-gt-十进制数" class="headerlink" title="2. 二进制-&gt;十进制数"></a>2. 二进制-&gt;十进制数</h3><p>整数位取2的正幂次，小数位取2的负幂次。</p>
<p>如1011.01</p>
<p>十进制数为：$1\times2^3+0\times2^2+1\times2^1+1\times2^0+0\times2^{-1}+1\times2^{-2}=8+0+2+1+0+0.25=11.25$</p>
<h2 id="II-计算机存储整数"><a href="#II-计算机存储整数" class="headerlink" title="II. 计算机存储整数"></a>II. 计算机存储整数</h2><p>整数分为正整数，0，负整数。在计算机中，整数分为有符号数和无符号数。</p>
<blockquote>
<p>有符号整数：N表示二进制位数，表示的范围为 $[-2^{N-1},2^{N-1}-1]$</p>
<p>如：8位二进制数表示的有符号整数范围为[-128,127]</p>
<p>无符号整数：N表示二进制位数，表示的范围为 $[0,2^{N}-1]$</p>
<p>如：8位二进制数表示的无符号整数范围为[0,255]</p>
</blockquote>
<h3 id="1-整数的编码方式"><a href="#1-整数的编码方式" class="headerlink" title="1. 整数的编码方式"></a>1. 整数的编码方式</h3><p><strong>计算机中，整数的存储是使用其对应的二进制数的补码形式存储。</strong></p>
<ul>
<li>原码：整数的原码就是直接将十进制数的绝对值转化成二进制数，并在前面加上一位符号位，0表正，1表负。</li>
<li>反码：正数的反码与原码相同，负数的反码是对其原码逐位取反，符号位除外。</li>
<li>补码：正数的补码与原码相同，负数的补码是对其反码加1。</li>
</ul>
<p>例如8位二进制数：</p>
<p>十进制数-100—&gt;原码为11100100—&gt;反码为10011011—&gt;补码为10011100</p>
<p>十进制数-1—&gt;原码为10000001—&gt;反码为11111110—&gt;补码为11111111</p>
<p>十进制数127—&gt;原码为01111111—&gt;反码为01111111—&gt;补码为01111111</p>
<p>十进制数-127—&gt;原码为11111111—&gt;反码为10000000—&gt;补码为10000001</p>
<p>十进制数-128—&gt;没有原码，因为超过8位了—&gt;绝对值的二进制数为10000000—&gt;取反01111111—&gt;补码为10000000</p>
<p><em>已知一个十进制负数求其补码的方法（8位范围是[-128,127] ，16位范围是[-32768,32767]）：</em></p>
<ol>
<li>先将其绝对值转为二进制数</li>
<li>然后取反后加1</li>
<li>根据正负在最高位选择0或1</li>
</ol>
<p>常见十进制数的补码(8位情况，其他位数补码与之不同)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制数</th>
<th style="text-align:center">二进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-128</td>
<td style="text-align:center">1000 0000</td>
</tr>
<tr>
<td style="text-align:center">-1</td>
<td style="text-align:center">1111 1111</td>
</tr>
<tr>
<td style="text-align:center">127</td>
<td style="text-align:center">0111 1111</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-为什么用补码存整数呢"><a href="#2-为什么用补码存整数呢" class="headerlink" title="2. 为什么用补码存整数呢"></a>2. 为什么用补码存整数呢</h3><p>当然是为了计算的方便了！！！</p>
<p>如果用原码来表示整数，则：</p>
<script type="math/tex; mode=display">
1 - 1 = 1 + ( -1 ) =(00000001) + (10000001) = (10000010) = -2</script><p>错误！！！</p>
<p>如果用反码来表示整数，则：</p>
<script type="math/tex; mode=display">
1-1 = 1 + ( -1 )= (00000001) + (11111110) = (11111111) = ( -0 )\\  
1-2 = 1 + ( -2 ) = (00000001) + (11111101) = (11111110) = ( -1 )</script><p>这都对，唯独在表示0时，1111 1111 和 0111 1111 都可以表示0，分别是+0和-0，这就出了问题。</p>
<p>所以用补码来表示：</p>
<script type="math/tex; mode=display">
1-1 = 1 + （-1） = (00000001) + (11111111) = (00000000) = 0 \\ 1-2 = 1 + （-2） = (00000001) + (11111110) = (11111111) =-1</script><h2 id="III-计算机存储小数"><a href="#III-计算机存储小数" class="headerlink" title="III. 计算机存储小数"></a>III. 计算机存储小数</h2><p>用二进制表示十进制的小数时，有一个弊端，就是无法准确表示所有小数，只能不断地增加位数来近似。如想要表示十进制小数0.20：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.01</td>
<td>0.25</td>
</tr>
<tr>
<td>0.0011</td>
<td>0.1875</td>
</tr>
<tr>
<td>0.001101</td>
<td>0.203125</td>
</tr>
<tr>
<td>0.00110011</td>
<td>0.19921875</td>
</tr>
</tbody>
</table>
</div>
<p>另外要存储特别大或特别小的数时，如 $101,000,000,000,000,000$ 或 $0.000,000,000,000,0001$ 时，前后需要存储15个0，特别浪费空间。因此计算机使用的是基于科学计数法的浮点数来存储这类特别大或特别小的数。</p>
<h3 id="1-浮点数"><a href="#1-浮点数" class="headerlink" title="1. 浮点数"></a>1. 浮点数</h3><p>浮点数也就是二进制数的科学计数法，其形式为 $V=(-1)^S\times M\times 2^E$ ，分为三个部分：</p>
<ul>
<li>S表示符号位，0为正，1为负</li>
<li>M是尾数，表示一个二进制小数，$1\leq M&lt;2$ </li>
<li>E是阶码，就是表示2的指数</li>
</ul>
<p>如：</p>
<p>二进制数：$1110110.1$</p>
<p>浮点数表示：$1.1101101\times 2^6$ </p>
<p>计算机中的浮点数有float(单精度)和double(双精度)</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220616151857.png" alt="image-20220616151857097" style="zoom: 50%;" /></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">float</th>
<th style="text-align:center">double</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M 尾数</td>
<td style="text-align:center">23位</td>
<td style="text-align:center">52位</td>
</tr>
<tr>
<td style="text-align:center">E 阶码</td>
<td style="text-align:center">8位</td>
<td style="text-align:center">11位</td>
</tr>
<tr>
<td style="text-align:center">总位数</td>
<td style="text-align:center">32位</td>
<td style="text-align:center">64位</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-IEEE754-有一些特别的规定"><a href="#2-IEEE754-有一些特别的规定" class="headerlink" title="2. IEEE754 有一些特别的规定"></a>2. <em>IEEE754</em> 有一些特别的规定</h3><ul>
<li><p>对于M(1.xxxxxx)，是大于等于1的二进制数，所以它的首位必然是1，因此在计算机内部保存M的时候，默认舍去第一位，仅保留后面的(.xxxxxx)，等到读取的时候，再把首位的1加上。</p>
</li>
<li><p>对于指数E，是一个无符号整数，这意味着，如果E为8位 (float类型) ，它的取值范围为0~255；如果E为11位（double类型），它的取值范围为0~2047。但是，我们知道，科学计数法中的<strong>E是可以出现负数</strong>的，所以<em>IEEE 754</em>规定，存入内存时E的真实值必须再加上一个中间数，<strong>对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023</strong>。比如，E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</p>
</li>
</ul>
<h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h3><p>如十进制数8.5，用float存储，在计算机中的形式如下：</p>
<p>1）先将十进制数8.5转化成二进制数 1000.1</p>
<p>2）再记为浮点数形式为 ：</p>
<ul>
<li>S=0表示正数</li>
<li>尾数为1.0001，去掉首位的1，M=0001</li>
<li>E=3+127=130-&gt;二进制数为1000 0010</li>
</ul>
<p>所以在计算机中，8.5f 的存储形式为：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220616154308.png" alt="image-20220616154308660" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【Markdown2】嵌入视频和PDF</title>
    <url>/2022/01/15/%E3%80%90Markdown2%E3%80%91%E5%B5%8C%E5%85%A5%E8%A7%86%E9%A2%91%E5%92%8CPDF/</url>
    <content><![CDATA[<p>在Markdown中嵌入视频、网页</p>
<span id="more"></span>
<p>之前一直说 Typora 是一个隐藏的网页浏览器，能解析 HTML 语法，没想到居然还能嵌入视频和PDF。</p>
<p><a href="https://support.typora.io/Media/">Embed Video, Media or Web Contents (typora.io)support.typora.io/Media/</a></p>
<h3 id="1-嵌入视频"><a href="#1-嵌入视频" class="headerlink" title="1.嵌入视频"></a>1.嵌入视频</h3><p>以B站为例，复制其嵌入代码</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20220115033313.jpg" alt="img"></p>
<p>得到：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=754115200&amp;bvid=BV1kk4y1m7sT&amp;cid=220773148&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接嵌入的话，视频窗口太小，我们加入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">height=&quot;500&quot;</span><br></pre></td></tr></table></figure>
<p>让窗口变大一些：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=754115200&amp;bvid=BV1kk4y1m7sT&amp;cid=220773148&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后直接复制到 typora 中即可，如果你操作得当的话，应该能看到下面这样的效果：</p>
<iframe src="//player.bilibili.com/player.html?aid=754115200&bvid=BV1kk4y1m7sT&cid=220773148&page=1" scrolling="no" border="0" height="500" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<h3 id="2-嵌入-gist"><a href="#2-嵌入-gist" class="headerlink" title="2.嵌入 gist"></a>2.嵌入 gist</h3><p><a href="https://link.zhihu.com/?target=https%3A//gist.github.com/">Create a new Gist (github.com)gist.github.com/</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://gist.github.com/Theigrams/98f6323969aa763cd1e343540e5420b4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20220115034053.jpg" alt="img"></p>
<h3 id="3-网页片段"><a href="#3-网页片段" class="headerlink" title="3.网页片段"></a>3.网页片段</h3><p>通过嵌入codepen，你甚至可以在typora里玩贪吃蛇！！！</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;codepen&quot;</span> <span class="attr">data-height</span>=<span class="string">&quot;265&quot;</span> <span class="attr">data-theme-id</span>=<span class="string">&quot;light&quot;</span> <span class="attr">data-default-tab</span>=<span class="string">&quot;js,result&quot;</span> <span class="attr">data-user</span>=<span class="string">&quot;moPsych&quot;</span> <span class="attr">data-slug-hash</span>=<span class="string">&quot;KKgQxWb&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&quot;</span> <span class="attr">data-pen-title</span>=<span class="string">&quot;Snake Game&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>See the Pen <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://codepen.io/moPsych/pen/KKgQxWb&quot;</span>&gt;</span></span><br><span class="line">  Snake Game<span class="tag">&lt;/<span class="name">a</span>&gt;</span> by moPsych (<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://codepen.io/moPsych&quot;</span>&gt;</span>@moPsych<span class="tag">&lt;/<span class="name">a</span>&gt;</span>)</span><br><span class="line">  on <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://codepen.io&quot;</span>&gt;</span>CodePen<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://static.codepen.io/assets/embed/ei.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><p class="codepen" data-height="265" data-theme-id="light" data-default-tab="js,result" data-user="moPsych" data-slug-hash="KKgQxWb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Snake Game">
  <span>See the Pen <a href="https://codepen.io/moPsych/pen/KKgQxWb">
  Snake Game</a> by moPsych (<a href="https://codepen.io/moPsych">@moPsych</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h3 id="4-PDF"><a href="#4-PDF" class="headerlink" title="4.PDF"></a>4.PDF</h3><p>当然，区区PDF也不在话下，如果是本地文件，直接拖入即可。</p>
<p>如果想导入云端PDF，需要通过 <code>Google Drive Viewer</code> 来显示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://docs.google.com/gview?embedded=true&amp;url=http://infolab.stanford.edu/pub/papers/google.pdf&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:800px; height:500px;&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只需把 <code>url=http://infolab.stanford.edu/pub/papers/google.pdf</code> 替换成自己的PDF链接即可，例如 GitHub 上的PDF也可以：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://docs.google.com/gview?embedded=true&amp;url=https://raw.githubusercontent.com/Theigrams/Mathematical-optimization/d304e27f613352b5d8240010cc58ddb4360ac48d/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A.pdf&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:800px; height:500px;&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe src="https://docs.google.com/gview?embedded=true&url=https://raw.githubusercontent.com/Theigrams/Mathematical-optimization/d304e27f613352b5d8240010cc58ddb4360ac48d/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A.pdf" style="width:800px; height:500px;" frameborder="0"></iframe>

<hr>
<p>发现了一个新的本地嵌入 PDF 的方法，把下面 <code>src</code> 中的 PDF 路径换成自己的即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;embed id=&quot;pdfPlayer&quot; src=&quot;C:\Users\question.pdf&quot; type=&quot;application/pdf&quot; width=&quot;1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS4】ROS中命名和重命名</title>
    <url>/2021/10/22/%E3%80%90ROS4%E3%80%91ROS%E4%B8%AD%E5%91%BD%E5%90%8D%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<p>本文介绍ROS中命名和重命名的相关知识。</p>
<span id="more"></span>
<p>其实命名和重命名是一回事，只不过我们自己写的节点或者参数等，可以在编程的时候自己直接命名，别人写的包我们不能在其源码上进行命名，所以就需要其他方式进行重命名。</p>
<p>ROS中关于命名和重命名的情况主要为：</p>
<ul>
<li>ROS工作空间覆盖</li>
<li>ROS节点重命名</li>
<li>ROS话题名称设置</li>
<li>ROS参数名称设置</li>
</ul>
<p>ROS中命名的策略有两个，一个是重新起名字(重映射)，另一个是在现有的命名前加上命名空间。</p>
<h1 id="一、ROS工作空间覆盖"><a href="#一、ROS工作空间覆盖" class="headerlink" title="一、ROS工作空间覆盖"></a>一、ROS工作空间覆盖</h1><p>工作空间覆盖是指，在不同的工作空间下，有重名的功能包。</p>
<p>因为要运行某个包，需要在<code>.bashrc</code>文件中设置环境变量路径。ROS 解析 <code>.bashrc 文件</code>，并生成 <code>ROS_PACKAGE_PATH</code>包路径，该变量中按照 <code>.bashrc</code>中配置设置工作空间优先级，如果先设置工作空间A，再设置工作空间B，那么在调用重名包时，B空间中的重名包被调用，因为它的搜索路径是先搜索B，再搜索A，既然在B中找到了该包，就不会再到A中找了。</p>
<p>应该避免该种情况发生。</p>
<h1 id="二、ROS节点重命名"><a href="#二、ROS节点重命名" class="headerlink" title="二、ROS节点重命名"></a>二、ROS节点重命名</h1><p>ROS中不允许同时运行两个名字相同的节点。当如果出现节点名相同时，需要进行重映射或添加命名空间。实现的方式主要有三种</p>
<h2 id="1-rosrun命令"><a href="#1-rosrun命令" class="headerlink" title="1.rosrun命令"></a>1.rosrun命令</h2><p><strong>(1)添加命名空间</strong></p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun pkg_name node_name  __ns:=/namespace</span><br></pre></td></tr></table></figure>
<p>查看节点名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/namespace/node_name</span><br></pre></td></tr></table></figure>
<p><strong>(2)重映射</strong></p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun pkg_name node_name __name:=/new_name</span><br></pre></td></tr></table></figure>
<p>查看节点名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/new_name</span><br></pre></td></tr></table></figure>
<h2 id="2-launch文件"><a href="#2-launch文件" class="headerlink" title="2.launch文件"></a>2.launch文件</h2><p>在编写launch文件时，完成操作。</p>
<p><strong>(1)添加命名空间</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;new_name&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;namespace&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>节点名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/namespace/new_name</span><br></pre></td></tr></table></figure>
<p><strong>(2)重映射</strong></p>
<p>node标签下的name可以完成重映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;new_name&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-编码实现"><a href="#3-编码实现" class="headerlink" title="3.编码实现"></a>3.编码实现</h2><p><strong>(1)重映射</strong></p>
<p>在我们创建节点的时候，需要进行节点初始化，代码如下；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_name&quot;</span>,ros::init_option::AnonymousName);</span><br></pre></td></tr></table></figure>
<p>在参数列表中，<code>ros::init_option::AnoymousName</code>是一个随机的数，可以在原节点名上加上一个随机数。</p>
<p><strong>(2)添加命名空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; map;</span><br><span class="line">map[<span class="string">&quot;__ns&quot;</span>] = <span class="string">&quot;namespace&quot;</span>;</span><br><span class="line">ros::<span class="built_in">init</span>(map,<span class="string">&quot;node_name&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="三、话题名称设置"><a href="#三、话题名称设置" class="headerlink" title="三、话题名称设置"></a>三、话题名称设置</h1><p>在 ROS 中节点终端，不同的节点之间通信都依赖于话题，话题名称也可能出现重复的情况，这种情况下，系统虽然不会抛出异常，但是可能导致订阅的消息非预期的，从而导致节点运行异常。这种情况下需要将两个节点的话题名称由相同修改为不同。又或者，两个节点是可以通信的，两个节点之间使用了相同的消息类型，但是由于，话题名称不同，导致通信失败。这种情况下需要将两个节点的话题名称由不同修改为相同。</p>
<h2 id="0-话题分类"><a href="#0-话题分类" class="headerlink" title="0.话题分类"></a>0.话题分类</h2><p>根据话题前面添加的前缀的不同，又可以将话题分为：</p>
<ul>
<li>全局话题</li>
<li>相对话题</li>
<li>私有话题</li>
</ul>
<p>全局话题的前缀为<code>/</code>     <strong>E.g.</strong> <code>/topic_name</code> </p>
<p>相对话题的前缀为节点的命名空间        <strong>E.g.</strong> <code>/namespace/topic_name</code></p>
<p>私有话题的前缀为节点名        <strong>E.g.</strong>  <code>/namespace/node_name/topic_name</code></p>
<h2 id="1-rosrun设置话题重映射"><a href="#1-rosrun设置话题重映射" class="headerlink" title="1.rosrun设置话题重映射"></a>1.rosrun设置话题重映射</h2><p>需要先知道节点中话题的名字。</p>
<p>然后通过：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun pkg_name node_name /origin_topic_name:=/new_topic_name</span><br></pre></td></tr></table></figure>
<h2 id="2-launch文件设置话题重映射"><a href="#2-launch文件设置话题重映射" class="headerlink" title="2.launch文件设置话题重映射"></a>2.launch文件设置话题重映射</h2><p>在launch文件中完成话题名重映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node_name&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;origin_topic_name&quot;</span> <span class="attr">to</span>=<span class="string">&quot;new_topic_name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-编码设置话题名称"><a href="#3-编码设置话题名称" class="headerlink" title="3.编码设置话题名称"></a>3.编码设置话题名称</h2><p><strong>(1)全局话题名</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_name&quot;</span>);</span><br><span class="line"> </span><br><span class="line">ros::NodeHandle n;<span class="comment">//创建节点句柄，它可以实现一些功能，设置话题时就需要它</span></span><br><span class="line"></span><br><span class="line">ros::Publisher pub=n.advertise&lt;std::msgs::string&gt;(<span class="string">&quot;/topic_name&quot;</span>,<span class="number">10</span>);<span class="comment">//这里的/就表示全局话题</span></span><br></pre></td></tr></table></figure>
<p>生成的话题名为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/topic_name</span><br></pre></td></tr></table></figure>
<p><strong>(2)相对话题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_name&quot;</span>);</span><br><span class="line"> </span><br><span class="line">ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">ros::Publisher pub=n.advertise&lt;std::msgs::string&gt;(<span class="string">&quot;topic_name&quot;</span>,<span class="number">10</span>);<span class="comment">//这里没有/就表示相对话题</span></span><br></pre></td></tr></table></figure>
<p>生成的话题名为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/namespace/topic_name</span><br></pre></td></tr></table></figure>
<p><strong>(3)私有话题</strong></p>
<p>私有话题与前面的有一点不同，是在生成节点句柄的时候。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_name&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">n</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;<span class="comment">//注意这里加上了~</span></span><br><span class="line"></span><br><span class="line">ros::Publisher pub=n.advertise&lt;std::msgs::string&gt;(<span class="string">&quot;topic_name&quot;</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>生成的话题名为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/namespace/node_name/topic_name</span><br></pre></td></tr></table></figure>
<h1 id="四、ROS参数名设置"><a href="#四、ROS参数名设置" class="headerlink" title="四、ROS参数名设置"></a>四、ROS参数名设置</h1><p>在参数名设置中，没有重映射机制，就是直接给参数命名。命名的时候为了避免重名，通过添加前缀的方式，实现全局参数，相对参数，私有参数三种。</p>
<h2 id="1-rosrun设置参数"><a href="#1-rosrun设置参数" class="headerlink" title="1.rosrun设置参数"></a>1.rosrun设置参数</h2><p>rosrun命令设置的是私有参数。参数名前面要加上<code>_</code></p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun pkg_name node_name _param_name:=10</span><br></pre></td></tr></table></figure>
<p>参数列表显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/namespace/node_name/param_name</span><br></pre></td></tr></table></figure>
<h2 id="2-launch文件设置"><a href="#2-launch文件设置" class="headerlink" title="2.launch文件设置"></a>2.launch文件设置</h2><p>通过 launch 文件设置参数的方式前面已经介绍过了，可以在 node 标签外，或 node 标签中通过 param 或 rosparam  来设置参数。在 node 标签外设置的参数是全局性质的，参考的是 / ，在 node 标签中设置的参数是私有性质的，参考的是  /命名空间/节点名称。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--全局参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--私有参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;t1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;p2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-编码设置参数"><a href="#3-编码设置参数" class="headerlink" title="3.编码设置参数"></a>3.编码设置参数</h2><p>在C++源码中，可以通过两种放式来设置参数：</p>
<p><strong>(1)通过<code>ros::param</code>设置参数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/set_A&quot;</span>,<span class="number">100</span>); <span class="comment">//全局参数,和命名空间以及节点名称无关</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;set_B&quot;</span>,<span class="number">100</span>); <span class="comment">//相对参数,参考命名空间</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;~set_C&quot;</span>,<span class="number">100</span>); <span class="comment">//私有参数,参考命名空间与节点名称</span></span><br></pre></td></tr></table></figure>
<p><strong>(2)<code>ros::NodeHandle</code>设置参数</strong></p>
<p>首先要创建<code>ros::NodeHandle</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::NodeHandle n1</span><br><span class="line"></span><br><span class="line">n1.<span class="built_in">setParam</span>(<span class="string">&quot;/param_name&quot;</span>,<span class="number">10</span>);<span class="comment">//设置全局参数</span></span><br><span class="line"></span><br><span class="line">n1.<span class="built_in">setParam</span>(<span class="string">&quot;param_name&quot;</span>,<span class="number">10</span>);<span class="comment">//设置相对参数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">n2</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">n2.<span class="title">setParam</span><span class="params">(<span class="string">&quot;param_name&quot;</span>,<span class="number">10</span>)</span><span class="comment">//设置私有参数</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS1】古月21讲学习笔记</title>
    <url>/2021/10/18/%E3%80%90ROS1%E3%80%91%E5%8F%A4%E6%9C%8821%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习《古月ROS入门21讲》的学习笔记<br><span id="more"></span><br>课程总览：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032824.png" alt="image-20211007012207647"></p>
<h1 id="一、ROS是什么"><a href="#一、ROS是什么" class="headerlink" title="一、ROS是什么"></a>一、ROS是什么</h1><p>ROS1.0发布于2010年，其发布的根本目的就是在机器人开发过程中，提高代码的复用率。就是在开发一个机器人时，可以通过ROS提供的各种功能，驱动机器人移动，感知外部环境，做出决策等。这就极大的节省了机器人开发的时间。</p>
<p>ROS(Robot operation system)全名为机器人操作系统，具体的它包括四大部分，分别为<strong>通信机制，开发工具，应用功能和生态系统</strong>。</p>
<h2 id="1-通信机制"><a href="#1-通信机制" class="headerlink" title="1.通信机制"></a>1.通信机制</h2><p>ROS提供了一种松耦合分布式通信机制，机器人的内部各个模块可以依靠这种通信机制完成信息的传递。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032831.png" alt="image-20211005000749206" style="zoom:67%;" /></p>
<h2 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2.开发工具"></a>2.开发工具</h2><p>ROS提供了一系列的开发工具，可以为机器人开发提供很大的帮助。</p>
<p>常用的开发工具有TF坐标变换，QT工具箱，Rviz，Gazebo。会在后面进行具体的使用介绍。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032836.png" alt="image-20211005000718567"></p>
<h2 id="3-应用功能"><a href="#3-应用功能" class="headerlink" title="3.应用功能"></a>3.应用功能</h2><p>ROS中包含各种功能包，可供机器人开发中使用。例如有可以驱动相机的功能包，有进行图像处理的功能包，有控制机器人运动的功能包，还有SLAM功能包。这些功能包的存在可以大大简化机器人的开发过程。</p>
<h2 id="4-生态环境"><a href="#4-生态环境" class="headerlink" title="4.生态环境"></a>4.生态环境</h2><p>ROS的生态环境具体指的是依据ROS系统，建立起来的一个ROS社区，在这个社区中，包含着我们需要的各种东西。主要有以下几部分组成：</p>
<ul>
<li>发行版：ROS发行版包括一系列带有版本号，可以直接安装的功能包。</li>
<li>软件源：ROS依赖于共享网络上的开源代码，不同组织机构可以开发或共享自己的机器人软件。</li>
<li>ROS wiki：记录ROS信息文档的论坛。</li>
<li>ROs Answer：咨询ROS相关的网站。</li>
</ul>
<h1 id="二、ROS中的核心概念"><a href="#二、ROS中的核心概念" class="headerlink" title="二、ROS中的核心概念"></a>二、ROS中的核心概念</h1><p>从上一章所知，ROS主要有四部分组成，包括通信机制，开发工具，应用功能和生态环境。抛开生态环境不说，因为整个ROS生态环境是当我们遇到困难或有什么特殊需求的时候，寻求帮助的地方。在我们实际的开发中，我们需要非常了解前三个部分。</p>
<p>下面我们来细细的说明一下ROS中的核心概念。</p>
<h2 id="1-组成ROS的基本单元"><a href="#1-组成ROS的基本单元" class="headerlink" title="1.组成ROS的基本单元"></a>1.组成ROS的基本单元</h2><p>当我们要了解ROS的通信机制时，就要知道是什么和什么在进行通信，也就是通信的主体是什么。在ROS中，通信的主体有节点和节点管理器两部分组成。</p>
<h3 id="1-节点-Node-—工人"><a href="#1-节点-Node-—工人" class="headerlink" title="(1)节点(Node)—工人"></a>(1)节点(Node)—工人</h3><p>节点是ROS系统中最基本的执行单元，有如下特点：</p>
<ul>
<li>节点要执行具体的任务进程，是一个可独立运行的可执行文件。</li>
<li>不同的节点可以使用不同的编程语言，可分布式运行在不同的主机。</li>
<li>节点在系统中的名称必须是唯一的。</li>
</ul>
<h3 id="2-节点管理器-Ros-Master-—管理员"><a href="#2-节点管理器-Ros-Master-—管理员" class="headerlink" title="(2)节点管理器(Ros Master)—管理员"></a>(2)节点管理器(Ros Master)—管理员</h3><p>对于节点的管理工作，需要节点管理器来完成，它主要有如下作用：</p>
<ul>
<li>为节点提供命名和注册服务。</li>
<li>跟踪和记录话题/服务通信（后面会说），辅助节点相互查找、建立连接。</li>
<li>提供参数服务器，节点使用此服务器存储和检索运行时的参数。</li>
</ul>
<p>下面我们用工人和管理员对以上的功能进行类比。对于每一个节点，我们可以把它看成是一个工人。工人就需要做好自己特定的工作（执行具体的任务进程），比如这个工人负责搬砖，另一个工人负责盖楼。不管这个工人来自哪里（使用不同的编程语言），或者在哪个工地（可运行在不同主机），只要能干活就可以。另外，工人不能重名（节点的名称唯一），这样不方便管理员管理。</p>
<p>而对于管理员，首先就是要为工人注册信息，分配工号（为节点提供命名和注册服务），然后给每个工人分配一个工作内容，并记录下工人所汇报的工作情况，方便其他工人了解完成情况（跟踪记录通信，辅助节点查找，建立连接）。另外，管理员还要记录下工程的水泥灰号，垒砖高度等工程参数，以方便工人在工作时可以随时查询（提供参数服务器）。</p>
<h2 id="2-通信机制"><a href="#2-通信机制" class="headerlink" title="2.通信机制"></a>2.通信机制</h2><p>通信机制主要有两种，一种是异步通信机制，叫做话题（Topic），另一种是同步通信机制，叫做服务（Service）。</p>
<h3 id="1-异步通信机制"><a href="#1-异步通信机制" class="headerlink" title="(1)异步通信机制"></a>(1)异步通信机制</h3><p>在该通信机制下，节点间传输的数据不是实时的。我们要知道两个概念：</p>
<h4 id="a-话题-Topic"><a href="#a-话题-Topic" class="headerlink" title="a.话题(Topic)"></a>a.话题(Topic)</h4><ul>
<li>节点间用来传输数据的总线。</li>
<li>使用发布/订阅模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以不唯一。</li>
</ul>
<h4 id="b-消息-Message"><a href="#b-消息-Message" class="headerlink" title="b.消息(Message)"></a>b.消息(Message)</h4><ul>
<li>消息是话题的数据。</li>
<li>具有一定的数据类型和数据结构，包括ROS提供的标准类型和用户自定义类型。</li>
<li>使用与编程语言无关的.msg文件定义，编译过程中生成对应的代码文件。</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032845.png" alt="image-20211005005705788"></p>
<p>好了，说完这么抽象的概念，我们还是用一个生活的例子来类比一下。在我们生活中，异步通信机制一个很明显的例子就是Youtube视频。例如有一个篮球话题（Topic），有一群订阅者（subsciber）和一群发布者（publisher）。当某一个发布者发布了一条视频（message）时，订阅者并不会马上知道，而是等他想看的时候，才会查看该话题下的内容，这就是异步通信机制。对于发布的视频的内容结构，可以是先热身，后打球，也可以是先打球，后洗澡，虽然结构可以变，但是有一定结构的。另外，无论视频内容如何，都必须是.avi格式的（.msg）。</p>
<p>所以说话题（Topic）是一个传输数据的总线，也可以理解成一个频道，一个管道，我们订阅了这个频道后，其内容会保持一定的结构，但是会变化。</p>
<p>在ROS中，话题的一个例子如下：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032852.png" alt="image-20211005010719866"></p>
<h3 id="2-同步通信机制"><a href="#2-同步通信机制" class="headerlink" title="(2)同步通信机制"></a>(2)同步通信机制</h3><p>同步通信机制，也叫做服务。它可以保证数据的传递是实时的。它有如下特点：</p>
<ul>
<li>使用客户端/服务器模型，客户端发送请求，服务器完成处理后返回应答数据。</li>
<li>使用与编程语言无关的.srv文件定义请求和应答数据结构，编译过程中生成对应的代码文件。</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032859.png" alt="image-20211005011052269" style="zoom: 67%;" /></p>
<p>这就好比一个服务员和一个顾客，顾客首先需要说出一个需求，然后服务员要做出回应。比如，顾客说帮我订一张机票（request），服务员立即定了一张机票然后回复订完了（reponse）。</p>
<p>ROS中服务的一个例子：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032904.png" alt="image-20211005011405078"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032910.png" alt="image-20211005011450237" style="zoom:67%;" /></p>
<h2 id="3-参数—全局共享字典"><a href="#3-参数—全局共享字典" class="headerlink" title="3.参数—全局共享字典"></a>3.参数—全局共享字典</h2><p>前面讲了工人和管理员的关系，管理员要记录一些所有工人都要用的信息，例如水泥的灰号。ROS中的参数的功能也是这样。参数由节点管理器提供服务器存储。特点如下：</p>
<ul>
<li>可通过网络访问的共享、多变量字典。</li>
<li>节点可以使用此服务器（也就是字典）来存储和检索运行时的参数。</li>
<li>适合存储静态、非二进制的配置参数，不适合存储动态配置的数据。</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032916.png" alt="image-20211005012244569"></p>
<h2 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4.文件系统"></a>4.文件系统</h2><p>前面所讲的节点等所有的东西都需要存储在文件中，也就是真实存在的形式。ROS的文件系统由三部分组成。</p>
<h3 id="1-功能包-Package"><a href="#1-功能包-Package" class="headerlink" title="(1)功能包(Package)"></a>(1)功能包(Package)</h3><p>ROS软件中的基本单元，包含节点源码、配置文件、数据定义等。</p>
<h3 id="2-功能包清单-Package-Manifest"><a href="#2-功能包清单-Package-Manifest" class="headerlink" title="(2)功能包清单(Package Manifest)"></a>(2)功能包清单(Package Manifest)</h3><p>记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。</p>
<h3 id="3-元功能包-Meta-Package"><a href="#3-元功能包-Meta-Package" class="headerlink" title="(3)元功能包(Meta Package)"></a>(3)元功能包(Meta Package)</h3><p>多个用于同一目的的功能包构成一个元功能包。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032921.png" alt="image-20211005012811067"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032926.png" alt="image-20211005012906244"></p>
<h1 id="三、ROS命令行工具"><a href="#三、ROS命令行工具" class="headerlink" title="三、ROS命令行工具"></a>三、ROS命令行工具</h1><p>ROS中提供了命令行工具帮助我们实现各种功能。</p>
<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h2><p><code>roscore</code>     启动Ros Master（必须启动）。</p>
<p><code>rosrun    功能包名    节点</code>     运行节点，要加功能包名，然后要运行的节点名。</p>
<h2 id="2-节点命令"><a href="#2-节点命令" class="headerlink" title="2.节点命令"></a>2.节点命令</h2><p>以<code>rosnode</code> 开头的命令，是处理节点的命令。</p>
<h3 id="1-rosnode-list"><a href="#1-rosnode-list" class="headerlink" title="(1)rosnode list"></a>(1)<code>rosnode list</code></h3><p>列出当前系统的所有节点。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032933.png" alt="image-20211005015249575"></p>
<p>在这里有一个rosout节点，是默认打开的，该节点主要是接受各个节点的信息形成一个日志信息。</p>
<h3 id="2-rosnode-info-节点名"><a href="#2-rosnode-info-节点名" class="headerlink" title="(2)rosnode info 节点名"></a>(2)<code>rosnode info 节点名</code></h3><p>查看某个节点信息。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032939.png" alt="image-20211005015739389"></p>
<p>在这里显示出的发布或订阅的内容中，前面部分为话题名，后面的是消息名。</p>
<h2 id="3-话题命令"><a href="#3-话题命令" class="headerlink" title="3.话题命令"></a>3.话题命令</h2><p>以<code>rostopic</code> 开头的命令，是处理话题的命令。</p>
<h3 id="1-rostopic-list"><a href="#1-rostopic-list" class="headerlink" title="(1)rostopic list"></a>(1)<code>rostopic list</code></h3><p>查看当前系统的所有话题。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032951.png" alt="image-20211005020128092"></p>
<h3 id="2-rostopic-pub"><a href="#2-rostopic-pub" class="headerlink" title="(2)rostopic pub"></a>(2)<code>rostopic pub</code></h3><p>向话题发布消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic	 pub 	话题名 	消息名 	内容</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rostopic 	pub 	/turtle1/cmd_vel 	geometry_msgs/Twist 	<span class="string">&quot;消息内容(在这里ROS定义的结构)&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这里，/turtle1/cmd_vel是话题名，geometry_msgs/Twist 是消息内容，后面双引号内是具体的消息内容，消息内容会有特定的结构。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032959.png" alt="image-20211005020805272"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic 	pub 	-r 		10 		话题名		消息名		内容</span><br></pre></td></tr></table></figure>
<p>-r表示发布循环发布，这里表示发布频率为10Hz。</p>
<p>按<code>Ctrl+C</code>可以停止发布。</p>
<h2 id="4-话题消息命令"><a href="#4-话题消息命令" class="headerlink" title="4.话题消息命令"></a>4.话题消息命令</h2><p>以<code>rosmsg</code> 开头的命令，是处理话题消息的命令。</p>
<h3 id="1-rosmsg-show"><a href="#1-rosmsg-show" class="headerlink" title="(1)rosmsg show"></a>(1)<code>rosmsg show</code></h3><p>查看某个消息的数据结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosmsg 		show	消息名</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033006.png" alt="image-20211005022203709"></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="5-服务命令"><a href="#5-服务命令" class="headerlink" title="5.服务命令"></a>5.服务命令</h2><p>以<code>rosservice</code> 开头的命令，是处理服务的命令。</p>
<h3 id="1-rosservice-list"><a href="#1-rosservice-list" class="headerlink" title="(1)rosservice list"></a>(1)<code>rosservice list</code></h3><p>查看服务端的服务。也就是查看可提供的服务。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033012.png" alt="image-20211005022505249"></p>
<h3 id="2-rosservice-call"><a href="#2-rosservice-call" class="headerlink" title="(2)rosservice call"></a>(2)<code>rosservice call</code></h3><p>对某个服务发送请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice		call		可提供服务名		<span class="string">&quot;请求内容&quot;</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">rosservice 		call 		/spawn 		<span class="string">&quot;x: 0.0</span></span><br><span class="line"><span class="string">y: 0.0</span></span><br><span class="line"><span class="string">theta: 0.0</span></span><br><span class="line"><span class="string">name:&#x27;	 &#x27; &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，服务名为/spawn，双引号内为请求的内容，具有系统定义的数据结构。</p>
<h2 id="6-服务消息命令"><a href="#6-服务消息命令" class="headerlink" title="6.服务消息命令"></a>6.服务消息命令</h2><p>以<code>rossrv</code>开头的命令，是处理服务消息的命令。</p>
<h3 id="1-rossrv-show"><a href="#1-rossrv-show" class="headerlink" title="(1)rossrv show"></a>(1)<code>rossrv show</code></h3><p>查看服务消息数据的内容结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rossrv 		show		服务消息名</span><br></pre></td></tr></table></figure>
<p>在标准的服务消息数据中，有—-分隔，在其上面的是request的内容，下面是response的内容。request可以是空的，如果是空的，直接call服务就可以。response能不能是空的还不知道。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033019.png" alt="image-20211006001820657"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033023.png" alt="image-20211006001952198"></p>
<h2 id="7-话题记录和复现"><a href="#7-话题记录和复现" class="headerlink" title="7.话题记录和复现"></a>7.话题记录和复现</h2><p>记录当前系统中所有话题的数据并保存下来，然后可以再用的时候复现出来。</p>
<h3 id="1-rosbag-record"><a href="#1-rosbag-record" class="headerlink" title="(1)rosbag record"></a>(1)<code>rosbag record</code></h3><p>记录想要保存的话题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosbag		record		-a		-O		储存的文件名</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rosbag 		record 		-a		-O		cmd_record</span><br></pre></td></tr></table></figure>
<p>在这里-a表示记录所有话题数据。-O表示保存数据为一个压缩包。</p>
<p>文件会被储存到终端当前的工作目录。</p>
<h3 id="2-rosbag-play"><a href="#2-rosbag-play" class="headerlink" title="(2)rosbag play"></a>(2)<code>rosbag play</code></h3><p>复现保存的话题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosbag 		play		储存的文件名</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rosbag 		play		cmd_record</span><br></pre></td></tr></table></figure>
<h2 id="8-参数命令"><a href="#8-参数命令" class="headerlink" title="8.参数命令"></a>8.参数命令</h2><p>以<code>rosparam</code> 开头的命令，都是处理参数的命令。</p>
<h3 id="1-rosparam-list"><a href="#1-rosparam-list" class="headerlink" title="(1)rosparam list"></a>(1)<code>rosparam list</code></h3><p>查看当前的全局参数。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033032.png" alt="image-20211006013652641"></p>
<h3 id="2-rosparam-get"><a href="#2-rosparam-get" class="headerlink" title="(2)rosparam get"></a>(2)<code>rosparam get</code></h3><p>获取某个参数的具体值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	get 	参数名</span><br><span class="line">rosparam 	get 	/run_id</span><br></pre></td></tr></table></figure>
<h3 id="3-rosparam-set"><a href="#3-rosparam-set" class="headerlink" title="(3)rosparam set"></a>(3)<code>rosparam set</code></h3><p>修改某个参数的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	<span class="built_in">set</span>		参数名		参数值</span><br><span class="line">rosparam 	<span class="built_in">set</span> 	/turtlesim/background_b		255</span><br></pre></td></tr></table></figure>
<h3 id="4-rosparam-dump"><a href="#4-rosparam-dump" class="headerlink" title="(4)rosparam dump"></a>(4)<code>rosparam dump</code></h3><p>把现在系统中的全局参数保存到一个文件，文件的类型为.yaml，文件存储到终端的当前路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	dump 	文件名.yaml</span><br></pre></td></tr></table></figure>
<h3 id="5-rosparam-load"><a href="#5-rosparam-load" class="headerlink" title="(5)rosparam load"></a>(5)<code>rosparam load</code></h3><p>从文件中加载参数，我们可以在文件中修改参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	load 	文件名.yaml</span><br></pre></td></tr></table></figure>
<h3 id="6-rosparam-delete"><a href="#6-rosparam-delete" class="headerlink" title="(6)rosparam delete"></a>(6)<code>rosparam delete</code></h3><p>删除某个参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	delete 	参数名</span><br></pre></td></tr></table></figure>
<h1 id="四、创建工作空间与功能包"><a href="#四、创建工作空间与功能包" class="headerlink" title="四、创建工作空间与功能包"></a>四、创建工作空间与功能包</h1><p>工作空间是用来存储ROS工程开发相关文件的文件夹。就像我们在使用IDE写代码的时候，首先要建立一个工程文件。</p>
<p>工作空间主要有四个文件夹：</p>
<ul>
<li>src：代码空间，用来放置功能包，所有功能包的代码，配置文件，launch文件存储在该处。</li>
<li>build：编译空间，放置编译过程中产生的中间文件。（一般不用管）</li>
<li>devel：开发空间，放置一些生成的可执行文件，库或脚本。</li>
<li>install：安装空间，安装位置。</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033041.png" alt="image-20211005030701463"></p>
<h2 id="1-创建工作空间"><a href="#1-创建工作空间" class="headerlink" title="1.创建工作空间"></a>1.创建工作空间</h2><p>(1)建立工作空间的文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir	-p	~/catkin_Name/src</span><br><span class="line"><span class="built_in">cd</span>		~/catkin_Name/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<p>(2)编译工作空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>(3)设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>		devel/setup.bash		</span><br></pre></td></tr></table></figure>
<p>(4)检查环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 	<span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>
<h2 id="2-创建功能包"><a href="#2-创建功能包" class="headerlink" title="2.创建功能包"></a>2.创建功能包</h2><p>如果要写代码，必须要创建功能包，因为功能包是ROS里放置源码的最小单元。</p>
<p>创建功能包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name/src</span><br><span class="line">catkin_create_pkg	功能包名	依赖1		依赖2		……</span><br></pre></td></tr></table></figure>
<p>编译功能包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span>		~/catkin_Name/devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>注意：同一个工作空间下，不允许存在同名的功能包。</p>
<h1 id="五、话题中各部分的编程实现"><a href="#五、话题中各部分的编程实现" class="headerlink" title="五、话题中各部分的编程实现"></a>五、话题中各部分的编程实现</h1><h2 id="1-发布者编程实现"><a href="#1-发布者编程实现" class="headerlink" title="1.发布者编程实现"></a>1.发布者编程实现</h2><p>之前我们控制的海龟是用键盘控制或者命令行控制，现在我们想通过编写一个程序来控制海龟的运动。这就需要写一个发布者的程序。</p>
<p>我们要清楚的是，发布者应该由节点充当。但是一个节点还可以对很多话题发布数据，所以我们在节点中，定义publisher来代表向一个话题的发布。它们之间的关系如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033056.png" alt="image-20211005164112040"></p>
<p>但容易混淆的是，发布消息的节点本身也可以叫做publisher。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033102.png" alt="image-20211005140716108"></p>
<h3 id="1-编写程序之前"><a href="#1-编写程序之前" class="headerlink" title="(1)编写程序之前"></a>(1)编写程序之前</h3><p>写具体的代码之前，我们要创建好工作空间，这里就不多说了。</p>
<p>然后要创建一个功能包。因为ROS的可执行文件都放在功能包中存储。如第四章第2节所述。功能包在工作空间的src文件夹下。</p>
<p>然后进入功能包，在功能包下的src文件夹中编写代码。</p>
<h3 id="2-代码实现过程"><a href="#2-代码实现过程" class="headerlink" title="(2)代码实现过程"></a>(2)代码实现过程</h3><ul>
<li>初始化ROS节点：在这一步要设置节点的名字。（在这里要注意节点名和可执行文件名的区别，节点可以理解为一个可执行文件，但这个可执行文件有一个名字，这个文件运行后会产生节点，节点也会有一个名字，这两个名字可能会有些不同。例如：在海龟仿真器中，功能包名字为turtlesim，生成节点的可执行文件名为turtlesim_node，运行后产生的节点名字为turtlesim）这里设置的就是运行后的节点名。</li>
<li>创建publisher，</li>
<li>向ROS Master注册节点信息，包括发布的话题名和话题中的消息类型。</li>
<li>创建消息数据。</li>
<li>按照一定频率循环发布的消息。</li>
</ul>
<p>如海龟速度发布程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ROS节点初始化</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建节点句柄，配置节点资源。</span></span><br><span class="line">	ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建一个Publisher，设置要往哪个话题发布什么样的消息内容。</span></span><br><span class="line"><span class="comment">	一个节点，可以发布不同的内容，用publisher来代表节点中不同的发布内容。</span></span><br><span class="line"><span class="comment"> 	在这里：发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，</span></span><br><span class="line"><span class="comment"> 	队列长度10，不能及时发布的数据就被存在队列中。*/</span></span><br><span class="line">	ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置循环的频率</span></span><br><span class="line">	<span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">// 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">		geometry_msgs::Twist vel_msg;<span class="comment">//数据类型是一个类，创建一个对象</span></span><br><span class="line">		vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">		vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 发布消息</span></span><br><span class="line">		turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">		<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, </span><br><span class="line">				vel_msg.linear.x, vel_msg.angular.z);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 按照循环频率延时</span></span><br><span class="line">	    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-编译代码"><a href="#3-编译代码" class="headerlink" title="(3)编译代码"></a>(3)编译代码</h3><p>编译代码，需要修改该程序包中的CMakeLists文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行文件名 	src/源码名)<span class="comment">#注意这里的可执行文件名就是一会要rosrun 功能包  可执行文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件名	<span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#这里直接用变量代替依赖的库路径，因为前面会自己找到依赖库的路径。</span></span><br></pre></td></tr></table></figure>
<p>然后回到工作空间根目录，用<code>catkin_make</code> 命令完成编译。</p>
<p>生成的可执行文件会在工作空间根目录下的devel/lib中找到。</p>
<h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="(4)配置环境变量"></a>(4)配置环境变量</h3><p>一定要设置环境变量，要不然系统是找不到这个可执行文件的。设置环境变量的文件是工作空间根目录下的devel中的setup.bash文件。</p>
<p>用下面的命令完成设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> 		devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>如果想避免重复的设置环境变量，也可以在终端的隐藏文件中设置。</p>
<p>首先打开主文件夹，然后按Ctrl+H快捷键显示隐藏文件，然后打开.bashrc，在最后面写上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> 		/home/pigpighero/工作空间/devel/setup.bash</span><br></pre></td></tr></table></figure>
<h3 id="5-运行"><a href="#5-运行" class="headerlink" title="(5)运行"></a>(5)运行</h3><p>接下来就可以在终端中运行这个发布者节点了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun  	功能包		可执行文件名</span><br></pre></td></tr></table></figure>
<h2 id="2-订阅者编程实现"><a href="#2-订阅者编程实现" class="headerlink" title="2.订阅者编程实现"></a>2.订阅者编程实现</h2><p>现在编程实现一个订阅者节点，和发布者是一样的，我们同样在功能包的src文件中编写代码。</p>
<p>代码的实现过程：</p>
<ul>
<li>初始化ROS节点</li>
<li>订阅需要的话题</li>
<li>循环等待话题消息，接收到消息后进入回调函数</li>
<li>在回调函数中完成消息处理</li>
</ul>
<p>在这里要注意一下回调函数，这和单片机开发中的中断函数类似，在收到消息后，可以立即跳入到回调函数中，完成消息的处理。</p>
<p>以订阅海龟的位置消息为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::Pose::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span></span><br><span class="line">    ros::Subscriber pose_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/turtle1/pose&quot;</span>, <span class="number">10</span>, poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后同样要注意编写CMakeLists文件和设置环境变量，这里都和前面一样。</p>
<h2 id="3-自定义话题消息结构"><a href="#3-自定义话题消息结构" class="headerlink" title="3.自定义话题消息结构"></a>3.自定义话题消息结构</h2><p>我们之前发布和订阅的话题的消息结构都是定义好的，我们现在自己来完成消息结构的定义。</p>
<p>下面我们用一个实际的例子，按照以下步骤来完成自定义的消息结构：</p>
<h3 id="1-定义msg文件"><a href="#1-定义msg文件" class="headerlink" title="(1)定义msg文件"></a>(1)定义msg文件</h3><p>消息的结构载体为.msg文件，这就是简单的纯文本文件，每一行由字段类型和字段名称组成。</p>
<p>我们首先在功能包中创建一个新的msg文件夹，用来存储所有的消息结构。</p>
<p>我们定义一个人的消息结构在Person.msg文件中：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">string 	name</span><br><span class="line">uint8 	sex</span><br><span class="line">uint8 	age</span><br></pre></td></tr></table></figure>
<h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="(2)编辑配置文件"></a>(2)编辑配置文件</h3><p><strong>首先要在package.xml中添加功能包依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033115.png" alt="image-20211005185240266"></p>
<p><strong>然后在CMakeLists添加相关配置</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation <span class="comment">#这个是后加的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033128.png" alt="image-20211005185707368"></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_message_files(FILES 	Person.msg)<span class="comment">#配置msg源文件</span></span><br><span class="line">generate_messages(DEPENDENCIES		std_msgs)<span class="comment">#生成消息时依赖于std_msgs</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行时依赖</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES learning_topic</span></span><br><span class="line">  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="(3)使用"></a>(3)使用</h3><p>最后就是编译了，在工作空间目录下使用<code>catkin_make</code> 命令完成。生成的文件在devel/include中。</p>
<p>在ROS中，消息的结构需要在发布和订阅消息的时候使用，我们先用一个.msg纯文本文件把消息结构写好，然后通过编译，生成头文件结构，这里面是包含该消息结构的类，我们在编写程序的时候可以直接引用头文件并使用。</p>
<p><strong>person_publisher.cpp:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_topic/Person.h&quot;</span><span class="comment">//这里引用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span></span><br><span class="line">    ros::Publisher person_info_pub = n.advertise&lt;learning_topic::Person&gt;(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置循环的频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化learning_topic::Person类型的消息</span></span><br><span class="line">    	learning_topic::Person person_msg;</span><br><span class="line">		person_msg.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">		person_msg.age  = <span class="number">18</span>;</span><br><span class="line">		person_msg.sex  = learning_topic::Person::male;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">		person_info_pub.<span class="built_in">publish</span>(person_msg);</span><br><span class="line"></span><br><span class="line">       	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">				  person_msg.name.<span class="built_in">c_str</span>(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照循环频率延时</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>person_subscriber.cpp:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">personInfoCallback</span><span class="params">(<span class="keyword">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">			 msg-&gt;name.<span class="built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span></span><br><span class="line">    ros::Subscriber person_info_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，在CMakeLists中加入：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(person_publisher src/person_publisher.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_publisher <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(person_subscriber src/person_subscriber.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_subscriber <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033149.png" alt="image-20211005193520292"></p>
<p>注意：在话题通信中，话题的建立是通过建立发布者或订阅者的。比如说上面的Person_publisher.cpp程序中，在建立publisher时，要注明发送的话题，此时便建立了话题。</p>
<h1 id="六、服务中各部分的编程实现"><a href="#六、服务中各部分的编程实现" class="headerlink" title="六、服务中各部分的编程实现"></a>六、服务中各部分的编程实现</h1><h2 id="1-客户端编程实现"><a href="#1-客户端编程实现" class="headerlink" title="1.客户端编程实现"></a>1.客户端编程实现</h2><p>前面我们使用命令行对海龟仿真节点发送了一个请求，又生成了一只海龟，现在我们通过程序来发送请求。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033200.png" alt="image-20211005230349178"></p>
<p>和编写发布者的过程类似，先创建一个新的功能包。在代码实现过程，也是在创建节点的基础上编写请求数据。具体的程序内容主要包括以下部分：</p>
<ul>
<li>初始化ROS节点。</li>
<li>创建一个Client实例。</li>
<li>发布服务请求数据。</li>
<li>等待Server处理之后的应答结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);<span class="comment">//查询当前系统中是否有spanw服务，如果没有一直等待</span></span><br><span class="line">	ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">	turtlesim::Spawn srv;</span><br><span class="line">	srv.request.x = <span class="number">2.0</span>;</span><br><span class="line">	srv.request.y = <span class="number">2.0</span>;</span><br><span class="line">	srv.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, </span><br><span class="line">			 srv.request.x, srv.request.y, srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示服务调用结果</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spwan turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-服务端编程实现"><a href="#2-服务端编程实现" class="headerlink" title="2.服务端编程实现"></a>2.服务端编程实现</h2><p>在这一节，我们实现这样一个功能，就是客户端向服务端发送一个请求，让服务端来控制海龟。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033212.png" alt="image-20211005235128008"></p>
<p>这里面，这个服务叫做/turtle_command，发送的request数据类型为std_srvs::Trigger。</p>
<p>服务端的程序主要有以下几部分组成：</p>
<ul>
<li>初始化ROS节点</li>
<li>创建Server实例</li>
<li>循环等待服务请求，进入回调函数</li>
<li>在回调函数中完成服务功能的处理，并反馈应答数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_srvs/Trigger.h&gt;</span><span class="comment">//服务数据类型的头文件</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher turtle_vel_pub;</span><br><span class="line"><span class="keyword">bool</span> pubCommand = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">commandCallback</span><span class="params">(std_srvs::Trigger::Request  &amp;req,<span class="comment">//客户端发送的请求</span></span></span></span><br><span class="line"><span class="params"><span class="function">         			std_srvs::Trigger::Response &amp;res)</span><span class="comment">//服务端的回应</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pubCommand = !pubCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="literal">true</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置反馈数据</span></span><br><span class="line">	res.success = <span class="literal">true</span>;</span><br><span class="line">	res.message = <span class="string">&quot;Change turtle command state!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_command_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span></span><br><span class="line">    ros::ServiceServer command_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/turtle_command&quot;</span>, commandCallback);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">	turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to receive turtle command.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置循环的频率</span></span><br><span class="line">	<span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 查看一次回调函数队列</span></span><br><span class="line">    	ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果标志为true，则发布速度指令</span></span><br><span class="line">		<span class="keyword">if</span>(pubCommand)</span><br><span class="line">		&#123;</span><br><span class="line">			geometry_msgs::Twist vel_msg;</span><br><span class="line">			vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">			vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line">			turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//按照循环频率延时</span></span><br><span class="line">	    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序运行的过程是这样的，先是创建好Server和Publisher，然后等待请求，当有请求指令时，立即跳入到回调函数。回调函数中设置了输入数据的类型为std_srvs::Trigger::Request，当有这种类型的数据输入时，才跳入回调函数（在本例中，Request是空的，所以可以不用输入内容）。进入到回调函数后，pubCommand变为真，这在主函数的循环中，if语句开始执行，将发送话题数据twist，控制海龟移动。</p>
<p>呼叫服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice 		call 		/turtle_command </span><br></pre></td></tr></table></figure>
<h2 id="3-服务数据的定义与使用"><a href="#3-服务数据的定义与使用" class="headerlink" title="3.服务数据的定义与使用"></a>3.服务数据的定义与使用</h2><p>上一节我们用的服务数据为Trigger，这是ROS定义好的，我们现在来自己定义一个服务的数据。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033222.png" alt="image-20211006003654128"></p>
<p>我们要实现的功能如上所示，我们自己定义一个服务消息数据为Person，客户端可以发送请求，获得show_person服务，服务端发出一个回应。</p>
<h3 id="1-定义数据"><a href="#1-定义数据" class="headerlink" title="(1)定义数据"></a>(1)定义数据</h3><p>请求数据和回应数据中间用<code>---</code>来隔开，和话题消息数据定义一样，我们用写在一个纯文本文件中，文件格式为.srv。</p>
<p>先在功能包目录下建立一个文件夹srv。然后创建.srv文件。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033227.png" alt="image-20211006004641504"></p>
<h3 id="2-编辑配置文件-1"><a href="#2-编辑配置文件-1" class="headerlink" title="(2)编辑配置文件"></a>(2)编辑配置文件</h3><p>与话题消息几乎一样，只不过在CMakeLists中，话题消息的配置使用的是add_message_files(FILES Person.msg)，而在服务数据的配置使用的是add_service_files(FILES Person.srv)。</p>
<p><strong>首先要在package.xml中添加功能包依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033236.png" alt="image-20211005185240266"></p>
<p><strong>然后在CMakeLists添加相关配置</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation <span class="comment">#这个是后加的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033245.png" alt="image-20211005185707368"></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_service_files(FILES 	Person.srv)<span class="comment">#配置msg源文件</span></span><br><span class="line">generate_messages(DEPENDENCIES		std_msgs)<span class="comment">#生成消息时依赖于std_msgs</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行时依赖</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES learning_topic</span></span><br><span class="line">  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-1"><a href="#3-使用-1" class="headerlink" title="(3)使用"></a>(3)使用</h3><p>最后就是编译了，在工作空间目录下使用<code>catkin_make</code> 命令完成。生成的文件在devel/include中。</p>
<p><strong>客户端：person_client.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line">	ros::ServiceClient person_client = node.serviceClient&lt;learning_service::Person&gt;(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化learning_service::Person的请求数据</span></span><br><span class="line">	learning_service::Person srv;</span><br><span class="line">	srv.request.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">	srv.request.age  = <span class="number">20</span>;</span><br><span class="line">	srv.request.sex  = learning_service::Person::Request::male;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, </span><br><span class="line">			 srv.request.name.<span class="built_in">c_str</span>(), srv.request.age, srv.request.sex);</span><br><span class="line"></span><br><span class="line">	person_client.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示服务调用结果</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>服务端：person_server.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">personCallback</span><span class="params">(learning_service::Person::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         			learning_service::Person::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="built_in">c_str</span>(), req.age, req.sex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置反馈数据</span></span><br><span class="line">	res.result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span></span><br><span class="line">    ros::ServiceServer person_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/show_person&quot;</span>, personCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to show person informtion.&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，在CMakeLists中加入：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(person_client src/person_client.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_client <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_client <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(person_server src/person_server.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_server <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_server <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="七、参数的使用与编程方法"><a href="#七、参数的使用与编程方法" class="headerlink" title="七、参数的使用与编程方法"></a>七、参数的使用与编程方法</h1><p>ROS Master中有一个参数服务器，它可以存储全局参数，各个节点都可以访问（不同的主机也可访问）。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033258.png" alt="image-20211006011750764"></p>
<p>还是创建一个节点来实现用程序使用全局参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程设置/读取海龟例程中的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_srvs/Empty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;parameter_config&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用服务，刷新背景颜色</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">	ros::ServiceClient clear_background = node.serviceClient&lt;std_srvs::Empty&gt;(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">	std_srvs::Empty srv;</span><br><span class="line">	clear_background.<span class="built_in">call</span>(srv);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、ROS中的常用组件"><a href="#八、ROS中的常用组件" class="headerlink" title="八、ROS中的常用组件"></a>八、ROS中的常用组件</h1><h2 id="1-坐标变换管理系统-TF功能包"><a href="#1-坐标变换管理系统-TF功能包" class="headerlink" title="1.坐标变换管理系统-TF功能包"></a>1.坐标变换管理系统-TF功能包</h2><p>TF功能包能管理机器人中的各个坐标系之间的变换关系。</p>
<p>TF可以在分布式系统中进行操作，也就是说，一个机器人系统中所有的坐标变换关系，对于所有的节点组件都是可用的，所有订阅TF消息的节点都会缓冲一份所有坐标系的变换关系数据，所以这种结构不需要中心服务器来存储任何数据。</p>
<p>想要使用TF功能包，需要一下两个步骤：</p>
<ul>
<li>广播TF变换：向系统中广播坐标系之间的变换关系。就是通过节点，根据自身的位置和对方的位置，计算出变换关系。</li>
<li>监听TF变换：接收并缓存系统中发布的所有坐标变换数据，并从中查询所需要的坐标变换关系。</li>
</ul>
<p>在ROS中，使用树结构来进行管理。</p>
<p>例如一个小车，小车的中心点为base_link坐标系原点，上面有一个激光雷达，激光雷达中心为base_laser坐标系原点。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033322.png" alt="image-20211006021136321"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033318.png" alt="image-20211006021150776"></p>
<h3 id="1-一个例程"><a href="#1-一个例程" class="headerlink" title="(1)一个例程"></a>(1)一个例程</h3><p>在ROS中有一个例程，海龟跟踪，这个就是通过TF坐标来实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo 	apt-get		install		ros-melodic-turtle-tf  //下载例程文件</span><br><span class="line">roslaunch  	turtle_tf	turtle_tf_demo.launch //roslaunch命令是启动.launch文件，这个文件中包括了很多个节点</span><br><span class="line">rosrun 		turtlesim		turtle_teleop_key //启动键盘控制</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun 		tf		view_frames  //运行tf的一个可视化工具，会在当前路径下生成pdf文件，来表示当前坐标系关系</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033329.png" alt="image-20211006023541876"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tf		tf_echo		turtle1		turtle2  //显示两个坐标系间的关系</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033335.png" alt="image-20211006023636826"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun 	rviz	 rviz 	-d 		&#x27;rospack find turtle_tf&#x27;/rviz/turtle_rviz.rviz		//运行rviz可视化工具，可以查看坐标关系</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033340.png" alt="image-20211006023829401" style="zoom:50%;" /></p>
<h3 id="2-创建TF广播器"><a href="#2-创建TF广播器" class="headerlink" title="(2)创建TF广播器"></a>(2)创建TF广播器</h3><p>首先，我们需要创建一个发布乌龟坐标系和世界坐标系之间TF变换的节点。然后这个节点可以把坐标变换关系发送到TF树中。</p>
<ul>
<li>定义TF广播器</li>
<li>创建坐标变换值</li>
<li>发布坐标变换</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程产生tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建tf的广播器</span></span><br><span class="line">	<span class="keyword">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化tf数据</span></span><br><span class="line">	tf::Transform transform;<span class="comment">//坐标变换矩阵4*4</span></span><br><span class="line">	transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );<span class="comment">//设置平移</span></span><br><span class="line">	tf::Quaternion q;</span><br><span class="line">	q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);<span class="comment">//设置四元数</span></span><br><span class="line">	transform.<span class="built_in">setRotation</span>(q);<span class="comment">//设置旋转</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 广播world与海龟坐标系之间的tf数据</span></span><br><span class="line">	br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));<span class="comment">//将坐标变换关系发送到坐标树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输入参数作为海龟的名字</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 订阅海龟的位姿话题</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line">	ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">	ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-创建TF监听器"><a href="#3-创建TF监听器" class="headerlink" title="(3)创建TF监听器"></a>(3)创建TF监听器</h3><p>监听器的作用就是从TF树中获取坐标变换关系。</p>
<ul>
<li>定义TF监听器</li>
<li>查找坐标变换</li>
</ul>
<p>现在我们从TF树中获取turtle2相对于turtle1的坐标变换，从而控制turtle2的移动。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求产生turtle2</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	turtlesim::Spawn srv;</span><br><span class="line">	add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建发布turtle2速度控制指令的发布者</span></span><br><span class="line">	ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建tf的监听器</span></span><br><span class="line">	tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line">	<span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">		tf::StampedTransform transform;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));<span class="comment">//等待TF数据，看系统中是否有这个数据。</span></span><br><span class="line">			listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);<span class="comment">//查询数据，结果保存到transform里</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span> (tf::TransformException &amp;ex) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">			ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span></span><br><span class="line">		geometry_msgs::Twist vel_msg;</span><br><span class="line">		vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">				                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">		vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">				                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">		turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">		rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-Launch文件"><a href="#2-Launch文件" class="headerlink" title="2.Launch文件"></a>2.Launch文件</h2><p>前面我们每启动一个节点，都需要在终端中输入一个命令，这十分麻烦，我们可以用启动文件来进行运行，这样一次就可以启动多个节点，还可以自动启动ROS Master节点管理器，并实现每个节点的各种配置。</p>
<p>Launch文件是一个.XML文件。它可以自动启动ROS Master。</p>
<h3 id="1-根元素"><a href="#1-根元素" class="headerlink" title="(1)根元素"></a>(1)根元素</h3><p>XML文件中必须包含一个根元素，采用<code>&lt;launch&gt;</code>标签定义，文件中其他的内容都必须在这个标签内。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">其他内容</span><br><span class="line">&lt;\launch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-节点元素"><a href="#2-节点元素" class="headerlink" title="(2)节点元素"></a>(2)节点元素</h3><p>采用节点标签定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span>	<span class="attr">pkg</span>=<span class="string">&quot;功能包名字&quot;</span>   <span class="attr">type</span>=<span class="string">&quot;可执行文件名字&quot;</span>	<span class="attr">name</span>=<span class="string">&quot;节点名字&quot;</span>		/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这三个属性是最基本的属性，后面节点的名字是定义运行该可执行文件产生的节点名字，会覆盖节点中init()赋予的节点名字。</p>
<p>在节点元素中，我们还可以增加其他属性。</p>
<p><code>output=&quot;screen&quot;</code> ：讲节点的标准输出打印到终端屏幕，默认输出为日志文档。</p>
<p><code>respawn=&quot;true&quot;</code>：复位属性，该节点停止时，会自动重启，默认为false。</p>
<p><code>required=&quot;true&quot;</code> ：必要节点，该节点终止时，launch文件中的其他节点也被终止。</p>
<p><code>ns=&quot;namespace&quot;</code> ：命名空间，为节点内的相对名称添加命名空间前缀。</p>
<p><code>args=&quot;arguments&quot;</code> ：节点需要的输入参数。</p>
<h3 id="3-参数元素"><a href="#3-参数元素" class="headerlink" title="(3)参数元素"></a>(3)参数元素</h3><p>为了方便全局参数的修改和设置，我们使用参数设置标签<code>&lt;param&gt;</code> 或 <code>&lt;rosparam&gt;</code> 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> 		<span class="attr">name</span>=<span class="string">&quot;参数名字&quot;</span>		<span class="attr">value</span>=<span class="string">&quot;设置参数值&quot;</span>   /&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是还是觉得一条一条的打很麻烦，我们还可以用加载参数文件的方式。</p>
<p><code>&lt;rosparam&gt;</code> 可以帮助我们将一个YAML格式文件中的参数全部加载到ROS参数服务器中，需要设置command属性为”load”，还可以设置命名空间”ns”。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span>  	<span class="attr">file</span>=<span class="string">&quot;文件名.YAML&quot;</span>		<span class="attr">command</span>=<span class="string">&quot;load&quot;</span>		<span class="attr">ns</span>=<span class="string">&quot;命名空间&quot;</span>		/&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有一个参数，就是launch文件中的参数，类似于文件内部的局部变量，仅限于在launch文件中使用，与ROS的参数无关。我们可以用<code>&lt;arg&gt;</code> 来设置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> 	<span class="attr">name</span>=<span class="string">&quot;参数名&quot;</span>		<span class="attr">default</span>=<span class="string">&quot;参数值&quot;</span>	/&gt;</span>   //设置参数</span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> 		<span class="attr">name</span>=<span class="string">&quot;foo&quot;</span>		<span class="attr">value</span>=<span class="string">&quot;$&#123;arg		设置的参数名&#125;&quot;</span>	/&gt;</span>		//使用这个参数</span><br></pre></td></tr></table></figure>
<h3 id="4-重映射机制"><a href="#4-重映射机制" class="headerlink" title="(4)重映射机制"></a>(4)重映射机制</h3><p>在别人的功能包的接口和自己要用的不一样的时候，我们可以将这个功能包改一个名字。例如，turtlebot的键盘控制节点发布的速度指令话题为/turtlebot/cmd_vel，但是我们的机器人订阅的速度控制话题是/cmd_vel，这是使用<code>&lt;remap&gt;</code> 就可以进行重映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span>	<span class="attr">from</span>=<span class="string">&quot;/turtlebot/cmd_vel&quot;</span>	<span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span>	/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-嵌套复用"><a href="#5-嵌套复用" class="headerlink" title="(5)嵌套复用"></a>(5)嵌套复用</h3><p>在复杂系统中，launch文件往往有很多，这些launch文件之间也可能会存在依赖关系，如果要直接服用一个已有launch文件中的内容，可以使用<code>&lt;include&gt;</code> 标签包含其他launch文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>	<span class="attr">file</span>=<span class="string">&quot;$&#123;dirname&#125;/other.launch&quot;</span>	/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-使用"><a href="#6-使用" class="headerlink" title="(6)使用"></a>(6)使用</h3><p>写好launch文件后，将其放在名为launch的文件夹中，然后在工作空间目录打开终端，使用<code>catkin_make</code> 进行编译，然后使用<code>roslaunch</code>直接运行launch文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch	功能包		launch文件</span><br></pre></td></tr></table></figure>
<h2 id="3-QT工具箱"><a href="#3-QT工具箱" class="headerlink" title="3.QT工具箱"></a>3.QT工具箱</h2><p>为了方便可视化调试和显示，ROS提供了QT工具箱。</p>
<p>以<code>rqt</code> 开头的命令即为QT工具的命令。</p>
<p><code>rqt_graph</code>     显示系统的计算图，通过这张图可以了解整个系统的全貌。</p>
<p><code>rqt_console</code>     显示工作日志信息。</p>
<p><code>rqt_plot</code>     数据绘图工具。</p>
<p><code>rosrun     rqt_reconfigure    rqt_reconfigure</code>    参数动态配置，可以在不重启系统时，动态配置ROS系统中的参数。</p>
<p><code>rqt_imag</code>     有摄像头时，显示图像。</p>
<p><code>rqt</code>    所有工具的集合窗口，在界面中选择工具。</p>
<h2 id="4-rviz三维可视化平台"><a href="#4-rviz三维可视化平台" class="headerlink" title="4.rviz三维可视化平台"></a>4.rviz三维可视化平台</h2><p>启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun	rviz	rviz</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033355.png" alt="image-20211007011943519"></p>
<h2 id="5-Gazebo"><a href="#5-Gazebo" class="headerlink" title="5.Gazebo"></a>5.Gazebo</h2><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033402.png" alt="image-20211007012012849"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033410.png" alt="image-20211007012025774"></p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS3】ROS开发环境搭建</title>
    <url>/2021/10/21/%E3%80%90ROS3%E3%80%91ROS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本文介绍如何创建ROS的工作空间，编程的开发环境。<br><span id="more"></span></p>
<h1 id="一、文件系统介绍"><a href="#一、文件系统介绍" class="headerlink" title="一、文件系统介绍"></a>一、文件系统介绍</h1><p>首先介绍一下ROS中的文件系统。<br>ROS文件系统指的是在硬盘上，ROS源码的组织形式。大致结构如下图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033529.png" alt="image-20211021164223501"></p>
<p>Workspace：为自定义的工作空间。</p>
<ul>
<li>build：编译空间，放置编译过程中产生的文件。（我们可以不用管）</li>
<li>devel：开发空间，用于存放编译后生成的目标文件，包括头文件、动态或静态链接库、可执行文件。</li>
<li>src：存放源码。各个功能包的源码文件就在该目录下。<ul>
<li>CMakeLists.txt：存储编译的基本配置。</li>
<li>Package：功能包，包含多个节点、库与配置文件源码。<ul>
<li>CMakeLists.txt：配置编译规则(与上层CMakeLists不同的是，此处仅配置该功能包下的编译规则)。</li>
<li>package.xml：包信息，比如：包名、版本、作者、依赖项等。</li>
<li>scripts：存储python源文件。</li>
<li>src：存储C++源文件。</li>
<li>include：头文件</li>
<li>msg：存储话题消息通信格式文件。</li>
<li>srv：存储服务通信格式文件。</li>
<li>launch：存储launch文件。</li>
<li>config：存储配置文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>关于文件系统的相关命令</strong></p>
<h2 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h2><p><code>catkin_create_pkg 自定义包名 依赖包</code>     创建新的ROS功能包</p>
<p><code>sudo apt install xxx</code>       安装 ROS功能包</p>
<h2 id="2-删"><a href="#2-删" class="headerlink" title="2.删"></a>2.删</h2><p><code>sudo apt purge xxx</code>       删除某个功能包</p>
<h2 id="3-查"><a href="#3-查" class="headerlink" title="3.查"></a>3.查</h2><p><code>rospack list</code>     列出所有功能包</p>
<p><code>rospack find 包名</code>      查找某个功能包是否存在，如果存在返回安装路径</p>
<p><code>roscd 包名</code>      进入某个功能包</p>
<p><code>rosls 包名</code>        列出某个包下的文件</p>
<p><code>apt search xxx</code>    搜索某个功能包</p>
<h2 id="4-改"><a href="#4-改" class="headerlink" title="4.改"></a>4.改</h2><p><code>rosed 包名 文件名</code>        修改功能包文件</p>
<p>需要安装 vim</p>
<p><strong>比如:</strong><code>rosed turtlesim Color.msg</code></p>
<h1 id="二、ROS开发环境搭建"><a href="#二、ROS开发环境搭建" class="headerlink" title="二、ROS开发环境搭建"></a>二、ROS开发环境搭建</h1><p>在介绍完了文件系统后，我们就可以搭建开发环境了。开发环境就是我们写代码然后又能运行所需要的环境。如果想运行我们写的代码，大致分为三个阶段。分别为准备阶段，编写阶段，编译阶段。</p>
<p>在前期的准备阶段，我们要创建一个写代码的地方。</p>
<h2 id="1-创建工作空间"><a href="#1-创建工作空间" class="headerlink" title="1.创建工作空间"></a>1.创建工作空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p 自定义工作空间名/src</span><br><span class="line"><span class="built_in">cd</span> 自定义工作空间名</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>上述命令，首先会创建一个工作空间以及一个<code>src</code>子目录，然后再进入工作空间调用 catkin_make命令编译。</p>
<p>==注意：如果想要<code>catkin_make</code>，就必须要有<code>src</code>目录。==</p>
<h2 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h2><p>环境变量就是让系统知道当前工作空间下的功能包和launch文件的名字，这方便我们在终端可以直接运行这些命令。</p>
<p>首先在创建完工作空间后，工作空间目录下的<code>devel</code>中，有一个<code>setup.bash</code>的文件。</p>
<p>然后我们来到linux的用户文件夹下，使用快捷键<code>Ctrl+H</code>显示出隐藏文件。</p>
<p>找到<code>.bashrc</code>文件，打开。</p>
<p>在后面添上一句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>	setup.bash的路径</span><br></pre></td></tr></table></figure>
<p>这样就配置好了环境变量，如果不配置，那么每次想要在终端运行该空间中的功能包节点时，就需要source 该文件路径。</p>
<h2 id="3-创建功能包"><a href="#3-创建功能包" class="headerlink" title="3.创建功能包"></a>3.创建功能包</h2><p>==进入工作空间中的<code>src</code>目录==。输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg 自定义的功能包名 roscpp rospy std_msgs</span><br></pre></td></tr></table></figure>
<p>这样就创建了功能包，产生了功能包目录，后面的<code>roscpp</code>等是该功能包的依赖。</p>
<h2 id="4-编写源文件"><a href="#4-编写源文件" class="headerlink" title="4.编写源文件"></a>4.编写源文件</h2><p>在功能包目录下建立<code>src</code>目录，在这里我们就可以创建要编写的C++源文件了。</p>
<p>在源文件中，要包括以下几个部分：</p>
<p>(1)头文件</p>
<p>(2)节点初始化</p>
<p>​    在<code>main</code>函数中，使用<code>ros::init(argc,argv,&quot;节点名&quot;)</code>函数初始化节点。这里初始化节点的名字就是运行节点后节点    的名字，但是名字也可在 launch文件中重映射。</p>
<p>(3)输出信息</p>
<p>​    可以用<code>ROS_INFO(&quot;输出信息&quot;)</code>函数输出节点运行后的信息，来验证节点是否启动成功。</p>
<p>C++源文件代码事例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//执行 ros 节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建 ros 节点句柄(非必须)</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//控制台输出 hello world</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-编写配置文件"><a href="#5-编写配置文件" class="headerlink" title="5.编写配置文件"></a>5.编写配置文件</h2><p>我们写完代码后，如果想要运行该程序，还要进行编译，编译就要按照一定的规则，所以我们要编写编译的规则文件，也就是配置文件<code>CMakeLists.txt</code></p>
<p>主要改的地方有两个：</p>
<p>(1)添加生成可执行文件。</p>
<p>(2)链接库文件。</p>
<h2 id="6-编译"><a href="#6-编译" class="headerlink" title="6.编译"></a>6.编译</h2><p>配置好<code>CMakeLists.txt</code>文件后，我们便可以进行编译了。</p>
<p>回到工作空间目录，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>生成了可执行文件，可执行文件存放在工作空间下的<code>devel</code>目录。</p>
<p>接下来要运行某个功能包的节点，就直接可以使用<code>rosrun</code>命令了。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>【ROS2】使用URDF创建机器人模型</title>
    <url>/2021/10/18/%E3%80%90ROS2%E3%80%91%E4%BD%BF%E7%94%A8URDF%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>编写urdf文件，创建机器人模型，可以在rviz中可视化或导入到gazebo中仿真。<br><span id="more"></span></p>
<h1 id="一、介绍urdf"><a href="#一、介绍urdf" class="headerlink" title="一、介绍urdf"></a>一、介绍urdf</h1><p>urdf是一个xml文件，通过参数服务器读取URDF文件，可以建立机器人模型，并在rviz或gazebo中可视化机器人模型。xacro是可编程urdf文件，可以定义宏和变量来优化urdf文件的编写过程，然后在生成urdf文件。</p>
<p>在仿真的过程中，我们会接触两个软件，一个是rviz，另一个是gazebo。</p>
<p>rviz是一个可视化工具，它可以将ros中的数据可视化出来。</p>
<p>gazebo是一个仿真工具，它可以建立真实的物理仿真环境，产生实验结果数据。</p>
<p>内容包括：</p>
<ul>
<li>URDF文件编写</li>
<li>使用xacro来编写URDF文件</li>
<li>设置传感器</li>
</ul>
<h1 id="二、urdf文件编写与在rviz中可视化"><a href="#二、urdf文件编写与在rviz中可视化" class="headerlink" title="二、urdf文件编写与在rviz中可视化"></a>二、urdf文件编写与在rviz中可视化</h1><h2 id="1-创建功能包"><a href="#1-创建功能包" class="headerlink" title="1.创建功能包"></a>1.创建功能包</h2><p>创建功能包，功能包的依赖有urdf，xacro</p>
<p>在功能包下建立<code>urdf文件夹</code>，和<code>launch文件夹</code> 。</p>
<p>在urdf文件夹下建立<code>.urdf</code>文件。</p>
<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;foot_print&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- &lt;cylinder radius=&quot;1&quot; length=&quot;1&quot;/&gt;   --&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- &lt;box size=&quot;length width height&quot;/&gt; --&gt;</span></span><br><span class="line">           			<span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span>/&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- &lt;mesh filename=&quot;package://mesh/xxx.stl&quot; --&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>       <span class="comment">&lt;!--set origin position--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rbga</span>=<span class="string">&quot;0 0 0 1&quot;</span>/&gt;</span>         <span class="comment">&lt;!--set color--&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- &lt;box size=&quot;length width height&quot;/&gt; --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;sphere radius=&quot;r&quot;/&gt; --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;mesh filename=&quot;package://mesh/xxx.stl&quot; --&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>       <span class="comment">&lt;!--set origin position--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">color</span> <span class="attr">rbga</span>=<span class="string">&quot;0 0 0 1&quot;</span>/&gt;</span>         <span class="comment">&lt;!--set color--&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;body2foot_print&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span>   <span class="comment">&lt;!--set joint name and type(such as : fixed continous ...)--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;foot_print&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;body&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>    <span class="comment">&lt;!--set joint position--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>            <span class="comment">&lt;!--set rotation axis--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在编写urdf时可以直接复制，然后修改。</p>
<blockquote>
<p>注意urdf中的joint位置，就是child link的坐标系相对于parent link的位置和角度，然后旋转轴的选择是根据parent link坐标轴定的。</p>
</blockquote>
<h2 id="3-编写launch文件"><a href="#3-编写launch文件" class="headerlink" title="3.编写launch文件"></a>3.编写launch文件</h2><p>在launch文件夹下新建一个.launch文件。</p>
<p>我们需要启动rviz，并把urdf文件导入。rviz启动后可以自动载入解析urdf文件。</p>
<p>在ros中，我们要把urdf文件的路径设置到参数服务器中，使用参数名为 <code>robot_description</code> ,==注意参数名必须是这个==。</p>
<p>代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--set parameters--&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span>  <span class="attr">textfile</span>=<span class="string">&quot;$(find package)/urdf/xxx.urdf&quot;</span>/&gt;</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">&lt;!--run rviz node--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">	    <span class="comment">&lt;!--run robot and joint state publish node--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面还有两句话，是要启动机器人状态和关节状态发布节点。这样才能在rviz中正常显示出机器人。</p>
<h2 id="4-其他补充"><a href="#4-其他补充" class="headerlink" title="4.其他补充"></a>4.其他补充</h2><h3 id="1-保存和调用rviz配置文件"><a href="#1-保存和调用rviz配置文件" class="headerlink" title="(1)保存和调用rviz配置文件"></a>(1)保存和调用rviz配置文件</h3><p>我们在rviz中，设置的一些配置选项，可以保存成.rviz文件，并保存在功能包下的<code>config</code>文件夹。</p>
<p>在rviz中的工具栏<code>file</code>中，有<code>save config as</code> ，便可以保存配置信息。</p>
<p>然后在3中的launch文件中，修改一下最后一行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--run rviz node--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find package)/config/xxx.rviz/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-检查urdf文件"><a href="#2-检查urdf文件" class="headerlink" title="(2)检查urdf文件"></a>(2)检查urdf文件</h3><p>在写完urdf文件后，我们并不知道写的对不对，因此可以用<code>check_urdf</code>个工具来进行检查。</p>
<p>首先要进入urdf的文件目录。</p>
<p>然后在终端输入<code>check_urdf xxx.urdf</code> 来进行检查。</p>
<p>如果语法没有问题，终端就会显示root link和child link。</p>
<h3 id="3-查看刚体结构信息"><a href="#3-查看刚体结构信息" class="headerlink" title="(3)查看刚体结构信息"></a>(3)查看刚体结构信息</h3><p>我们生成的是机器人模型，机器人中各部分的关系我们也可以用图像的方式进行查看。</p>
<p>首先进入urdf文件所在目录。</p>
<p>在终端输入<code>urdf_to_graphiz xxx.urdf</code>，然后就会在该目录下生成一个pdf文件，显示各刚体间的关系。</p>
<h1 id="三、xacro文件编写"><a href="#三、xacro文件编写" class="headerlink" title="三、xacro文件编写"></a>三、xacro文件编写</h1><p>前面我们介绍了urdf文件的编写，但是有一个问题就是，每当编写一个link时，都要写一串代码，不能提高代码的复用率。所以，xacro文件就是一种可以编程的urdf文件，它可以定义宏（也就是函数）和变量，来编辑urdf，这样方便后面的参数修改和代码复用。</p>
<h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现"></a>1.代码实现</h2><h3 id="1-包含xlmns空间"><a href="#1-包含xlmns空间" class="headerlink" title="(1)包含xlmns空间"></a>(1)包含xlmns空间</h3><p>具体的urdf格式和之前都相同，不同的是就是可以把urdf的代码进行封装和调用。</p>
<p>这里要注意，使用xacro写urdf时，一定要加上<code>xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span> </span><br><span class="line">		</span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-变量封装与调用"><a href="#2-变量封装与调用" class="headerlink" title="(2)变量封装与调用"></a>(2)变量封装与调用</h3><p>封装：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;Param_Name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;body&quot;</span>/&gt;</span>     </span><br></pre></td></tr></table></figure>
<p>调用：在调用处，用花括号来使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;Param_Name&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-宏-函数-定义与调用"><a href="#3-宏-函数-定义与调用" class="headerlink" title="(3)宏(函数)定义与调用"></a>(3)宏(函数)定义与调用</h3><p>我们现在以生成刚体为例，首先要写清楚宏的名字，然后传入的变量名。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;creat_link&quot;</span> <span class="attr">params</span>=<span class="string">&quot;name  radius length color&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">gemometry</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;length&#125;&quot;</span>/&gt;</span>                                    	</span><br><span class="line">         <span class="tag">&lt;/<span class="name">gemometry</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;radius/2&#125; 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>调用的时候直接传入参数即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:creat_link</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span> <span class="attr">color</span>=<span class="string">&quot;black&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-头文件包含"><a href="#4-头文件包含" class="headerlink" title="(4)头文件包含"></a>(4)头文件包含</h3><p>一个xacro文件可以包含另一个xacro文件，因此我们可以分文件给机器人各个部分建模。</p>
<p>包含头文件的相对路径为当前xacro文件所在的路径，也可以使用绝对路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;xxx.xacro&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-xacro转换为urdf文件"><a href="#2-xacro转换为urdf文件" class="headerlink" title="2.xacro转换为urdf文件"></a>2.xacro转换为urdf文件</h2><p>可以通过ros中的节点将xacro文件转换成urdf文件。</p>
<p>进入xacro所在目录，在终端中输入<code>rosrun xacro xacro xxx.xacro &gt; xxx.urdf</code></p>
<h2 id="3-launch文件编写"><a href="#3-launch文件编写" class="headerlink" title="3.launch文件编写"></a>3.launch文件编写</h2><p>如2中所述，我们可以现将xacro文件转换成urdf文件，然后再将其导入参数服务器。</p>
<p>还有一种方法是不生成中间的urdf文件，在launch文件中编写直接导入到参数服务器。</p>
<p>代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> = <span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span> = <span class="string">&quot;$(find xacro)/xacro $(find package)/urdf/xxx.xacro&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>加载robot_description 时使用command属性，属性值是调用xacro功能包的xacro程序直接解析xacro文件。</p>
<p>这样就可以在正常显示机器人了。</p>
<blockquote>
<p>注意：在使用gazebo插件时，例如后面提到的相机传感器等，使用的是xacro配置文件，那么就必须要调用xacro功能包中的xacro程序来进行解析，否则传感器是不能仿真成功的。切记切记，我之前就直接把xacro文件当成urdf文件了，结果摄像头显示失败。</p>
</blockquote>
<h1 id="四、urdf集成到gazebo"><a href="#四、urdf集成到gazebo" class="headerlink" title="四、urdf集成到gazebo"></a>四、urdf集成到gazebo</h1><p>从urdf集成到gazebo与集成到rviz不同，因为rviz是可视化工具，所以不需要知道机器人各部分的物理属性，而到gazebo中，则需要将这些物理属性配置出来。</p>
<p>主要的不同点有：</p>
<ul>
<li>在urdf编写时，还要加入<code>&lt;collision&gt;</code>和<code>&lt;inertial&gt;</code>两个标签。</li>
<li>urdf的颜色属性，由gazebo来配置。</li>
</ul>
<p>在创建功能包的时候，我们添加的依赖有urdf,xacro,gazebo_ros,gazebo_ros_control,gazebo_plugins</p>
<h2 id="1-urdf代码实现"><a href="#1-urdf代码实现" class="headerlink" title="1.urdf代码实现"></a>1.urdf代码实现</h2><h3 id="1-添加-lt-collision-gt-和-lt-inertial-gt"><a href="#1-添加-lt-collision-gt-和-lt-inertial-gt" class="headerlink" title="(1)添加&lt;collision&gt;和&lt;inertial&gt;"></a>(1)添加<code>&lt;collision&gt;</code>和<code>&lt;inertial&gt;</code></h3><p>第一个不同就是要添加<code>&lt;collision&gt;</code>和<code>&lt;inertial&gt;</code>两个标签，<code>&lt;collision&gt;</code>的子标签和<code>&lt;geometry&gt;</code>类似。而<code>&lt;inertial&gt;</code>标签是添加刚体的惯性属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;foot_print&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">geometry</span>&gt;</span>                           </span><br><span class="line">        		<span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span>/&gt;</span>                              </span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>       <span class="comment">&lt;!--set origin position--&gt;</span></span><br><span class="line">   		  <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">color</span> <span class="attr">rbga</span>=<span class="string">&quot;0 0 0 1&quot;</span>/&gt;</span>         <span class="comment">&lt;!--set color--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">                    </span><br><span class="line">		<span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span>                           </span><br><span class="line">        		<span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span>/&gt;</span>                              </span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">                    </span><br><span class="line">		<span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;1&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-计算惯性矩阵宏"><a href="#2-计算惯性矩阵宏" class="headerlink" title="(2)计算惯性矩阵宏"></a>(2)计算惯性矩阵宏</h3><p>在ros中有通过xacro定义的宏来计算。</p>
<p>球体惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Macro for inertia matrix --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;sphere_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>圆柱惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;cylinder_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r h&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">iyz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*r*r/2&#125;&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>立方体惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;Box_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m l w h&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(h*h + l*l)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(w*w + l*l)/12&#125;&quot;</span> <span class="attr">iyz</span>= <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*(w*w + h*h)/12&#125;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，原则上，除了 base_footprint 外，机器人的每个刚体部分都需要设置惯性矩阵，且惯性矩阵必须经计算得出，如果随意定义刚体部分的惯性矩阵，那么可能会导致机器人在 Gazebo 中出现抖动，移动等现象。</p>
<h3 id="3-添加颜色"><a href="#3-添加颜色" class="headerlink" title="(3)添加颜色"></a>(3)添加颜色</h3><p>如果要在gazebo中显示link的颜色，必须使用gazebo指定的标签。</p>
<p>其中Gazebo的G必须大写，颜色首字母也必须大写。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;link_name&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Blue<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-launch文件"><a href="#2-launch文件" class="headerlink" title="2.launch文件"></a>2.launch文件</h2><p>启动gazebo，我们调用gazebo功能包中的launch文件。</p>
<p>在这里我们用include包含<code>empty_world.launch</code>文件，然后我们用参数导入我们需要的世界环境。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find package)/worlds/box_house.world&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在gazebo中加载机器人模型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model car -param robot_description&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这句话的意思是启动<code>gazebo_ros</code>中的<code>spawn_model</code>节点，然后加载参数服务器中的<code>robot_description</code>。</p>
<p><code>-urdf</code>是说加载的是urdf文件 </p>
<p><code>-model car</code>是把这个模型命名为car</p>
<p><code>-param robot_description</code> 从参数robot_description 中载入模型。</p>
<p>最终的launch文件为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> = <span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span> = <span class="string">&quot;$(find xacro)/xacro $(find package)/urdf/xxx.xacro&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  	<span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find package)/world/xx.world&quot;</span></span></span><br><span class="line"><span class="tag">    &lt;/<span class="attr">include</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model car  -param robot_description&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-配置传感器"><a href="#3-配置传感器" class="headerlink" title="3.配置传感器"></a>3.配置传感器</h2><p>gazebo作为仿真工具，有一些插件，在urdf文件编写的时候，可以将这些插件赋予机器人的各个部分。</p>
<p>例如可以为轮子赋予驱动器，也就是电机。为我们建立的相机模型，赋予相机的功能。这些都需要gazebo提供的插件。</p>
<h3 id="1-运动控制器"><a href="#1-运动控制器" class="headerlink" title="(1)运动控制器"></a>(1)运动控制器</h3><p>gazebo自带运动控制器，它可以为驱动器输入控制信号。</p>
<p>首先，我们要设置驱动器位置，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;joint_trans&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- Transmission is important to link the joints and the controller --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_trans&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_motor&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;wheel_front_left2body&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;wheel_front_right2body&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里我们输入放置驱动器部位的关节名称。</p>
<p>驱动器建立好后，我们再配置控制器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;differential_drive_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_diff_drive.so&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">rosDebugLevel</span>&gt;</span>Debug<span class="tag">&lt;/<span class="name">rosDebugLevel</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">publishWheelTF</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publishWheelTF</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">robotNamespace</span>&gt;</span>/<span class="tag">&lt;/<span class="name">robotNamespace</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">publishTf</span>&gt;</span>1<span class="tag">&lt;/<span class="name">publishTf</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">publishWheelJointState</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publishWheelJointState</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>100.0<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">legacyMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">legacyMode</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">leftJoint</span>&gt;</span>wheel_front_left2body<span class="tag">&lt;/<span class="name">leftJoint</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">rightJoint</span>&gt;</span>wheel_front_right2body<span class="tag">&lt;/<span class="name">rightJoint</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">wheelSeparation</span>&gt;</span>$&#123;body_width * 2&#125;<span class="tag">&lt;/<span class="name">wheelSeparation</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">wheelDiameter</span>&gt;</span>$&#123;wheel_radius * 2&#125;<span class="tag">&lt;/<span class="name">wheelDiameter</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">broadcastTF</span>&gt;</span>1<span class="tag">&lt;/<span class="name">broadcastTF</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">wheelTorque</span>&gt;</span>300<span class="tag">&lt;/<span class="name">wheelTorque</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">wheelAcceleration</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">wheelAcceleration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">commandTopic</span>&gt;</span>cmd_vel<span class="tag">&lt;/<span class="name">commandTopic</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">odometryFrame</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometryFrame</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">odometryTopic</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometryTopic</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">robotBaseFrame</span>&gt;</span>foot_print<span class="tag">&lt;/<span class="name">robotBaseFrame</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-相机"><a href="#2-相机" class="headerlink" title="(2)相机"></a>(2)相机</h3><p>在建立好相机刚体模型后，我们可以为这个刚体模型赋予相机的功能。</p>
<p>另外要注意的是，相机的视角是沿着所依附link的x轴正方向，例如相机的x轴朝前，相机的视角就是超前。如果想让相机朝下看，那么在设置相机joint的时候，就让link的x轴朝下方。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;camera&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera_node&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>30.0<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="tag">&lt;<span class="name">camera</span> <span class="attr">name</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">horizontal_fov</span>&gt;</span>1.3962634<span class="tag">&lt;/<span class="name">horizontal_fov</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">width</span>&gt;</span>1280<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">height</span>&gt;</span>720<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">format</span>&gt;</span>R8G8B8<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clip</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">near</span>&gt;</span>0.02<span class="tag">&lt;/<span class="name">near</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">far</span>&gt;</span>300<span class="tag">&lt;/<span class="name">far</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">clip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>gaussian<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mean</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">mean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">stddev</span>&gt;</span>0.007<span class="tag">&lt;/<span class="name">stddev</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noise</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_camera&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_camera.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cameraName</span>&gt;</span>/camera<span class="tag">&lt;/<span class="name">cameraName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageTopicName</span>&gt;</span>image_raw<span class="tag">&lt;/<span class="name">imageTopicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cameraInfoTopicName</span>&gt;</span>camera_info<span class="tag">&lt;/<span class="name">cameraInfoTopicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>camera<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hackBaseline</span>&gt;</span>0.07<span class="tag">&lt;/<span class="name">hackBaseline</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK3</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionT1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionT1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionT2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionT2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-雷达"><a href="#3-雷达" class="headerlink" title="(3)雷达"></a>(3)雷达</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;laser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;ray&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rplidar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pose</span>&gt;</span>0 0 0 0 0 0<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visualize</span>&gt;</span>true<span class="tag">&lt;/<span class="name">visualize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>5.5<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ray</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scan</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horizontal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">samples</span>&gt;</span>360<span class="tag">&lt;/<span class="name">samples</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resolution</span>&gt;</span>1<span class="tag">&lt;/<span class="name">resolution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">min_angle</span>&gt;</span>-3<span class="tag">&lt;/<span class="name">min_angle</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max_angle</span>&gt;</span>3<span class="tag">&lt;/<span class="name">max_angle</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">horizontal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">scan</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">range</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">min</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">min</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">max</span>&gt;</span>30.0<span class="tag">&lt;/<span class="name">max</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resolution</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">resolution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">range</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>gaussian<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mean</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">mean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">stddev</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">stddev</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noise</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ray</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_rplidar&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_laser.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">topicName</span>&gt;</span>/scan<span class="tag">&lt;/<span class="name">topicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>laser<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-深度相机"><a href="#4-深度相机" class="headerlink" title="(4)深度相机"></a>(4)深度相机</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;support&quot;</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;depth&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">always_on</span>&gt;</span>true<span class="tag">&lt;/<span class="name">always_on</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">camera</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horizontal_fov</span>&gt;</span>$&#123;60.0*PI/180.0&#125;<span class="tag">&lt;/<span class="name">horizontal_fov</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">format</span>&gt;</span>R8G8B8<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">width</span>&gt;</span>640<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">height</span>&gt;</span>480<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">clip</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">near</span>&gt;</span>0.05<span class="tag">&lt;/<span class="name">near</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">far</span>&gt;</span>8.0<span class="tag">&lt;/<span class="name">far</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">clip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;kinect_camera_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_openni_kinect.so&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cameraName</span>&gt;</span>camera<span class="tag">&lt;/<span class="name">cameraName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>10<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">imageTopicName</span>&gt;</span>rgb/image_raw<span class="tag">&lt;/<span class="name">imageTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">depthImageTopicName</span>&gt;</span>depth/image_raw<span class="tag">&lt;/<span class="name">depthImageTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pointCloudTopicName</span>&gt;</span>depth/points<span class="tag">&lt;/<span class="name">pointCloudTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cameraInfoTopicName</span>&gt;</span>rgb/camera_info<span class="tag">&lt;/<span class="name">cameraInfoTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">depthImageCameraInfoTopicName</span>&gt;</span>depth/camera_info<span class="tag">&lt;/<span class="name">depthImageCameraInfoTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>body<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">baseline</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">baseline</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k3</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k3</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_t1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_t1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_t2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_t2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pointCloudCutoff</span>&gt;</span>0.4<span class="tag">&lt;/<span class="name">pointCloudCutoff</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>【cmake-3】About Library</title>
    <url>/2022/01/26/%E3%80%90cmake-3%E3%80%91About-Library/</url>
    <content><![CDATA[<p>通常编译的工程文件都会链接库，库分为两类：</p>
<ul>
<li>静态库：static library</li>
<li>分享库（动态库）：shared library</li>
</ul>
<span id="more"></span>
<p>这两类库的区别简单介绍一下：</p>
<p>静态库就是和可执行文件打包在一起（编译好的二进制文件是一个整体），而分享库是可执行文件和库文件不打包在一起，只有链接关系，当程序运行的时候再去调用，这样做可以减少存储空间，反正有许多好处。</p>
<p>添加静态库：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Hello_library STATIC hello.cpp)</span><br></pre></td></tr></table></figure>
<p>生成的文件名是<code>libHello_library.a</code> </p>
<p>添加分享库：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Hello_library SHARED hello.cpp)</span><br></pre></td></tr></table></figure>
<p>生成的文件名是<code>libHello_library.so</code> </p>
<p>这里生成的库名是我们设置的，但是生成的文件是编译后系统取的。在写cmake的时候，如果觉得库的名字不好记，还可以给它起一个外号：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello::library ALIAS Hello_library)</span><br></pre></td></tr></table></figure>
<p>同理我们也可以为我们的target链接库，这里就不区分静态库还是分享库了：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">target</span> PUBLIC hello::library)</span><br></pre></td></tr></table></figure>
<p>这里链接的库名，其实也就是这个库的路径，我们这里没有说明，但实际中我们得先用<code>find_package()</code>来搜索库。</p>
<p>使用该命令查找到库后，会自动定义一些变量：</p>
<ul>
<li><code>xxx_FOUND</code>：判断找没找到这个库</li>
<li><code>xxx_INCLUDE_DIRS</code>：库的头文件路径</li>
<li><code>xxx_LIBRARY</code>：库的路径</li>
</ul>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>【cmake-1】Hello CMake</title>
    <url>/2022/01/26/%E3%80%90cmake-1%E3%80%91Hello-CMake/</url>
    <content><![CDATA[<p>参考：<a href="https://github.com/ttroy50/cmake-examples">github示例</a>、<a href="https://cliutils.gitlab.io/modern-cmake/">学习文档</a></p>
<span id="more"></span>
<p>前几讲主要是介绍cmake的用法，具体的细节会放在后面，因此只看完前面的话应该可以直接上手使用了。</p>
<p>在我们编译代码的时候需要一定的编译规则，简单的工程文件我们可以直接使用<code>gcc</code>或<code>g++</code>来编译，但是当一个工程项目十分复杂的时候，我们就需要提前制定好编译规则。编译规则的文件由<code>MakeFile</code>定义，但是编写<code>MakeFile</code>也是十分复杂的过程，因此我们可以用<code>CMake</code>语言来制定编译规则得到一个<code>CMakeLists.txt</code> 文件，再使用<code>cmake</code> 命令生成MakeFile。</p>
<p>我们现在的工程目录为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure>
<p>当创建使用cmake创建一个工程的时候，先要指定cmake的版本：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br></pre></td></tr></table></figure>
<p>然后设置工程的名字：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(Hello_CMake)</span><br></pre></td></tr></table></figure>
<p>这里设置好工程名字后，会自动的定义一个变量（变量的概念后面会说），叫做<code>PROJECT_NAME</code> ，在使用的用<code>$&#123;PROJECT_NAME&#125;</code>。</p>
<p>然后我们可以设置我们要编译的文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(Hello_CMake main.cpp)</span><br></pre></td></tr></table></figure>
<p>接下来我们就可以编译文件了。编译文件的方法有两种，一种叫做<strong>in-place</strong>，另一种叫做<strong>out-of-source</strong>。通常情况下我们会使用第二种：</p>
<p>在工程的根目录下新建一个<code>build</code>文件夹，在命令行中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>
<p>好了现在就会在<code>build</code> 目录下生成了我们编译生成的可执行文件<code>Hello_CMake</code>。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>【VScode】VScode编译环境配置</title>
    <url>/2021/10/18/%E3%80%90VScode%E3%80%91VScode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在linux或mac中编译C++,首先要配置好编译环境。<br><span id="more"></span></p>
<h3 id="1-首先编写CMakeLists-txt文件"><a href="#1-首先编写CMakeLists-txt文件" class="headerlink" title="1.首先编写CMakeLists.txt文件"></a>1.首先编写CMakeLists.txt文件</h3><p>注意：在<code>c_cpp_properties.json</code>中设置了头文件路径，在编译的过程中就会有头文件内容的提示，但仍需要在<code>CMakeLists.txt</code>中写好包含的头文件路径，否则编译器只会在<code>usr/include文件夹下</code>和<code>CMakeLists.txt</code>所在文件夹下寻找头文件</p>
<p>如果不在<code>c_cpp_properties.json</code>中设置头文件路径，在写代码的时候可能会没有提示，而且头文件名字下会有红波浪线，但可以正常编译</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(文件名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ VAR) <span class="comment">#把当前路径下的所有源文件打包程VAR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(添加头文件路径)<span class="comment">#如果在vscode中已经添加了头文件路径了，就不需要再添加了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(搜索库)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;添加库的头文件&#125;</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)<span class="comment">#如果想调试，加上这一句，生成可调试文件</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS<span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;</span>)<span class="comment">#生成错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(可执行文件名 <span class="variable">$&#123;VAR&#125;</span>)<span class="comment">#生成可执行文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件 库名) <span class="comment">#链接库</span></span><br></pre></td></tr></table></figure>
<h3 id="2-文件根目录中建立一个build文件夹"><a href="#2-文件根目录中建立一个build文件夹" class="headerlink" title="2.文件根目录中建立一个build文件夹"></a>2.文件根目录中建立一个build文件夹</h3><p>编译过程中生成的中间文件和可执行文件全在该文件夹下，可执行文件的位置可在CMakeLists.txt中改变路径</p>
<h3 id="3-建立-json文件夹，编写launch-json文件"><a href="#3-建立-json文件夹，编写launch-json文件" class="headerlink" title="3.建立.json文件夹，编写launch.json文件"></a>3.建立.json文件夹，编写launch.json文件</h3><p>新建launch.json文件，该文件是在VSCODE中按F5后所执行的命令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/可执行文件名&quot;</span>,**<span class="comment">//执行文件的路径加上可执行文件，$&#123;workspaceFolder&#125;为根目录**</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,<span class="comment">//打开外部终端</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">             <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;Build&quot;</span>,<span class="comment">//该命令表示执行launch.json的命令之前的预执行任务，要在tasks.json中设置</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-编写tasks-json文件"><a href="#4-编写tasks-json文件" class="headerlink" title="4.编写tasks.json文件"></a>4.编写tasks.json文件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>:<span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOrder&quot;</span>: <span class="string">&quot;sequence&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span>:[<span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;make&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>【cmake-4】Install一下子</title>
    <url>/2022/01/26/%E3%80%90cmake-4%E3%80%91install%E4%B8%80%E4%B8%8B%E5%AD%90/</url>
    <content><![CDATA[<p>这个例子展示了如何将你生成的target安装到你的系统中。</p>
<span id="more"></span>
<p>工程的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── cmake-examples.conf</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│ └── installing</span><br><span class="line">│ └── Hello.h</span><br><span class="line">├── README.adoc</span><br><span class="line">└── src</span><br><span class="line">├── Hello.cpp</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>make install</code> 进行安装，安装的位置由<code>CMAKE_INSTALL_PREFIX</code> 来控制，这个变量表示安装目的地的根目录。</p>
<p>在cmake中，我们可以用<code>install()</code> 函数来设置。</p>
<h3 id="1-安装可执行文件"><a href="#1-安装可执行文件" class="headerlink" title="1. 安装可执行文件"></a>1. 安装可执行文件</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">TARGET</span> <span class="keyword">target</span> DESTINATION bin )</span><br></pre></td></tr></table></figure>
<p>这里<code>TARGET</code> 和<code>DESTINATION</code>是参数，就像我们填表格一样，要安装的文件是啥？后面写上target，要安装的目的地是哪？后面写上bin。</p>
<p>最终这个文件会被安装到<code>CMAKE_INStALL_PREFIX/bin</code> 路径下。</p>
<h3 id="2-安装库文件"><a href="#2-安装库文件" class="headerlink" title="2. 安装库文件"></a>2. 安装库文件</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">TARGET</span> <span class="keyword">target</span> LIBRARY DESTINATION lib)</span><br></pre></td></tr></table></figure>
<p>注意安装库的参数列表中多了一个<code>LIBRARY</code></p>
<h3 id="3-安装头文件"><a href="#3-安装头文件" class="headerlink" title="3. 安装头文件"></a>3. 安装头文件</h3><p>头文件在一个目录下，所以我们把整个目录都安过去：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/ DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-安装文档文件"><a href="#4-安装文档文件" class="headerlink" title="4. 安装文档文件"></a>4. 安装文档文件</h3><p>其他的一些配置信息，文档什么的按文件处理：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES cmake-examples.conf DESTINATION etc)</span><br></pre></td></tr></table></figure>
<p>如果我们想要更改那个安装前缀<code>CMAKE_INSTALL_PREFIX</code> ，也就是根目录，可以用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_PREFIX <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/install&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;The path to use for make install&quot;</span></span><br><span class="line">FORCE)</span><br></pre></td></tr></table></figure>
<p>为什么这么写，以后会说。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>【cmake-2】Hello Include</title>
    <url>/2022/01/26/%E3%80%90cmake-2%E3%80%91Hello-Include/</url>
    <content><![CDATA[<p>因为在工程中，头文件会放在一个目录中，源文件会放在另一个目录中，这时候需要我们为要编译的文件添上头文件路径。</p>
<span id="more"></span>
<p>我们的工程目录为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│ └── Hello.h</span><br><span class="line">└── src</span><br><span class="line">├── Hello.cpp</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure>
<p>因为源文件都在一个目录下，我们可以用一个变量代替他们：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SOURCES src/Hello.cpp src/main.cpp)</span><br></pre></td></tr></table></figure>
<p><code>set()</code> 是函数，里面的参数用空格分开。</p>
<p>我们也可以使用通配符来设置变量：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SOURCE <span class="string">&quot;src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> cmake中的expand和linux命令行是一样的，上面的命令中不加双引号也行。</p>
</blockquote>
<p>我们还需要添加头文件路径：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">target</span> PRIVATE <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>这里的参数<code>PRIVATE</code>后面会说。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>【git1】git最基本的用法</title>
    <url>/2021/10/18/%E3%80%90git1%E3%80%91git%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>git的一些用法<br><span id="more"></span></p>
<p><a href="https://www.runoob.com/git/git-tutorial.html">参考</a></p>
<p><a href="https://docs.github.com/cn">git官方文档</a></p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先需要知道几个关系    </p>
<p>git本地分为工作区、暂存区、本地库三个地方</p>
<p>工作区(workspace)：即为写代码，写文件的地方</p>
<p>暂存区(staging area)：保存着待提交的文件</p>
<p>本地库(local repository)：提交后文件所在的地方</p>
<p>远程仓库(remote repository)：云端的仓库</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032438.png" alt="image-20210711044151491"></p>
<h3 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h3><p>github要想访问使用的电脑，需要先告诉github通往电脑的钥匙，在（<a href="https://www.jianshu.com/p/7edb6b838a2e">与远程库建立连接</a>）中介绍了怎么获取电脑的钥匙。</p>
<p>一般我会在远程建立一个仓库，在本地建立一个仓库，然后在本地仓库中写，再传到远程仓库。</p>
<p>具体过程：</p>
<ol>
<li><p>先在github上建立一个仓库。</p>
</li>
<li><p>然后把这个仓库<code>git clone</code>到本地。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 地址(在github上有)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在得到的文件夹中就可以进行写代码了。</p>
</li>
<li><p>想要添加到缓存区，就用<code>git add</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add 文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要提交，就用下面的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;描述信息&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在第一次git commit 时候，需要配置好提交人的姓名和邮箱。</p>
<p>git config —global user.name=”Piggy”</p>
<p>git config —global user.email=”a363158526@gmail.com”</p>
</blockquote>
</li>
<li><p>如果要发送到github上，用<code>git push</code>。</p>
<blockquote>
<p>注意，如果这里是第一次git push，要登录用户名和密码。这里的用户名是github上的用户名，我的叫做PiggyHero，密码不是登录的密码，而是github的token，token的获取是在github的设置中，找到Developer settings-&gt;Personal access tokens，然后点击Generate new token，根据需求自己设置token的权限。</p>
<p>token是一串字符，需要保存下来，因为我们只能看见一次，然后就被隐藏起来了。</p>
</blockquote>
</li>
</ol>
<h3 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h3><p>也可以不像一中那样，现在github上建立仓库，而是先在本地建立仓库。</p>
<ol>
<li><p>先建立一个文件夹，作为仓库所在的文件夹，然后<code>git init</code>。</p>
</li>
<li><p>在远程建立一个仓库，记下来SSH地址。</p>
</li>
<li><p>在终端中到本地仓库所在文件夹，使用以下代码建立关联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin SSH地址 //建立本地库与远程库的关系</span><br><span class="line">git push -u origin master //把当前的分支master上的内容转移到远程的库上</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="git-基本命令介绍"><a href="#git-基本命令介绍" class="headerlink" title="git 基本命令介绍"></a>git 基本命令介绍</h2><h3 id="1-git-help"><a href="#1-git-help" class="headerlink" title="1.git help"></a>1.git help</h3><p><code>git help -命令名称或手册名称</code></p>
<p>按F向下翻页，按B向上翻页</p>
<h3 id="2-git-config"><a href="#2-git-config" class="headerlink" title="2.git config"></a>2.git config</h3><p>配置的范围有三种：</p>
<p>（1）系统：无论是哪个用户，在整个系统的范围内，都使用同一配置</p>
<p>（2）全局：只在用户范围内使用该配置</p>
<p>（3）项目：在该项目范围内，使用该配置</p>
<p>一般设置用户的配置文件，用global</p>
<p><code>git config --global 想要配置的东西</code></p>
<p><code>git config --unset --global</code>   恢复原来的配置</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#x27;labixiaoxin&#x27;</span><br><span class="line">git config --unset --global user.name</span><br><span class="line">git config --global user.email ‘labixiaoxin@email.com’</span><br></pre></td></tr></table></figure>
<p>配置的文件在当前的主目录下面，用 <code>cat</code>命令来查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.gitconfig</span><br></pre></td></tr></table></figure>
<h3 id="3-git-init"><a href="#3-git-init" class="headerlink" title="3.git init"></a>3.git init</h3><p>初始化文件夹，会生成repository，文件夹里面会生成git需要的各种文件</p>
<p>如果不想跟踪这个项目，就把 <strong>.git</strong>文件删掉，一般情况下不去改这些文件</p>
<p><strong>.config</strong>文件是项目级别的配置信息，之前的<strong>~/.config </strong>文件是用户级别的配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 文件目录</span><br><span class="line">git init </span><br></pre></td></tr></table></figure>
<h3 id="4-git-status"><a href="#4-git-status" class="headerlink" title="4.git status"></a>4.git status</h3><p>查看当前的状态，显示当前所在的分支和变动的文件</p>
<p><code>git status</code></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032549.png" alt="image-20210708115817078"></p>
<h3 id="5-git-add"><a href="#5-git-add" class="headerlink" title="5.git add"></a>5.git add</h3><p>git添加的流程：先修改文件或增加文件 $\longrightarrow$ 然后告诉git哪些文件想要提交（git add）$\longrightarrow$ 提交（git commit）</p>
<p>添加要提交的文件</p>
<p><code>git add 要添加的文件</code></p>
<p><code>git add .</code>添加所有的文件</p>
<h3 id="6-git-commit"><a href="#6-git-commit" class="headerlink" title="6.git commit"></a>6.git commit</h3><p>提交，后面可以加上提交的信息</p>
<p><code>git commit -m &#39;想要说明的信息&#39;</code></p>
<h3 id="7-git-log"><a href="#7-git-log" class="headerlink" title="7.git log"></a>7.git log</h3><p>使用 <code>git log</code>查看以往的提交信息</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032601.png" alt="image-20210708120726347"></p>
<h3 id="8-git-diff"><a href="#8-git-diff" class="headerlink" title="8.git diff"></a>8.git diff</h3><p><code>git diff 要查看的文件</code>比较的是工作区和暂存区该文件的不同</p>
<p><code>git diff --staged</code>比较的是暂存区和仓库中该文件的不同</p>
<p>这里如果没添加文件，会对比所有修改的文件</p>
<p>红色是修改前的，绿色是修改后的</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032607.png" alt="image-20210708121041581"></p>
<h3 id="8-git-rm"><a href="#8-git-rm" class="headerlink" title="8.git rm"></a>8.git rm</h3><p><code>git rm</code> 表示从暂存区和工作区删除文件，并且将修改后的文件加入暂存区。</p>
<blockquote>
<p>该命令只能删除已经提交到本地库中的文件。当在工作目录中修改，则不能删除；或者及时在工作目录中修改了， 又<code>git add</code>到暂存区了，也是不能用该命令删除的。</p>
</blockquote>
<p>其背后的原理是这样的：例如有一个test.md文件，当你提交后，暂存区里是你最后一次提交后的目录。然后你修改了test.md文件，此时你再删除，git记录的是修改后的test.md被删除了，当你再提交时，git的记录会发生冲突，版本库中的文件是没修改的test.md，你删除的是修改的test.md，两个文件不一样，所以会出错</p>
<p>如果你想硬要针对这种情况删除修改的test.md，并且git能够识别，要用 <code>git rm -f</code>命令，此时便可以删除修改了的test.md</p>
<p>如果仅想在暂存区中删除文件，也就是说仅从跟踪清单中删除，使用 <code>git rm --cached</code></p>
<hr>
<p><strong>另外还有当重命名一个文件时</strong>，直接在文件夹中重命名，然后 <code>git status</code> 会显示该文件被删除，此时可以 <code>git rm</code>原名文件，然后 <code>git add</code>重命名后的文件，git会自动识别该文件名</p>
<h3 id="9-git-mv"><a href="#9-git-mv" class="headerlink" title="9.git mv"></a>9.git mv</h3><p>也可以直接用git mv重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv 现在名 原来名</span><br></pre></td></tr></table></figure>
<p>git mv也可以移动文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv 文件名 目录 </span><br></pre></td></tr></table></figure>
<h3 id="10-git-reset"><a href="#10-git-reset" class="headerlink" title="10.git reset"></a>10.git reset</h3><p>回退版本命令，指定退回某一次提交的版本</p>
<p>共有三种模式</p>
<p>(1)—mixed</p>
<p>首先是 <code>--mixed</code>为默认模式，当变更到指定的版本后，工作区的文件保持不变，会重置暂存区，暂存区的目录和指定的版本的目录相同</p>
<p>例如第一次提交的文件有a.cpp，第二次提交的文件有b.cpp</p>
<p>如果回退到第一个版本，那么b.cpp变为未跟踪文件，暂存区与第一次提交的版本目录相同</p>
<p><code>git reset HEAD^</code> 变更到上一个版本</p>
<p><code>git reset HEAD^ hello.cpp</code>此时最新的版本还在，只是这个最新版本中的hello.cpp回到上一个版本，而工作目录中的文件不变，暂存区中的hello.cpp是上一个版本</p>
<p><code>git reset 版本号</code>回退到指定的版本</p>
<p>(2)—soft</p>
<p>soft只更改HEAD的位置，暂存区和工作目录都不改变，暂存区的文件等待重新提交</p>
<p>例如：<strong>9e78i</strong> 提交添加了 style.css 文件，<strong>035cc</strong> 提交添加了 index.js 文件。使用软重置，我们可以撤销提交记录，但是保留新建的 style.css 和 index.js 文件。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032615.png" alt="img"></p>
<p>如果是mixed模式，需要先 <code>git add</code>才与soft效果相同</p>
<p>(3)—hard</p>
<p>hard模式，是把暂存区和工作目录都变更到指定版本，也就是说本地的文件也和目标的版本相同，就是把当前工作目录的文件，已暂存的文件全部清除（如果记下最后一次版本号，也可以复原）</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032622.gif" alt="img"></p>
<blockquote>
<p><code>git reset HEAD^^^</code>  几个就表示 <code>^</code>，就表示当前版本的前几个版本</p>
<p><code>git reset HEAD~3</code> 也可以用 <code>~数字</code>表示</p>
</blockquote>
<h3 id="11-git-revert"><a href="#11-git-revert" class="headerlink" title="11.git revert"></a>11.git revert</h3><p><code>git revert</code>也同样有三种模式，和reset相同，不同的是reset是回到指定版本，而它表示在现有版本上继续向下走，也就是把之前的版本添加到现在版本之后</p>
<p>举个例子，我们在 ec5be 上添加了 index.js 文件。之后发现并不需要这个文件。那么就可以使用 git revert ec5be 指令还原之前的更改。如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032630.gif" alt="img"></p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习10】环境变量</title>
    <url>/2022/01/22/%E3%80%90linux%E5%AD%A6%E4%B9%A010%E3%80%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>shell程序用一个叫做环境变量（environment variable）的特性来存储有关shell会话和工作环境的信息。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。</p>
<span id="more"></span>
<p>在shell程序中，环境变量可以分为两类：</p>
<ul>
<li>全局环境</li>
<li>局部环境</li>
</ul>
<h2 id="I-查看变量"><a href="#I-查看变量" class="headerlink" title="I. 查看变量"></a>I. 查看变量</h2><p>全局环境变量对所有的shell程序会话和其生成的子shell都是可见的。而局部环境变量则只对创建它们的shell程序可见。</p>
<blockquote>
<p>系统所设置的环境变量都是以大写字母来命名的，我们自己命名的环境变量可以是小写。</p>
</blockquote>
<p>如果想要查看 <strong>全局环境变量</strong> ，可以使用 <code>env</code> 和 <code>printenv</code> 命令，但是显示个别的全局环境变量，则用 <code>printenv  global_variable_name</code> 来查看。</p>
<p>而linux中没有单独查看<strong>局部环境变量</strong>的命令，使用<code>set</code> 可以查看全部的环境变量，包括全局环境变量、局部环境变量和用户自定义的环境变量。</p>
<h2 id="II-设置变量"><a href="#II-设置变量" class="headerlink" title="II. 设置变量"></a>II. 设置变量</h2><h3 id="1-设置局部用户自定义变量"><a href="#1-设置局部用户自定义变量" class="headerlink" title="1. 设置局部用户自定义变量"></a>1. 设置局部用户自定义变量</h3><p>可以直接在终端中设置一个局部的环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> my_variable=Hello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_variable</span></span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>注意：在设置环境变量的时候，等号前后都没空格。</p>
<h3 id="2-设置全局环境变量"><a href="#2-设置全局环境变量" class="headerlink" title="2. 设置全局环境变量"></a>2. 设置全局环境变量</h3><p>设置全局环境变量的方法是先创建一个局部环境变量，然后使用 <code>export</code> 命令来完成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> my_variable=<span class="string">&quot;Hello world&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> my_variable</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_variable</span></span></span><br><span class="line">Hello world</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>这样，在该shell程序的子shell程序中，也可以看见该环境变量。但如果再开启其他终端，则看不见该变量了。</p>
<p>还需要注意的是在子shell中修改全局环境变量，不会影响到父shell中该变量的值。</p>
<h3 id="3-删除环境变量"><a href="#3-删除环境变量" class="headerlink" title="3. 删除环境变量"></a>3. 删除环境变量</h3><p>如果要删除环境变量，可以使用 <code>unset</code> 命令，同理在子shell中删除全局变量并不会影响父shell。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> my_variable</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在涉及到环境变量名的时候，什么时候加$，什么时候不加很乱，有这样一个小技巧，就是如果用到变量就加，如果是操作变量就不加。</p>
</blockquote>
<h2 id="III-设置PATH环境变量"><a href="#III-设置PATH环境变量" class="headerlink" title="III. 设置PATH环境变量"></a>III. 设置PATH环境变量</h2><p>PATH变量是系统内部定义的一个变量，该变量定义了用于查找命令程序的路径。如果我们有了一些新的命令，可以将路径添加到PATH中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> PATH=<span class="variable">$PATH</span>:/home/tree</span></span><br></pre></td></tr></table></figure>
<p>但是，要注意的是我们现在对PATH变量的修改只能持续到退出或重启系统，是不能一直持续下去的。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【git2】git背后的原理</title>
    <url>/2021/12/15/%E3%80%90git2%E3%80%91git%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>细细介绍git背后原理</p>
<span id="more"></span>
<p>在git跟踪一个项目时，有以下三个部分：</p>
<ul>
<li>工作区：就是在电脑里能看到的目录</li>
<li>暂存区：英文叫做stage和index，一般存放在<strong>.git/index</strong>中</li>
<li>版本库：工作区有一个隐藏的目录，<strong>.git</strong>，这就是版本库</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032636.png" alt="image-20210711045622504"></p>
<ul>
<li>首先介绍暂存区中的内容，暂存区就是一个目录树，该目录树上的内容是文件的索引，可以理解为是一个指针，它指向一个文件</li>
<li>这个文件都存在 <strong>objects</strong>中，<strong>objects</strong>表示git的对象库，里面包含了创建的各种对象及内容，它们被存在 <strong>.git/objects</strong>中</li>
<li>当工作区的文件被修改后，使用 <code>git add</code>命令，暂存区的目录树便会被更新，同时工作区中修改的文件会被复制到objects中生成一个新的对象，而该对象的🆔就被记录在刚刚所说的暂存区的目录树中</li>
<li>当使用 <code>git commit</code>后，暂存区的目录树也变成了一个对象，该对象的🆔被记录在版本库中的<strong>master</strong>中，master分支同时也作出相应的更新，master所代表的版本树中的每一个叶子都指向不同版本的目录树。<strong>HEAD</strong>是指向master版本树的一个指针，表示当前所在的版本（它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点）</li>
<li>当执行 <code>git reset HEAD</code>命令后，暂存区的目录会被重写，变成了HEAD所指向的版本所对应的目录树，但此时工作区不受影响</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code>后，会直接从暂存区删除文件（把索引删掉，objects中的文件也删掉），工作区则不做出改变</li>
</ul>
<p>如果还不明白，看下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032656.png" alt="image-20210711063540634"></p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【git问题解决】解决github无法访问</title>
    <url>/2021/12/14/%E3%80%90git%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91%E8%A7%A3%E5%86%B3github%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6844904193170341896">原文链接</a></p>
<span id="more"></span>
<blockquote>
<p>你是不是在访问全球最大的【交友网站】（GitHub）也遇到过以下情况:<br> 1.突然电脑无法访问github了.无论你重启电脑，重置网络，重置你的大脑都无法正常访问了。<br> 2.使用昂贵的【绿色上网】却可以神奇的访问到GitHub。<br> 3.当你使用昂贵的【绿色上网】，开心的在命令行上敲上你熟悉的git 、pull、push等命令进行访问远程库的时候，却给命令行甩你一行【Failed to connect to github.com port 443: Operation timed out】</p>
</blockquote>
<p>身为一个专业的开发人员，这些错误是难不到你的！然后你疯狂的百度、Google搜索，然后得到的是为git的设置代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你以为你很快速的解决的时候！！！现实却是打脸的！！！ 你得到的命令行再一次甩你一行【connect to 127.0.0.01 port 1080: Connection refused】</p>
</blockquote>
<p>如果你也遇到这些情况，那你很幸运，这篇文章可以帮你解决90%的问题。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p><strong>1.打开<a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com/</a>  如下图：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032306.awebp" alt="140.jpeg" style="zoom: 33%;" /></p>
<p>把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！</p>
<p><strong>2.打开<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo</a> 如下图：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032314.awebp" alt="fas.png" style="zoom: 33%;" /></p>
<p>把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！</p>
<p><strong>3.打开<a href="https://github.com.ipaddress.com/assets-cdn.github.com">https://github.com.ipaddress.com/assets-cdn.github.com</a> 如下图：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032318.awebp" alt="153.png" style="zoom: 33%;" /></p>
<p>把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！</p>
<p><strong>4.打开电脑的hosts文件，把下列的东东写在最后，然后保存即可</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.113.4(图1的IP Address) github.com </span><br><span class="line">199.232.69.194(图2的IP Address) github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153(图3的IP Address)  assets-cdn.github.com</span><br><span class="line">185.199.109.153(图3的IP Address)  assets-cdn.github.com</span><br><span class="line">185.199.110.153(图3的IP Address)  assets-cdn.github.com</span><br><span class="line">185.199.111.153(图3的IP Address)  assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032323.awebp" alt="WX20200616-233432.png" style="zoom: 50%;" /></p>
<p><strong>5.在终端在输以下指令刷新DNS（需要权限）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder;say DNS cache has been flushed</span><br></pre></td></tr></table></figure>
<p><strong>然后就见证神奇的时刻！！！！！</strong></p>
<p><strong>小提示</strong></p>
<blockquote>
<p>提示1:<br> 我是用Mac电脑,Mac的Hosts文件可以通过以下路径进行找打： </p>
<p>1.Finder-&gt;Go-&gt;Go to Folder</p>
<p>2.然后输入/etc/hosts即可找到.</p>
<p>3.Windows请自行解决</p>
<p>提示2:<br>这个Hosts文件一般的编辑器还真打不开，可以使用NotePad++、SubLineText等编辑器进行编辑</p>
</blockquote>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习11】软件包管理</title>
    <url>/2022/01/22/%E3%80%90linux%E5%AD%A6%E4%B9%A011%E3%80%91%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>在linux系统中，我们下载软件的方式有两种：</p>
<ul>
<li>以软件包的形式通过包管理软件下载安装</li>
<li>以源码手动编译安装</li>
</ul>
<p>本文主要介绍以软件包形式进行软件安装。</p>
<span id="more"></span>
<h2 id="I-软件包系统"><a href="#I-软件包系统" class="headerlink" title="I. 软件包系统"></a>I. 软件包系统</h2><p>不同的linux版本使用的是不同类型的软件包系统，原则上适用一种版本的软件包系统和另一种是不兼容的。在linux发行版本中，有两大软件包技术阵营：</p>
<ul>
<li>Debian类（.deb）：使用该类的版本有Debian、Ubuntu等</li>
<li>Red Hat类（.rpm）：使用该类的版本有CentOS、Red Hat等</li>
</ul>
<p><strong>包文件</strong>是组成软件包系统的基本软件单元，是由组成软件包文件压缩而成的文件集。这些包文件是由一些维护者创建的，这些维护者不一定是软件的创作者，而是从创作者那获得源码，经过一些小的修改然后编译以获得与linux版本比较兼容的软件包。然后再将这些软件包上传到<strong>软件库</strong>中。软件库可以理解为当前linux版本的软件仓库，里面包含着各种各样的软件包。</p>
<p>关于<strong>依赖性</strong>：几乎没有一个程序是独立的，程序之间相互依赖完成特定的工作。现代软件包管理系统都提供依赖性解决策略，从而确保用户安装了软件包的同时也安装了其所有的依赖关系。</p>
<h2 id="II-软件包工具"><a href="#II-软件包工具" class="headerlink" title="II. 软件包工具"></a>II. 软件包工具</h2><p>软件包工具包含两类：</p>
<ul>
<li>低级工具：对软件包进行处理，执行如安装、删除软件包文件等任务</li>
<li>高级工具：进行元数据搜索以及提供依赖性解决的高级工具</li>
</ul>
<p>对高级和低级工具的简单理解就是，假如你想下一个软件，如果从linux发行版本的<strong>软件库</strong>中下载，就使用<strong>高级工具</strong>进行下载、安装并解决好了<strong>依赖关系</strong>。如果你从网上下了一个<strong>软件包文件</strong>，则需要自己来安装，这时就使用低级工具，但是不能解决依赖关系。</p>
<p>不同版本的软件包管理系统如下：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220122223449532.png" alt="image-20220122223449532"></p>
<h2 id="III-软件包管理"><a href="#III-软件包管理" class="headerlink" title="III. 软件包管理"></a>III. 软件包管理</h2><p>声明：下面使用<code>package_name</code> 来表示软件包的实际名称。<code>package_file</code> 来表示该软件包的文件名。</p>
<h3 id="1-在软件库里找软件包"><a href="#1-在软件库里找软件包" class="headerlink" title="1. 在软件库里找软件包"></a>1. 在软件库里找软件包</h3><p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt-cache search search_string <span class="comment">#根据关键字在缓存中搜索软件包</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum search package_name</span></span><br></pre></td></tr></table></figure>
<p>我们知道从库中下载软件就是从所设置的软件源上下载，软件源中会提供一个软件列表，上面罗列了全部的软件。但是软件是不断更新的，所以软件列表也是不断更新的。使用<code>apt update</code> 命令就是更新软件列表，让最新的软件列表缓存到本地。</p>
<p>而<code>apt-cache search search_string</code> 命令就是从这个缓存下来的列表中搜索跟关键字匹配的软件。</p>
<blockquote>
<p>在 Ubuntu 中软件源其实还细分为下面两种：</p>
<ul>
<li>Ubuntu 官方软件源</li>
<li>PPA 软件源</li>
</ul>
<p>官方软件源列表在<code>/etc/apt/source.list</code> 中，如果想要更改软件源，可以修改该文件。</p>
<p>PPA 源出现的背景是因为系统自带的源是很有限的，我们肯定需要一些其他的软件包然而如果是直接下载deb格式的文件的话，又不能获取到更新和维护，所以这就用到了十分重要的 PPA 源了。</p>
<p>所谓 PPA 源，就是指 “Personal Package Archives” ，也就是<strong>个人软件包集</strong>。这其实是一个网站，即launchpad.net。Launchpad 是 Ubuntu 母公司 Canonical 公司所架设的网站，是一个提供维护、支援或联络 Ubuntu 开发者的平台。由于不是所有的软件都能进入 Ubuntu 的官方的软件库，launchpad.net 提供了 PPA，允许开发者建立自己的软件仓库，自由的上传软件。供用户安装和查看更新。</p>
<p>添加和删除PPA软件源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:user/ppa-name</span><br><span class="line">sudo add-apt-repository --remove ppa:user/ppa-name    </span><br></pre></td></tr></table></figure>
<p>例如，我们想要添加一个 Wireshark 软件的 PPA 源，我们可以根据它官网上提供的命令来进行添加，如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/20211215033826.webp" alt="img"></p>
<p>当我们添加完 PPA 源之后，系统就会在 <code>/etc/apt/sources.list.d/</code>文件夹里创建了两个文件：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/20211215033835.webp" alt="img"></p>
<p>我们再来打开一下 <code>wireshark-dev-stable-trusty.list</code><br>文件看看里面的内容是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://ppa.launchpad.net/wireshark-dev/stable/ubuntu trusty main</span><br><span class="line"># deb-src http://ppa.launchpad.net/wireshark-dev/stable/ubuntu trusty main</span><br></pre></td></tr></table></figure>
<p>原来文件里就是添加了一个跟软件源一模一样的东西，他们的作用殊途同归啊。我想这其实是 Ubuntu 为了分辨官方的源和第三方的源才设计成在<code>sources.list</code>和 <code>sources.list.d/</code>这两个地方中存储软件源信息。因为第三方的源毕竟不太可信，如果随便更新的话可是会出事情的。</p>
</blockquote>
<h3 id="2-安装软件库中的软件包"><a href="#2-安装软件库中的软件包" class="headerlink" title="2. 安装软件库中的软件包"></a>2. 安装软件库中的软件包</h3><p>因为是软件库中的软件包，我们可以使用高级包管理工具，这样可以下载安装，并解决依赖关系。</p>
<p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt install package_name</span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install package_name</span></span><br></pre></td></tr></table></figure>
<h3 id="3-安装软件包文件中的软件包"><a href="#3-安装软件包文件中的软件包" class="headerlink" title="3. 安装软件包文件中的软件包"></a>3. 安装软件包文件中的软件包</h3><p>这里是安装软件包文件中的软件包，也就是我们自己下载了一个<code>.deb</code> 或 <code>.rpm</code> 的文件，这就需要使用低级工具来安装。但是使用低级工具的<strong>缺点是它不能解决依赖关系。</strong></p>
<p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dpkg --install package_file</span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -i package_file</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于该方法采用低级rpm工具安装，所以并不会解决依赖性关系。一旦rpm在安装过程中发现缺少依赖包，rpm就会跳出错误后退出。</p>
</blockquote>
<h3 id="4-删除软件包"><a href="#4-删除软件包" class="headerlink" title="4. 删除软件包"></a>4. 删除软件包</h3><p>删除软件包可以使用高级工具和低级工具。高级工具的方法是：</p>
<p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt remove package_name</span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum erase package_name</span></span><br></pre></td></tr></table></figure>
<h3 id="5-更新库中的软件包"><a href="#5-更新库中的软件包" class="headerlink" title="5. 更新库中的软件包"></a>5. 更新库中的软件包</h3><p>当安装好软件后，我们想保证这些软件都是最新版本的，如果从软件库中获取使用：</p>
<p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt upgrade</span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum update</span></span><br></pre></td></tr></table></figure>
<h3 id="6-更新软件包文件中的软件包"><a href="#6-更新软件包文件中的软件包" class="headerlink" title="6. 更新软件包文件中的软件包"></a>6. 更新软件包文件中的软件包</h3><p>如果软件包的更新版本已从非库源中下载，则使用下列命令：</p>
<p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dpkg --install package_file</span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -U package_file</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>dpkg</code> 命令的选项和安装软件的时候一样。</p>
<h3 id="7-列出已安装的软件包列表"><a href="#7-列出已安装的软件包列表" class="headerlink" title="7. 列出已安装的软件包列表"></a>7. 列出已安装的软件包列表</h3><p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dpkg --list</span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -qa</span></span><br></pre></td></tr></table></figure>
<h3 id="8-判断软件包是否安装"><a href="#8-判断软件包是否安装" class="headerlink" title="8. 判断软件包是否安装"></a>8. 判断软件包是否安装</h3><p>使用低级工具来查。</p>
<p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dpkg --status package_name</span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -q package_name</span></span><br></pre></td></tr></table></figure>
<h3 id="9-显示已安装软件包的相关信息"><a href="#9-显示已安装软件包的相关信息" class="headerlink" title="9. 显示已安装软件包的相关信息"></a>9. 显示已安装软件包的相关信息</h3><p><strong>Debian类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-cache show package_name</span></span><br></pre></td></tr></table></figure>
<p><strong>Red Hat类：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum info package_name</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【git问题解决】git连不上远端库问题解决</title>
    <url>/2021/12/02/%E3%80%90git%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91git%E8%BF%9E%E4%B8%8D%E4%B8%8A%E8%BF%9C%E7%AB%AF%E5%BA%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在使用 Git 时发现在使用 <code>git clone</code> 或 <code>git pull</code> 等需要访问远程仓库的操作时，总是无法连接 GitHub 服务器。</p>
<span id="more"></span>
<p>报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/xxx/xxx.git</span><br><span class="line">fatal: unable to access &#x27;https://github.com/xxx/xxx.git/&#x27;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<p>在 clone GitHub 仓库时可以使用 HTTPS 或者 SSH 进行 clone，而 SSH 却没有 HTTPS 的网络连接问题，所以可以将 push/pull 的连接方式由 HTTPS 改为 SSH。</p>
<blockquote>
<p>要求：你需要提前生成 SSH 公私钥对，并将公钥添加到你的 GitHub 账户中。关于这一部分的详细信息，请参阅 <a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">Connecting to GitHub with SSH</a>。</p>
</blockquote>
<p>进入仓库对应目录，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>
<p>更改完成后，可以使用如下命令查看当前的 origin 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习1】linux是什么</title>
    <url>/2022/01/19/%E3%80%90linux%E5%AD%A6%E4%B9%A01%E3%80%91linux%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>参考：《Linux命令行与shell脚本编程大全》《Linux命令行大全》</p>
<span id="more"></span>
<p>操作系统就是提供用户和计算机底层硬件交互的一个媒介，例如想算1+1等于几，不可能直接动手在芯片上算，需要通过键盘输入，然后看到显示器上的输出结果，这就是通过操作系统来完成的。而linux系统就是主流的一个操作系统，它可以划分为四个部分：</p>
<ul>
<li>linux内核</li>
<li>GNU工具</li>
<li>图形化桌面环境</li>
<li>应用软件</li>
</ul>
<p>基本的结构框图如图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220117210801737.png" alt="image-20220117210801737"></p>
<h2 id="I-linux内核"><a href="#I-linux内核" class="headerlink" title="I. linux内核"></a>I. linux内核</h2><p>内核可以理解为软件和硬件间的一个中间层，连接着软件和硬件。例如我们使用word写了一个文件，写完后这个文件不是直接存储在磁盘上的，而是通过内核这个媒介将其写到磁盘上，软件是不能直接操纵硬件的。内核中留了许多API，可以供各个软件使用，然后在驱动底层硬件。</p>
<p>内核主要负责以下四种功能：</p>
<ul>
<li>系统内存管理</li>
<li>软件程序管理</li>
<li>硬件设备管理</li>
<li>文件系统管理</li>
</ul>
<h2 id="II-GNU工具"><a href="#II-GNU工具" class="headerlink" title="II. GNU工具"></a>II. GNU工具</h2><p>GNU工具在内核的上一层，</p>
<h3 id="1-GNU简介"><a href="#1-GNU简介" class="headerlink" title="1. GNU简介"></a>1. GNU简介</h3><p>当有了内核之后，就建立了软件和硬件连接的桥梁。但通常我们并不会直接和内核打交道，而是通过更为上层的工具进行操作。假如你要开发一个linux系统下的软件，那么你有可能要了解内核的API，然后进行开发，但用户使用时只需要打开软件就可以了而不用考虑内核，这时该程序实现了一些<strong>具体功能</strong>（例如通过网易云听音乐，word写作业等）。此外，用户有时还需要控制文件和程序（如将文件进行复制粘贴，开启程序，结束程序等），此时就需要系统工具来执行一些<strong>标准功能</strong>，这些系统工具处在内核的上一层，可以与用户直接交互。</p>
<p>Linus在创建linux内核时，并没有可用的系统工具。但与此同时，另一伙人即GNU组织开发了一套完整的系统工具，却没有可以运行它们的内核。于是这两伙人就结合在一起，发布了完整的linux操作系统。这些系统工具称为GNU工具。</p>
<blockquote>
<p>GNU工具也可以理解为一种软件，只不过是linux操作系统自带的，与linux内核绑定在一起的。linux系统的更准确的名字应该叫做GNU/linux系统。</p>
</blockquote>
<h3 id="2-shell"><a href="#2-shell" class="headerlink" title="2. shell"></a>2. shell</h3><p><strong>shell就是比较重要的GNU工具之一，它是一个程序，将你输入的文本命令解释成命令，然后在内核中执行。</strong></p>
<p>shell包含了一组内部命令，用这些命令可以完成诸如复制文件、移动文件、重命名文件、显示和终止系统中正运行的程序等操作。shell也允许你在命令行提示符中输入程序的名称，它会将程序名传递给内核以启动它。</p>
<p>也可以将多个shell命令放入文本文件中作为程序执行，这称为 <strong>shell脚本</strong>，你在命令行提示符中输入的任何命令都可以放进一个shell脚本中一起执行，这提供了极大的便利。</p>
<p>有许多种shell程序可用，通常我们使用的是由GNU项目开发的 <strong>bash shell</strong> ，我们平时使用的终端仿真器（简称终端）就是与shell程序进行交互的命令行提示符，我们在终端中输入文本命令，终端将其发给shell程序，shell程序将其转化成命令发给内核来执行。</p>
<h2 id="III-linux桌面环境"><a href="#III-linux桌面环境" class="headerlink" title="III. linux桌面环境"></a>III. linux桌面环境</h2><p>早期的linux只有一个简单的操作系统文本界面，这个文本界面可以让人们来运行程序，控制计算机。但随着windows的普及，传统的文本界面已经不再满足用户需求，因此linux图形化桌面环境应运而生。</p>
<blockquote>
<p>图形化桌面环境是一个底层程序，直接与显卡和显示器交互。</p>
</blockquote>
<p>linux有许多可以选择的图形化桌面，常用的有：</p>
<ul>
<li>X window</li>
<li>KDE</li>
<li>GNOME（现已成为许多linux发行版的默认桌面环境）</li>
<li>Unity（ubuntu使用的环境）</li>
</ul>
<h2 id="IV-应用软件"><a href="#IV-应用软件" class="headerlink" title="IV. 应用软件"></a>IV. 应用软件</h2><p>这里就很简单了，就是我们可以直接使用的程序，可以通过鼠标点击打开或通过命令行使用。</p>
<p>将以上四个部分集合在一起，就是linux的发行版，不同发行版有不同的用途，如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220117232802132.png" alt="image-20220117232802132"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220117232815603.png" alt="image-20220117232815603"></p>
<h2 id="V-总结"><a href="#V-总结" class="headerlink" title="V. 总结"></a>V. 总结</h2><p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220117210801737.png" alt="image-20220117210801737"></p>
<p>如上图所示，linux操作系统包括了四大部分，其中核心是linux的内核，处在最底层，建立了软硬件间的桥梁。向上一层是图形化桌面程序和GUN系统工具程序，我们可以通过这一层来直接操作内核来实现一些标准的功能。最上层就是应用程序了，我们可以使用这些应用程序来实现具体的一些功能。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习12】依赖包是什么</title>
    <url>/2022/01/22/%E3%80%90linux%E5%AD%A6%E4%B9%A012%E3%80%91%E4%BE%9D%E8%B5%96%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>我们在Ubuntu中常说的依赖是什么呢？</p>
<span id="more"></span>
<p>依赖包就是某个软件用到的库文件。</p>
<p>任何程序员写程序都有可能会依赖一些别人已经写成的库，所以几乎一定规模的程序必然有依赖。</p>
<p>不同体系用不同的方法解决依赖问题。</p>
<p>GNU/Linux：通常这个系统大多数软件是自由软件，换句话说，他们通常依赖的库也是自由的，所以软件开发者认为你可以自由的获取这些依赖库，自然就不需要自己再提供了。由系统“发行版”负责维护属于这个系统的所有依赖库，并且安装软件时确定依赖。<br>这个体系的特点是：</p>
<ul>
<li>系统依赖通常是统一的，如果有多个程序依赖同一个库，在这个系统中通常是同一份。</li>
<li>具有庞大的资源。例如 Debian 系现成的可依赖软件多达 30G，所以通常不可能预先把所有依赖都安装全，但庞大的依赖库给编程人员提供了很多方便。</li>
<li>你安装的软件越多，共同依赖所体现出的价值越高，解决依赖问题就越简单（因为当你安装足够多软件时，主流的依赖已经全部在你系统了）。</li>
<li>由于巨大的共同依赖库存在，软件本身可以很小。</li>
</ul>
<p>Windows：通常而言，这个系统的软件是商业软件，因此，他们依赖的库也很有可能是商业软件，所以，不可能要求用户自行获取这些依赖，这些依赖通常在发布软件的时候提供。如果你安装的软件少，这个体系很方便。<br>不过这造成了一些缺点：</p>
<ul>
<li>没有一个庞大的公共库，很多功能以及基础库都是每个公司自己实现一套，浪费很多劳动力，编程人员到每个公司得学习一套不同的库，给编程人员带来不便。</li>
<li>所有应用程序都自己带依赖，因此很可能有许多程序同时附带了相同的依赖，并且这些相同依赖还有可能是不同的版本，这会造成许多混乱。</li>
<li>由于所有应用程序都自己提供所有依赖，每个软件体积都很庞大。</li>
<li>系统中安装的软件越多，越容易出问题。</li>
</ul>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习13】双系统安装ubuntu</title>
    <url>/2022/02/02/%E3%80%90linux%E5%AD%A6%E4%B9%A013%E3%80%91%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85ubuntu/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/masbay/p/11627727.html">原文链接</a></p>
<span id="more"></span>
<h2 id="I-查看电脑的信息"><a href="#I-查看电脑的信息" class="headerlink" title="I. 查看电脑的信息"></a>I. 查看电脑的信息</h2><h3 id="1-查看BIOS模式"><a href="#1-查看BIOS模式" class="headerlink" title="1.查看BIOS模式"></a>1.查看BIOS模式</h3><p>“win+r”快捷键进入”运行”，输入”msinfo32”回车，出现以下界面，可查看BIOS模式：</p>
<p>UEFI模式：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155617224-505026878.png" alt="img"> </p>
<p>传统MBR模式：</p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155627085-38479036.png" alt="img"></p>
<p>BIOS模式有传统的MBR模式和新式UEFI模式，这将对安装双系统的方法产生直接影响。目前来看，大部分电脑都属于新式UEFI模式，不过也存在一些老机子仍然属于传统MBR模式。本教程只介绍新式UEFI模式下的双系统安装方法，如果你的电脑属于传统MBR模式，强烈建议你重装windows系统来更新BIOS模式到UEFI。</p>
<h3 id="2-搞清楚电脑的硬盘数"><a href="#2-搞清楚电脑的硬盘数" class="headerlink" title="2.搞清楚电脑的硬盘数"></a>2.搞清楚电脑的硬盘数</h3><p>电脑是单双硬盘希望你买电脑时就已经清楚，这也算是卖点之一，如果这个都不知道，也请不要自暴自弃，继续往下看。</p>
<p>“此电脑”点击右键，点击”管理”，点击”磁盘管理”：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155635425-1228218585.png" alt="img"> </p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155645369-1469851559.png" alt="img"></p>
<p>相信你已经清楚了自己电脑的信息，以下请注意有区分”单硬盘”和”双硬盘”操作的部分。</p>
<h2 id="II-制作系统盘"><a href="#II-制作系统盘" class="headerlink" title="II. 制作系统盘"></a>II. 制作系统盘</h2><p>需要准备以下工具：</p>
<ul>
<li>ubuntu系统镜像</li>
<li>刻录软件，推荐”软碟通”，会提示注册，选择继续试用就好</li>
<li>一个大于 2G 的 U 盘</li>
</ul>
<p>1.安装并打开软碟通，插上 U 盘，并且最好备份你的 U 盘，因为之后需要格式化；</p>
<p>2.进入软碟通，选择文件，浏览到你的ubuntu镜像所在的目录，选择ubuntu镜像文件，双击打开，如图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155655018-1960987937.png" alt="img"> </p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155703110-550044578.png" alt="img"></p>
<p>3.在软碟通界面菜单栏选择”启动”，选择”写入硬盘映像”，如图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155710921-1438593351.png" alt="img"> </p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155718113-961152863.png" alt="img"> </p>
<p><strong>接下来很重要，注意次序</strong>：</p>
<p>1）看你的硬盘驱动器是否对应的是你的 U 盘（必须是） ，一般默认是；</p>
<p>2）看映像文件是否对应你的 ubuntu 镜像；</p>
<p>3）如果上述均没有错误，选择格式化，之后就会格式化你的 U 盘；</p>
<p>4）在 U 盘格式化完毕之后，选择写入，之后就是慢慢等待了，等待写入完毕；</p>
<p>5）步骤II完毕。</p>
<h2 id="III-在windows下创建空白分区"><a href="#III-在windows下创建空白分区" class="headerlink" title="III. 在windows下创建空白分区"></a>III. 在windows下创建空白分区</h2><p>说明：这一步是为ubuntu系统分配空间，单硬盘和双硬盘存在一点区别。</p>
<p>1.”此电脑”点击右键，点击”管理”，点击”磁盘管理”：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155727456-1801872024.png" alt="img"> </p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155736407-1314175984.png" alt="img"></p>
<p>2.为ubuntu分配空间</p>
<p>（1）如果是<strong>单硬盘</strong>，选择最后一个盘（比如 CD两个盘的最后一个是D盘，CDE盘的最后一个是E盘，CDEF盘的最后一个是F盘，以此类推），在该盘点击右键，选择压缩卷，如下，输入压缩空间量，单位为M,如果空间充足，建议分出80G或100G，空间不足也可以分60G（1G=1024M）：</p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155746492-823119485.png" alt="img"></p>
<p><strong>如果你的最后一个盘容量太小，还不够分出60G，那需要从其他盘匀一些过来，你需要用到DiskGenius这个工具，具体操作不在此介绍，希望你自行解决。</strong></p>
<p>（2）如果是<strong>双硬盘</strong>，需要先在C盘（按理来说就是电脑的第一块硬盘，部分电脑系统装得比较奇怪，装到了第二块硬盘）分出200M的空白分区用来安装ubuntu的启动项，然后再在另一块硬盘选择最后一个盘（比如 CD两个盘的最后一个是D盘，CDE盘的最后一个是E盘，CDEF盘的最后一个是F盘，以此类推），在该盘点击右键，选择压缩卷，如下，输入压缩空间量，单位为M,如果空间充足，建议分出80G或100G，空间不足也可以分60G（1G=1024M）：</p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155754570-1534007065.png" alt="img"></p>
<blockquote>
<p><strong>这里解释两个问题</strong>：</p>
<p>（1）单双硬盘为什么分区存在区别：你可以看到分区的差别只是双硬盘的时候在C盘分出了200M用来安装启动项。电脑在开机的时候，会自动在C盘所在的那个硬盘搜索启动项以启动系统，我们当然希望安装的ubuntu启动项也能够被搜索到，所以需要将启动项安装在这里，这样开机时会搜索到windows和ubuntu两个启动项，我们可以手动选择进入哪个系统。当然这里的”启动项需要安装在C盘所在的硬盘”并不是绝对的，只是为了开机能够自动搜索到启动项，安装在其他硬盘也可以，只是每次开机都需要进boot manager才能找到ubuntu启动项，比较麻烦，所以建议按照我的方法来分区。</p>
<p>（2）为什么要选择最后一个盘压缩卷：windows和ubuntu的文件存储格式是不一样的，我们分区的操作只是将磁盘分了一部分给ubuntu，事实上两个系统还是在共用一块磁盘，为了防止存储格式不同两个系统可能相互影响，我们通过从最后一个盘压缩将ubuntu的分区分到了磁盘最后一段，也就是一块磁盘的前部分是windows的分区，后部分是ubuntu的分区。</p>
</blockquote>
<p>我的电脑是双硬盘，下面是我的分区结果：</p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155817344-1762043768.png" alt="img"></p>
<h2 id="IV-用做好的系统盘安装系统"><a href="#IV-用做好的系统盘安装系统" class="headerlink" title="IV. 用做好的系统盘安装系统"></a>IV. 用做好的系统盘安装系统</h2><p><strong>注</strong>：因为各个厂商的计算机bios和boot manager启动的快捷键不相同，所以请自行百度如何进bios和boot manager。</p>
<p>1.插好系统盘，重启电脑，开机进bios，在Security页面，关掉secure boot（不同电脑secure boot可能在不同位置），然后到Boot页面，如果有Fast Boot这一项（部分联想电脑有），也把它关掉，没有忽略；然后保存更改，在Boot页面下方启动项选择 USB启动，回车，如果顺利进入安装页面，继续往下做；如果点击USB启动项无法进入，保存并退出，电脑会重启，根据自己电脑按相应的键进boot manager，找到USB启动项，回车即可进入。 </p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155825646-829460601.png" alt="img"> </p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155834541-119582737.png" alt="img"> </p>
<p>2.然后会进入这个界面，选择Install Ubuntu，回车确认</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155842924-234123646.png" alt="img"> </p>
<p>3.或许没有上一个界面，但是下面的界面一定是有的，不同镜像会有些差异，但意思都一样，语言栏往下拉会有中文</p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155851405-1310842418.png" alt="img"></p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155902369-769951208.png" alt="img"></p>
<p>4.点击”安装Ubuntu”，出现以下或类似界面只选”为图形或无线硬件，以及MP3和其他媒体安装第三方软件”，不选第一个，边安装边下载更新很慢，点击”继续”</p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155913817-716268278.png" alt="img"></p>
<p>5.出现以下或类似界面，一定要选择”其他选项”，因为需要手动分区 <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155923831-1993218964.png" alt="img"></p>
<p>6.分区界面如下</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510155951033-222884096.png" alt="img"> </p>
<p>在这里，你可以看到在第三步已经分好的空闲分区，上图是单硬盘的情况，只有一个空闲分区，大小是你分区时给定的；双硬盘的话还能看到另一个空闲分区，大小200M左右，所以<strong>下面的分区操作单双硬盘存在一点差别</strong>。</p>
<p>在这里，我们进行手动分区，假设你留出的空闲分区为 80G，点击空闲盘符，点击”+”进行分区，如下：</p>
<p>1）efi：如果是<strong>单硬盘</strong>，在唯一的一个空闲分区上添加，大小200M，逻辑分区，空间起始位置，用于efi；如果是<strong>双硬盘</strong>，找到事先分好的200M空闲分区添加，逻辑分区，空间起始位置，用于efi。这个分区必不可少，用于安装ubuntu启动项。以下步骤单双硬盘就一样了，都在那个80G的空闲分区上添加</p>
<p>2）swap:中文是”交换空间”，充当ubuntu的虚拟内存，一般的大小为电脑物理内存的2倍左右，可以将其分为 8G，逻辑分区，空间起始位置，用于”swap”或”交换空间”</p>
<p>3）/:这是ubuntu 的根目录,用于安装系统和软件，相当于windows的C盘，我们将其分为 20G，主分区，空间起始位置，用于”ext4日志文件系统”，挂载点为”/“（根据你的磁盘空间调整，可以大一点，毕竟ubuntu装软件都是默认装在根目录的）</p>
<p>4）/home:相当于windows的其他盘，剩下的全分给它，逻辑分区，空间起始位置，用于”ext4日志文件系统”，挂载点为”/home”</p>
<p>好了，分区完毕，你完全可以按照上面的描述进行分区，不会有任何问题，起码我一直都是这么做的（强烈建议）。当然，你也可以划分的更详细，具体划分可以百度。</p>
<p><strong>下面的这一步很重要</strong>：在分区界面的下方，选择安装启动项的位置，我们刚刚不是创建了200M的efi分区吗，现在你看看这个区前面的编号是多少，比如是/dev/sda1,不同的机子会有不同的编号，下拉列表选择这个efi分区编号（<strong>这里一定要注意，windows的启动项也是efi文件，大小大概是500M，而我们创建的ubuntu的efi大小是200M，一定要选对</strong>），之后点击”Install Now”</p>
<p>（下图百度的不准）！</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510160001711-2046731157.png" alt="img"> </p>
<p>7.设置地区不重要，按你需要设置，也可以直接继续，不影响</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510160009567-761733002.png" alt="img"> </p>
<p>8.键盘布局默认是英语的，建议不改（默认中文也行）</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510160017596-1795786784.png" alt="img"> </p>
<p>9.这里设置用户，自己输入就可以了，例如英文字母，尽量简单点，密码也简单点</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510160026715-1634480995.png" alt="img"> </p>
<p>10.系统开始安装，耐心等待安装完毕就可以了</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510160036426-1982854746.png" alt="img"> </p>
<p>11.全部完成之后，会提醒你重启，把U盘拔了，点”现在重启”，如果卡死就强制关机再重启就好</p>
<p> <img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510160049624-207765391.png" alt="img"></p>
<p>12.重启后你会看到以下界面，第一项是ubuntu启动项，第二项是ubuntu高级设置，第三项是windows启动项，第四项不用管，默认选择的是第一个，回车进ubuntu系统</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/1628751-20190510160059814-848304499.png" alt="img"> </p>
<p>13.也许你已经装好了系统并且成功进入了，那恭喜，你可以离开了；但是如果你装完之后重启，发现卡死在启动界面动不了了，这很大可能是你的电脑有特殊独立显卡，ubuntu系统下缺少驱动导致，你可以参考我的另一篇博客解决：<a href="https://www.cnblogs.com/masbay/p/10718514.html。">https://www.cnblogs.com/masbay/p/10718514.html。</a></p>
<p><strong>友情提示</strong>：如果你参照教程安装出现了问题，极有可能是因为不同电脑之间的差异导致，可能有些问题我也没有遇到过，所以如果出现特殊问题，请移步评论区，说不定就有热心的小伙伴碰到过并完美解决。如果你遇到了实在难以解决的问题，可以向我求助，同时广泛在网络寻找解决办法，如果解决，希望你可以将解决方法放到评论区，帮助遇到同样问题的朋友们尽快解决问题，感谢你的支持与分享。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习2】操作文件和目录</title>
    <url>/2022/01/19/%E3%80%90linux%E5%AD%A6%E4%B9%A02%E3%80%91%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>使用图形界面时，我们可以很简单地进行文件复制粘贴等操作，那么为什么要用命令行呢？</p>
<p>答：命令行程序具有强大的功能和灵活的操作。</p>
<span id="more"></span>
<p>举一个例子，如果想从一个目录仅复制那些目标目录中不存在的文件或是旧的版本，使用图形操作就比较困难了，你需要一个一个去对比。而是用命令行仅需要一条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp -u *.html destination</span></span><br></pre></td></tr></table></figure>
<p>本文涉及到的命令：</p>
<ul>
<li>cp</li>
<li>mv</li>
<li>mkdir</li>
<li>rm</li>
<li>file</li>
<li>cat</li>
<li>more</li>
<li>less</li>
<li>tail</li>
<li>head</li>
</ul>
<h2 id="I-通配符"><a href="#I-通配符" class="headerlink" title="I. 通配符"></a>I. 通配符</h2><p>通配符直白一点说就是用 <code>*</code> 等符号来代替文字，就像东北打麻将的hui儿，你缺啥用它都可以替。 当你想操作<code>a.cpp</code> 和 <code>b.cpp</code> 时，就可以用 <code>*.cpp</code> 来代替。</p>
<p>通配符的具体规则如下：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118010908098.png" alt="image-20220118010908098"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">通配符</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">匹配任意多个字符（包括0和1个）</td>
</tr>
<tr>
<td style="text-align:center">？</td>
<td style="text-align:center">匹配任一单个字符</td>
</tr>
<tr>
<td style="text-align:center">[characters]</td>
<td style="text-align:center">匹配任意一个属于字符集中的字符</td>
</tr>
<tr>
<td style="text-align:center">[!characters]</td>
<td style="text-align:center">匹配任意一个不属于字符集中的字符</td>
</tr>
<tr>
<td style="text-align:center">[[:class:]]</td>
<td style="text-align:center">匹配任意一个属于指定字符类中的字符</td>
</tr>
<tr>
<td style="text-align:center">[:alnum:]</td>
<td style="text-align:center">匹配任意一个字母或数字</td>
</tr>
<tr>
<td style="text-align:center">[:alpha:]</td>
<td style="text-align:center">匹配任意一个字母</td>
</tr>
<tr>
<td style="text-align:center">[:digit:]</td>
<td style="text-align:center">匹配任意一个数字</td>
</tr>
<tr>
<td style="text-align:center">[:lower:]</td>
<td style="text-align:center">匹配任意一个小写字母</td>
</tr>
<tr>
<td style="text-align:center">[:upper:]</td>
<td style="text-align:center">匹配任意一个大写字母</td>
</tr>
</tbody>
</table>
</div>
<p>注：表示范围用<code>-</code>号表示。例<code>[0-9]</code> <code>[a-z]</code> 。</p>
<p>示例：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118014216733.png" alt="image-20220118014216733"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118014233903.png" alt="image-20220118014233903"></p>
<h2 id="II-mkdir——创建目录"><a href="#II-mkdir——创建目录" class="headerlink" title="II. mkdir——创建目录"></a>II. mkdir——创建目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir directory</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir dir1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir dir1 dir2 dir3 <span class="comment">#分别创建了三个目录</span></span></span><br></pre></td></tr></table></figure>
<h2 id="III-cp和mv命令"><a href="#III-cp和mv命令" class="headerlink" title="III. cp和mv命令"></a>III. cp和mv命令</h2><h3 id="1-cp——复制文件和目录"><a href="#1-cp——复制文件和目录" class="headerlink" title="1. cp——复制文件和目录"></a>1. cp——复制文件和目录</h3><p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118012522753.png" alt="image-20220118012522753"></p>
<p>示例：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118012547119.png" alt="image-20220118012547119"></p>
<h3 id="2-mv——移动和重命名文件"><a href="#2-mv——移动和重命名文件" class="headerlink" title="2. mv——移动和重命名文件"></a>2. mv——移动和重命名文件</h3><p>移动和cp命令类似，命令选项也和cp一样。</p>
<p>当在一个文件夹dir下，有文件file1，现在有如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv file1 file2</span>	</span><br></pre></td></tr></table></figure>
<p>该命令就是为文件file1重命名为file2。</p>
<h2 id="IV-rm——删除文件和目录"><a href="#IV-rm——删除文件和目录" class="headerlink" title="IV. rm——删除文件和目录"></a>IV. rm——删除文件和目录</h2><p>在使用rm命令时一定要小心，尤其是与通配符在一起使用时，因为rm执行后，文件将不可恢复。</p>
<p>有如下例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm *.html</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm * .html <span class="comment">#在*和.间多了一个空格，但是会导致将当前目录下的全部文件都删除</span></span></span><br></pre></td></tr></table></figure>
<p>很可怕，所以rm之前可以用ls看看通配符好不好使。</p>
<p>用法：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118013347767.png" alt="image-20220118013347767"></p>
<h2 id="V-查看文件"><a href="#V-查看文件" class="headerlink" title="V. 查看文件"></a>V. 查看文件</h2><h3 id="1-查看文件类型"><a href="#1-查看文件类型" class="headerlink" title="1. 查看文件类型"></a>1. 查看文件类型</h3><p>使用<code>file</code> 命令可以查看文件的类型。</p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file text_file</span></span><br><span class="line">text_file: ASCII text  #这说明了text_file是一个(text)文本文件，且确定了该文本文件的字符编码。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file Dir</span></span><br><span class="line">Dir: directory  #这说明了Dir是一个目录</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file text_sl</span></span><br><span class="line">text_sl: symbolic link to &#x27;text&#x27;  #告诉了该文件是一个符号链接，并指出了所链接的文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file my_script</span></span><br><span class="line">my_script: Bourne-Again shell script, ASCII text executable  #说明了该文件是一个可执行文件，且文件内容是ASCII编码</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),</span><br><span class="line">dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, stripped</span><br><span class="line"><span class="meta">#</span><span class="bash">可以确定该程序编译时所面向的平台以及需要何种类型的库。</span></span><br></pre></td></tr></table></figure>
<h3 id="2-查看整个文件"><a href="#2-查看整个文件" class="headerlink" title="2. 查看整个文件"></a>2. 查看整个文件</h3><ul>
<li>cat：查看文本内容全部输到屏幕上</li>
<li>more：会在每页数据后面停下来，通过空格或回车来向后浏览</li>
<li>less：more的升级版，可以向前和向后翻页</li>
</ul>
<h3 id="3-查看部分文件"><a href="#3-查看部分文件" class="headerlink" title="3. 查看部分文件"></a>3. 查看部分文件</h3><ul>
<li>tail：默认情况下查看文件的后10行</li>
<li>head：默认情况下查看文件的前10行</li>
</ul>
<p>如需要特定的行数，用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tail -5 file1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> head -20 file2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【cmake-5】细说PRIVATE-INTERFACE-PUBLIC</title>
    <url>/2022/01/26/%E3%80%90cmake-5%E3%80%91%E7%BB%86%E8%AF%B4PRIVATE-INTERFACE-PUBLIC/</url>
    <content><![CDATA[<p>具体的解释在后面，先总结一下子。</p>
<span id="more"></span>
<h2 id="I-结论"><a href="#I-结论" class="headerlink" title="I. 结论"></a>I. 结论</h2><p>在编译的时候<strong>链接库文件</strong>和说明<strong>头文件路径</strong>是两件大事。</p>
<p><strong>CMake可以在链接库文件的时候把库<code>文件的头文件路径</code>（说明该库的用法）自动添加到<code>目标文件的头文件路径</code>。</strong></p>
<p>链接库文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;)</span><br></pre></td></tr></table></figure>
<p>定义：</p>
<ul>
<li><code>target</code> 是要生成的文件，可能是可执行文件或库文件</li>
<li><code>item</code> 链接的库文件</li>
<li><code>future target</code> 未来链接<code>target</code> 的文件</li>
</ul>
<h3 id="1-target-include-directories"><a href="#1-target-include-directories" class="headerlink" title="1. target_include_directories()"></a>1. target_include_directories()</h3><p>每个<code>target</code> 有两个列表，一个是<code>INCLUDE_DIRECTORIES</code> ，另一个是<code>INTERFACE_INCLUDE_DIRECTORIES</code> 。</p>
<p><code>INCLUDE_DIRECTORIES</code> 是编译<code>target</code>时，要看的头文件路径。而当<code>future target</code> 链接 <code>target</code>时，CMake会自动的把<code>target</code>的<code>INTERFACE_INCLUDE_DIRECTORIES</code> 添加到<code>future target</code> 的 <code>INCLUDE_DIRECTORIES</code>中。</p>
<p>当我们使用<code>target_include_directories()</code> 时，根据参数<code>&lt;PRIVATE|PUBLIC|INTERFACE&gt;</code>的不同，可以分别为这两个列表添加路径。</p>
<p>如：<code>target_include_directories(&lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;)</code></p>
<ul>
<li><code>PRIVATE</code> ：把<code>item</code> 只添加到<code>target</code>的<code>INCLUDE_DIRECTORIES</code></li>
<li><code>PUBLIC</code>：把<code>item</code> 添加到<code>target</code>的<code>INCLUDE_DIRECTORIES</code> 和 <code>INTERFACE_INCLUDE_DIRECTORIES</code> </li>
<li><code>INTERFACE</code>：把<code>item</code> 只添加到<code>target</code>的<code>INTERFACE_INCLUDE_DIRECTORIES</code> </li>
</ul>
<h3 id="2-target-link-libraries"><a href="#2-target-link-libraries" class="headerlink" title="2. target_link_libraries()"></a>2. target_link_libraries()</h3><p><code>target_link_libraries()</code>是同样的道理，<code>target</code> 同样有两个列表，一个是<code>LIBRARIES</code> ，另一个是<code>INTERFACE_LIBRARIES</code> 。</p>
<p> <code>LIBRARIES</code> 是编译<code>target</code>时，要链接的库。而当<code>future target</code> 链接 <code>target</code>时，CMake会自动的把 <code>INTERFACE_LIBRARIES</code>添加到<code>future target</code> 的<code>LIBRARIES</code> 中。</p>
<p>当我们使用<code>target_link_libraries()</code> 时，根据参数<code>&lt;PRIVATE|PUBLIC|INTERFACE&gt;</code>的不同，可以分别为这两个列表添加路径。</p>
<p>如：<code>target_link_libraries(&lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;)</code></p>
<ul>
<li><code>PRIVATE</code> ：把<code>item</code> 只添加到<code>target</code>的<code>LIBRARIES</code> </li>
<li><code>PUBLIC</code>：把<code>item</code> 添加到<code>target</code>的<code>LIBRARIES</code> 和 <code>INTERFACE_LIBRARIES</code> </li>
<li><code>INTERFACE</code>：把<code>item</code> 只添加到<code>target</code>的<code>INTERFACE_LIBRARIES</code> </li>
</ul>
<h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h3><p><strong>例子1</strong></p>
<p><code>fruit</code>库的 <code>INCLUDE_DIRECTORIES</code> 有 <code>fruit_h</code>, <code>tree_h</code>, <code>INTERFACE_INCLUDE_DIRECTORIES</code> 有<code>fruit_h</code>。如果有一个新的库<code>apple</code> 链接到<code>fruit</code> 库, 这时会将<code>fruit</code> 的<code>INTERFACE_INCLUDE_DIRECTORIES</code> 添加到 <code>apple</code> 库的<code>INCLUDE_DIRECTORIES</code>。 所以此时 <code>apple</code> 库的<code>INCLUDE_DIRECTORIES</code> 有<code>fruit_h</code> 。</p>
<p><strong>例子2</strong></p>
<p><code>fruit</code> 库有一些函数，例如<code>size</code> 和 <code>color</code> ，然后<code>apple</code> 库有一个函数<code>apple_size</code> ，这个函数调用了<code>size</code> ，并以<code>PRIVATE</code> 的方式链接到了<code>fruit</code> 上。现在创建了一个可执行文件<code>eat_apple</code> 调用了<code>apple_size</code> ，这时便可以通过<code>PRIVATE</code>或<code>PUBLIC</code>的方式链接到<code>apple</code>库。</p>
<p>但是如果<code>eat_apple</code> 想要调用<code>size</code>和<code>color</code> 函数，此时编译会报错。应该在<code>apple</code>库链接<code>fruit</code>库的时候选择<code>PUBLIC</code>模式来代替<code>PRIVATE</code>。</p>
<h2 id="II-CMake-Inheritance"><a href="#II-CMake-Inheritance" class="headerlink" title="II. CMake Inheritance"></a>II. CMake Inheritance</h2><p>CMake uses somewhat similar inheritance concepts to C++, especially for the C++ <code>public</code> and <code>private</code> access specifiers and inheritance types. The CMake keywords <code>PUBLIC</code>, <code>PRIVATE</code>, and <code>INTERFACE</code> used in <code>target_include_directories()</code> and <code>target_link_libraries()</code>, in my opinion, are mixtures of access specifier and inheritance type from C++.</p>
<h3 id="1-Include-Inheritance"><a href="#1-Include-Inheritance" class="headerlink" title="1. Include Inheritance"></a>1. Include Inheritance</h3><p>In CMake, for any <code>target</code>, in the preprocessing stage, it comes with a <code>INCLUDE_DIRECTORIES</code> and a <code>INTERFACE_INCLUDE_DIRECTORIES</code> for searching the header files building. <code>target_include_directories</code> will populate all the directories to <code>INCLUDE_DIRECTORIES</code> and/or <code>INTERFACE_INCLUDE_DIRECTORIES</code> depending on the keyword <code>&lt;PRIVATE|PUBLIC|INTERFACE&gt;</code> we specified. The <code>INCLUDE_DIRECTORIES</code> will be used for the current <code>target</code> only and the <code>INTERFACE_INCLUDE_DIRECTORIES</code> will be appended to the <code>INCLUDE_DIRECTORIES</code> of any other <code>target</code> which has dependencies on the current <code>target</code>. With such settings, the configurations of <code>INCLUDE_DIRECTORIES</code> and <code>INTERFACE_INCLUDE_DIRECTORIES</code> for all building targets are easy to compute and scale up even for multiple hierarchical layers of building dependencies and many building targets.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Include Inheritance</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PUBLIC</code></td>
<td>All the directories following <code>PUBLIC</code> will be used for the current target and the other targets that have dependencies on the current target, i.e., appending the directories to <code>INCLUDE_DIRECTORIES</code> and <code>INTERFACE_INCLUDE_DIRECTORIES</code>.</td>
</tr>
<tr>
<td><code>PRIVATE</code></td>
<td>All the include directories following <code>PRIVATE</code> will be used for the current target only, i.e., appending the directories to <code>INCLUDE_DIRECTORIES</code>.</td>
</tr>
<tr>
<td><code>INTERFACE</code></td>
<td>All the include directories following <code>INTERFACE</code> will NOT be used for the current target but will be accessible for the other targets that have dependencies on the current target, i.e., appending the directories to <code>INTERFACE_INCLUDE_DIRECTORIES</code>.</td>
</tr>
</tbody>
</table>
</div>
<p>Note that when we do <code>target_link_libraries(&lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;)</code>, the dependent <code>&lt;item&gt;</code>, if built in the same CMake project, would append the <code>INTERFACE_INCLUDE_DIRECTORIES</code> of <code>&lt;item&gt;</code> to the <code>INCLUDE_DIRECTORIES</code> of <code>&lt;target&gt;</code>. By controlling the <code>INTERFACE_INCLUDE_DIRECTORIES</code>, we could eliminate some unwanted or conflicting declarations from <code>&lt;item&gt;</code> to the <code>&lt;target&gt;</code>.</p>
<p>For example, the <code>fruit</code> library has <code>INCLUDE_DIRECTORIES</code> of <code>fruit_h</code>, <code>tree_h</code>, and <code>INTERFACE_INCLUDE_DIRECTORIES</code> of <code>fruit_h</code>. If there is a <code>apple</code> library that is linked with the <code>fruit</code> library, the <code>apple</code> library would also have the <code>fruit_h</code> in its <code>INCLUDE_DIRECTORIES</code> as well. We could equivalently say, the <code>apple</code> library’s include directory inherited the <code>fruit_h</code> of the <code>fruit</code> library.</p>
<h3 id="2-Link-Inheritance"><a href="#2-Link-Inheritance" class="headerlink" title="2. Link Inheritance"></a>2. Link Inheritance</h3><p>Similarly, for any <code>target</code>, in the linking stage, we would need to decide, given the <code>item</code> to be linked, whether we have to put the <code>item</code> in the link dependencies, or the link interface, or both, in the compiled <code>target</code>. Here the link dependencies means the <code>item</code> has some implementations that the <code>target</code> would use, and it is linked to the <code>item</code>, so that whenever we call the functions or methods corresponding to those implementations it will always be mapped correctly to the implementations in <code>item</code> via the link, whereas the link interface means the <code>target</code> becomes an interface for linking the <code>item</code> for other targets which have dependencies on the <code>target</code>, and the <code>target</code> does not have to use <code>item</code> at all.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Link Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PUBLIC</code></td>
<td>All the objects following <code>PUBLIC</code> will be used for linking to the current target and providing the interface to the other targets that have dependencies on the current target.</td>
</tr>
<tr>
<td><code>PRIVATE</code></td>
<td>All the objects following <code>PRIVATE</code> will only be used for linking to the current target.</td>
</tr>
<tr>
<td><code>INTERFACE</code></td>
<td>All the objects following <code>INTERFACE</code> will only be used for providing the interface to the other targets that have dependencies on the current target.</td>
</tr>
</tbody>
</table>
</div>
<p>For example, if the <code>fruit</code> library has the implementation of functions, such as <code>size</code> and <code>color</code>, and the <code>apple</code> library has a function <code>apple_size</code> which called the <code>size</code> from the <code>fruit</code> library and was <code>PRIVATE</code> linked with the <code>fruit</code> library. We could create an executable <code>eat_apple</code> that calls <code>apple_size</code> by <code>PUBLIC</code> or <code>PRIVATE</code> linking with the <code>apple</code> library. However, if we want to create an executable <code>eat_apple</code> that calls the <code>size</code> and <code>color</code> from the <code>fruit</code> library, only linking with the <code>apple</code> library will cause building error, since the <code>fruit</code> library was not part of the interface in the <code>apple</code> library, and is thus inaccessible to <code>eat_apple</code>. To make the <code>apple</code> library to inherit the <code>size</code> and <code>color</code> from the <code>fruit</code> library, we have to make the linking of the <code>apple</code> library to the the <code>fruit</code> library <code>PUBLIC</code> instead of <code>PRIVATE</code>.</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习3】软连接和硬链接</title>
    <url>/2022/01/19/%E3%80%90linux%E5%AD%A6%E4%B9%A03%E3%80%91%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>本文介绍linux中的符号链接（软链接）和硬链接。</p>
<span id="more"></span>
<p>首先说以下链接有什么用：</p>
<p><strong>例子1——符号链接的用武之地：</strong></p>
<p>当有一个程序叫做foo，但是它是一个不断更新的程序，有许多的版本，如foo-0.1，foo-0.2等。当其他程序如piggy在使用foo的过程中，就需要不断改变其引用的名称，一个程序还好，当有许多个程序时是十分麻烦的。这时就需要符号链接来帮助完成。我们可以先建立foo和foo-0.1的符号链接，然后piggy程序引用的程序名是foo，这样当foo-0.1升级到foo-0.2时，只需要让foo重新链接到foo-0.2上就可以了。</p>
<p><strong>例子2——硬链接的用武之地：</strong></p>
<p>当有一些重要的文件不可以被删除时，我们就可以使用硬链接。如有一个文件叫file1，我们可以建立一个硬链接file2，当file1不小心被删除时，别担心此时还有file2是这个文件。</p>
<h2 id="I-符号链接（软链接）"><a href="#I-符号链接（软链接）" class="headerlink" title="I. 符号链接（软链接）"></a>I. 符号链接（软链接）</h2><p>为了与硬链接形成对比，符号链接也叫做软连接（后面就用软连接来代替符号链接了）。软连接可以理解为是一个<strong>超链接</strong> ，我们可以用下图来表示与原文件间的关系。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118152532971.png" alt="image-20220118152532971"></p>
<blockquote>
<p>文件和目录的inode编号是一个用于标识的唯一数字，这个数字是由内核分配给文件系统中的每一个对象。</p>
<p>而文件名相当于你进入该文件的一条路。</p>
</blockquote>
<p>在上图中可以看到，当创建一个软连接时，又创建了一个真实存在的新文件，在这个新文件中，存放的是其所指向的<strong>原文件的路径</strong>。当原文件被删除时，软链接自动失效，因为软链接的存在就是为了指向某个文件或目录的，当原文件没有了，那么软链接也自然没用了。==另外，不只是删除失效，移动原文件到不同的路径软链接也会失效。==</p>
<p>软链接的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ln -s file file-sl <span class="comment">#软链接名放在第二个参数中</span></span></span><br></pre></td></tr></table></figure>
<h2 id="II-硬链接"><a href="#II-硬链接" class="headerlink" title="II. 硬链接"></a>II. 硬链接</h2><p>硬链接是给原文件加上另一个文件名，也就是多了一条进入原文件的路径。当原文件的一条路被堵死了，还有另一条路可以进入。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118160134214.png" alt="image-20220118160134214"></p>
<p>每一个文件都有一个文件名，所以默认情况下每一个文件都有一个硬链接。硬链接有一些局限性：</p>
<ul>
<li>硬链接不能引用自身文件系统之外的文件，也就是说，链接不能引用与该链接不在同一磁盘分区的文件。</li>
<li>硬链接无法引用目录。</li>
</ul>
<h2 id="III-查看文件的链接"><a href="#III-查看文件的链接" class="headerlink" title="III. 查看文件的链接"></a>III. 查看文件的链接</h2><p>那么如何查看文件的链接情况呢？可以使用长列表来查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118163203352.png" alt="image-20220118163203352"></p>
<p>对于显示出的结果，从前到后有以下信息：</p>
<ul>
<li>文件类型，d表示目录，-表示文件，c表示字符型文件，b表示块设备，l表示软链接</li>
<li>文件的权限</li>
<li><strong>文件的硬链接数量</strong></li>
<li>文件属主用户名</li>
<li>文件属组组名</li>
<li>文件的大小（以字节为单位）</li>
<li>文件上次修改时间</li>
<li>文件名和目录名</li>
</ul>
<p>如果是软链接，在文件名后面还会有表示指向的文件。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118163635175.png" alt="image-20220118163635175"></p>
<p>硬链接是一个普通的文件，其前面是<code>-</code> 。如果想要知道两个硬链接是否是同一个文件，则可以看它们的inode编号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ls -li</span>	</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220118163833129.png" alt="image-20220118163833129"></p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习5】虚拟机安装</title>
    <url>/2022/01/21/%E3%80%90linux%E5%AD%A6%E4%B9%A05%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>使用VMWare安装linux系统。</p>
<span id="more"></span>
<h2 id="I-安装VMWare"><a href="#I-安装VMWare" class="headerlink" title="I. 安装VMWare"></a>I. 安装VMWare</h2><p>参考：<a href="https://www.bilibili.com/read/cv9694457">https://www.bilibili.com/read/cv9694457</a></p>
<h2 id="II-安装虚拟机"><a href="#II-安装虚拟机" class="headerlink" title="II. 安装虚拟机"></a>II. 安装虚拟机</h2><ol>
<li>以管理员身份打开VMWare</li>
<li>在VMWare中新建虚拟机</li>
<li>典型/自定义，选择自定义安装</li>
<li>虚拟机兼容性，默认下一步</li>
<li>安装来源，选择稍后安装操作系统</li>
<li>操作系统选择，选择linux centos8 64位</li>
<li>自定义虚拟机名称和文件夹位置</li>
<li>虚拟机CPU，可以默认下一步</li>
<li>内存选择，可以选1024M</li>
<li>网络链接，选择NAT</li>
<li>IO类型，默认下一步</li>
<li>虚拟磁盘类型，默认下一步</li>
<li>创建新磁盘，默认下一步</li>
<li>磁盘大小，默认下一步，20G</li>
<li>磁盘文件名，默认下一步</li>
<li>完成</li>
</ol>
<h2 id="III-安装系统"><a href="#III-安装系统" class="headerlink" title="III. 安装系统"></a>III. 安装系统</h2><ol>
<li>下载好要装的系统镜像文件ISO</li>
<li><strong>在新虚拟机中，选择DVD，选择使用ISO镜像，选择镜像ISO文件</strong></li>
<li>开启虚拟机</li>
<li>安装操作系统</li>
</ol>
<blockquote>
<p>在上面第3步时，可能会报错显示虚拟VT-X没有打开，则需要重新打开计算机，进入BIOS启动页面，找到configuration选项中，找到虚拟化开关，打开。</p>
</blockquote>
<p>例：</p>
<p>如果安装CentOS系统，在软件选择中，选择带GUI的服务器，并选择附加软件开发工具和兼容性程序库。然后设置安装位置，/boot , /swap, / 。然后设置root密码。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习7】扩展和引用</title>
    <url>/2022/01/21/%E3%80%90linux%E5%AD%A6%E4%B9%A07%E3%80%91%E6%89%A9%E5%B1%95%E5%92%8C%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>当我们每次在终端中输入命令后，shell程序都会在执行命令之前进行多重处理——可以理解为进行一些简单的翻译。这个处理过程称为扩展，在这些命令执行之前，shell就已经将其扩展成其他内容了。</p>
<span id="more"></span>
<p>例如：</p>
<p>使用 <code>echo</code> 命令来验证，它的作用是将文本参数打印到屏幕上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span></span></span><br><span class="line">this is a test</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> *</span></span><br><span class="line">Desktop Documents Music Pictures Public Templates Video</span><br></pre></td></tr></table></figure>
<p>为什么 <code>echo *</code> 的结果不是 <code>*</code> 呢，这时因为在执行<code>echo</code> 之前，shell程序已经提前把 <code>*</code> 翻译好了，变成了当前路径下的全部文件，并将其作为<code>echo</code> 命令的参数。</p>
<p><strong>而引用就是来控制扩展的，就是让shell什么时候不翻译或是翻译一部分，选择性地避免不想要的扩展。</strong></p>
<h2 id="I-扩展的规则"><a href="#I-扩展的规则" class="headerlink" title="I. 扩展的规则"></a>I. 扩展的规则</h2><h3 id="1-路径名扩展"><a href="#1-路径名扩展" class="headerlink" title="1. 路径名扩展"></a>1. 路径名扩展</h3><p>通过使用通配符来实现扩展机制称为 <strong>路径名扩展</strong> 。</p>
<blockquote>
<p>注：类似<code>echo *</code> 的扩展，不包括隐藏文件。</p>
</blockquote>
<p>如果想要使用通配符来扩展隐藏文件，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> .*</span></span><br><span class="line">. .. .file # 这包括了父目录和当前目录</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> .[!.]?*</span> </span><br><span class="line">.file # 这种情况下，用？来表示这里必有一个字符</span><br></pre></td></tr></table></figure>
<h3 id="2-波浪线扩展"><a href="#2-波浪线扩展" class="headerlink" title="2. 波浪线扩展"></a>2. 波浪线扩展</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ~</span></span><br><span class="line">/home/piggy</span><br></pre></td></tr></table></figure>
<h3 id="3-算数扩展"><a href="#3-算数扩展" class="headerlink" title="3. 算数扩展"></a>3. 算数扩展</h3><p>shell支持通过扩展来运行<strong>算数表达式</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $((<span class="number">1</span>+<span class="number">2</span>))</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>算数扩展使用为 <code>$((expression))</code> ，这里表达式外面必须套两层括号，里面可以嵌套更多的表达式。</p>
<h3 id="4-花括号扩展"><a href="#4-花括号扩展" class="headerlink" title="4. 花括号扩展"></a>4. 花括号扩展</h3><p>花括号扩展就是一种并列的关系，可以理解为炸开花。</p>
<p>花括号内部可以是一系列逗号连接的字符串，也可以是一系列整数或单个字符。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> File&#123;A,B,C&#125;</span></span><br><span class="line">FileA FileB FileC</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> Number&#123;1..3&#125;</span></span><br><span class="line">Number1 Number2 Number3</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> A&#123;a&#123;1,2&#125;,B&#123;1,2&#125;&#125;b</span></span><br><span class="line">Aa1b Aa2b AB1b Ab2b</span><br></pre></td></tr></table></figure>
<p>花括号扩展一般用在生成一群文件的时候，且命名有一些顺序规则。</p>
<h3 id="5-参数扩展"><a href="#5-参数扩展" class="headerlink" title="5. 参数扩展"></a>5. 参数扩展</h3><p>参数是指系统在某个区域存储的一小块数据，并且给这一小块数据命名了。</p>
<p>它的使用是<code>$parameter</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$USER</span></span></span><br><span class="line">piggy</span><br></pre></td></tr></table></figure>
<h3 id="6-命令替换"><a href="#6-命令替换" class="headerlink" title="6. 命令替换"></a>6. 命令替换</h3><p>该规则的使用表达为 <code>$(command)</code> ，是翻译成命令的输出结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(ls)</span></span><br><span class="line">Desktop Documents Music Pictures Public Templates Video</span><br></pre></td></tr></table></figure>
<h2 id="II-引用"><a href="#II-引用" class="headerlink" title="II. 引用"></a>II. 引用</h2><p>先看两个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a      <span class="built_in">test</span></span></span><br><span class="line">this is a test</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$100</span>.0</span></span><br><span class="line">00.0</span><br></pre></td></tr></table></figure>
<p>这两个例子都发生了扩展，shell私自的翻译了一下子，第一个例子是当有一堆空格连续在一起的时候，shell会将它翻译为一个空格，且每一个连着的字符串被识别为一个参数，这叫做单词分割。第二个例子中，<code>$1</code> 是一个未定义的变量，所以shell将其翻译为一个空字符。</p>
<p>那么怎么可以避免这种不想要的扩展呢？有以下的几种方式。</p>
<h3 id="1-双引号"><a href="#1-双引号" class="headerlink" title="1. 双引号"></a>1. 双引号</h3><p>除了<code>$</code> <code>\</code> 还是有其特殊的意思外，所有的字符都是去它们的特殊含义，被看成是普通的字符。</p>
<p>这意味着以下扩展失效：</p>
<ul>
<li>单词分割</li>
<li>路径名扩展</li>
<li>波浪线扩展</li>
<li>花括号扩展</li>
</ul>
<p>但还有以下扩展保留：</p>
<ul>
<li>参数扩展</li>
<li>算数扩展</li>
<li>命令替换</li>
</ul>
<p>单词分割扩展失效，就可以处理文件名中包含空格的文件了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch <span class="string">&quot;piggy hero.txt&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l piggy hero.txt</span></span><br><span class="line">ls: cannot access piggy: No such file or directory</span><br><span class="line">ls: cannot access hero.txt: No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> mv <span class="string">&quot;piggy hero&quot;</span> piggy_hero</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在单词分割中，shell会先查找是否存在空格、制表符以及换行（换行字符）等界定符（delimiter）。这就意味着没有用引号包含起来的空格、制表符和换行字符都不会被当成文本的一部分，而只是被当成分割符。</p>
</blockquote>
<p>有一个比较有趣的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cal</span></span><br><span class="line">February 2012</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">		 1  2  3  4</span><br><span class="line">5   6  7  8  9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $(cal)	<span class="comment">#这是因为cal的输出结果中包含换行符，但是在作为echo的参数之前，先被shell翻译为空格</span></span></span><br><span class="line">February 2012 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</span><br><span class="line">18 19 20 21 22 23 24 25 26 27 28 29</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cal)</span>&quot;</span>	<span class="comment">#加了双引号之后，限制了shell的翻译</span></span></span><br><span class="line">February 2012</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">		 1  2  3  4</span><br><span class="line">5   6  7  8  9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-单引号"><a href="#2-单引号" class="headerlink" title="2. 单引号"></a>2. 单引号</h3><p>如果想要抑制全部的翻译（扩展），那么就是用单引号 <code>&#39;&#39;</code> 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;text ~/ * .txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER&#x27;</span></span></span><br><span class="line">text ~/ * .txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;text ~/ * .txt &#123;a,b&#125; <span class="subst">$(echo foo)</span> <span class="subst">$((2+2)</span>) <span class="variable">$USER</span>&quot;</span></span></span><br><span class="line">text ~/ * .txt &#123;a,b&#125; foo 4 piggy</span><br></pre></td></tr></table></figure>
<h3 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3. 转义字符"></a>3. 转义字符</h3><p>有时候我们仅想选择性抑制单个扩展，这时就可以使用转义字符<code>\</code> ，转义字符经常在双引号中用来有选择性地阻止扩展。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;The balance for user <span class="variable">$USER</span> is: \$5.00&quot;</span></span></span><br><span class="line">The balance for user $USER is: \$5.00</span><br></pre></td></tr></table></figure>
<p>转义字符也常用来消除文件名中某个字符的特殊含义，这些字符包括<code>$</code>、<code>！</code>、<code>&amp;</code>、空格等。</p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch a\<span class="variable">$b</span> a\!b a\&amp;b a\ b</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line"><span class="meta">a$</span><span class="bash">b a!b a&amp;b a b</span></span><br></pre></td></tr></table></figure>
<p>一些反斜杠转义字符序列：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121010916486.png" alt="image-20220121010916486"></p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
  </entry>
  <entry>
    <title>【linux学习4】关于命令</title>
    <url>/2022/01/19/%E3%80%90linux%E5%AD%A6%E4%B9%A04%E3%80%91%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>我们常用的linux的命令行语法结构如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command -options arguments</span><br></pre></td></tr></table></figure>
<p>通常命令后面跟有一个或多个选项（options），不同选项功能也不一样。</p>
<span id="more"></span>
<p>然后接着是参数（arguments），这些参数是命令作用的对象。</p>
<h2 id="I-什么是命令"><a href="#I-什么是命令" class="headerlink" title="I. 什么是命令"></a>I. 什么是命令</h2><p>现在我们说的命令就是前面语法结构中的command。一条命令可以是以下四种类型：</p>
<ul>
<li>外部命令</li>
<li>内建命令</li>
<li>shell函数：是合并到环境变量上的小型shell脚本。</li>
<li>alias命令：在其他命令基础上自定义的命令。</li>
</ul>
<h3 id="判断命令属于哪种类型"><a href="#判断命令属于哪种类型" class="headerlink" title="判断命令属于哪种类型"></a>判断命令属于哪种类型</h3><p>如果想要知道所使用的命令属于这四种类型的哪一种，可以使用——<code>type</code> 命令来判断。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">type</span> <span class="built_in">command</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">例如：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">type</span> ls</span></span><br><span class="line"><span class="meta">#</span><span class="bash">返回结果：</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls is aliased to <span class="string">&#x27;ls --color=tty&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="II-外部命令"><a href="#II-外部命令" class="headerlink" title="II. 外部命令"></a>II. 外部命令</h2><p>这类命令也叫做<strong>文件系统命令</strong>，是存在shell程序之外的。它可以是编译好的可执行二进制文件（之前我们说过可执行二进制文件的名字可以直接通过shell发送给内核来运行）和用shell、Python等脚本编写的程序。通常可以在<code>/bin</code> 、<code>/usr/bin</code> 等目录中找到。</p>
<h3 id="1-查找命令文件的位置"><a href="#1-查找命令文件的位置" class="headerlink" title="1. 查找命令文件的位置"></a>1. 查找命令文件的位置</h3><p>如果知道一条外部命令后，可以通过<code>which</code> 找到其所在的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> ps</span></span><br><span class="line">/bin/ps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：只有外部命令才可以使用which来查找位置，对于内建命令，用which来查找，其结果要么没有响应，要么得到一条错误的信息。</p>
</blockquote>
<h3 id="2-外部命令的执行过程"><a href="#2-外部命令的执行过程" class="headerlink" title="2. 外部命令的执行过程"></a>2. 外部命令的执行过程</h3><p>在shell程序中输入外部命令时，会衍生出一个子进程。</p>
<p>例如：</p>
<p>ps作为外部命令执行时，会创建一个子进程，如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220119002931466.png" alt="image-20220119002931466"></p>
<p>可以看出ps命令的PID时2801，父进程的PID是2743，而bash的PID就是2743。这个例子就说明了，我们在shell程序中输入命令ps后，此时内核会收到该名字然后运行对应的可执行文件，从而生成一个新的进程。</p>
<p>如果命令是内建命令，则不会有新的进程生成。</p>
<h2 id="III-内建命令"><a href="#III-内建命令" class="headerlink" title="III. 内建命令"></a>III. 内建命令</h2><p>这类命令称为shell builtin 。它们已经和shell程序编译成一体，作为shell工具的组成部分存在，不需要借助外部程序文件来运行。因此内建命令的执行速度要更快，效率也更高。</p>
<p>当然也有比较特殊的命令，可以有多种实现。比如<code>echo</code> 和 <code>pwd</code> ，既有内建命令和外部命令。可以使用<code>type -a</code> 来查看全部的情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">type</span> -a <span class="built_in">echo</span></span> </span><br><span class="line">echo is a shell builtin</span><br><span class="line">echo is /bin/echo</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> <span class="built_in">echo</span></span></span><br><span class="line">/bin/echo</span><br></pre></td></tr></table></figure>
<h2 id="IV-获得命令文档"><a href="#IV-获得命令文档" class="headerlink" title="IV. 获得命令文档"></a>IV. 获得命令文档</h2><h3 id="1-help"><a href="#1-help" class="headerlink" title="1. help"></a>1. help</h3><p>一些内建命令可以使用<code>help</code> 命令来查看其命令文档，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">help</span> <span class="built_in">cd</span></span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220119014334472.png" alt="image-20220119014334472"></p>
<p>输出的语法描述中，方括号表示一个可选的选项，竖线表示两个互斥的选项。</p>
<p>有时不管是内建命令还是外部命令，也都可以在命令后加<code>--help</code> 来查看帮助文档。</p>
<h3 id="2-man"><a href="#2-man" class="headerlink" title="2. man"></a>2. man</h3><p>可以使用<code>man</code> 命令来查看命令的使用手册。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> man program	<span class="comment">#program是具体的手册名，但一般命令名就是手册名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man passwd	<span class="comment">#默认情况下可能显示的是第一部分，要看具体命令有几部分</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man 5 passwd	<span class="comment">#显示第5部分</span></span></span><br></pre></td></tr></table></figure>
<p>手册文档的组织结构：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220119010940042.png" alt="image-20220119010940042"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220119010952599.png" alt="image-20220119010952599"></p>
<h3 id="3-apropos"><a href="#3-apropos" class="headerlink" title="3. apropos"></a>3. apropos</h3><p><strong>apropos的作用是你知道想要实现什么功能，但不知道用什么命令。</strong>此时就可以配合想要实现的作用或者描述信息来进行搜索。其本质是根据你提供的信息在手册中查找。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apropos <span class="string">&quot;list directory&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>显示的结果：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/v2-ba4ad8abf9543cbfb1fd307605b13502_b.jpg" alt="img"></p>
<p>在这里，第一个字段是手册页的名称，第二个字段表示显示的部分，最后一个字段包含了所描述的信息。</p>
<p>如果想要多搜几个关键条目，可以用<code>-a</code> 标志，灵活的添加多个条目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apropos <span class="string">&quot;match&quot;</span> -a <span class="string">&quot;pattern&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-whatis"><a href="#4-whatis" class="headerlink" title="4. whatis"></a>4. whatis</h3><p>显示命令的简要描述，包括手册页的名字及各部分和关于该部分的一行描述。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> whatis ls</span></span><br><span class="line">ls (1) 		- list directory contents</span><br><span class="line"><span class="meta">$</span><span class="bash"> whatis passwd</span></span><br><span class="line">passwd (5)		- the password file</span><br><span class="line">passwd (1)		- change user password</span><br><span class="line">passwd (1ssl)	- compute password hashes</span><br></pre></td></tr></table></figure>
<p>如果想要看具体的，可以使用man来查看手册。</p>
<h3 id="5-info"><a href="#5-info" class="headerlink" title="5. info"></a>5. info</h3><p>基本上，info 与 man的用途差不多，都是用来查询命令或是文件格式。info 与 man 最大的区别是，man page一次性输出全部信息，而 info page 则是将文件数据拆分成一个一个段落，每个段落用自己的页面来编写，并且在各个页面中还有类似网页的超链接来跳转到各个不同的页面中，每个独立页面也被称为一个节点。支持 info 命令的文件默认放置在 /usr/share/info/ 目录中。</p>
<h2 id="V-使用别名创建命令"><a href="#V-使用别名创建命令" class="headerlink" title="V. 使用别名创建命令"></a>V. 使用别名创建命令</h2><p>在创建之间可以使用<code>type</code> 来查一下想设置的名字是否被用过。</p>
<p>使用别名创建命令用<code>alias</code> 命令。具体的使用方法为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">alias</span> new_name=<span class="string">&#x27;command1; command2; ...&#x27;</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">alias</span> foo=<span class="string">&#x27;cd /usr; ls; cd -&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>如果想要删除这个别名，可以用<code>unalias</code>，具体用法为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unalias</span> foo</span></span><br></pre></td></tr></table></figure>
<p>如果想要看当前环境中定义的别名，可以直接使用alias。</p>
<blockquote>
<p>注：在命令行定义别名还有一个小问题。当shell会话结束时，这些别名也随之消失了。</p>
</blockquote>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习9】权限</title>
    <url>/2022/01/21/%E3%80%90linux%E5%AD%A6%E4%B9%A09%E3%80%91%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>和UNIX一样，linux是多任务和多用户系统。多用户意味着在同一时间可以有多个用户使用同一台计算机。为了保护多用户功能实际可用，系统特别设计了一种方案来保护当前用户不受其他用户操作的影响。</p>
<span id="more"></span>
<h2 id="I-所有者、组成员和其他用户"><a href="#I-所有者、组成员和其他用户" class="headerlink" title="I. 所有者、组成员和其他用户"></a>I. 所有者、组成员和其他用户</h2><p>一个文件能被三种人操作（读，写，执行），这三种人为：</p>
<ul>
<li>该文件的所有者</li>
<li>该文件所有者的同组组员</li>
<li>其他人</li>
</ul>
<p>我们可以使用 <code>id</code> 命令来查看此时的用户信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> id</span></span><br><span class="line">uid=1000(piggy) gid=1000(piggy) groups=1000(piggy),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)</span><br></pre></td></tr></table></figure>
<p>显示的结果：</p>
<ul>
<li>uid(user ID)：当前用户的ID，在创建账户时就已被分配，为了方便ID和用户名一一对应。</li>
<li>gid(group ID)：当前用户所属组的ID，用户可以归属于多个组。</li>
</ul>
<p>这些信息从何而来呢？</p>
<p>这些信息来源于一系列的文本文件，用户账户定义在文件 <code>/etc/passwd</code> 中，用户组定义在文件 <code>/etc/group</code> 文件中。在文件/etc/passwd中定义了对应用户的用户登录名、uid、gid、账户真实姓名、主目录、以及登录的shell信息。</p>
<p>许多类UNIX系统会把普通用户分配到一个公共的群组中，然而在linux中则会创建一个独一无二的，只有一个用户的群组，组名和用户名相同。</p>
<h2 id="II-读取、写入和执行"><a href="#II-读取、写入和执行" class="headerlink" title="II. 读取、写入和执行"></a>II. 读取、写入和执行</h2><p>使用<code>ls</code> 命令可以查看文件或目录的属性信息。在文件属性信息中，234对应的9个字符称为 <strong>文件模式</strong> ，表示文件所有者，同组其他用户和其他所有人对该文件的读、写、执行权限。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121170805946.png" alt="image-20220121170805946"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121170818935.png" alt="image-20220121170818935"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121170830896.png" alt="image-20220121170830896"></p>
<h3 id="1-更改文件模式"><a href="#1-更改文件模式" class="headerlink" title="1. 更改文件模式"></a>1. 更改文件模式</h3><p>使用 <code>chmod</code> 命令可以更改文件的模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 600 filename</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x filename</span></span><br></pre></td></tr></table></figure>
<p>在该命令的第二项表示更改对哪类人的权限。可以根据八进制的规则更改，也可以用符号来表示。</p>
<h4 id="1-八进制规则"><a href="#1-八进制规则" class="headerlink" title="(1)八进制规则"></a>(1)八进制规则</h4><p>八进制规则就是 <code>rwx</code> 对应三位，写1则为激活，0为取消。八进制就可以用一个数来表示一类人的文件模式，那么三个数就可以表示三类人。</p>
<p>例如：</p>
<p><code>723</code> 表示 <code>111010011</code> ，进而表示的是 <code>rwx-w--wx</code> 。</p>
<h4 id="2-符号表示"><a href="#2-符号表示" class="headerlink" title="(2)符号表示"></a>(2)符号表示</h4><p>符号表示就是第二个参数换为字符。用 <code>u</code> 、<code>g</code> 、<code>o</code> 、<code>a</code> 分别表示所有者，同组人，其他人，三类人。然后通过 <code>+-=</code> 来设置文件模式。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod u+w filename <span class="comment">#给文件的所有者添加可写模式。</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-在图形化窗口更改文件模式"><a href="#2-在图形化窗口更改文件模式" class="headerlink" title="2. 在图形化窗口更改文件模式"></a>2. 在图形化窗口更改文件模式</h3><p>另外还可以在图形化界面上更改文件模式。</p>
<h3 id="3-设置默认权限"><a href="#3-设置默认权限" class="headerlink" title="3. 设置默认权限"></a>3. 设置默认权限</h3><p>还有一个很好玩的命令，就是<code>umask</code> ，它的作用是设置掩码，来更改默认生成文件的文件模式。当umask的值为<code>0000</code> 时，生成的文件的文件模式是 <code>rw-rw-rw-</code> ，当umask设置为 <code>0022</code> 时，转成二进制数为 <code>000010010</code> ，这时默认生成的文件模式是<code>rw-r--r--</code> 。更改umask的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> <span class="comment">#查看当前umask的值</span></span></span><br><span class="line">0002</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> 0022</span></span><br></pre></td></tr></table></figure>
<h2 id="III-让不允许变为允许"><a href="#III-让不允许变为允许" class="headerlink" title="III. 让不允许变为允许"></a>III. 让不允许变为允许</h2><h3 id="1-更改使用人的身份"><a href="#1-更改使用人的身份" class="headerlink" title="1. 更改使用人的身份"></a>1. 更改使用人的身份</h3><p>如果我们的身份不符合系统的要求，怎么才可以做想做的事情呢？首先想到的是让自己符合呀，那就要改变自己的身份了。如果我们想更改我们所登录的身份该如何做呢？这个身份大致分为两个等级，一种是平民身份(user)，一种是皇帝身份(root)。平民身份就是可以做一部分的事情，但是得由皇帝允许。而皇帝就是什么都可以做。皇帝只能有一个，平民可以有许多。</p>
<ul>
<li>su：换身份，让自己当皇帝。</li>
<li>sudo：换说的话，告诉他们我是转告皇帝说的话。</li>
</ul>
<p>当我们做一些操作时，系统要求只可以root用户来做，所以需要改变我们的身份。可以使用 <code>su</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[piggy@computer]$</span><span class="bash"> su - <span class="comment"># &quot;-&quot;表示加载变更用户的环境变量</span></span></span><br><span class="line">Password:	#输入root密码</span><br><span class="line"><span class="meta">[root@computer]#</span><span class="bash"> <span class="built_in">exit</span>  <span class="comment">#可以退出该账户</span></span></span><br><span class="line"><span class="meta">[piggy@computer]$</span><span class="bash"> su - test_user <span class="comment">#登录test_user账户</span></span></span><br><span class="line">Password:	#输入test_user的密码</span><br><span class="line"><span class="meta">[test_user@computer]$</span><span class="bash"> <span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>su -</code> 命令中的 <code>-</code> 表示要加载目标用户的环境变量。后面的参数中如果没有指定用户名，则表示要登陆超级用户root。</p>
<blockquote>
<p>在运行<code>su -</code>命令时，就相当于又开启了一个shell程序。这个shell程序加载的是目标账户的环境变量。</p>
</blockquote>
<p>另一个方便的命令是<code>sudo</code> ，但是与<code>su</code> 的原理是不一样的。<code>sudo</code> 的英文全称为 super user do，以超级用户的方式执行命令。而<code>su</code> 的英文全称是 switch user，是换用户的意思。</p>
<p>只要在命令前面加上<code>sudo</code> ，就表示这条命令有超级用户的权限。要注意的是还需要输入用户的密码。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[piggy@computer]$</span><span class="bash"> sudo su - <span class="comment">#可以直接进入root用户</span></span></span><br><span class="line">piggy password:</span><br><span class="line"><span class="meta">[root@computer]#</span></span><br></pre></td></tr></table></figure>
<p>但你一定会问，进入root用户为什么输入piggy的密码呢？原来<code>sudo</code>命令只会将名字在 <code>/etc/sudoers</code> 中的用户提升命令权限，piggy在这个里面，所以输入piggy的密码表示你是这个用户的人，所以你可以提升权限。</p>
<blockquote>
<p><code>sudo su -</code> 和 <code>sudo -i</code> 的命令效果一样，且都是输入piggy的密码。</p>
</blockquote>
<p><strong>小结：</strong>我们已经看到：</p>
<ul>
<li>使用 <code>su -</code> ，提供 root 账户的密码，可以切换到 root 用户；</li>
<li>使用 <code>sudo su -</code> ，提供当前用户的密码，也可以切换到 root 用户</li>
</ul>
<p>两种方式的差异也显而易见：如果我们的 Linux 系统有很多用户需要使用的话，前者要求所有用户都知道 root 用户的密码，这显然是非常危险的；后者是不需要暴露 root 账户密码的，用户只需要输入自己的账户密码就可以，而且哪些用户可以切换到 root，这完全是受 root 控制的（root 通过设置 <code>/etc/sudoers</code> 实现的），这样系统就安全很多了。</p>
<h3 id="2-更改文件所有者"><a href="#2-更改文件所有者" class="headerlink" title="2. 更改文件所有者"></a>2. 更改文件所有者</h3><p>当我要拿一个东西的时候人家不让，我让我变成皇帝或者假装是转述皇帝的话。现在从另一个角度来看，人家不让是因为东西是人家的，那么我把它变成我自己的不就完了么。所以我们可以用<code>chown</code> 来更改文件的所有者和所属群组。但是话说回来，既然你拿都不让，怎么还能归你呢。这时还是假传皇帝的圣旨，提升自己说话的分量，也就是在命令前加上 <code>sudo</code> 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chown [ower][:[group]] file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown emperor:China file  <span class="comment">#将file的所有者改为emperor，所属组改为China</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown emperor: file  <span class="comment">#将file的所有者改为emperor，所属组改为emperor的所在组</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux问题解决】Ubuntu安装Flash插件</title>
    <url>/2022/02/04/%E3%80%90linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91Ubuntu%E5%AE%89%E8%A3%85Flash%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>Ubuntu安装Adobe Flash Player插件</p>
<span id="more"></span>
<ol>
<li><p>添加有Flash Player的软件库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb http://archive.canonical.com/ $(lsb_release -sc) partner&quot;</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Flash Player</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install adobe-flashplugin</span><br><span class="line">sudo apt install browser-plugin-freshplayer-pepperflash</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后重启浏览器</p>
</li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux问题解决】Ubuntu安装无线网卡</title>
    <url>/2022/02/04/%E3%80%90linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91Ubuntu%E5%AE%89%E8%A3%85%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/chengxuyuan99/article/details/117226445?spm=1001.2014.3001.5506">原文参考连接</a></p>
<span id="more"></span>
<ol>
<li><p>首先使用<code>lsusb</code>查看网卡设备</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20220204063853.png" alt="image-20220203191327479"></p>
<p>看到设备号显示<code>0bda:b711</code> ，对应的芯片为<code>RTL8188GU</code>。如果不是该设备号自行上网查找对应芯片。</p>
</li>
<li><p>然后根据对应芯片下载驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/McMCCRU/rtl8188gu</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载后进行安装(需要提前安装好编译工具<code>make</code>,<code>gcc</code>,<code>linux-header</code>,<code>bc</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd rtl8188gu</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br><span class="line">sudo modprobe 8188gu</span><br><span class="line">sudo usb_modeswitch -KW -v 0bda -p b711</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习6】重定向和管道</title>
    <url>/2022/01/21/%E3%80%90linux%E5%AD%A6%E4%B9%A06%E3%80%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p>在执行命令的时候，我们可以在终端上看到命令输出的结果，这些结果被内核发送到屏幕上，我们也可以让这些结果输出文件里，这就叫做重定向。同理，我们也可以让文件作为输入，因此重定向的全称为I/O重定向。</p>
<span id="more"></span>
<p>本文涉及的命令：</p>
<ul>
<li>cat</li>
<li>sort</li>
<li>uniq</li>
<li>wc</li>
<li>grep</li>
<li>head</li>
<li>tail</li>
<li>tee</li>
</ul>
<h2 id="I-简短的介绍"><a href="#I-简短的介绍" class="headerlink" title="I. 简短的介绍"></a>I. 简短的介绍</h2><p>我们在使用程序的时候往往会有输出，这些输出通常分为两种：</p>
<ul>
<li>程序运行结果，即程序执行输出的数据</li>
<li>程序的状态或错误信息，描述程序当前的执行状态</li>
</ul>
<p>根据linux中一切皆文件的思想。实际上程序是把它们的运行结果发送到一个叫做 <strong>标准输出</strong> 的文件中，而把状态和错误信息发送到一个叫做 <strong>标准错误</strong> 的文件中。 而这个标准输出文件和标准错误文件都与屏幕相连。</p>
<p>另外，许多程序都是从一个叫做 <strong>标准输入</strong> 的文件中获得输入。这个文件与我们的键盘相连。</p>
<p>而我们所做的重定向就是改变这些输出的方向和输入的来源。</p>
<h2 id="II-I-O重定向"><a href="#II-I-O重定向" class="headerlink" title="II. I/O重定向"></a>II. I/O重定向</h2><h3 id="1-标准输出重定向"><a href="#1-标准输出重定向" class="headerlink" title="1. 标准输出重定向"></a>1. 标准输出重定向</h3><p>输出重定向就是指将输出发送到哪。我们使用 <code>&gt;</code> 后接文件名来表示发送的目的地。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /usr/bin &gt; ls_output.txt</span></span><br></pre></td></tr></table></figure>
<p>这时原来在屏幕上看到的结果被发送到文件中了。</p>
<blockquote>
<p><code>&gt;</code> 符号后面的文件接收结果的时候是从头接收到，也就是再从头接收一次数据就会被覆盖。<code>&gt;&gt;</code> 符号表示从文件后面接收，不会覆盖文件。</p>
</blockquote>
<h3 id="2-标准错误重定向"><a href="#2-标准错误重定向" class="headerlink" title="2. 标准错误重定向"></a>2. 标准错误重定向</h3><p>前面的符号只能做标准输出的重定向。如果想要做标准错误重定向，使用 <code>2&gt;</code> 。这里的2表示输出的是标准错误（0表示标准输入，1表示标准输出，2表示标准错误）。就是标准输出和标准错误走的不是一条路，所以要标注明白。</p>
<p>如果想要同时将标准输出和标准错误重定向到同一文件中，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /bin/usr &gt; ls_output.txt 2&gt;&amp;1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l /bin/usr &amp;&gt; ls_output.txt</span></span><br></pre></td></tr></table></figure>
<p>在第一种方法中，是执行两次重定向。先是将标准输出重定向到文件上，然后再把标准错误重定向的标准输出上。这个顺序不能反。</p>
<p>如果不想有输出，可以将其重定向到一个垃圾桶文件中 <code>/dev/null</code> 。</p>
<h3 id="3-标准输入重定向"><a href="#3-标准输入重定向" class="headerlink" title="3. 标准输入重定向"></a>3. 标准输入重定向</h3><p>使用 <code>&lt;</code> 符号完成标准输入重定向。</p>
<p>例：</p>
<p>有一个命令 <code>cat</code> ，其作用是将后面跟着的参数文件发送到标准输出中。当后面不接参数的时候，cat等待着标准输入，然后发送到标准输出中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; file.txt</span></span><br><span class="line">结果显示到屏幕上</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有许多命令都是从标准输入获得输入，然后结果发送到标准输出上。</p>
</blockquote>
<h2 id="III-管道"><a href="#III-管道" class="headerlink" title="III. 管道"></a>III. 管道</h2><p>前面我们说许多命令等待着标准输入的输入，然后发送到标准输出文件上，那么我们还可以把一个命令的标准输出发送到另一个命令的标准输入中，这就是 <strong>管道</strong>。</p>
<p>管道 <code>|</code> 可以把一个命令的标准输出传送到另一个命令的标准输入中，就像一节一节的管子一样。</p>
<p>例：</p>
<p><code>less</code> 与cat类似，把数据发送到标准输出中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /usr/bin | less</span></span><br></pre></td></tr></table></figure>
<p>因此，还可以加上一些对数据操作的命令，来处理这些数据，就是对这些输入的数据做出一些改变。如：</p>
<ul>
<li>sort：按字母顺序排列</li>
<li>uniq：报告或忽略文件中重复的行</li>
<li>wc：打印行数，字数和字节数</li>
<li>grep：打印匹配的行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep hello</span></span><br></pre></td></tr></table></figure>
<p>grep就是从输入的数据中，找到包含hello的行。</p>
<p>另外还有<code>head</code> 和 <code>tail</code> 显示头几行和后几行。</p>
<p>还有一个比较有用的命令 <code>tee</code> ，它好像是一个三通一样。就是给管道分一个叉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /usr/bin | tee ls.txt | grep zip</span></span><br></pre></td></tr></table></figure>
<p>上条命令将 <code>ls /usr/bin</code> 的输出重定向到 <code>ls.txt</code> 中，同时也重定向到 <code>grep</code> 的标准输入中。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【mac问题解决】Mac无法抹掉硬盘问题解决</title>
    <url>/2021/10/18/%E3%80%90mac%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91Mac%E6%97%A0%E6%B3%95%E6%8A%B9%E6%8E%89%E7%A1%AC%E7%9B%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/31672180">解决方案</a></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux学习8】管理进程</title>
    <url>/2022/01/21/%E3%80%90linux%E5%AD%A6%E4%B9%A08%E3%80%91%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>进程就是运行着的程序，我们可以管理运行着的程序，让它们终止、挂起等，这就是管理进程。</p>
<p>在知道咋管理之前，得先知道怎么查看进程。</p>
<span id="more"></span>
<h2 id="I-查看进程"><a href="#I-查看进程" class="headerlink" title="I. 查看进程"></a>I. 查看进程</h2><h3 id="1-ps"><a href="#1-ps" class="headerlink" title="1. ps"></a>1. ps</h3><p>使用<code>ps</code> 命令可以查看进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps <span class="comment">#显示和当前终端会话相关的进程</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps x <span class="comment">#显示所有进程</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps aux <span class="comment">#显示进程更多的信息 即BSD模式显示</span></span></span><br></pre></td></tr></table></figure>
<p>下面介绍输出的信息有啥：</p>
<ul>
<li>PID（process ID）：进程的身份证号</li>
<li>TTY（teletype）：表示进程的控制终端</li>
<li>TIME：表示进程消耗CPU时间总和</li>
<li>STAT（state）：表示进程的状态（状态参数的意思见表一）</li>
</ul>
<p>表一</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121223428006.png" alt="image-20220121223428006"></p>
<p>BSD模式下ps命令输出的列标题</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121223513393.png" alt="image-20220121223513393"></p>
<h3 id="2-top"><a href="#2-top" class="headerlink" title="2. top"></a>2. top</h3><p>前面的<code>ps</code> 仅能静态的显示进程，可是程序run的时候是一个动态的过程，这时可以用 <code>top</code> 来动态显示进程信息，默认状态下3秒更新一次。在动态信息显示的过程中，按 <code>h</code> 显示帮助菜单，<code>q</code> 退出top。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121223838666.png" alt="image-20220121223838666"></p>
<p>上面显示的信息说明：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121223857601.png" alt="image-20220121223857601"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121223910602.png" alt="image-20220121223910602"></p>
<h2 id="II-控制进程"><a href="#II-控制进程" class="headerlink" title="II. 控制进程"></a>II. 控制进程</h2><p>现在我们以一个小程序<code>xlogo</code>为例说明。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xlogo</span></span><br><span class="line"><span class="meta">#</span><span class="bash">此时终端正在执行xlogo，可以按Ctrl+C来终止</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果想要到后台执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xlogo &amp;</span></span><br><span class="line">[1] 18785</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看到，想要<strong>后台</strong>执行，需要在命令后面添加 <code>&amp;</code> 。这时终端返回一个信息 <code>[1]18785</code> ，者是该进程的PID编号，前面的<code>[1]</code> 称为作业控制(job control)，可以理解为shell程序在做作业，正在后台运行。可以通过<code>jobs</code> 来查看当前shell程序的作业情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">jobs</span></span></span><br><span class="line">[1]+ Running 					xlogo $</span><br></pre></td></tr></table></figure>
<p>前面表示作业编号和状态，后面是当时的命令。如果想要将该作业重新放到<strong>前台</strong>。可以用<code>fg</code> 命令，如果仅有一个作业，后面不用加参数，如果有多个作业，要用<code>fg %job_ID</code> 来选择要到前台的作业。如果该作业挂起状态，想在后台运行，就用<code>bg</code> 命令，用法和<code>fg</code> 相同。</p>
<p>如果想要暂停一个进程，可以把它先弄到前台来，然后按<code>Ctrl+Z</code> 暂停。当然还有其他的方式来弄，后面说。</p>
<h2 id="III-杀手非杀手"><a href="#III-杀手非杀手" class="headerlink" title="III. 杀手非杀手"></a>III. 杀手非杀手</h2><p><code>kill</code> 这个命令大家会以为是杀死进程，但是它的作用是发送信号，只不过默认状态下发送的是<code>TERM</code>信号表示终止。进程和操作系统之间是通过信号来通信的。<code>kill</code> 的用法是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> [-signal] PID</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -HUP 18785</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -1 18785</span></span><br></pre></td></tr></table></figure>
<p>可以指定信号的<strong>编号或信号名</strong>来完成发送，后面的<strong>PID编号</strong>也可以是<strong>作业编号</strong>。常用的发送信号如下表所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121225223717.png" alt="image-20220121225223717"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121225446730.png" alt="image-20220121225446730"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220121225458299.png" alt="image-20220121225458299"></p>
<p>想要查看更多的信号，可以使用 <code>kill -l</code> 来查看。</p>
<blockquote>
<p>和文件管理一样，进程也是有所有者的，只有进程的所有者才能给它们的进程使用kill发送信号。</p>
</blockquote>
<p>如果想要一下子给许多的进程发送信号，还可以使用<code>killall</code> 命令，用法为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> killall [-u user] [-signal] name...</span></span><br></pre></td></tr></table></figure>
<p>同理，<code>killall</code> 和 <code>kill</code> 一样需要注意用户权限。</p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux问题解决】双系统grub界面循环无法启动windows</title>
    <url>/2022/02/03/%E3%80%90linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91%E5%8F%8C%E7%B3%BB%E7%BB%9Fgrub%E7%95%8C%E9%9D%A2%E5%BE%AA%E7%8E%AF%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8windows/</url>
    <content><![CDATA[<p><strong>问题描述：</strong></p>
<p>安装双系统，当启动进入grub时，正常显示windows10的选项，但是选择后直接黑屏，然后又返回到grub的界面，如此循环无法进入windows10。<span id="more"></span>此时选择ubuntu选项任然可以进入，进入后直接update-grub还是不起作用。</p>
<p><strong>解决方式：</strong></p>
<p>进入ubuntu后编辑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gedit /boot/grub/grub.cfg</span></span><br></pre></td></tr></table></figure>
<p>找到windows10的启动项（看看有没有这个启动项）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuentry &#x27;Windows 10 (loader) (on /dev/sdXX)&#x27;</span><br></pre></td></tr></table></figure>
<p>然后找到<code>chainloader +1</code>语句，在其后面加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntldr /bootmgr</span><br></pre></td></tr></table></figure>
<p>保存，然后重启计算机，就可以正常进入windows10了。</p>
<p><a href="http://www.4k8k.xyz/article/Joyeishappy/81283135">参考原文链接点这里</a></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【mac问题解决】Mac强制退出软件和打开未验证的软件</title>
    <url>/2021/10/18/%E3%80%90mac%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91Mac%E5%BC%BA%E5%88%B6%E9%80%80%E5%87%BA%E8%BD%AF%E4%BB%B6%E5%92%8C%E6%89%93%E5%BC%80%E6%9C%AA%E9%AA%8C%E8%AF%81%E7%9A%84%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="强制退出"><a href="#强制退出" class="headerlink" title="强制退出"></a>强制退出</h3><p>同时按 <code>option</code> ，<code>command</code> 和 <code>esc</code> 键，即可弹出强退窗口。</p>
<h3 id="无法打开“-”，因为无法验证开发者"><a href="#无法打开“-”，因为无法验证开发者" class="headerlink" title="无法打开“*”，因为无法验证开发者"></a>无法打开“<em>*</em>”，因为无法验证开发者</h3><ol>
<li>打开方达，在右侧菜单栏选择应用程序</li>
<li>找到提示无法验证的应用，右键点击打开</li>
<li>第一次会出现以下提示，继续点击打开即可</li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux问题解决】Ubuntu安装蓝牙驱动</title>
    <url>/2022/02/04/%E3%80%90linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91Ubuntu%E5%AE%89%E8%A3%85%E8%93%9D%E7%89%99%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/shqpzyd/article/details/113682513">参考点这里</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/415475035">还有这里</a></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【mac问题解决】Mac解决因为安全策略问题无法打开软件</title>
    <url>/2021/11/28/%E3%80%90mac%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91Mac%E8%A7%A3%E5%86%B3%E5%9B%A0%E4%B8%BA%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>M1报错问题</strong></p>
<p>无法打开“xxx”，因为“安全策略”已设为“宽松安全性”</p>
<span id="more"></span>
<p><strong>解决方案</strong></p>
<p><strong>1.</strong>关机，长按开机按钮，进入“恢复” App 中，选取“实用工具”&gt;“启动安全性实用工具”。</p>
<p><strong>2.</strong>选择要用来设定安全策略的系统。</p>
<p><strong>3.</strong>如果磁盘已使用文件保险箱加密，请点按“解锁”，输入密码，然后点按“解锁”。</p>
<p><strong>4.</strong>点按“安全策略”。</p>
<p><strong>5.</strong>检查以下安全性选项：</p>
<p>完整安全性：确保只有当前的操作系统或者当前 Apple 信任的签名操作系统软件才能运行。此模式在安装软件时需要网络连接。</p>
<p>降低安全性：允许运行 Apple 信任过的任何版本的签名操作系统软件。</p>
<p><strong>6.</strong>如果需要，请选择“降低安全性”，输入管理员用户名和密码，然后执行以下一项操作：</p>
<p>选择“允许用户管理来自被认可开发者的内核扩展”复选框以允许使用旧版内核扩展的软件进行安装。</p>
<p>选择“允许远程管理内核扩展和软件自动更新”复选框以授权使用移动设备管理 (MDM) 解决方案远程管理旧版内核扩展和软件更新。</p>
<p><strong>7.</strong>点按“好”。</p>
<p><strong>8.</strong>重新启动 Mac 以使更改生效。</p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>【mac问题解决】Word中使用Endnote插件</title>
    <url>/2021/10/18/%E3%80%90mac%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91Word%E4%B8%AD%E4%BD%BF%E7%94%A8Endnote%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在mac中使用Endnote的Word插件。<br><span id="more"></span></p>
<h2 id="一、安装插件"><a href="#一、安装插件" class="headerlink" title="一、安装插件"></a>一、安装插件</h2><ol>
<li>关闭word，打开endnote</li>
<li>EndNote —&gt;Customizer —&gt;勾选Cite While You Write</li>
<li>等待完成</li>
<li>打开word 工具—&gt; 模版与加载项 —&gt; 勾选CWYW</li>
<li>重启word</li>
</ol>
<p>因为新的Macbook air 和Macbook pro使用的是苹果自身的M1芯片，endnote x9和20版本的软件并不兼容这样的芯片，虽然可以用rosetta打开，但是它的word插件确不能被word打开，表现为word运行不了endnote加载项目提示<strong>“Word 无法加载加载项。加载项与此版本的 Word 不兼容。</strong>请向加载项提供者索取更新。(EndNote CWYW Word 16.bundle)”。</p>
<p><a href="https://zhuanlan.zhihu.com/p/359185025">解决方案</a></p>
<h2 id="二、插入与删除参考文献"><a href="#二、插入与删除参考文献" class="headerlink" title="二、插入与删除参考文献"></a>二、插入与删除参考文献</h2><p>插入文献：直接在Word的菜单栏中找到Endnote，点击。然后点击工具栏中insert citation，选择要插入的文献。也可直接在Endnote中复制文献或直接拖拽文献到Word中。</p>
<p>删除文献：在引用处将被引文献的标号删除，然后点击update citation。</p>
<p>引用文献的格式可以在Word中设置。</p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>【opencv1】opencv的数据类型</title>
    <url>/2021/12/02/%E3%80%90opencv1%E3%80%91opencv%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>OpenCV的数据类型分为三类：</p>
<ol>
<li>直接从C++的标准库继承来的，例如int和float等。还包括一些简单的矩阵和数组，代表了一些几何意思，比如点，矩形等。我的理解是就是用标准库提供的容器，然后换了一个名字。</li>
<li>辅助对象，这些对象代表较为抽象的概念。比如，垃圾收集指针类，范围类等。</li>
<li>大型数组类型。例如Mat，这一类我的理解是使用标准库提供的容器进行整合，形成新的类。</li>
</ol>
<span id="more"></span>
<h2 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1.基础类型"></a>1.基础类型</h2><p>在opencv中，基础类型有以下几个：</p>
<ul>
<li><code>cv::Vec&lt;&gt;</code> 向量类</li>
<li><code>cv::Matx&lt;&gt;</code> 矩阵类</li>
<li><code>cv::Point</code> 点类</li>
<li><code>cv::Scalar</code> 四维向量，用于描述颜色，四元数</li>
<li><code>cv::Size</code> 二维向量，用于描述图像大小</li>
<li><code>cv::Rect</code> 四维向量，用于描述矩形</li>
<li><code>cv::RotatedRect</code> 包含一个Point，一个Size和一个浮点数角度，表示非轴对称矩形</li>
<li><code>cv::Complex</code> 复数类</li>
</ul>
<p>上面这几个类型是基础类型。在opencv中通常用 typedef来定义别名。</p>
<p>例如：</p>
<p><code>cv::Point2d</code>，<code>cv::Vec2i</code>，<code>cv::Matx33f</code> </p>
<p>在这里数字表示维度，后面的字母表示数据类型。有{b,w,s,i,f,d}，分别对应{unsigned char,unsigned short,short,int,float,double}。</p>
<p>==下面写对各个类型的介绍：用到时后再写==</p>
<h2 id="2-辅助对象"><a href="#2-辅助对象" class="headerlink" title="2.辅助对象"></a>2.辅助对象</h2><p>辅助对象被用来对控制各种各样的算法和各种在容器上的操作。</p>
<p>==等学到这的时候再写==</p>
<h2 id="3-图像和大型数组"><a href="#3-图像和大型数组" class="headerlink" title="3.图像和大型数组"></a>3.图像和大型数组</h2><p><code>cv::Mat</code>是该类型中的代表，它用来表示一个图像。</p>
<blockquote>
<p>它可以表示任意维度的稠密数组，这个稠密表示数组中的所有元素都有一个存储值。</p>
<p>而稀疏数组是非0的地方才会被存储，这样回更节约内存。但是当数组比较稠密的时候，用稀疏数组来存反而会浪费内存。一个比较常用的使用稀疏数组的例子是用其来存储直方图。</p>
</blockquote>
<p>本节就主要介绍<code>cv::Mat</code></p>
<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1)基本介绍"></a>1)基本介绍</h3><h4 id="Mat的结构是什么样子的？"><a href="#Mat的结构是什么样子的？" class="headerlink" title="Mat的结构是什么样子的？"></a>Mat的结构是什么样子的？</h4><p>Mat是一个类，由两部分组成：</p>
<ul>
<li>矩阵的头（包含矩阵的尺寸、存储方法、存储地址等）</li>
<li>图像数据矩阵</li>
</ul>
<h4 id="Mat存储机制是什么样子的？"><a href="#Mat存储机制是什么样子的？" class="headerlink" title="Mat存储机制是什么样子的？"></a>Mat存储机制是什么样子的？</h4><p><strong>矩阵那么大，经常复制太占用资源了！</strong></p>
<p>opencv引用计数机制来管理图像的存储，让给个Mat对象都有自己的信息头，但各个对象共享同一个矩阵，通过矩阵指针来进行访问矩阵。拷贝构造函数只复制信息头和矩阵指针。这样就可以避免频繁的复制整个矩阵了。</p>
<p>如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat A,C;</span><br><span class="line">A=<span class="built_in">imread</span>(<span class="string">&quot;image.png&quot;</span>);</span><br><span class="line"><span class="function">Mat <span class="title">B</span><span class="params">(A)</span></span>;</span><br><span class="line">C=A;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，A B C三个对象都指向同一个数据矩阵，当通过其中一个对象修改数据矩阵后，通过显示这三个对象的图像，就都发生了变化。</p>
<blockquote>
<p>当建立新对象，并用已有的对象为其复制，实质上就是改变了访问原图像数据矩阵的途径而已。</p>
</blockquote>
<p>另外，也可以创建新的对象，使其仅指向感兴趣的区域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">D</span><span class="params">(A,Rect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>))</span></span>;<span class="comment">//框出一个矩形区域</span></span><br></pre></td></tr></table></figure>
<h4 id="数据矩阵由谁来清理？"><a href="#数据矩阵由谁来清理？" class="headerlink" title="数据矩阵由谁来清理？"></a>数据矩阵由谁来清理？</h4><p>在这个数据矩阵多一个指向者的时候，它的引用就会加一，当一个指向它的对象被释放后，它的引用就会减一，当引用数为0时，那么数据矩阵就会被释放。</p>
<h4 id="如何才能复制一份数据矩阵？"><a href="#如何才能复制一份数据矩阵？" class="headerlink" title="如何才能复制一份数据矩阵？"></a>如何才能复制一份数据矩阵？</h4><p>可以使用对象的clone()函数或copyTo()函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat F=A.<span class="built_in">clone</span>();</span><br><span class="line">Mat G;</span><br><span class="line">A.<span class="built_in">copyTo</span>(G);</span><br></pre></td></tr></table></figure>
<h3 id="2-像素值的存储方式"><a href="#2-像素值的存储方式" class="headerlink" title="2)像素值的存储方式"></a>2)像素值的存储方式</h3><p>我们知道了图像是以什么样的一种方式存在计算机中，那么每个像素或者说矩阵中的每一个元素的值是怎么确定的呢？</p>
<h4 id="什么是颜色空间？"><a href="#什么是颜色空间？" class="headerlink" title="什么是颜色空间？"></a>什么是颜色空间？</h4><p>首先我们要知道颜色空间的概念。</p>
<p>颜色空间就是给定了你一定的颜色，如何通过组合这几个颜色来表示我们想要的颜色。这就是根据颜色空间对图像进行编码。</p>
<p>例如：给定了一个颜色空间，红黄蓝。当我们想要表示一个贼红的东西，我们就可以用向量(1,0,0)来表示。</p>
<p>无论哪种颜色空间，都把颜色分成三个或四个基元素。</p>
<p><strong>图像的颜色空间主要有以下几种：</strong></p>
<ul>
<li>RGB：基色为红绿蓝</li>
<li>RGBA：在RGB的基础上，加上一个透明度通道</li>
<li>HSV和HLS：把颜色分解成色调、饱和度和亮度/明度。</li>
<li>YCrCb ==我不知道是啥==</li>
<li>CIE L*a*b* ==我也不知道是啥==</li>
</ul>
<h4 id="什么是像素值定义域？"><a href="#什么是像素值定义域？" class="headerlink" title="什么是像素值定义域？"></a>什么是像素值定义域？</h4><p>还是上面的例子，在红黄蓝空间上，我们用(1,0,0)来表示贼红。但是这样表示的颜色数量太少，因为最红的值是1，这就说明我们只用了一bit来表示 一个颜色占的分量。那么如果用1byte，就是8个bit来表示最红，浅红，淡红都可以表示出来了。所以就用8bit来表示一个颜色通道。二进制8位最大值对应的10进制的值为255，所以我们就可以用(255,0,0)来表示贼红。这样就可以表示出很多种颜色了。</p>
<p>这就是像素值的定义域，它取决于存储它的元素的数据类型。最小的数据类型为char，占1个byte，可以是有符号(-127—127)，也可以是无符号(0—255)。还可以使用float(4个byte)和double(8个byte)来表示。可以让颜色粒度更低。</p>
<h4 id="什么是图像深度？"><a href="#什么是图像深度？" class="headerlink" title="什么是图像深度？"></a><strong>什么是图像深度？</strong></h4><p>另外，在opencv中，经常会说到图像的深度，这个和像素的定义域的意思差不多，图像的深度是指描述一个像素值所占的位数。例如：int型的深度是32。</p>
<h4 id="opencv中封装了图像数据类型！"><a href="#opencv中封装了图像数据类型！" class="headerlink" title="opencv中封装了图像数据类型！"></a>opencv中封装了图像数据类型！</h4><p>在opencv中，图像的数据类型和通道数已经被封装好了，命名规则如下：</p>
<p>类型的命名为：<code>CV_&#123;8U,16S,16U,32S,32F,64F&#125;C&#123;1,2,3&#125;</code></p>
<p>例如：<code>CV_8UC1</code>表示8位unsigned char型1通道的图像。</p>
<h3 id="3-显式创建Mat对象"><a href="#3-显式创建Mat对象" class="headerlink" title="3)显式创建Mat对象"></a>3)显式创建Mat对象</h3><p>==Mat的构造函数 ，用时候再学==</p>
<h3 id="4-操作Mat对象中的数据元素"><a href="#4-操作Mat对象中的数据元素" class="headerlink" title="4)操作Mat对象中的数据元素"></a>4)操作Mat对象中的数据元素</h3><p>有三种方法可以获得图像数据的每一个元素，完成对其进行操作。</p>
<p>我们画一个图来说明图像数据矩阵的样子。图像数据矩阵是一个二维的数组。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000123.png" alt="Snipaste_2021-11-15_09-54-57"></p>
<p>如果是三通道的，那么每一个元素存的是一个三维的数组，那么图像数组真实的列数=图像矩阵列数 * 图像的通道数。</p>
<h4 id="（1）使用at成员函数"><a href="#（1）使用at成员函数" class="headerlink" title="（1）使用at成员函数"></a>（1）使用at成员函数</h4><p><code>at&lt;&gt;()</code>可以直接返回某一个元素的值，模板参数需要指定好元素中的数据类型。例如图像是CV_8UC3，那么调用该函数的时候就要写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vec3b element = img.at&lt;Vec3b&gt;(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p> 这表示第1行的第1个元素，是一个3维向量。</p>
<p>下面是<code>at&lt;&gt;()</code>支持的用法</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000148.png" alt="image-20211115101040117"></p>
<p>如果想要遍历所有的元素，那么就需要通过多级嵌套循环来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">800</span>,<span class="number">600</span>,CV_8UC3)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n_r=img.rows;</span><br><span class="line"><span class="keyword">int</span> n_c=img.cols;</span><br><span class="line"><span class="comment">//输出该图像的每一个元素</span></span><br><span class="line">Vec3b element;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;n_c;ii++)</span><br><span class="line">    &#123;</span><br><span class="line">        element[<span class="number">0</span>]=img.at&lt;Vec3b&gt;(i,ii)[<span class="number">0</span>];</span><br><span class="line">        element[<span class="number">1</span>]=img.at&lt;Vec3b&gt;(i,ii)[<span class="number">1</span>];</span><br><span class="line">        element[<span class="number">2</span>]=img.at&lt;Vec3b&gt;(i,ii)[<span class="number">2</span>];</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;行第&quot;</span>&lt;&lt;ii&lt;&lt;<span class="string">&quot;列的元素为&quot;</span>&lt;&lt;element[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>element[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;element[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以通过该种方式操作像素值</span></span><br><span class="line">img.at&lt;uchar&gt;(<span class="number">100</span>,<span class="number">100</span>)[<span class="number">0</span>]=<span class="number">50</span>;</span><br></pre></td></tr></table></figure>
<h4 id="（2）使用C语言风格的指针"><a href="#（2）使用C语言风格的指针" class="headerlink" title="（2）使用C语言风格的指针"></a>（2）使用C语言风格的指针</h4><p>还有另外的一个模板成员函数<code>ptr&lt;&gt;()</code> ，该函数返回的是某一行的指针。通过这种方法获取数组的元素是最快的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vec3b * pointer1 = img.ptr&lt;Vec3b&gt;(<span class="number">0</span>);<span class="comment">//返回的是第1行的指针(第一行数组的指针)</span></span><br><span class="line"></span><br><span class="line">Vec3b a =pointer1[<span class="number">0</span>];<span class="comment">//指第1行的第1个元素</span></span><br><span class="line">Vec3b b=img.ptr&lt;Vec3b&gt;(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//返回的是第1行第2个元素</span></span><br><span class="line">Vec3b c=img.ptr&lt;Vec3b&gt;(<span class="number">0</span>)[<span class="number">2</span>];<span class="comment">//返回的是第1行第3个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********还有另一种情况************/</span></span><br><span class="line">uchar * pointer3=img.ptr&lt;uchar&gt;(<span class="number">0</span>);<span class="comment">//返回第1行的指针</span></span><br><span class="line">uchar d=pointer3[<span class="number">0</span>];<span class="comment">//表示第1行第1个元素的第一个通道</span></span><br><span class="line">uchar e=pointer3[<span class="number">1</span>];<span class="comment">//表示第1行第1个元素的第二个通道</span></span><br><span class="line">uchar f=pointer3[<span class="number">3</span>];<span class="comment">//表示第1行第2个元素的第一个通道</span></span><br></pre></td></tr></table></figure>
<p>上面模板参数Vec3b和uchar的区别，就是指针的区别，Vec3b的指针[1]，一次跳过3个字节地址。uchar的指针[1]，一次跳过1个字节地址。</p>
<blockquote>
<p>图像的同一行的所有元素的内存地址是连续的，但是不同行之间的内存地址不一定是连续的，可以使用<code>isContinuous()</code>来判断。</p>
</blockquote>
<h4 id="（3）使用iterator"><a href="#（3）使用iterator" class="headerlink" title="（3）使用iterator"></a>（3）使用iterator</h4><p>Mat的iterator有两种：</p>
<ul>
<li><code>cv::MatIterator&lt;&gt;</code> non-const array iterator</li>
<li><code>cv::MatConstIterator&lt;&gt;</code> const array iterator</li>
</ul>
<p>iterator是一个更智能的指针，它不用我们来考虑各个数据的内存地址是否连续。它的指向是数组中的每一个元素。</p>
<blockquote>
<p>non-const array iterator 和 const array iterator 应该就是该iterator可不可以操作图像，如果是const array iterator，就不可以操作图像。(？？？)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">800</span>,<span class="number">600</span>,CV_32FC3)</span></span>;</span><br><span class="line">MatConstIterator&lt;Vec3f&gt; it=img.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!=img.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;(*it)[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;(*it)[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;(*it)[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-成块操作数据元素"><a href="#5-成块操作数据元素" class="headerlink" title="5)成块操作数据元素"></a>5)成块操作数据元素</h3><p>通过Mat的成员函数可以获得其子区域的数据。还有两个运算符重载函数。</p>
<blockquote>
<p>在做这些操作的时候，不是把数据矩阵复制到mat对象中，而是为mat对象建立一个新的header来指向所选的区域，如果修改这个对象所指的数据，那么原来的数据也会变动。</p>
</blockquote>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000155.png" alt="image-20211115115344641"></p>
<p><code>diag()</code> 提取对角线上的元素</p>
<ul>
<li>参数0，提取对角线上的元素</li>
<li>参数为正，提取上三角元素</li>
<li>参数为负，提取下三角元素</li>
</ul>
<h3 id="6-矩阵元素运算表达式"><a href="#6-矩阵元素运算表达式" class="headerlink" title="6)矩阵元素运算表达式"></a>6)矩阵元素运算表达式</h3><p>可以直接通过运算符对矩阵进行操作。</p>
<p>这里要注意，=赋值操作，例如m2=m1，这表示对m1所指的数据增加了一个引用m1和m2共享同一份数据，而m2=m1+m0表示m2指向一份新的数据，这个数据的值由m1和m0相加得到。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000202.png" alt="image-20211115123615830"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000241.png" alt="image-20211115123635416"></p>
<h3 id="7-Saturation-casting"><a href="#7-Saturation-casting" class="headerlink" title="7)Saturation casting"></a>7)Saturation casting</h3><p>当我们的图像在处理时，有可能会发生内存溢出现象。比如说我的图像原来是uchar型的，当我们操作的时候出现了负数，这就不允许了。所以我们需要加上一个饱和过滤的函数，来把这些不符合的给滤掉。</p>
<p>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uchar&amp; Vxy = m0.at&lt;uchar&gt;( y, x );</span><br><span class="line">Vxy = cv::saturate_cast&lt;uchar&gt;((Vxy<span class="number">-128</span>)*<span class="number">2</span> + <span class="number">128</span>);</span><br></pre></td></tr></table></figure>
<h3 id="8-Mat的成员函数们"><a href="#8-Mat的成员函数们" class="headerlink" title="8)Mat的成员函数们"></a>8)Mat的成员函数们</h3><p>Mat中还有很多的成员函数可供使用。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000212.png" alt="image-20211115125610273"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000338.png" alt="image-20211115125627092"></p>
]]></content>
      <categories>
        <category>软件编程</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【linux问题解决】Ubuntu更换软件源</title>
    <url>/2022/02/04/%E3%80%90linux%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E3%80%91Ubuntu%E6%9B%B4%E6%8D%A2%E8%BD%AF%E4%BB%B6%E6%BA%90/</url>
    <content><![CDATA[<p>国内软件源：<strong><a href="http://wiki.ubuntu.org.cn/模板:18.04source">点我查看</a></strong></p>
<span id="more"></span>
<ol>
<li><p>首先备份一下软件源列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bcakup</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后更改软件源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>sources.list</code>文件中，粘贴软件源地址(Ubuntu18.04为例)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 阿里云源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">##測試版源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># 源碼</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">##測試版源</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 清华大学源</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">##測試版源</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># 源碼</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">##測試版源</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【数字图像处理2】人类视觉系统</title>
    <url>/2021/12/19/%E3%80%90%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%862%E3%80%91%E4%BA%BA%E7%B1%BB%E8%A7%86%E8%A7%89%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>在学习数字图像处理之前，先了解一下人类的视觉系统。</p>
<span id="more"></span>
<h3 id="1-眼睛的结构"><a href="#1-眼睛的结构" class="headerlink" title="1.眼睛的结构"></a>1.眼睛的结构</h3><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222011221.png" alt="image-20211222011220881"></p>
<p>人眼结构可以分为三层，从外到内为：</p>
<ul>
<li>第一层：角膜+巩膜外壳（Cornea+Sclera)</li>
<li>第二层：脉络膜（Choroid）</li>
<li>第三层：视网膜（Retina）</li>
</ul>
<p>这三层组成了眼球结构，在最内层的视网膜上布满了感受光线的细胞。这些细胞分为：</p>
<ul>
<li>视锥细胞（Cone）：在明亮环境下，对颜色十分敏感。用于亮视觉。</li>
<li>视杆细胞（Rod）：对颜色不敏感，仅在暗光条件下感受光照强度。用于暗视觉。</li>
</ul>
<p>在视网膜上有一个直径约1.5mm的圆形凹陷处，在该区域布满了视锥细胞。在该区域周围则布满了视杆细胞，视锥细胞和视杆细胞的分布情况如上图右边所示。</p>
<p>眼球前部的晶状体（Len）相当于相机中的透镜。在相机中，透镜的焦距固定，通过改变透镜到成像平面的距离来使不同距离处的物体所反射的光线投射到成像平面上。在人眼中，晶状体的焦距可通过周围肌肉的控制改变（焦距的变化范围大约是14mm到17mm），而晶状体到视网膜的距离是固定不变的，这个距离大约为17mm。</p>
<h3 id="2-人眼图像的形成"><a href="#2-人眼图像的形成" class="headerlink" title="2.人眼图像的形成"></a>2.人眼图像的形成</h3><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222023735.png" alt="image-20211222023735357"></p>
<p>人眼的成像系统可以看做是一个小孔成像模型，如上图所示。</p>
<p>当光线投射到视网膜上后，视网膜上的感受细胞将根据感受到的光强度（intensity）生成电信号，通过神经传入到大脑中，然后再通过大脑实现理解。</p>
<blockquote>
<p>补充：视锥细胞有三种，分别可以感受红蓝绿三色光的光强，这和相机中的传感器一样，通过三色光的强度不同来分辨不同的颜色。</p>
</blockquote>
<h3 id="3-亮适应（Brightness-Adaptation）"><a href="#3-亮适应（Brightness-Adaptation）" class="headerlink" title="3.亮适应（Brightness Adaptation）"></a>3.亮适应（Brightness Adaptation）</h3><p>那么人眼可以感受到的光强范围是多少呢？从最暗到最亮的范围大约是 $10^{10}$ ，根据一些实验结果显示，人们主观感受到的亮度（subjective brightness）是实际投射到视网膜上的光强的对数函数，如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222025514.png" alt="image-20211222025514601"></p>
<p>但是人眼并不能同时感受这么大范围的光照强度变化，而仅仅感受到一小部分范围的光强变化。例如在夜晚我们关灯后，我们看到的是一片漆黑，并不能看出桌子在哪，床在哪，但过了一会虽然没有灯，我们还是可以看见一些物体的轮廓，这就是人眼的适应能力，称为Brightness Adaptation。当环境的光强在上图的点 $B_a$ 时，人眼所能感受的光强范围为交叉的曲线所示，视觉系统当前的适应范围称为Brightness Adaptation Level，只要是低于 $B_b$ 处的光强，人主观感受到的光强就都一样，都是该范围中的最低值。而当环境光强提高时，Brightness Adaptation Level会升高，$B_a$ 也会到一个新的位置。</p>
<h3 id="4-光强分辨能力"><a href="#4-光强分辨能力" class="headerlink" title="4.光强分辨能力"></a>4.光强分辨能力</h3><p>下面我们来介绍一下当光强变化多少时，人们才能感受到。通过实验发现这取决于周围环境的光强。</p>
<p>有这样的一个实验，在一个矩形区域A中设置一个圆形区域B，A区域的光强为 $I$ ，B区域的光强为 $I+\Delta I$ 。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222032737.png" alt="image-20211222032737793"></p>
<p>通过不断增加 $\Delta I$ ，让观察者来观察，当观察者发现变化时记录下来 $\Delta I /I$ 。$\Delta I /I$ 和环境光强的关系如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222032800.png" alt="image-20211222032800529"></p>
<p>$\Delta I /I$ 较大表示分辨能力较弱，可以看出当环境的光强较低时，分辨能力较弱，而环境光强较高时，分辨能力较强。图中两段曲线说明了在暗光环境下，是由视杆细胞来感受光线的，视杆细胞对光强的辨别能力较弱。而在强光环境下，由视锥细胞来感受光线，视锥细胞对光强变化感受灵敏。</p>
<h3 id="5-人眼视觉系统的另外一些特点"><a href="#5-人眼视觉系统的另外一些特点" class="headerlink" title="5.人眼视觉系统的另外一些特点"></a>5.人眼视觉系统的另外一些特点</h3><p>之前我们说到，人主观感受到的光强是实际光强的对数函数，但事实远非如此，这只是一种宏观上的近似。</p>
<p>首先我们看下面这幅图像：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222033725.png" alt="image-20211222033725163"></p>
<p>主观感受到的光强在不同强度的边界上会倾向于有一些”超调“或”衰减“。机理暂时不明确。</p>
<p>再看下面这幅图像：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222034137.png" alt="image-20211222034137201"></p>
<p>中间的正方形的灰度值都是一样的，但是当背景较暗时，就感觉稍微亮一点。这也说明了主观感受到的光强还和环境的光强有关。</p>
<p>人类视觉系统还会有一种叫光幻觉（optical illusions）的现象。如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222034647.png" alt="image-20211222034647771"></p>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【矩阵】线性代数可视化学习笔记</title>
    <url>/2021/10/18/%E3%80%90%E7%9F%A9%E9%98%B5%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>3Blue1Brown 线代课程学习笔记，受益匪浅。<br><span id="more"></span></p>
<h1 id="线性代数可视化"><a href="#线性代数可视化" class="headerlink" title="线性代数可视化"></a>线性代数可视化</h1><p><a href="https://www.bilibili.com/video/BV1ib411t7YR?p=1">参考</a></p>
<h2 id="1-向量是什么"><a href="#1-向量是什么" class="headerlink" title="1.向量是什么"></a>1.向量是什么</h2><p>对于向量的理解，可以分为三个层面：</p>
<ul>
<li><p><strong>物理学家眼中</strong>：向量是一个空间中箭头，它只包括长度和方向两个信息，而与其所在的空间位置无关</p>
</li>
<li><p><strong>计算机专业眼中</strong>：向量是一个有序数组，这个有序数组可以表示物理学家眼中的向量在空间中的坐标，而且这个向量通常是以坐标系原点为起点的。为了区分于点的坐标，向量通常竖着写</p>
</li>
<li><p><strong>数学家眼中</strong>：向量可以是任何东西，只要能保证两个向量相加和数与向量相乘满足一定的条件即可</p>
</li>
</ul>
<p>通过建立坐标系，可以使一个向量与有序的数组相联系，每一个数组对应一个向量，每一个向量也可以用数组来表示，这就为物理学家在描述向量时提供了一种数学语言</p>
<p><strong>向量两个最基本的运算：</strong></p>
<ul>
<li><p>向量加法：遵循三角形法则 $\longrightarrow$ 用数组描述的向量通过对应元素相加可以很好的描述该法则</p>
</li>
<li><p>向量的数乘：表示对向量的伸长与缩短 </p>
</li>
</ul>
<h2 id="2-线性组合、基与张成空间"><a href="#2-线性组合、基与张成空间" class="headerlink" title="2.线性组合、基与张成空间"></a>2.线性组合、基与张成空间</h2><p>在标准的坐标系中，有两个特殊的向量，单位向量 $\hat i$ 和 $\hat j$ ，对于多维空间也同样。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015953.png" alt="image-20210715005154764" style="zoom:67%;" /></p>
<p>它们合起来称作坐标系的基，当把坐标中的每一个元素看作是标量时，每一个基向量就是这些标量所缩放的向量</p>
<h3 id="·-什么是线性组合"><a href="#·-什么是线性组合" class="headerlink" title="· 什么是线性组合"></a>· 什么是线性组合</h3><p>多个向量的数乘之和称为这些向量的线性组合</p>
<h3 id="·-向量张成的空间"><a href="#·-向量张成的空间" class="headerlink" title="· 向量张成的空间"></a>· 向量张成的空间</h3><p>给定一组向量，通过该组向量的线性组合生成的<strong>向量的集合</strong>，称为该组向量==张成的空间==</p>
<p>以二维空间为例，给定向量 $\vec w$ 和 $\vec v$ ，有以下三种情况：</p>
<ol>
<li><p>当$\vec w$ 和 $\vec v$ 不共线时，所张成的空间为二维平面，也就是二维空间中的任意向量都可以由这两个向量的线性组合得到</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015958.png" alt="image-20210715035555651" style="zoom: 33%;" /></p>
</li>
<li><p>当$\vec w$ 和 $\vec v$ 共线时，所张成的空间为一条直线，仅能表示终点在该直线上的向量</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020002.png" alt="image-20210715040223112" style="zoom:50%;" /></p>
</li>
<li><p>当$\vec w$ 和 $\vec v$ 都为0向量时，所张成的空间为一点，仅能表示0向量</p>
</li>
</ol>
<p><strong>同样对于我们常用的三维空间，当仅有两个不共面的向量时，这两个向量所张成的空间为一个平面</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020007.png" alt="image-20210715040537951" style="zoom: 20%;" /></p>
<h3 id="·-线性相关与线性无关"><a href="#·-线性相关与线性无关" class="headerlink" title="· 线性相关与线性无关"></a>· 线性相关与线性无关</h3><p>从上面的表述中，便可以得到<strong>线性相关</strong>的定义：当一组向量中，其中一个向量处在其他向量所张成的空间中（这个向量可以由其他的向量线性组合表示出来），那么这一组向量就是线性相关的</p>
<p>而<strong>线性无关</strong>的定义与它正好相反：一组向量中，任何一个向量都不处在其他向量所张成的空间中（任何一个向量不可以由其他向量线性组合表示出来）</p>
<h3 id="·-空间中的一组基"><a href="#·-空间中的一组基" class="headerlink" title="· 空间中的一组基"></a>· 空间中的一组基</h3><p>某向量空间的一组基是张成该空间的一个线性无关的向量集合</p>
<h2 id="3-矩阵与线性变换"><a href="#3-矩阵与线性变换" class="headerlink" title="3.矩阵与线性变换"></a>3.矩阵与线性变换</h2><h3 id="·-首先需要知道的"><a href="#·-首先需要知道的" class="headerlink" title="· 首先需要知道的"></a>· 首先需要知道的</h3><p>我们之前所说向量的时候，当有基向量存在时，可以用一个数组也就是坐标来表示一个向量，现在我们定义一个永远不变的坐标系和基向量，这个坐标系的x轴和y轴垂直，且基向量是与x轴和y轴正方向相同的单位向量，暂且我们就称坐标系和基向量为<strong>永不变坐标系和永不变基向量</strong>，之后的所有向量或坐标系的基的描述都是在这个永不变基的基础上进行的</p>
<h3 id="·-线性变换"><a href="#·-线性变换" class="headerlink" title="· 线性变换"></a>· 线性变换</h3><p>变换实际上是函数的另一种说法，函数的作用是输入一个数，输出一个数；在线性代数中，变换的输入是一个向量，输出也是一个向量</p>
<p><strong>线性变换</strong>是变换的一种特殊形式，它有两个特点：</p>
<ul>
<li><p>直线在线性变换后，仍是直线</p>
</li>
<li><p>原点必须保持不变</p>
</li>
</ul>
<p>那么如何用数学语言来描述线性变换呢？答案就是用矩阵来描述</p>
<h3 id="·-矩阵"><a href="#·-矩阵" class="headerlink" title="· 矩阵"></a>· 矩阵</h3><p>矩阵就是一种数学语言，来描述线性变换，矩阵的每一列记录基向量在线性变换后的坐标</p>
<p>以二维空间为例：</p>
<script type="math/tex; mode=display">
\vec v = -1\vec i + 2\vec j\\
Transformed \ \vec v=-1(Transformed \ \vec i)+2(Transformed\ \vec j)</script><p>当经过一次线性变换后，如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020013.png" alt="image-20210715034732752" style="zoom:67%;" /></p>
<script type="math/tex; mode=display">
[Transformed\ \vec i ,Transformed\ \vec j]=\left[\begin{array}{ll}
3 & 1 \\
0 & 2
\end{array}\right]</script><script type="math/tex; mode=display">
Transformed\ \vec v=
-1\left[\begin{array}{l}
3 \\
0
\end{array}\right]+2\left[\begin{array}{l}
1 \\
2
\end{array}\right]=\left[\begin{array}{ll}
3&1\\
0&2
\end{array}\right]\left[\begin{array}{l}
\ -1\\
\  \ 2\end{array}\right]
=\left[\begin{array}{l}
-1  \\
\ \ 4 
\end{array}\right]</script><p><strong>这也就定义了矩阵和向量的乘法</strong>，矩阵乘以向量，就是对该向量的一个线性变换</p>
<p>当变换后的两个基向量线性相关时，由这两个向量所张成的空间就变成了一条线，而原来的向量就被变换到这个空间上，也就是变换后的向量的终点在一条直线上</p>
<blockquote>
<p>总之，线性变换就是对向量的变换，对向量的变换的方法是对描述该向量的基进行变换，因此线性变换也是操纵空间的一种手段</p>
</blockquote>
<p>那么当有许多个矩阵乘以一个向量的时候，它的几何意义又是什么呢？</p>
<h3 id="·-复合变换与矩阵乘法"><a href="#·-复合变换与矩阵乘法" class="headerlink" title="· 复合变换与矩阵乘法"></a>· 复合变换与矩阵乘法</h3><p>矩阵A、B分别代表着线性变换1和2，AB代表着先进行线性变换2，然后再进行线性变换1（注意这里是先2后1），令AB=C，那么C就代表着先进行2再进行1的一个复合变换，也可以把C当作是一次独立的变换，它的效果和先2再1的效果相同</p>
<p>另外，AB $\neq$ BA，也就是说先进行2再进行1和先进行1再进行2的效果是不同的</p>
<blockquote>
<p>前面所说的线性变换理解成是一个处理向量的函数，现在从另一个角度来总结一下，线性变换用矩阵来描述，而矩阵的列向量表示线性变换后基向量的坐标，对一个向量进行线性变换，就是先对基向量进行线性变换，然后用这个向量的坐标对变换后的基向量进行线性组合，最终得到变换后的向量。因为基向量可以描述一个空间，因此基向量变了，其所对应的空间也发生了变化</p>
</blockquote>
<h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4.行列式"></a>4.行列式</h2><p>上节说过，线性变换是操纵空间的一种手段，那么如何刻画空间变化了多少呢，这就需要请出行列式了，行列式就是用来描述空间变化的多少</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020020.png" alt="image-20210715053137633" style="zoom:53%;" /></p>
<p>下面以二维空间为例：</p>
<p>我们在坐标系中用网格线来描述这个空间的形态，在标准坐标系中，绿色箭头代表i向量，红色箭头代表j向量，此时向量i和j所围成的区域是一个正方形，其面积为1</p>
<p>当进行线性变换后，基向量的方向和长度都发生了变化，如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020024.png" alt="image-20210715053620420" style="zoom:50%;" /></p>
<p>那么此时由基向量i和j所围成的区域也发生了变化，变成了一个平行四边形，而该区域的面积等于矩阵的行列式</p>
<blockquote>
<p>矩阵的行列式是描述其线性变换所对空间变化的量度</p>
</blockquote>
<p>当行列式为0时，表示这个平面被压缩成了一条线，<strong>而0矩阵表示把平面压缩成一个点</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020028.png" alt="image-20210715054036323" style="zoom:50%;" /></p>
<p>当行列式为负时，表示这个平面发生了反转</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020030.png" alt="image-20210715054301501" style="zoom:50%;" /></p>
<p>注意：原来绿色的基向量在红色基向量的右边，此时发生了平面翻转</p>
<p>三维空间中，矩阵的行列式表示变换后基向量所围成空间区域的体积，当行列式为0时，表示该变换将三维空间压缩成一个平面或一条直线又或是一个点（这在后面会引出秩的用法）。更多维空间的道理是一样的，这里就不过多赘述</p>
<h2 id="5-逆矩阵、列空间、秩和零空间"><a href="#5-逆矩阵、列空间、秩和零空间" class="headerlink" title="5.逆矩阵、列空间、秩和零空间"></a>5.逆矩阵、列空间、秩和零空间</h2><p>线性代数的用处很多，其中的一个用处是解线性方程组</p>
<p>方程组的求解和之前所讲的行列式和矩阵以及线性变换密切相关</p>
<p>例如我们现在有一个方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
1x+2y+3z=5\\
3x+8y+7z=6\\
0x+3y+6z=0
\end{cases}</script><p>这是一个三阶线性方程组，因为它与矩阵和向量的乘法很像，所以可以写成矩阵的形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
1&2&3\\
3&8&7\\
0&3&6
\end{array}\right]
\left[\begin{array}{l}
x\\
y\\
z
\end{array}\right]=\left[\begin{array}{l}
5\\
6\\
0
\end{array}\right]</script><p>即：</p>
<script type="math/tex; mode=display">
A\vec x=\vec v</script><p>上述式子已知 $\vec v$ ，A矩阵表示一个线性变换，如若求 $\vec x$ ,则只需将A矩阵所表示的线性变换的逆变换作用到 $\vec v$ 上，那么是不是什么时候都可以用这种方法呢？</p>
<h3 id="·矩阵的逆"><a href="#·矩阵的逆" class="headerlink" title="·矩阵的逆"></a>·矩阵的逆</h3><p>矩阵的逆表示矩阵线性变换所对应的逆变换，如果矩阵A的行列式不等于0，那么矩阵A是可逆的</p>
<p>之前的方程组的解为： $\vec x = A^{-1}\vec v$</p>
<p>上面说到矩阵的逆表示逆变换，所以当进行一次变换再进行一次逆变换等同于没有变化</p>
<script type="math/tex; mode=display">
A^{-1}A=AA^{-1}=I</script><p><strong>但是当矩阵的行列式为0时</strong>，矩阵的逆不存在。背后的几何意义是线性变换将多维空间变换为低维空间，如果想找到<strong>一个</strong>低维空间还原成高维空间的逆变换，是得不到一个确定的变换的，因为有一维或多维的缺失，所以这个变换可以有任意多种形式</p>
<p>再回到我们的方程组，当矩阵的行列式为0时，解是可能存在的，这分为两种情况：</p>
<ul>
<li>一种是当 $\vec v$ 向量在A所压缩的空间上时，解存在</li>
<li>另一种是 $\vec v$ 向量在A所压缩的空间外时，无解</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020036.png" alt="image-20210715085801043" style="zoom: 33%;" /></p>
<h3 id="·矩阵的秩"><a href="#·矩阵的秩" class="headerlink" title="·矩阵的秩"></a>·矩阵的秩</h3><p>可以发现，虽然原空间通过变换后，变成一个低维的空间，此时都会有无解的情况发生，但无解情况的出现的难易程度是不一样的。例如当三维空间变换成二维空间时，是一个平面，只要 $\vec v$ 在这个平面上，解存在。但是当变换成一维空间也就是一条线时，只有 $\vec v$ 在这条线上时，解存在。虽然上面两种情况的A矩阵的行列式都为0，但是它们出现无解的情况是不同的，这时就要引出秩的概念</p>
<p><strong>秩</strong>表示变换后空间的维数，例如三维矩阵的秩最大为3，它表示基向量可以张成整个三维空间，但是当矩阵的秩为2时，空间被压缩了，此时表示基向量只能张成二维空间，但是它没有秩为1的压缩情况严重</p>
<h3 id="·列空间"><a href="#·列空间" class="headerlink" title="·列空间"></a>·列空间</h3><p>矩阵的列向量所张成的空间即为列空间，当 $ \vec x$ 表示任意的向量时，$A\vec x$ 就是矩阵A的列空间</p>
<p>关于秩更准确的定义：矩阵秩表示矩阵列空间的维数</p>
<p><strong>当秩等于矩阵的列时，意味着它达到了它所能达到的最大值，此时叫作满秩</strong></p>
<p>0向量一定包含在列空间中，因为线性变换不改变原点的位置，也就是 $A\vec0=\vec 0$ </p>
<p><strong>对于一个满秩变换来说，唯一能在变换后落在原点的向量就是0向量本身。但是对于一个非满秩的矩阵，它将空间压缩到一个低维的空间，也就是说有一系列向量在变换后被压缩到原点。</strong>例如对于原二维的空间，当进行压缩到一维空间的变换时，会使原二维空间中某一方向直线上的所有的向量都压缩到原点。再如原三维空间，压缩到一个二维空间时，也会使原三维空间中某一方向直线上所有的向量压缩到原点，当压缩到一个一维空间时，会使原三维空间中过原点的某一平面上的所有向量压缩到原点。</p>
<h3 id="·零空间-核空间"><a href="#·零空间-核空间" class="headerlink" title="·零空间/核空间"></a>·零空间/核空间</h3><p>变换后被压缩到原点的向量的集合，叫作矩阵的零空间或者核空间</p>
<p>==被压缩空间的维数==就是零空间的维数。例如三维空间中的一个向量经过一个方阵的线性变换后，被限制在二维平面上，那么该方阵的零空间维数为1，如果是将该向量变换成一个点，那么该方阵的零空间维数为2。零空间的维数就是表示方阵可以将几维的空间压缩到原点。也可以看作是方程 $A\vec x =0$​​​的解的情况，首先A得为方阵，当A的零空间为0时，也就是A满秩，那么只有零向量是该方程的解。如果A的零空间为2时，那么解向量的维数为2。</p>
<h3 id="·非方阵"><a href="#·非方阵" class="headerlink" title="·非方阵"></a>·非方阵</h3><p>非方阵的几何意义和之前的方阵稍稍有些不同，先来说之前的方阵，方阵表示将一个向量进行变换，这些变换有旋转这个向量，拉伸压缩这个向量，无论怎么变换这个向量，这个向量都处于原空间中，即变换前是一个n维的向量，变换后还是n维的向量。举一个例子，对于三维空间中的一个向量，当矩阵A的秩为2时，表示将这个向量压缩到一个二维的平面中，尽管是压缩到二维平面中，只是把这个向量限制在二维平面上，但这个向量仍是三维空间中的向量。</p>
<p>而非方阵就得用另一种方式来描述，和之前所提及的函数一样，非方阵可以看作是一个映射，输入一个m维的向量，映射出一个n维的向量，这两个向量分别处于不同的空间中。</p>
<p>例如一个矩阵为 $m\times n$ 维，那么它表示将一个n维空间中的向量映射到m维空间中，矩阵的列向量同样是原空间中的基向量在新空间中的映射</p>
<blockquote>
<p>小结：方阵表示线性变换，指在原有空间中对向量进行变换；非方阵表示线性映射，把原空间中的向量映射到一个新的空间中</p>
</blockquote>
<h2 id="6-向量的点积"><a href="#6-向量的点积" class="headerlink" title="6.向量的点积"></a>6.向量的点积</h2><h3 id="·向量点积的几何意义"><a href="#·向量点积的几何意义" class="headerlink" title="·向量点积的几何意义"></a>·向量点积的几何意义</h3><p>有两个向量 $\vec v$ 和 $\vec w$ ，点积的几何意义表示 $\vec v$ 在 $\vec w$ 方向上的投影的长度和 $\vec w$长度的乘积</p>
<p>点积的结果和向量的顺序无关，即$\vec v ·\vec w=\vec w·\vec v$ </p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020043.png" alt="image-20210716055411474" style="zoom:33%;" /></p>
<p>利用对称性，可以直观证明上述结论，令 $\vec v$ 和 $\vec w$ 的长度相同，根据对称性可以知道， $\vec v$ 在 $\vec w$ 上的投影长度与 $\vec w $  在 $\vec v$ 上的投影长度相同。当 $ \vec v$ 放大两倍后，这种对称性就不再存在了，但此时 $\vec w$ 在 $2\vec v$ 上的投影不变，也可以说  $2\vec v$ 在 $\vec w$ 上的投影长度变为原来的2倍，所以 $(2\vec v)·\vec w=\vec w·(2\vec v)$ </p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020049.png" alt="image-20210716055903784"></p>
<h3 id="·向量点积的矩阵表示"><a href="#·向量点积的矩阵表示" class="headerlink" title="·向量点积的矩阵表示"></a>·向量点积的矩阵表示</h3><p>如果把一个向量当成一个 $n\times1$ 的矩阵来看时，那么对向量的转置就得到了一个 $1\times n$的矩阵，向量的点积可以用向量的转置乘以向量来计算</p>
<p><strong>那么为什么可以这样计算呢？</strong>首先可以想到，既然转置是一个矩阵，就可以表示一个线性变换了，这个线性变换的几何意义就是把多维空间中的向量映射到一个一维空间上。经过映射得到的一维向量是一个数，它表示在多维空间中的一个向量在某一方向上的投影长度。</p>
<p>现在以二维空间为例：</p>
<p>在二维空间中有一单位向量 $\vec u$ ，在该向量的方向上布置一个数轴，这个数轴也就是一个一维空间。如果想把 $\vec u$ ==映射==到这个一维空间中，则需要找到二维空间的基向量在这个一维空间上的位置，我们用投影位置来表示基向量在一维空间上的位置，如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020055.png" alt="image-20210716092117757"></p>
<p>根据投影关系和对称关系，可以得到二维空间中的基向量 $\vec i 和 \vec j$ 在一维空间的位置</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020101.png" alt="image-20210716092532170"></p>
<p>则$\vec i 和 \vec j$在一维空间的坐标为：</p>
<script type="math/tex; mode=display">
[u_x \ u_y]</script><p>对于二维空间中任意的向量在这个轴上的投影，可以用这个矩阵乘以向量的坐标来得到</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020106.png" alt="image-20210716092801428"></p>
<p>最终得到的结果为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
u_{x} & u_{y}
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]=u_{x} \cdot x+u_{y} \cdot y</script><p>这与这个任意向量和 $\vec u$ 的点积完全相同</p>
<blockquote>
<p>总结：为什么点积可以用向量的转置乘以向量？向量的转置表示一个矩阵，这个矩阵又代表着一个线性变换，这个线性变换就表示把一个多维空间的向量==投影==到一个一维空间中。</p>
</blockquote>
<p>当 $\vec v=k\vec u$ 是任意的向量时</p>
<script type="math/tex; mode=display">
k\left[\begin{array}{ll}u_{x} & u_{y}\end{array}\right]\left[\begin{array}{l}x \\
y\end{array}\right]=\left[\begin{array}{ll}ku_{x} & ku_{y}\end{array}\right]\left[\begin{array}{l}x \\
y\end{array}\right]=ku_{x} \cdot x+ku_{y} \cdot y</script><p>两个任意向量的点积表示先将一个向量投影到另一向量所在的方向上，然后将投影长度和另一向量的长度相乘</p>
<h2 id="7-向量的叉积"><a href="#7-向量的叉积" class="headerlink" title="7.向量的叉积"></a>7.向量的叉积</h2><h3 id="·什么是叉积"><a href="#·什么是叉积" class="headerlink" title="·什么是叉积"></a>·什么是叉积</h3><p>两个向量的叉积会产生一个与这两个向量都垂直的新向量，并且其长度等于这两个向量所围成的四边形的面积，而且它们的方向满足右手定则。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020113.png" alt="image-20210716095942997"></p>
<p>既然是表示面积，这就与之前说过的行列式有关系，但这只对二维向量成立（因为只有两个向量，只有二维向量才能满足方阵，才有行列式）</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020117.png" alt="image-20210716095517110"></p>
<p>两个向量所组成的矩阵对应着一个线性变换，线性变换的度量就是矩阵的行列式，也就是基向量所围成的四边形面积</p>
<h3 id="·关于三维空间中的叉积的计算"><a href="#·关于三维空间中的叉积的计算" class="headerlink" title="·关于三维空间中的叉积的计算"></a>·关于三维空间中的叉积的计算</h3><p>对于三维空间中的叉积，可以用下面的计算公式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
v_{1} \\
v_{2} \\
v_{3}
\end{array}\right] \times\left[\begin{array}{l}
w_{1} \\
w_{2} \\
w_{3}
\end{array}\right]=\operatorname{det}\left(\left[\begin{array}{ccc}
\vec{\imath} & v_{1} & w_{1} \\
\vec{\jmath} & v_{2} & w_{2} \\
\vec{k} & v_{3} & w_{3}
\end{array}\right]\right)</script><p>现在就来说明一下为什么可以用这个公式来计算叉积</p>
<p>由第4节可知，矩阵的行列式表示列向量所张成的平行六面体的体积，而上面行列式的第一列不是一个向量，而是三个基向量，下面先来定义一个线性映射 $L(\vec a)$</p>
<script type="math/tex; mode=display">
L(\vec a)=\operatorname{\det}\left(\left[\begin{array}{c}
{x} & v_{1} & w_{1} \\
{y} & v_{2} & w_{2} \\
{z} & v_{3} & w_{3}
\end{array}\right]\right)\quad(\vec a=\left[\begin{array}{l}\ x\\
y\\
z\end{array}\right])</script><p>这个线性映射将一个三维向量映射到一维空间中，表示一个数，于是可以写成这种形式：</p>
<script type="math/tex; mode=display">
L(\vec a)=[\begin{array}{}p_1&p_2&p_3\end{array}]\cdot\left[\begin{array}{}x\\
y\\
z\end{array}\right]=\operatorname{det}\left(\left[\begin{array}{ccc}
{x} & v_{1} & w_{1} \\
{y} & v_{2} & w_{2} \\
{z} & v_{3} & w_{3}
\end{array}\right]\right)</script><p>于是展开有：</p>
<script type="math/tex; mode=display">
\begin{array}{r}
\quad x\left(v_{2} \cdot w_{3}-v_{3} \cdot w_{2}\right)+ \\
p_{1} \cdot x+p_{2} \cdot y+p_{3} \cdot z=y\left(v_{3} \cdot w_{1}-v_{1} \cdot w_{3}\right)+ \\
z\left(v_{1} \cdot w_{2}-v_{2} \cdot w_{1}\right)
\end{array}</script><p>即：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&p_{1}=v_{2} \cdot w_{3}-v_{3} \cdot w_{2} \\
&p_{2}=v_{3} \cdot w_{1}-v_{1} \cdot w_{3} \\
&p_{3}=v_{1} \cdot w_{2}-v_{2} \cdot w_{1}
\end{aligned}</script><p>现在用 $\vec p=[p_1\ p_2\ p_3]^T$，然后来谈几何意义</p>
<p>行列式表示三个列向量所张成的平行六面体的体积，而 $\vec p$ 和 $\vec a$ 的点积就等于这个体积，那么 $\vec p$ 是一个什么向量才能满足它们两个的点积等于体积呢。对于$\vec a$来说，它是任意一个向量，而 $\vec v$ 和 $\vec w$ 向量是固定的，平行六面体的体积等于面积乘以高，也就是说，当面积确定后，只需要知道高就可以了</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020123.png" alt="image-20210716111418718"></p>
<p>这个高就是 $\vec a$ 在垂直于 $\vec v$ 和 $\vec w$ 的方向上的投影，于是现在就可以知道 $\vec p$ 的意义了，$\vec p$ 的方向垂直于$\vec v$ 和 $\vec w$ ，它的长度是$\vec v$ 和 $\vec w$ 所张成平行四边形的面积</p>
<h2 id="8-基变换"><a href="#8-基变换" class="headerlink" title="8.基变换"></a>8.基变换</h2><p>现在有两个二维世界中的人，猪猪侠和包包侠，在猪猪侠的世界中，基向量是这样的：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020127.png" alt="image-20210716112957364"></p>
<p>在包包侠的世界中，基向量是这样的：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020130.png" alt="image-20210716114150696"></p>
<p>当有同一个向量时，在两个人的眼中，描述是不同的</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020134.png" alt="image-20210716114326652"></p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
\vec{e}_{i} & \vec{e}_{j}
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\vec{e}_{i}^{\prime}\ \ \ \  \ \vec{e}_{j}^{\prime}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]</script><p>现在包包侠把她所看到的向量的坐标告诉猪猪侠，那么猪猪侠必须要先知道包包侠的基向量在猪猪侠的基向量下的坐标，然后才能知道</p>
<p>于是包包侠的两个基向量在猪猪侠的基向量下的坐标为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}a&b\\
c&d\end{array}\right]</script><p>所以猪猪侠就知道了这个向量在他的基下的坐标：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\begin{array}{}a&b\\
c&d\end{array}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]=A\vec v^{\prime}</script><p>同理猪猪侠把这个他看到的向量的坐标告诉包包侠，包包侠也得转化到自己的基下来，即：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]
=\left[\begin{array}{}a&b\\
c&d\end{array}\right]^{-1}\left[\begin{array}{l}
x \\
y
\end{array}\right]=A^{-1}\vec v</script><p>现在猪猪侠想把这个向量变一变，比如旋转个90度，于是他用自己世界的基来描述变化后空间的位置，也就是新的坐标轴上单位向量的坐标为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]</script><p>于是变化后向量的坐标为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{new} \\
y_{new}
\end{array}\right]=\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]</script><p>现在包包侠也同样想把这个向量变一下，变得和猪猪侠一样，此时她直接乘以猪猪侠的M矩阵是不可以的，因为M是在猪猪侠的基上得到的，她想了一个好办法：</p>
<ul>
<li>她先把想变化的向量告诉猪猪侠，猪猪侠在自己的基下把这个向量表示出来</li>
<li>然后猪猪侠去变，乘以M矩阵</li>
<li>然后她再将猪猪侠变化后的向量换到自己的基下表示</li>
</ul>
<p>上述的过程就用下面的公式来表示：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{new}^{\prime} \\
y_{new}^{\prime}
\end{array}\right]=\left[\begin{array}{}a&b\\
c&d\end{array}\right]^{-1}\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]\left[\begin{array}{}a&b\\
c&d\end{array}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]=A^{-1}MA\vec v^{\prime}</script><h2 id="9-特征值和特征向量"><a href="#9-特征值和特征向量" class="headerlink" title="9.特征值和特征向量"></a>9.特征值和特征向量</h2><h3 id="·特征向量"><a href="#·特征向量" class="headerlink" title="·特征向量"></a>·特征向量</h3><p>矩阵乘以一个向量表示对这个向量的线性变换，以二维空间为例：</p>
<p>一个向量所张成的空间，就是这个向量所在的直线，当这个向量被变换后，很可能会离开这个空间，如下图所示</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020142.png" alt="image-20210716121344977"></p>
<p>但是也会有一些向量，没有离开它本身的张成空间，线性变换只是对它进行了拉伸或压缩，此时矩阵的作用如同一个标量</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020148.png" alt="image-20210716121501072"></p>
<p>这两个方向空间中的向量都不会偏离其原来所在的直线，而其他向量都会发生偏转</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020153.png" alt="image-20210716121716491"></p>
<p>这些不发生偏转的向量就叫作特征向量</p>
<h3 id="·特征值"><a href="#·特征值" class="headerlink" title="·特征值"></a>·特征值</h3><p>每一个特征向量都有一个与其对应的特征值，特征值表征这个向量空间上的向量被拉伸和压缩多少</p>
<p>那么特征向量有啥用呢？</p>
<p>考虑一个三维旋转的线性变换，当找到了它的特征向量，就找到了它的旋转轴</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020159.png" alt="image-20210716122229199"></p>
<p>当特征值为0时，表示没有特征向量 </p>
<h2 id="10-抽象向量空间"><a href="#10-抽象向量空间" class="headerlink" title="10.抽象向量空间"></a>10.抽象向量空间</h2><p>无论是什么东西，只要符合以下八条公理，那么这个东西就可以称作向量，它遵循着之前讲过的所用性质</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216020203.png" alt="image-20210716125152513"></p>
<blockquote>
<p>任意向量都能表达为基向量以某种方式进行线性组合，所以求一个向量变换后的结果，就是求变换后基向量以相同方式进行线性组合的结果</p>
</blockquote>
]]></content>
      <categories>
        <category>数理基础</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>【概率论与数理统计】极大似然估计和后验估计</title>
    <url>/2021/10/18/%E3%80%90%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E3%80%91%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<p>极大似然估计和后验估计。<br><span id="more"></span></p>
<h1 id="一、概率和统计的区别"><a href="#一、概率和统计的区别" class="headerlink" title="一、概率和统计的区别"></a>一、概率和统计的区别</h1><h2 id="1-概率研究"><a href="#1-概率研究" class="headerlink" title="1.概率研究"></a>1.概率研究</h2><p>已知一个模型和模型的参数，研究根据这个模型产生结果的概率和结果的一些特性（例如均值，方差等）</p>
<p>例子：以某地人口的身高统计研究为例，假设已经知道某地的人口的身高呈正态分布，因此根据该模型，可以知道该地人口身高的均值，方差等特点，也可以知道某人身高为1.9的概率</p>
<h2 id="2-统计研究"><a href="#2-统计研究" class="headerlink" title="2.统计研究"></a>2.统计研究</h2><p>统计研究与概率研究相反，是已知一组数据，但并不知道该模型和模型的具体参数</p>
<p>例子：已知某地一个小区的人口身高的数据，想要推测出该地整个人口身高分布的数学模型，假设已经知道该模型为正态分布，但不知道正态分布中具体的参数等信息，所以需要统计研究来得出</p>
<p>总结：概率研究是已知模型和参数，推数据。统计是已知数据，推模型和参数</p>
<h1 id="二、独立事件"><a href="#二、独立事件" class="headerlink" title="二、独立事件"></a>二、独立事件</h1><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032140.png" alt="image-20211008173107621" style="zoom:50%;" /></p>
<p>独立事件A和B，发生的概率为 $p(AB)=p(A)p(B)$</p>
<p>当A和B有某种关系的时候，也就是说不独立的时候，$p(AB)=p(A|B)p(B)$，可以根据此来判断AB是否独立</p>
<h1 id="三、极大似然估计和后验估计"><a href="#三、极大似然估计和后验估计" class="headerlink" title="三、极大似然估计和后验估计"></a>三、极大似然估计和后验估计</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><a href="https://zhuanlan.zhihu.com/p/32480810">参考</a></p>
<p>这两者都属于统计类别下的。对于统计估计出的模型参数$\theta$，有两个学派：</p>
<p><strong>频率学派</strong>：在进行参数估计时，所估计的参数$\theta$存在唯一的真值，也就是说$p(\theta)=1$。</p>
<p><strong>贝叶斯学派</strong>：认为$\theta$是一个随机变量，符合一定的概率分布，$p(\theta)$是有概率分布的。</p>
<p>抽象一点来讲，频率学派和贝叶斯学派对世界的认知有本质不同：频率学派认为世界是确定的，有一个本体，这个本体的真值是不变的，我们的目标就是要找到这个真值或真值所在的范围；而贝叶斯学派认为世界是不确定的，人们对世界先有一个预判，而后通过观测数据对这个预判做调整，我们的目标是要找到最优的描述这个世界的概率分布。</p>
<p>贝叶斯概率公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(A \mid B)&=\frac{P(A,B)}{P(B)}=\frac{P(B\mid A)P(A)}{P(A,B)+P(\tilde A,B)}\\
&=\frac{P(B\mid A)P(A)}{P(B\mid  A)P(A)+P(B\mid \tilde A)P(\tilde A)}
\end{aligned}\tag{1}</script><p><strong>E.g.</strong> 有一辆汽车，它被砸记作事件A，警报器响，记作事件B，现在想求得警报器响时，是车被砸的概率。那么，有以下几种表示：</p>
<ul>
<li>$P(A\mid B)$：在B发生时，A发生的概率。即警报器响了，是车被砸了的概率。</li>
<li>$P(A,B)$ ：A，B同时发生的概率。即警报器响和车被砸同时发生的概率。</li>
<li>$P(B\mid A)$ ：车被砸了，警报器响的概率。</li>
<li>$P(B\mid \tilde A)$ ：车没被砸，警报器响的概率。</li>
</ul>
<p>现在(1)式中，在警报响时，车被砸的概率=警报响与车被砸同时发生的概率 $\div$ 警报响的概率。</p>
<p>继续拆分：</p>
<p>警报响与车被砸同时发生的概率=车被砸的概率 $\times$ 车被砸时，警报响的概率。</p>
<p>警报响的概率=车被砸警报响的概率+车没被砸警报响的概率。</p>
<p><strong>在生活中为什么警报响了，通常是车没有被砸呢？</strong></p>
<p><strong>角度一：</strong></p>
<p>为了提高警报响时，就是车被砸了的说服力。我们希望警报响时，是车被砸的概率变为1。那么我们再看(1)，当 $P(B\mid \tilde A)P(\tilde A)=0$ 时，也就是车没被砸，警报响的概率为0。这样，我们就避免了干扰情况的影响，提高了说服力。但是，$P(B\mid \tilde A)P(\tilde A)=0$ 会等于0么。虽然车没被砸时，警报响的概率很小，但是车没有被砸的概率很大，接近于1，所以它们的乘积也不会太小。</p>
<p><strong>角度二：</strong></p>
<p>我们再来看式(1)，现在我们刨除其他的影响不说（例如，放炮导致的警报响），让其他影响的概率保持不变。来看分子，前面是车被砸时，警报响的概率。这个概率很大，我们可以认为其等于1，但是它还要乘以车被砸的概率，车被砸的概率很小很小，因此它们的乘积也很小。所以，即使是警报响了，车被砸的概率也会很小。在这里，车被砸的概率是<strong>先验</strong>。</p>
<p>从上面两个角度来看，其实就是$P(B\mid \tilde A)P(\tilde A)和P(B\mid  A)P(A)$ 间的比较，$P(B\mid A)$ 虽然很大，但是 $P(A)$ 很小；$P(B\mid \tilde A)$ 虽然很小，但是 $P(\tilde A)$ 很大。在这个例子中，就是 $P(B\mid \tilde A)比P(A)$ 胜了一筹，也就是车没被砸时警报响的概率比车被砸的大，才导致的即使警报响了，车被砸的概率也很小。</p>
<p>从以上两个角度，我们可以知道贝叶斯公式考虑事情发生的因素：一件本来就难以发生的事情，就算出现某个证据和它强烈相关，也要谨慎考虑（就是考虑这件事情本身的先验概率）。而一个不是那么相关，但是极其容易发生的事情，也需要考虑。</p>
<h2 id="2-似然函数"><a href="#2-似然函数" class="headerlink" title="2.似然函数"></a>2.似然函数</h2><p>对于 $P(X\mid \theta)$ 这个函数，它的输入有两个，分别是 $X和\theta$ 。</p>
<p>当 $\theta$ 已经确定，$X$ 是变量时，这个函数叫做概率函数，它描述对于不同的样本点$x$，其出现的概率为多少。</p>
<p>当 $X=x$ 时，$\theta$ 是变量时，这个函数就叫做似然函数，它描述对于不同的模型参数，出现$x$这个样本点的概率是多少。 </p>
<h2 id="3-最大似然估计——MLE"><a href="#3-最大似然估计——MLE" class="headerlink" title="3.最大似然估计——MLE"></a>3.最大似然估计——MLE</h2><p>最大似然估计是<strong>频率学派</strong>的方法，即认为参数 $\theta$ 是一个固定的常数。</p>
<p>假设数据 $x_1,x_2\cdots x_n$ 是独立同分布的一组样本，那么令 $X=\{x_1,\cdots x_n\}$ 。我们可以计算出出现这样样本的概率：</p>
<script type="math/tex; mode=display">
P(X,\theta)=P(X\mid\theta)P(\theta)\tag{2}</script><p>在(2)中，因为 $P(\theta)=1$ ，所以：</p>
<script type="math/tex; mode=display">
P(X,\theta)=P(X\mid\theta)\tag{3}</script><p>我们就可以假设我们已经知道了 $\theta$ ，然后求出在该概率模型参数下，出现此时样本的概率，这个概率是 $\theta$ 的函数。因为既然能出现此时的</p>
<p>样本情况，那么概率函数应该是最大值，所以 $\theta$ 是极大值点。</p>
<script type="math/tex; mode=display">
\hat \theta=\max _\theta P(X\mid\theta)\tag{4}</script><p> <strong>E.g.</strong> 我们现在有一个硬币，这个硬币服从二项分布，我们设正面朝上的概率为 $\theta$ 。现在想通过试验来求出硬币的正面朝上的概率为多少。假设我们做了一组试验，扔了10次，其中正面朝上的次数为7。</p>
<script type="math/tex; mode=display">
P(X=\{7次正，3次反\},\theta)=P(X\mid\theta)=\theta^7(1-\theta)^3=f(\theta)\tag{5}</script><p>现在既然出现了7次正面向上，3次反面向上的数据样本，我们就可以认为此时的概率一定是所有情况中最大的。我们可以把似然函数$f(\theta)$ 的图像画出来：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032227.png" alt="image-20211009211806463" style="zoom:50%;" /></p>
<p>可以看出 $\theta=0.7$ 时，似然函数取极大值。但是我们知道，一般的硬币都是均匀分布的，为什么正面朝上的概率会是0.7呢。这就包含了贝叶斯学派的思想，即引入先验估计。</p>
<h2 id="4-最大后验估计——MAP"><a href="#4-最大后验估计——MAP" class="headerlink" title="4.最大后验估计——MAP"></a>4.最大后验估计——MAP</h2><p>最大后验估计是贝叶斯学派的方法，他们认为参数 $\theta$ 是不确定的，也是一个随机变量。需要求出在该样本情况下，参数的概率分布，然后选取概率最大的样本点。</p>
<script type="math/tex; mode=display">
P(\theta\mid X)=\frac{P(X,\theta)}{P(X)}=\frac{P(X\mid\theta)P(\theta)}{P(X)}\tag{6}</script><p>式（6）中，$P(\theta\mid X)$ 是后验估计，实际上我们的目标就是找到 $\theta$ ，让它最大。$P(\theta)$ 是先验估计。$P(X)$ 是试验得到的概率，仅与试验结果有关，当我们已经获取试验结果后，可以认为它是一个常数。</p>
<script type="math/tex; mode=display">
\hat\theta=\max_\theta P(\theta \mid X)=\max_\theta P(X\mid\theta)P(\theta)\tag{7}</script><p>最大后验的思想是不仅仅需要似然函数最大，也需要先验的概率很大。</p>
<p>同样是抛硬币的例子：</p>
<p>我们先验的知道正面朝上的概率为0.5，因此认为 $\theta$ 服从均值为0.5，方差为1的正态分布。</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X,\theta)&=P(X\mid\theta)P(\theta)\\
&=f(\theta)P(\theta)
\end{aligned}\tag{8}</script><p>图像为：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032233.png" alt="image-20211009220826964" style="zoom:50%;" /></p>
<p>此时 $\theta$ 已经向左偏移，为0.558。即用最大后验估计，得到的结果。</p>
<p>当试验次数为1000次，其中正面朝上的次数为700次时，$f(\theta)P(\theta)$ 的图像为：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215032237.png" alt="image-20211009221159457" style="zoom:50%;" /></p>
<p>此时 $\theta=0.696$ 。</p>
<p>从这个例子可以知道：当数据量增大时，估计的参数分布会越来越向数据靠拢，先验的影响力会越来越小。</p>
]]></content>
      <categories>
        <category>数理基础</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>【数字图像处理1】什么是数字图像处理</title>
    <url>/2021/12/19/%E3%80%90%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%861%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>主要参考：冈萨雷斯《数字图像处理》</p>
<p>计算机视觉是现在最火的研究领域，一开始我以为数字图像处理是计算机视觉的一部分，然而事实并非如此。接下来会通过比较数字图像处理，图像分析，计算机视觉的关系来介绍什么是数字图像处理。</p>
<span id="more"></span>
<h3 id="1-什么是数字图像处理"><a href="#1-什么是数字图像处理" class="headerlink" title="1.什么是数字图像处理"></a>1.什么是数字图像处理</h3><p>图像我们大家都十分熟悉，平常在手机和电脑上看到的都是数字图像。与之对应的可以叫作非数字图像，例如我们小时候用胶卷相机拍出来的照片，或者是在医院拍的CT，得到的图片在胶片上呈现，是非数字化的。因为计算机能看懂的只有0和1，也就是二进制数，所以用数字来描述一幅图像，得到的就是数字图像。数字图像处理最早的起源可以追溯到上世纪二十年代，那时候人们为了实现远距离传输图像，先将一张图像编码成信号的形式（例如白色就用高电位表示，黑色用低电位表示），然后接收端再解码进行打印。显然，那时候并没有对图像进行什么实质意义上的处理，但是此时已经涉及到了数字图像的概念。</p>
<p>数字图像处理，图像分析，计算机视觉三者并没有十分明确的分界。但是一般认为，数字图像处理的输入和输出都是一张图片，例如我们平常用到的P图软件。而计算机视觉的目标是模拟人类的视觉系统，是人工智能的一个分支，其输入是图像，输出就不一定是啥了，这要根据任务的需要，如果理解一张图片，那么输出可能就是一段描述图像内容的话。图像分析介于二者之间，是中间的过程，与这两个领域都有交集，其输入是图片，输出是图像中的一些特征信息，但这些信息并没有上升到语义的级别。</p>
<blockquote>
<p>我的理解是，图像分析没有用到数据驱动的方法，而是单纯的通过数学的方法对图像进行处理，从而得到图像中的一些信息。</p>
</blockquote>
<p>以文本识别为例，从图像中提取出文本并将其描述成计算机可以处理的形式便属于图像分析。而要理解全文的意思，就属于计算机视觉的领域了。在《数字图像处理》这本书中，会涉及到图像处理和分析这两部分内容。</p>
<h3 id="2-数字图像处理的步骤"><a href="#2-数字图像处理的步骤" class="headerlink" title="2.数字图像处理的步骤"></a>2.数字图像处理的步骤</h3><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211222004857.png" alt="image-20211222004850371"></p>
<p>在本书中，其章节安排是按照图像处理的顺序进行的。</p>
<blockquote>
<p>注意：在一个图像处理系统里，上述过程不一定全都有。</p>
</blockquote>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM1】视觉SLAM基本框架</title>
    <url>/2021/10/18/%E3%80%90%E8%A7%86%E8%A7%89SLAM1%E3%80%91%E8%A7%86%E8%A7%89SLAM%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>视觉SLAM的结构框架。<br><span id="more"></span></p>
<h2 id="I-视觉SLAM框架结构"><a href="#I-视觉SLAM框架结构" class="headerlink" title="I. 视觉SLAM框架结构"></a>I. 视觉SLAM框架结构</h2><p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220712035243.png" alt="20211215032349"></p>
<p><strong>SLAM(Simultaneous Localization and Mapping)</strong>是根据传感器数据先计算出自身位置和路标点位置（存在噪声），然后再进行优化从而得到相对准确的自身位置和路标点位置。</p>
<p><strong>例如：</strong>一架无人机，在真实的世界中移动。那么它的自身位置就是x, y, z, 加上三个姿态角度。而路标的位置是指周围环境中的物体的x, y, z 。</p>
<h2 id="II-各部分介绍"><a href="#II-各部分介绍" class="headerlink" title="II. 各部分介绍"></a>II. 各部分介绍</h2><h3 id="1-传感器信息读取"><a href="#1-传感器信息读取" class="headerlink" title="1.传感器信息读取"></a>1.传感器信息读取</h3><p>传感器可以分为两类：</p>
<ul>
<li>携带在本体上的传感器：如：相机，IMU，激光传感器等</li>
<li>安装在环境中的传感器：如：墙壁上的二维码</li>
</ul>
<p>携带在本体上的传感器不用事先在周围环境中布置，因此可以适用的范围很大。我们通常都是使用这类传感器，只有特殊需求的时候才使用第二种传感器。传感器一般测量的不是直接的物理量，比如你想使用IMU测量无人机的位置，而IMU直接测量的结果是它的加速度和角速度。所以想要求位置和姿态角，就需要进行积分。</p>
<p>在视觉SLAM中，我们使用的传感器是相机，这里的相机与我们日常生活中使用的单反相机不同，它的结构比较简单，不需要携带昂贵的镜头，常用的相机分为三种：</p>
<ul>
<li>单目相机（Monocular）</li>
<li>双目相机（Stereo）</li>
<li>深度相机（RGB-D）</li>
</ul>
<h4 id="（1）单目相机"><a href="#（1）单目相机" class="headerlink" title="（1）单目相机"></a>（1）单目相机</h4><p>单目相机的特点就是不能探测到物体的深度信息，例如我们闭上一只眼睛看东西，很难分辨清楚哪个在前面。在人类的直觉上，大概可以判断一张照片中，谁在前谁在后，但是这里包含了先验知识，就是我们已经知道一些物体的大小。</p>
<p>单目相机拍摄的图像是三维空间在二维平面上的投影，所以想要恢复出深度信息，必须要改变相机的视角，这就要移动相机。当用相机拍摄一个静止的物体时，不同的视角会得到该物体在相机平面上的不同位置，这就是<strong>视差</strong>，我们可以通过视差来估计出相机的深度。但是，这种方式得到的深度信息也是一个相对值，如下图所示，比如前方有两个物体A和B（红色是真实位置），我们通过该方法计算时，仅能知道宽度和深度的比值是3:1，并不能知道具体的数值。这表明单目SLAM估计得轨迹和地图与真是的相差了一个比例系数，也就是<strong>尺度</strong>（后面在对极几何中就能深刻理解该问题了）。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220712025811.png" alt="image-20220712025810996" style="zoom:50%;" /></p>
<h4 id="（2）双目相机"><a href="#（2）双目相机" class="headerlink" title="（2）双目相机"></a>（2）双目相机</h4><p>为了解决单目相机尺度缺失的弊端，又有了双目相机。双目相机和我们的眼睛一样，两个眼睛间的距离是不变的（称之为<strong>基线</strong>），我们可以通过三角形的相似性可以准确的测量出物体的深度。但是它的缺点是计算量大（需要对像素点进行匹配），标定和配置复杂。而且双目相机是有测量距离的，基线越长，范围越远（可以想象当我们睁开双眼看很远处的两个物体时，我们也是无法分辨出谁在前谁在后的）。</p>
<h4 id="（3）深度相机"><a href="#（3）深度相机" class="headerlink" title="（3）深度相机"></a>（3）深度相机</h4><p>深度相机是相机中存在一个类似激光的传感器，可以进行扫描得到物体的深度。相比于双目相机，可以不用计算就得到深度，但是它的测量范围小，噪声大，特别是在遇到强光干扰和透射材料时，有很大的问题。</p>
<h3 id="2-视觉里程计"><a href="#2-视觉里程计" class="headerlink" title="2. 视觉里程计"></a>2. 视觉里程计</h3><p>之前介绍传感器时，我们知道传感器通常是不能直接得出我们想要知道的物理量，在视觉SLAM中也一样，我们不可能直接根据图像就能知道相机的位置和环境中物体的位置。因此需要一些方法来进行计算，通过两帧相邻时刻的图像，可以计算出相机的移动和图像中物体的深度。</p>
<p>视觉里程计和汽车的里程计相同，只能知道当前时刻的运动信息（视觉SLAM中，视觉里程计得到的物理量是相机在该时刻<strong>运动的距离</strong>和<strong>转动的角度</strong>），和过去的信息没有关联。这就导致了一个问题，每一时刻的运动信息中包含了大量的噪声，这样简单的累积起来会导致最终的结果极其不准确。例如，我们闭着眼睛向前走，每一次的步幅为 $70\pm 5$ cm，向前走的角度为 $0°\pm5°$ ，当我们走了10步之后，谁能保证就是向正前方走了7m么？这就是不可避免的<strong>累计漂移</strong>。</p>
<p>为了解决累计漂移问题，还需要进行后端优化和回环检测，来校正整个轨迹的形状。</p>
<h3 id="3-后端优化"><a href="#3-后端优化" class="headerlink" title="3. 后端优化"></a>3. 后端优化</h3><p>后端优化就可以和视觉二字脱离了，接触的是前端传给它的纯数据。后端优化就是从包含噪声的原始数据中计算出最优的轨迹和地图，以及确定这个轨迹和地图的不确定性有多大。</p>
<p>在历史上来说，现在我们称之后端优化的部分，在很长一段时间内直接称为SLAM研究。这也反映出了SLAM问题的本质就是对运动物体自身和周围环境空间不确定性的估计。而前视觉SLAM的端通常和计算机视觉相关。</p>
<p>后端优化的主要方法有：</p>
<ul>
<li>滤波</li>
<li>非线性优化</li>
</ul>
<h3 id="4-回环检测"><a href="#4-回环检测" class="headerlink" title="4. 回环检测"></a>4. 回环检测</h3><p>回环检测主要是解决累计漂移的问题，我们想通过让视觉SLAM系统知道自己来过哪，来更正当前错误的轨迹。为完成这一目标，可以通过图像间的相似性来判断该地点是否来过。在实际的SLAM系统中，回环检测会把A和B是同一点这一信息告诉后端优化算法，然后由后端优化算法来调整符合回环检测的结果。</p>
<h3 id="5-建图"><a href="#5-建图" class="headerlink" title="5. 建图"></a>5. 建图</h3><p>根据不同的任务需求，所建的地图是不一样的。但大体上来说，可以分为：</p>
<ul>
<li>度量地图</li>
<li>拓扑地图</li>
</ul>
<h4 id="（1）度量地图"><a href="#（1）度量地图" class="headerlink" title="（1）度量地图"></a>（1）度量地图</h4><p>主要有：</p>
<ul>
<li>稀疏地图（Sparse）</li>
<li>稠密地图（Dense）<ul>
<li>二维度量地图，由小格子（Grid）组成。</li>
<li>三维度量地图，由小方块（Voxel）组成。</li>
</ul>
</li>
</ul>
<p>稀疏地图主要由用于定位的路标点组成（也就是前端计算相机位姿的特征点），而稠密地图则是重建所有看到的东西，主要用于导航。在稠密地图中，每一单位元素有三种状态，分别为占据、空闲、未知，这样的地图可以用来给各种导航算法使用。但是每一个点都存储状态，会耗费大量的存储空间。</p>
<h4 id="（2）拓扑地图"><a href="#（2）拓扑地图" class="headerlink" title="（2）拓扑地图"></a>（2）拓扑地图</h4><p>拓扑地图更强调地图元素之间的关系。主要考虑节点间的连通性。</p>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM2】SLAM的数学描述</title>
    <url>/2021/10/18/%E3%80%90%E8%A7%86%E8%A7%89SLAM2%E3%80%91SLAM%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<p>主要介绍如何使用数学语言来描述SLAM问题。<br><span id="more"></span></p>
<h2 id="I-数学描述"><a href="#I-数学描述" class="headerlink" title="I. 数学描述"></a>I. 数学描述</h2><p>设 $\vec{x}$ 表示相机的位置，$\vec x_1\ , \ \vec x_2 \ …\ ,\vec x_k$表示不同时刻的位置信息，$\vec y_1 \ , \vec y_2 \ ,\ …\ \vec y_n$表示路标的位置，共有n个路标点</p>
<p>我们的<strong>目标是：</strong>描述以下两件事情：</p>
<ol>
<li>什么是运动 ：k-1时刻到k时刻，$\vec x$是如何变化的</li>
<li>什么是观测：在k时刻，相机在 $\vec x_k$处探测到某一路标，$\vec y_j$​ </li>
</ol>
<h3 id="1-运动与观测方程"><a href="#1-运动与观测方程" class="headerlink" title="1. 运动与观测方程"></a>1. 运动与观测方程</h3><p>首先来说关于 <strong><u>运动</u></strong> 的数学描述：</p>
<script type="math/tex; mode=display">
\vec x_k = f(\vec x_{k-1}\ , \vec u_k\ ,\vec w_k)</script><p>$\vec u_k$表示k时刻运动的输入(可以是传感器读数或者我们的命令输入，具体可以是速度，加速度，也可以是位移差)，$\vec w_k$表示噪声</p>
<p>接下来说关于 <strong><u>观测</u></strong> 的表述：</p>
<script type="math/tex; mode=display">
\vec z_{k,j}=h(\vec y_j\ ,\vec x_k \ ,\vec {v_{k,j}})</script><p>该式表示的是相机在位置 $\vec x_k$上看到某个路标点 $\vec y_j$时，产生了一个观测数据 $\vec z_{k,j}$ ，而 $\vec v_{k,j}$表示观测噪声</p>
<h3 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h3><p>以二维运动为例：</p>
<p>如图所示</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033742.png" style="zoom:60%;" /></p>
<p>已知上一时刻k-1的相机位姿 $\vec x_{k-1}$ 和运动输入$\vec{u}_{k}$（在视觉SLAM中可以由视觉里程计得出或通过传感器得出）</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\vec{x}_{k}=\left[x_{1}, x_{2}, \theta\right]_{k}^{\top} \\
&\vec{u}_{k}=\left[\Delta x_{1}, \Delta x_{2}, \Delta \theta\right]_{k}^{\top}
\end{aligned}</script><p>运动方程为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{1} \\
x_{2} \\
\theta
\end{array}\right]_{k}=\left[\begin{array}{l}
x_{1} \\
x_{2} \\
\theta
\end{array}\right]_{k-1}+\left[\begin{array}{c}
\Delta x_{1} \\
\Delta x_{2} \\
\Delta \theta
\end{array}\right]_{k}+\vec{w}_{k}</script><p>对于观测方程，以二维激光传感器为例，如图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215033747.png" alt="img" style="zoom:60%;" /></p>
<p>路标点j与相机位置关系由距离r和夹角 $\varphi$表示，即观测数据 $z_{k,j}=[r_{j},\varphi_{j}]^T_k$（这是由传感器测出的值），这里的k表示k时刻下的观测数据</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
r_{j} \\
\varphi_{j}
\end{array}\right]_k=\left[\begin{array}{c}
\sqrt{\left(x_{1,k}-y_{1, j}\right)^{2}+\left(x_{2,k}, -y_{2, j}\right)^{2}} \\
\arctan \left(\frac{y_{2,j} -x_{2, k}}{y_{1, j}-x_{1, k}}\right)
\end{array}\right]+\vec{v}</script><p>其中$\vec{v}$是观测误差。</p>
<p>SLAM问题就是已知观测数据 $\boldsymbol{z_{k,j}}=[r_j,\phi_j]^T$  来求 $\vec x_k$和 $\vec y_j$ 。</p>
<blockquote>
<p>注意：这里求 $\vec x_k$表示定位问题，即求出相机自己本身在世界坐标系下的坐标，而求出 $\vec y_j$表示建图问题，即求出周围环境中路标点在世界坐标系下的坐标</p>
</blockquote>
<p>如果求出了 $\vec x_k$和 $\vec y_j$，也就完成了定位和建图，而反看上面的运动方程和观测方程，假如没有噪声的存在，那么直接解方程就是了，就可以准确的求出相机和路标点在世界坐标系下的位置，然而现实并不是这样，由于噪声的存在，<strong>解方程的问题就变成了一个状态估计问题</strong>，这也是SLAM的最基本问题。</p>
<p>按照运动和观测方程是否为线性和噪声是否服从高斯分布，可以分为以下几类以及解决其状态估计的办法：</p>
<ul>
<li>线性高斯分布（LG）$\longrightarrow$ 卡尔曼滤波（KF）</li>
</ul>
<ul>
<li>非线性非高斯分布（NLNG）$\longrightarrow$扩展卡尔曼滤波（EKF）或非线性优化</li>
<li>主流使用的是图优化（Graph Optimization）</li>
</ul>
<h2 id="II-思考"><a href="#II-思考" class="headerlink" title="II. 思考"></a>II. 思考</h2><p>SLAM问题的状态和观测方程为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{ll}
\boldsymbol{x}_{k}=f\left(\boldsymbol{x}_{k-1}, \boldsymbol{u}_{k}, \boldsymbol{w}_{k}\right), & k=1, \cdots, K \\
\boldsymbol{z}_{k, j}=h\left(\boldsymbol{y}_{j}, \boldsymbol{x}_{k}, \boldsymbol{v}_{k, j}\right), & (k, j) \in \mathcal{O}
\end{array} .\right.</script><p>这里 $\mathcal{O}$ 是一个集合，记录这哪个时刻观察了哪个路标，即每个 $k$ 对应着一些列的 $j$ ，因为通常情况下每个时刻仅能看到一部分的路标。</p>
<p>在视觉SLAM中，$\boldsymbol{z_{k,j}}$ 就是观测量，也就是每一张图片。而输入量 $\boldsymbol{u}_{k}$ 是相机的位姿变化量，也就是后面中说到的相机的变换矩阵 $T$ 。有人认为应该把 $\boldsymbol{u}_{k}$ 放入到观测方程中，因为这是通过前端观测量$\boldsymbol{z_{k,j}}$ 计算出来的，写成：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\boldsymbol{z}_{k, j}=h\left(\boldsymbol{y}_{j}, \boldsymbol{x}_{k-1}, \boldsymbol{u}_{k},\boldsymbol{v}_{k, j}\right), & (k, j) \in \mathcal{O}
\end{array}</script><p>这在实际中是没有差别的。</p>
<p>那么视觉SLAM的一个过程就是先知道 $\boldsymbol{z_{k,j}}$ ，然后可以计算出 $\boldsymbol{u}_{k}$ ，然后再分别计算出 $\boldsymbol{x}_{k}$ 和 $\boldsymbol{y}_{k}$ 。此时是带噪声的，还要通过后端优化和回环检测两个步骤。</p>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM3】三维空间刚体运动描述</title>
    <url>/2022/07/12/%E3%80%90%E8%A7%86%E8%A7%89SLAM3%E3%80%91%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<p>本节主要讨论如何来描述三维空间刚体的运动。主要由六个参数来表示一个刚体在三维空间中的运动状态（平移+旋转）。</p>
<span id="more"></span>
<p>描述位移的方法很简单，用一个向量。而描述旋转的方法有很多：</p>
<ul>
<li>旋转矩阵</li>
<li>欧拉角</li>
<li>旋转向量</li>
<li>四元数</li>
</ul>
<h2 id="I-特别重要写在前面"><a href="#I-特别重要写在前面" class="headerlink" title="I. 特别重要写在前面"></a>I. 特别重要写在前面</h2><h3 id="1-分清点，向量，坐标之间的关系"><a href="#1-分清点，向量，坐标之间的关系" class="headerlink" title="1. 分清点，向量，坐标之间的关系"></a>1. 分清点，向量，坐标之间的关系</h3><p><strong>点</strong>是空间中最基本的元素，没有长度和体积。<strong>向量</strong>可以认为是从某个点指向另一个点的一个箭头，是空间中真实存在的一个东西。</p>
<p>而不知不觉中我们最容易混淆的是坐标。坐标可以分为 <strong>点的坐标</strong> 和 <strong>向量的坐标</strong>。</p>
<p>点的坐标很好理解，就是建立一个坐标系，然后我们用坐标来描述该点的空间位置，例如在三维空间中的一个点P，我们可以用坐标 $[1,2,3]^T$ 来表示。</p>
<p>向量的坐标是建立一组基后，我们通过使用这组基来描述向量。例如一个向量 $\boldsymbol{v}$ ，在建立一组基后，我们可以用坐标来描述向量：</p>
<script type="math/tex; mode=display">
\boldsymbol{v}=\left[\boldsymbol{e}_{1}, \boldsymbol{e}_{2}, \boldsymbol{e}_{3}\right]\left[\begin{array}{c}
1\\
2\\
3
\end{array}\right]=1 \boldsymbol{e}_{1}+2 \boldsymbol{e}_{2}+3\boldsymbol{e}_{3}\tag{1}</script><p>这里的$[1,2,3]^ T$ 称为向量 $\boldsymbol{v}$ 在此基下的坐标。</p>
<p>可以看到上面的两个例子，点P的坐标和向量 $\boldsymbol{v}$  的坐标在数学形式上是一样的，<strong>我们也会把点的坐标或者是向量的坐标叫做列向量</strong>，但你要清楚的是虽然叫做列向量，但并不是一个向量，因为向量是真实存在的，不是写出来的。这里的列向量仅仅表示的是一个坐标，它可能是一个点的坐标，也有可能是一个向量的坐标。</p>
<h3 id="2-区别坐标变换时的坐标是点的还是向量的"><a href="#2-区别坐标变换时的坐标是点的还是向量的" class="headerlink" title="2. 区别坐标变换时的坐标是点的还是向量的"></a>2. 区别坐标变换时的坐标是点的还是向量的</h3><p>刚才说过，给你一个坐标一定要弄清楚是点的坐标还是向量的坐标，因为在坐标变换中是不一样的。我们可以分为这两类：</p>
<ul>
<li>描述同一<strong>向量</strong>在不同基下（也可以说是不同坐标系下）的坐标间的变化——仅考虑转动</li>
<li>描述同一个<strong>点</strong>在不同坐标系下的坐标间的变化——考虑平移和转动</li>
</ul>
<p>为什么要这样呢？<strong>是因为向量在空间中平移运动时，不会改变其坐标的数值，</strong>而点就不一样了。至于具体如何变换，<a href="#jump">在后面</a>。</p>
<blockquote>
<p>点的坐标变换是很抽象的，但是我们知道点的坐标和向量的坐标密切相关，于是我们可以这样理解：<strong>先把点的坐标转化为向量的坐标，再进行坐标变换，然后再转化成点的坐标。（在某一坐标系下，点的坐标等于由原点指向该点的向量的坐标）</strong></p>
</blockquote>
<h3 id="3-旋转的是向量还是坐标系"><a href="#3-旋转的是向量还是坐标系" class="headerlink" title="3. 旋转的是向量还是坐标系"></a>3. 旋转的是向量还是坐标系</h3><p>还有一个问题会常常弄混我们，就是我们是旋转的向量还是旋转的坐标系。</p>
<p>旋转向量的时候，坐标系是不变的。我们会得到<strong>新向量</strong>的坐标。</p>
<p>而旋转坐标系的时候，向量是固定不变的，我们会得到该向量在<strong>新坐标系下</strong>的坐标。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220210045719914.png" alt="image-20220210045719914" style="zoom: 67%;" /></p>
<p>如上面的图所示，左边的是旋转的坐标系，右边的是旋转的向量。二者在变换后，左边向量在新坐标系下的坐标和右边的新向量的坐标是相同的，但是要注意，此时相同，是因为旋转的方向是不同的。</p>
<p>总之旋转坐标系和旋转向量之间，相差了一个角度方向。例如我把坐标系逆时针旋转30°，等价于把向量顺时针旋转30°。在后面的使用中，一般都指<strong>左边</strong>的这种情况，就是同一个向量在不同坐标系下的坐标。</p>
<h3 id="4-坐标和符号系统"><a href="#4-坐标和符号系统" class="headerlink" title="4. 坐标和符号系统"></a>4. 坐标和符号系统</h3><p>既然说到坐标系，我们现在就介绍后面要用到的两个坐标系，并说明符号系统。</p>
<p>后面我们会使用两个坐标系：</p>
<ul>
<li>world coordinate system——固定在大地上的惯性坐标系（后面简称世界系）</li>
<li>body-fixed coordinate system——固定在刚体上的运动坐标系（后面简称刚体系）</li>
</ul>
<p>然后来说明符号系统：</p>
<p>如果用 $\boldsymbol{x}$ 来表示一个点在世界系中的坐标，那么该点在刚体系下的坐标为 $\boldsymbol{ {x}^\prime}$ 。</p>
<p>$\boldsymbol {x_w}$ 表示世界系原点在世界系的坐标，所以这里 $\boldsymbol {x_w}=[0,0,0]^T$ ，同理 $\boldsymbol{x_b’}$ 表示刚体系原点在刚体系下的坐标 $\boldsymbol{x_b’}=[0,0,0]^T$ 。</p>
<h2 id="II-旋转矩阵"><a href="#II-旋转矩阵" class="headerlink" title="II. 旋转矩阵"></a>II. 旋转矩阵</h2><h3 id="1-旋转矩阵是什么"><a href="#1-旋转矩阵是什么" class="headerlink" title="1. 旋转矩阵是什么"></a>1. 旋转矩阵是什么</h3><p>旋转矩阵乘以一个列向量后，可以保证这个列向量的模长不变，可以满足这个功能的矩阵组成了一个组合，我们可以叫这个组合为 <code>Special Orthogonal Group</code>，三维的就是 $SO(3)$ ，如果$R \in S O(3)$ ，那么：</p>
<script type="math/tex; mode=display">
det \ R =\pm 1 \quad and \quad R^{-1}=R^T\tag{2}</script><p>注意这里的$det \ R=-1$ 时的$R$ 不是刚体的变换，所以我们这里不考虑。</p>
<p>简言之，只要满足式(2)中要求的矩阵，就是一个旋转矩阵，因此我们定义一个旋转矩阵为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R &=\left[\begin{array}{lll}
\mathbf{r}_{1} & \mathbf{r}_{2} & \mathbf{r}_{3}
\end{array}\right] \\
&=\left[\begin{array}{lll}
r_{11} & r_{12} & r_{13} \\
r_{21} & r_{22} & r_{23} \\
r_{31} & r_{32} & r_{33}
\end{array}\right]
\end{aligned}\tag{3}</script><p>旋转矩阵有九个自由度，但实际上旋转用三个变量就可以描述，因此旋转矩阵有一定的冗余。</p>
<h3 id="2-旋转矩阵描述坐标变换"><a href="#2-旋转矩阵描述坐标变换" class="headerlink" title="2. 旋转矩阵描述坐标变换"></a><span id="jump">2. 旋转矩阵描述坐标变换</span></h3><h4 id="1-向量在不同坐标系下的坐标变换"><a href="#1-向量在不同坐标系下的坐标变换" class="headerlink" title="(1) 向量在不同坐标系下的坐标变换"></a>(1) 向量在不同坐标系下的坐标变换</h4><p>我们所定义的这个旋转矩阵描述的是从世界系到刚体系下的坐标变化（当然我们也可以定义成刚体系到是世界系的变化，相差了一个转置）。</p>
<p>也就是说有一个坐标为 $\boldsymbol{z} \in \mathbb{R}^{3}$ 的世界系下的向量，该向量在刚体系下的坐标为$\boldsymbol{z’} \in \mathbb{R}^{3}$ ，则有如下关系：</p>
<script type="math/tex; mode=display">
\boldsymbol{z'}=R\boldsymbol z\\
\boldsymbol{z}=R^T\boldsymbol {z'}\tag{4}</script><p><strong>注意：向量的坐标变换只有旋转！！！</strong></p>
<blockquote>
<p>这里我们仅描述了两个向量坐标之间的旋转关系，还未描述平移关系。这里可能会有一些懵，向量在空间中平移是不改变其坐标的。但是我们要注意到，这里的z是一个向量的坐标，而这个坐标又被人们称为列向量。在当前这个条件，z对应的是一个向量，因此不可能有平移变换。但是当z表示一个点的坐标是，就需要考虑了（有时尽管z表示一个点的坐标时，还被称为列向量）。</p>
</blockquote>
<h4 id="2-点在不同坐标系下的坐标变换（旋转-平移）"><a href="#2-点在不同坐标系下的坐标变换（旋转-平移）" class="headerlink" title="(2) 点在不同坐标系下的坐标变换（旋转+平移）"></a>(2) 点在不同坐标系下的坐标变换（旋转+平移）</h4><p>这回我们来说点，点的坐标变换和向量的有一些不同，因为点的坐标变化要考虑平移的影响。为什么呢？因为向量在空间中无论怎么平移运动，它的坐标都不变。<strong>所以在进行点的坐标变换时，我们要借助向量这一性质。</strong></p>
<p>用 $\boldsymbol x_p \in \mathbb{R}^{3}$ 表示一点P在世界系下的坐标，$\mathbf{x}^{\prime}_p \in \mathbb{R}^{3}$ 表示点P在刚体系下的坐标。</p>
<p>如图所示，我们可以用坐标来描述各个向量。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/windows_img/image-20220209161334490.png" alt="image-20220209161334490"></p>
<p>来看<code>wp</code>向量，它在w系下的坐标为 $\boldsymbol x_p-\boldsymbol x_w$ ，在b系下的坐标为$\boldsymbol x_p’-\boldsymbol x_w’$ ，这里的$\boldsymbol x_w=\boldsymbol 0$ 。  <strong>$R$ 表示从b系到w系的旋转矩阵</strong>，用来描述坐标系变化后，<strong>向量坐标</strong>的变化。所以有如下关系：</p>
<script type="math/tex; mode=display">
\begin{array}{lll}\\
\boldsymbol x_p - \boldsymbol x_w
&=R(\boldsymbol x'_p - \boldsymbol{x'}_w)\\
&=R\boldsymbol x'_p-R\boldsymbol x'_w\\
&=R\boldsymbol x'_p-R(\boldsymbol x'_w -\boldsymbol x'_b)\\
&=R\boldsymbol x'_p - (\boldsymbol x_w-\boldsymbol x_b)\\
&=R\boldsymbol x'_p+\boldsymbol x_b \\
\end{array}
\tag{5}</script><p>同理：</p>
<script type="math/tex; mode=display">
\begin{array}{lll}\\
\boldsymbol x'_p - \boldsymbol x'_b
&=R^T(\boldsymbol x_p - \boldsymbol x_b)\\
&=R^T\boldsymbol x_p-R^T\boldsymbol x_b\\
&=R^T\boldsymbol x_p-R^T(\boldsymbol x_b -\boldsymbol x_w)\\
&=R^T\boldsymbol x_p - (\boldsymbol x'_b-\boldsymbol x'_w)\\
&=R^T\boldsymbol x_p+\boldsymbol x'_w \\
\end{array}
\tag{6}</script><p>所以刚体系到世界系，世界系到刚体系的点的坐标变换可以描述为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\boldsymbol x_p=R\boldsymbol x'_p+\boldsymbol x_b\\
\boldsymbol x'_p=R^T\boldsymbol x_p+\boldsymbol x'_w
\tag{7}
\end{array}
\right.</script><p>在式(5)中，我们可以看出，p点在世界系下的坐标等于，p点在刚体系下的坐标向量左乘旋转矩阵，再加上刚体系原点在世界系下的坐标向量。当然上述写法并不是线性变换，所以我们可以使用齐次坐标来表示，由(5)可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left[\begin{array}{c}
\mathbf{x} \\
1
\end{array}\right] &=\left[\begin{array}{cc}
R & \mathbf{x}_{b} \\
\mathbf{0}^{T} & 1
\end{array}\right]\left[\begin{array}{c}
\mathbf{x}^{\prime} \\
1
\end{array}\right] \\
&=\left[\begin{array}{cc}
R & -R \mathbf{x}_{w}^{\prime} \\
\mathbf{0}^{T} & 1
\end{array}\right]\left[\begin{array}{c}
\mathbf{x}^{\prime} \\
1
\end{array}\right]\\
&=T_{wb}\left[\begin{array}{c}
\mathbf{x}^{\prime} \\
1
\end{array}\right]
\end{aligned}\tag{8}</script><script type="math/tex; mode=display">
\begin{aligned}
\left[\begin{array}{c}
\mathbf{x}^{\prime} \\
1
\end{array}\right] &=\left[\begin{array}{cc}
R^T & \mathbf{x}_{w}^{\prime} \\
\mathbf{0}^{T} & 1
\end{array}\right]\left[\begin{array}{c}
\mathbf{x} \\
1
\end{array}\right] \\
&=\left[\begin{array}{cc}
R^T & -R^T \mathbf{x}_{b} \\
\mathbf{0}^{T} & 1
\end{array}\right]\left[\begin{array}{l}
\mathbf{x} \\
1
\end{array}\right]\\
&=T_{bw}\left[\begin{array}{l}
\mathbf{x} \\
1
\end{array}\right]
\end{aligned}\tag{9}</script><p>这里的矩阵 $T_{bw}$和 $T_{wb}$ 是欧式变换矩阵，它是一个四维的方阵，这样我们就可以把旋转和平移都写进一个矩阵里。这种矩阵称为<code>特殊欧式群（Special Euclidean Group）</code> ：</p>
<script type="math/tex; mode=display">
\mathrm{SE}(3)=\left\{T=\left[\begin{array}{ll}
\boldsymbol{R} & \boldsymbol{t} \\
\mathbf{0}^{\mathrm{T}} & 1
\end{array}\right] \in \mathbb{R}^{4 \times 4} \mid \boldsymbol{R} \in \mathrm{SO}(3), \boldsymbol{t} \in \mathbb{R}^{3}\right\}\tag{10}</script><p>该矩阵的逆表示一次反变换：</p>
<script type="math/tex; mode=display">
\boldsymbol{T}^{-1}=\left[\begin{array}{cc}
\boldsymbol{R}^{\mathrm{T}} & -\boldsymbol{R}^{\mathrm{T}} \boldsymbol{t} \\
\mathbf{0}^{\mathrm{T}} & 1
\end{array}\right]\tag{11}</script><h3 id="3-刚体的位姿"><a href="#3-刚体的位姿" class="headerlink" title="3. 刚体的位姿"></a>3. 刚体的位姿</h3><p>刚体的位姿包括刚体的位置和刚体的姿态角度。刚体的位置通常会用 $\boldsymbol x_b$ 来表示，它代表刚体坐标系的原点b在世界系下的坐标。同理也可以用 $\boldsymbol x_w’$ 来表示，两者的关系由(7)可知。</p>
<h3 id="4-绕单一坐标轴旋转"><a href="#4-绕单一坐标轴旋转" class="headerlink" title="4. 绕单一坐标轴旋转"></a>4. 绕单一坐标轴旋转</h3><p>当仅绕着某一坐标轴旋转时，它的旋转矩阵 $R_i\in SO(3)\quad \{i=1,2,3 \}$ 分别表示绕着x,y,z轴旋转。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&R_{1}(\alpha)=\left[\begin{array}{ccc}
1 & 0 & 0 \\
0 & \cos (\alpha) & \sin (\alpha) \\
0 & -\sin (\alpha) & \cos (\alpha)
\end{array}\right] \\
&R_{2}(\alpha)=\left[\begin{array}{ccc}
\cos (\alpha) & 0 & -\sin (\alpha) \\
0 & 1 & 0 \\
\sin (\alpha) & 0 & \cos (\alpha)
\end{array}\right] \\
&R_{3}(\alpha)=\left[\begin{array}{ccc}
\cos (\alpha) & \sin (\alpha) & 0 \\
-\sin (\alpha) & \cos (\alpha) & 0 \\
0 & 0 & 1
\end{array}\right]
\end{aligned}\tag{12}</script><h2 id="III-欧拉角"><a href="#III-欧拉角" class="headerlink" title="III. 欧拉角"></a>III. 欧拉角</h2><p>按照一定顺序绕坐标轴旋转三次可以描述空间中的任意定点旋转，因此我们可以定义三个角度来表示每一次旋转的度数，这三个角度就是欧拉角。</p>
<p>欧拉角的定义要有一定的顺序，不可以乱转。欧拉角的旋转顺序有一个限制，那就是任何两个连续的旋转，都必须绕着不同的转动轴旋转。因此一共有12种顺序规则：</p>
<ul>
<li>经典欧拉角：z-x-z, x-y-x, y-z-y, z-y-z, x-z-x, y-x-y</li>
<li>泰勒-布莱恩角：x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z</li>
</ul>
<p>另外还有一个要注意的是，根据每次绕的转轴是否是固定不动的，还将欧拉角分为<strong>内旋</strong>和<strong>外旋</strong>，也称为动态旋转轴和静态旋转轴。内旋就是绕刚体坐标系下的坐标轴来进行旋转，外旋是绕着世界坐标系下的坐标轴来旋转。</p>
<p>如下图是内旋转动，也就是动态欧拉角：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220713161225.gif" alt="欧拉角"></p>
<p>我们在航空熟知的偏航-俯仰-滚转角就是一组欧拉角，我们用$\boldsymbol u=[\phi,\theta,\psi]$来描述，它的旋转顺序是Z-Y-X，属于<strong>内旋转动</strong>(因为内旋，所以绕的坐标轴是一直变化的，所以我们用$i,j,k$ 来表示所绕的坐标轴，其中k是世界系下的z轴，j是刚体系的y轴，i是刚体系的x轴)。由该欧拉角可以得到一个旋转矩阵：</p>
<script type="math/tex; mode=display">
R_{i,j,k}(\phi,\theta,\psi)=R_i(\phi)R_j(\theta)R_k(\psi) \tag{13}</script><p>因此一个坐标为 $\boldsymbol{z} \in \mathbb{R}^{3}$ 的世界系下的向量，该向量在刚体系下的坐标为$\boldsymbol{z’} \in \mathbb{R}^{3}$ ，则有如下关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\mathbf{z}^{\prime}=R_{i j k}(\mathbf{u}) \mathbf{z} \\
&\mathbf{z}=R_{i j k}(\mathbf{u})^{T} \mathbf{z}^{\prime}
\end{aligned}\tag{14}</script><blockquote>
<p>如果定义的是外旋转动，旋转顺序Z-Y-X所对应的旋转矩阵和式(12)的相乘顺序正好相反。</p>
</blockquote>
<h2 id="IV-旋转向量"><a href="#IV-旋转向量" class="headerlink" title="IV. 旋转向量"></a>IV. 旋转向量</h2><p>在描述刚体绕一点旋转时，还可以用旋转向量(也叫做轴角/角轴)来描述。任意旋转都可以用一个旋转轴和旋转角来刻画。</p>
<p>我们用 $\boldsymbol n$ 向量来表示旋转轴，$\theta$ 表示旋转角度。这里的向量$\boldsymbol n$是单位向量，因此有两个自由度，算上角度，旋转向量的自由度也为3个。</p>
<p>旋转向量与旋转矩阵之间的关系可以由罗德里格斯公式得出：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}=\cos \theta \boldsymbol{I}+(1-\cos \theta) \boldsymbol{n} \boldsymbol{n}^{\mathrm{T}}+\sin \theta \boldsymbol{n}^{\wedge}\tag{15}</script><p>这里的 $n^{\wedge}$ 表示向量 $\boldsymbol n$ 的反对称矩阵。</p>
<p>对(14)两边矩阵取迹，有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\operatorname{tr}(\boldsymbol{R}) &=\cos \theta \operatorname{tr}(\boldsymbol{I})+(1-\cos \theta) \operatorname{tr}\left(\boldsymbol{n} \boldsymbol{n}^{\mathrm{T}}\right)+\sin \theta \operatorname{tr}\left(\boldsymbol{n}^{\wedge}\right) \\
&=3 \cos \theta+(1-\cos \theta) \\
&=1+2 \cos \theta
\end{aligned}\tag{16}</script><p>则可以知道旋转角为：</p>
<script type="math/tex; mode=display">
\theta=\arccos \frac{\operatorname{tr}(\boldsymbol{R})-1}{2}\tag{17}</script><p>对于旋转向量来说，它是旋转轴上的一个单位向量，所以有：</p>
<script type="math/tex; mode=display">
R \boldsymbol n=\boldsymbol n \tag{18}</script><p>因此转轴向量$\boldsymbol n$是旋转矩阵$R$ 特征值为1对应的特征向量。</p>
<h2 id="V-四元数"><a href="#V-四元数" class="headerlink" title="V. 四元数"></a>V. 四元数</h2><p>四元数的来源就不多说了，直接说怎么用。</p>
<p>四元数拥有一个实部和三个虚部。我们可以记为：</p>
<script type="math/tex; mode=display">
\boldsymbol{q}=q_{0}+q_{1} \mathrm{i}+{q}_{2} \mathrm{j}+{q}_{3} \mathrm{k}\\
\boldsymbol{q}=[s,\boldsymbol v]^T\quad s=q_0\in\mathbb R  \quad \boldsymbol v=[q_1,q_2,q_3]^T\in\mathbb{R}^3\tag{19}</script><p>如果实部为0，则我们称为纯虚四元数，我们接下来会用<strong>纯虚四元数来表示向量</strong>，<strong>单位四元数来表示旋转</strong>。</p>
<p>假设有一点p在世界系下的坐标为$\boldsymbol p\in \mathbb R^3$，在刚体系下的坐标为$\boldsymbol{p’}\in \mathbb R^3$ ，单位四元数$\boldsymbol q$ 表示指定的旋转，则有如下的关系：</p>
<script type="math/tex; mode=display">
\boldsymbol p^{\prime}=\boldsymbol q \boldsymbol p \boldsymbol q^{-1}\tag{20}</script><p>实际上四元数的乘法可以转化成矩阵的乘法，也就是说四元数在进行四元数乘法的时候，每一个四元数对应着一个矩阵，<strong>注意：四元数乘法对应着左乘和右乘</strong> ，因此一个四元数对应着<strong>左乘矩阵</strong>和<strong>右乘矩阵</strong>。</p>
<script type="math/tex; mode=display">
\boldsymbol{q}^{+}=\left[\begin{array}{cc}
s & -\boldsymbol{v}^{\mathrm{T}} \\
\boldsymbol{v} & s \boldsymbol{I}+\boldsymbol{v}^{\wedge}
\end{array}\right], \quad \boldsymbol{q}^{\oplus}=\left[\begin{array}{cc}
s & -\boldsymbol{v}^{\mathrm{T}} \\
\boldsymbol{v} & s \boldsymbol{I}-\boldsymbol{v}^{\wedge}
\end{array}\right]\tag{21}</script><p>式(21)中左边的是四元数 $\boldsymbol q$ 对应的左乘矩阵，右边的是四元数 $\boldsymbol q$ 对应的右乘矩阵。例如四元数 $\boldsymbol q_1 \boldsymbol q_2$ 相乘，等价于：</p>
<script type="math/tex; mode=display">
\boldsymbol{q}_{1}^{+} \boldsymbol{q}_{2}=\left[\begin{array}{cc}
s_{1} & -\boldsymbol{v}_{1}^{\mathrm{T}} \\
\boldsymbol{v}_{1} & s_{1} \boldsymbol{I}+\boldsymbol{v}_{1}^{\wedge}
\end{array}\right]\left[\begin{array}{l}
s_{2} \\
\boldsymbol{v}_{2}
\end{array}\right]=\left[\begin{array}{c}
-\boldsymbol{v}_{1}^{\mathrm{T}} \boldsymbol{v}_{2}+s_{1} s_{2} \\
s_{1} \boldsymbol{v}_{2}+s_{2} \boldsymbol{v}_{1}+\boldsymbol{v}_{1}^{\wedge} \boldsymbol{v}_{2}
\end{array}\right]=\boldsymbol{q}_{1} \boldsymbol{q}_{2}\tag{22}</script><p>还可以写为：</p>
<script type="math/tex; mode=display">
\boldsymbol{q}_{1} \boldsymbol{q}_{2}=\boldsymbol{q}_{1}^{+} \boldsymbol{q}_{2}=\boldsymbol{q}_{2}^{\oplus} \boldsymbol{q}_{1}\tag{23}</script><p>对于单位四元数对空间点进行坐标变换的问题，有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{p}^{\prime} &=\boldsymbol{q} \boldsymbol{p} \boldsymbol{q}^{-1}=\boldsymbol{q}^{+} \boldsymbol{p}^{+} \boldsymbol{q}^{-1} \\
&=\boldsymbol{q}^{+} \boldsymbol{q}^{-1^{\oplus}} \boldsymbol{p}\\
&= \boldsymbol{q}^{-1^{\oplus}}(\boldsymbol{q}^{+}\boldsymbol{p})
\end{aligned}\tag{24}</script><p>由(24)可得：</p>
<script type="math/tex; mode=display">
\boldsymbol{q}^{+}\left(\boldsymbol{q}^{-1}\right)^{\oplus}=\left[\begin{array}{cc}
s & -\boldsymbol{v}^{\mathrm{T}} \\
\boldsymbol{v} & s \boldsymbol{I}+\boldsymbol{v}^{\wedge}
\end{array}\right]\left[\begin{array}{cc}
s & \boldsymbol{v}^{\mathrm{T}} \\
-\boldsymbol{v} & s \boldsymbol{I}+\boldsymbol{v}^{\wedge}
\end{array}\right]=\left[\begin{array}{cc}
1 & \mathbf{0} \\
\mathbf{0}^{\mathrm{T}} & \boldsymbol{v} \boldsymbol{v}^{\mathrm{T}}+s^{2} \boldsymbol{I}+2 s \boldsymbol{v}^{\wedge}+\left(\boldsymbol{v}^{\wedge}\right)^{2}
\end{array}\right]\tag{25}</script><p>所以可得到旋转矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}=\boldsymbol{v} \boldsymbol{v}^{\mathrm{T}}+s^{2} \boldsymbol{I}+2 s \boldsymbol{v}^{\wedge}+\left(\boldsymbol{v}^{\wedge}\right)^{2}\tag{26}\\</script><p>对于旋转向量：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\theta=2 \arccos q_{0} \\
{\left[n_{x}, n_{y}, n_{z}\right]^{\mathrm{T}}=\left[q_{1}, q_{2}, q_{3}\right]^{\mathrm{T}} / \sin \frac{\theta}{2}}
\end{array}\right. \tag{27}</script>]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM4】Eigen库的使用</title>
    <url>/2022/07/13/%E3%80%90%E8%A7%86%E8%A7%89SLAM4%E3%80%91Eigen%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Eigen是一个C++开源线性代数库，与其他的库相比，它是一个纯用头文件搭建起来的库。</p>
<p><a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">官网主页</a></p>
<span id="more"></span>
<p>在Ubuntu软件源中安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libeigen3-dev</span><br></pre></td></tr></table></figure>
<h2 id="I-关于矩阵使用"><a href="#I-关于矩阵使用" class="headerlink" title="I. 关于矩阵使用"></a>I. 关于矩阵使用</h2><p>代码示例：</p>
<p><code>slambook2/ch3/useEigen/eigenMatrix.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen 核心部分</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稠密矩阵计算的代数运算（逆、特征值）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment">* 本程序演示了 Eigen 基本类型的使用</span></span><br><span class="line"><span class="comment">****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Eigen 中所有向量和矩阵都是Eigen::Matrix，它是一个模板类。它的前三个参数为：数据类型，行，列</span></span><br><span class="line">  <span class="comment">// 声明一个2*3的float矩阵</span></span><br><span class="line">  Matrix&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">3</span>&gt; matrix_23;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同时，Eigen 通过 typedef 提供了许多内置类型，不过底层仍是Eigen::Matrix</span></span><br><span class="line">  <span class="comment">// 例如 Vector3d 实质上是 Eigen::Matrix&lt;double, 3, 1&gt;，即三维向量</span></span><br><span class="line">  Vector3d v_3d;</span><br><span class="line">  <span class="comment">// 这是一样的</span></span><br><span class="line">  Matrix&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">1</span>&gt; vd_3d;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Matrix3d 实质上是 Eigen::Matrix&lt;double, 3, 3&gt;</span></span><br><span class="line">  Matrix3d matrix_33 = Matrix3d::<span class="built_in">Zero</span>(); <span class="comment">//初始化为零</span></span><br><span class="line">  <span class="comment">// 如果不确定矩阵大小，可以使用动态大小的矩阵</span></span><br><span class="line">  Matrix&lt;<span class="keyword">double</span>, Dynamic, Dynamic&gt; matrix_dynamic;</span><br><span class="line">  <span class="comment">// 更简单的</span></span><br><span class="line">  MatrixXd matrix_x;</span><br><span class="line">  <span class="comment">// 这种类型还有很多，我们不一一列举</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是对Eigen阵的操作</span></span><br><span class="line">  <span class="comment">// 输入数据（初始化）</span></span><br><span class="line">  matrix_23 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;matrix 2x3 from 1 to 6: \n&quot;</span> &lt;&lt; matrix_23 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用()访问矩阵中的元素</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;print matrix 2x3: &quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) cout &lt;&lt; <span class="built_in">matrix_23</span>(i, j) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 矩阵和向量相乘（实际上仍是矩阵和矩阵）</span></span><br><span class="line">  v_3d &lt;&lt; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>;</span><br><span class="line">  vd_3d &lt;&lt; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是在Eigen里你不能混合两种不同类型的矩阵，像这样是错的</span></span><br><span class="line">  <span class="comment">// Matrix&lt;double, 2, 1&gt; result_wrong_type = matrix_23 * v_3d;</span></span><br><span class="line">  <span class="comment">// 应该显式转换</span></span><br><span class="line">  Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">1</span>&gt; result = matrix_23.cast&lt;<span class="keyword">double</span>&gt;() * v_3d;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;[1,2,3;4,5,6]*[3,2,1]=&quot;</span> &lt;&lt; result.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  Matrix&lt;<span class="keyword">float</span>, <span class="number">2</span>, <span class="number">1</span>&gt; result2 = matrix_23 * vd_3d;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;[1,2,3;4,5,6]*[4,5,6]: &quot;</span> &lt;&lt; result2.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同样你不能搞错矩阵的维度</span></span><br><span class="line">  <span class="comment">// 试着取消下面的注释，看看Eigen会报什么错</span></span><br><span class="line">  <span class="comment">// Eigen::Matrix&lt;double, 2, 3&gt; result_wrong_dimension = matrix_23.cast&lt;double&gt;() * v_3d;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一些矩阵运算</span></span><br><span class="line">  <span class="comment">// 四则运算就不演示了，直接用+-*/即可。</span></span><br><span class="line">  matrix_33 = Matrix3d::<span class="built_in">Random</span>();      <span class="comment">// 随机数矩阵</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;random matrix: \n&quot;</span> &lt;&lt; matrix_33 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;transpose: \n&quot;</span> &lt;&lt; matrix_33.<span class="built_in">transpose</span>() &lt;&lt; endl;      <span class="comment">// 转置</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; matrix_33.<span class="built_in">sum</span>() &lt;&lt; endl;            <span class="comment">// 各元素和</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; matrix_33.<span class="built_in">trace</span>() &lt;&lt; endl;          <span class="comment">// 迹</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;times 10: \n&quot;</span> &lt;&lt; <span class="number">10</span> * matrix_33 &lt;&lt; endl;               <span class="comment">// 数乘</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;inverse: \n&quot;</span> &lt;&lt; matrix_33.<span class="built_in">inverse</span>() &lt;&lt; endl;        <span class="comment">// 逆</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;det: &quot;</span> &lt;&lt; matrix_33.<span class="built_in">determinant</span>() &lt;&lt; endl;    <span class="comment">// 行列式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 特征值</span></span><br><span class="line">  <span class="comment">// 实对称矩阵可以保证对角化成功</span></span><br><span class="line">  <span class="function">SelfAdjointEigenSolver&lt;Matrix3d&gt; <span class="title">eigen_solver</span><span class="params">(matrix_33.transpose() * matrix_33)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Eigen values = \n&quot;</span> &lt;&lt; eigen_solver.<span class="built_in">eigenvalues</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Eigen vectors = \n&quot;</span> &lt;&lt; eigen_solver.<span class="built_in">eigenvectors</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解方程</span></span><br><span class="line">  <span class="comment">// 我们求解 matrix_NN * x = v_Nd 这个方程</span></span><br><span class="line">  <span class="comment">// N的大小在前边的宏里定义，它由随机数生成</span></span><br><span class="line">  <span class="comment">// 直接求逆自然是最直接的，但是求逆运算量大</span></span><br><span class="line"></span><br><span class="line">  Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, MATRIX_SIZE&gt; matrix_NN</span><br><span class="line">      = MatrixXd::<span class="built_in">Random</span>(MATRIX_SIZE, MATRIX_SIZE);</span><br><span class="line">  matrix_NN = matrix_NN * matrix_NN.<span class="built_in">transpose</span>();  <span class="comment">// 保证半正定</span></span><br><span class="line">  Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; v_Nd = MatrixXd::<span class="built_in">Random</span>(MATRIX_SIZE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">clock_t</span> time_stt = <span class="built_in">clock</span>(); <span class="comment">// 计时</span></span><br><span class="line">  <span class="comment">// 直接求逆</span></span><br><span class="line">  Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x = matrix_NN.<span class="built_in">inverse</span>() * v_Nd;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of normal inverse is &quot;</span></span><br><span class="line">       &lt;&lt; <span class="number">1000</span> * (<span class="built_in">clock</span>() - time_stt) / (<span class="keyword">double</span>) CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通常用矩阵分解来求，例如QR分解，速度会快很多</span></span><br><span class="line">  time_stt = <span class="built_in">clock</span>();</span><br><span class="line">  x = matrix_NN.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(v_Nd);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of Qr decomposition is &quot;</span></span><br><span class="line">       &lt;&lt; <span class="number">1000</span> * (<span class="built_in">clock</span>() - time_stt) / (<span class="keyword">double</span>) CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于正定矩阵，还可以用cholesky分解来解方程</span></span><br><span class="line">  time_stt = <span class="built_in">clock</span>();</span><br><span class="line">  x = matrix_NN.<span class="built_in">ldlt</span>().<span class="built_in">solve</span>(v_Nd);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of ldlt decomposition is &quot;</span></span><br><span class="line">       &lt;&lt; <span class="number">1000</span> * (<span class="built_in">clock</span>() - time_stt) / (<span class="keyword">double</span>) CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li><p>Eigen中的矩阵的数据类型必须一致，它不能隐性的进行数据转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">double</span>,<span class="number">3</span>,<span class="number">3</span>&gt; matrix33d;	</span><br><span class="line">Matrix&lt;<span class="keyword">float</span>,<span class="number">3</span>,<span class="number">3</span>&gt; matrix33f = matrix33d.cast&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵的维度必须对应好，否则也会报错。</p>
</li>
<li><p>因为是纯头文件搭建的库，所以仅需在 <code>CMakeLists.txt</code> 中添加：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;usr/include/eigen3&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在编译时就已知大小的矩阵要比动态矩阵处理起来快。</p>
</li>
</ol>
<h2 id="II-几何模块"><a href="#II-几何模块" class="headerlink" title="II. 几何模块"></a>II. 几何模块</h2><p>实际操作各种旋转，与旋转有关的类有：</p>
<ul>
<li>旋转矩阵（3*3）：<code>Eigen::Matrix3d</code></li>
<li>旋转向量（3*1）：<code>Eigen::AngleAxisd</code></li>
<li>欧拉角（3*1）：<code>Eigen::Vector3d</code></li>
<li>四元数（4*1）：<code>Eigen::Quaterniond</code></li>
<li>欧式变换矩阵（4*4）：<code>Eigen::Isometry3d</code></li>
<li>仿射变换（4*4）：<code>Eigen::Affine3d</code></li>
<li>射影变换（4*4）：<code>Eigen::Projective3d</code></li>
</ul>
<p>代码示例：</p>
<p><code>slambook2/ch3/useGeometry/useGeometry.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本程序演示了 Eigen 几何模块的使用方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eigen/Geometry 模块提供了各种旋转和平移的表示</span></span><br><span class="line">  <span class="comment">// 3D 旋转矩阵直接使用 Matrix3d 或 Matrix3f</span></span><br><span class="line">  Matrix3d rotation_matrix = Matrix3d::<span class="built_in">Identity</span>();</span><br><span class="line">  <span class="comment">// 旋转向量使用 AngleAxis, 它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符）</span></span><br><span class="line">  <span class="function">AngleAxisd <span class="title">rotation_vector</span><span class="params">(M_PI / <span class="number">4</span>, Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span></span>;     <span class="comment">//沿 Z 轴旋转 45 度</span></span><br><span class="line">  cout.<span class="built_in">precision</span>(<span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;rotation matrix =\n&quot;</span> &lt;&lt; rotation_vector.<span class="built_in">matrix</span>() &lt;&lt; endl;   <span class="comment">//用matrix()转换成矩阵</span></span><br><span class="line">  <span class="comment">// 也可以直接赋值</span></span><br><span class="line">  rotation_matrix = rotation_vector.<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">  <span class="comment">// 用 AngleAxis 可以进行坐标变换</span></span><br><span class="line">  <span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  Vector3d v_rotated = rotation_vector * v;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;(1,0,0) after rotation (by angle axis) = &quot;</span> &lt;&lt; v_rotated.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 或者用旋转矩阵</span></span><br><span class="line">  v_rotated = rotation_matrix * v;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;(1,0,0) after rotation (by matrix) = &quot;</span> &lt;&lt; v_rotated.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 欧拉角: 可以将旋转矩阵直接转换成欧拉角</span></span><br><span class="line">  Vector3d euler_angles = rotation_matrix.<span class="built_in">eulerAngles</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// ZYX顺序，即yaw-pitch-roll顺序</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;yaw pitch roll = &quot;</span> &lt;&lt; euler_angles.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 欧氏变换矩阵使用 Eigen::Isometry</span></span><br><span class="line">  Isometry3d T = Isometry3d::<span class="built_in">Identity</span>();                <span class="comment">// 虽然称为3d，实质上是4＊4的矩阵</span></span><br><span class="line">  T.<span class="built_in">rotate</span>(rotation_vector);                                     <span class="comment">// 按照rotation_vector进行旋转</span></span><br><span class="line">  T.<span class="built_in">pretranslate</span>(<span class="built_in">Vector3d</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>));                     <span class="comment">// 把平移向量设成(1,3,4)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Transform matrix = \n&quot;</span> &lt;&lt; T.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用变换矩阵进行坐标变换</span></span><br><span class="line">  Vector3d v_transformed = T * v;                              <span class="comment">// 相当于R*v+t</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v tranformed = &quot;</span> &lt;&lt; v_transformed.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于仿射和射影变换，使用 Eigen::Affine3d 和 Eigen::Projective3d 即可，略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 四元数</span></span><br><span class="line">  <span class="comment">// 可以直接把AngleAxis赋值给四元数，反之亦然</span></span><br><span class="line">  Quaterniond q = <span class="built_in">Quaterniond</span>(rotation_vector);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;quaternion from rotation vector = &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>().<span class="built_in">transpose</span>()</span><br><span class="line">       &lt;&lt; endl;   <span class="comment">// 请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部</span></span><br><span class="line">  <span class="comment">// 也可以把旋转矩阵赋给它</span></span><br><span class="line">  q = <span class="built_in">Quaterniond</span>(rotation_matrix);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;quaternion from rotation matrix = &quot;</span> &lt;&lt; q.<span class="built_in">coeffs</span>().<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 使用四元数旋转一个向量，使用重载的乘法即可</span></span><br><span class="line">  v_rotated = q * v; <span class="comment">// 注意数学上是qvq^&#123;-1&#125;</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;(1,0,0) after rotation = &quot;</span> &lt;&lt; v_rotated.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 用常规向量乘法表示，则应该如下计算</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;should be equal to &quot;</span> &lt;&lt; (q * <span class="built_in">Quaterniond</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) * q.<span class="built_in">inverse</span>()).<span class="built_in">coeffs</span>().<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>通过运算符重载，四元数和三维向量可以直接计算乘法，但在数学上则需要先把三维向量转成纯虚四元数。在程序中，也可以用数学上定义的变换方式进行坐标变换。</li>
<li>欧式变换矩阵也可以直接和三维向量相乘。</li>
<li>四元数在使用前要进行归一化，<code>q.normalize()</code></li>
</ol>
<h2 id="III-显示运动轨迹"><a href="#III-显示运动轨迹" class="headerlink" title="III. 显示运动轨迹"></a>III. 显示运动轨迹</h2><p>我们现在想要画出相机运动的轨迹，也就是相机在世界坐标系下的位姿。刚体坐标系下的原点在世界系下的坐标变换如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left[\begin{array}{c}
\mathbf{x} \\
1
\end{array}\right] &=T_{wb}\left[\begin{array}{c}
\mathbf{x}^{\prime} \\
1
\end{array}\right] \\
&=\left[\begin{array}{cc}
R & \mathbf{x}_{b} \\
\mathbf{0}^{T} & 1
\end{array}\right]
\left[\begin{array}{c}
\mathbf{x}^{\prime} \\
1
\end{array}\right]\\
&=\left[\begin{array}{cc}
R & \mathbf{x}_{b} \\
\mathbf{0}^{T} & 1
\end{array}\right]\left[\begin{array}{c}
0\\0\\0\\
1
\end{array}\right]\\
&=\left[\begin{array}{c}
\mathbf{x}_b\\
1
\end{array}\right]

\end{aligned}</script><p>事实上，<strong>相机在世界系下的位置就是与其固联的刚体坐标系原点在世界坐标系下的坐标。</strong>所以我们可以直接在 $T_{wb}$ 中看出相机的位置。因此用  $T_{wb}$ 描述变换更加直观。</p>
<p>因此我们提前存储了相机的位姿，存储的格式为：</p>
<script type="math/tex; mode=display">
time, t_x,t_y,t_z,q_x,q_y,q_z,q_w</script><p>这里的 $[t_x,t_y,t_z]^T$ 就是 $ \mathbf{x}_{b}$ 向量。</p>
<p>我们使用<code>Pangolin</code>库来进行可视化。</p>
<p>代码示例：</p>
<p><code>slambook2/ch3/useGeometry/plotTrajectory.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pangolin/pangolin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本例演示了如何画出一个预先存储的轨迹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path to trajectory file</span></span><br><span class="line">string trajectory_file = <span class="string">&quot;./examples/trajectory.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTrajectory</span><span class="params">(vector&lt;Isometry3d, Eigen::aligned_allocator&lt;Isometry3d&gt;&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;Isometry3d, Eigen::aligned_allocator&lt;Isometry3d&gt;&gt; poses;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(trajectory_file)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!fin) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cannot find trajectory file at &quot;</span> &lt;&lt; trajectory_file &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!fin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    <span class="keyword">double</span> time, tx, ty, tz, qx, qy, qz, qw;</span><br><span class="line">    fin &gt;&gt; time &gt;&gt; tx &gt;&gt; ty &gt;&gt; tz &gt;&gt; qx &gt;&gt; qy &gt;&gt; qz &gt;&gt; qw;</span><br><span class="line">    <span class="function">Isometry3d <span class="title">Twr</span><span class="params">(Quaterniond(qw, qx, qy, qz))</span></span>;</span><br><span class="line">    Twr.<span class="built_in">pretranslate</span>(<span class="built_in">Vector3d</span>(tx, ty, tz));</span><br><span class="line">    poses.<span class="built_in">push_back</span>(Twr);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;read total &quot;</span> &lt;&lt; poses.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; pose entries&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// draw trajectory in pangolin</span></span><br><span class="line">  <span class="built_in">DrawTrajectory</span>(poses);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTrajectory</span><span class="params">(vector&lt;Isometry3d, Eigen::aligned_allocator&lt;Isometry3d&gt;&gt; poses)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// create pangolin window and plot the trajectory</span></span><br><span class="line">  pangolin::<span class="built_in">CreateWindowAndBind</span>(<span class="string">&quot;Trajectory Viewer&quot;</span>, <span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">  <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">  <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line">  <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"></span><br><span class="line">  <span class="function">pangolin::OpenGlRenderState <span class="title">s_cam</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pangolin::ProjectionMatrix(<span class="number">1024</span>, <span class="number">768</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">512</span>, <span class="number">389</span>, <span class="number">0.1</span>, <span class="number">1000</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    pangolin::ModelViewLookAt(<span class="number">0</span>, <span class="number">-0.1</span>, <span class="number">-1.8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line"></span><br><span class="line">  pangolin::View &amp;d_cam = pangolin::<span class="built_in">CreateDisplay</span>()</span><br><span class="line">    .<span class="built_in">SetBounds</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">-1024.0f</span> / <span class="number">768.0f</span>)</span><br><span class="line">    .<span class="built_in">SetHandler</span>(<span class="keyword">new</span> pangolin::<span class="built_in">Handler3D</span>(s_cam));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (pangolin::<span class="built_in">ShouldQuit</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    d_cam.<span class="built_in">Activate</span>(s_cam);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; poses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">// 画每个位姿的三个坐标轴</span></span><br><span class="line">      Vector3d Ow = poses[i].<span class="built_in">translation</span>();</span><br><span class="line">      Vector3d Xw = poses[i] * (<span class="number">0.1</span> * <span class="built_in">Vector3d</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">      Vector3d Yw = poses[i] * (<span class="number">0.1</span> * <span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">      Vector3d Zw = poses[i] * (<span class="number">0.1</span> * <span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">      <span class="built_in">glBegin</span>(GL_LINES);</span><br><span class="line">      <span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(Ow[<span class="number">0</span>], Ow[<span class="number">1</span>], Ow[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(Xw[<span class="number">0</span>], Xw[<span class="number">1</span>], Xw[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(Ow[<span class="number">0</span>], Ow[<span class="number">1</span>], Ow[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(Yw[<span class="number">0</span>], Yw[<span class="number">1</span>], Yw[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(Ow[<span class="number">0</span>], Ow[<span class="number">1</span>], Ow[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(Zw[<span class="number">0</span>], Zw[<span class="number">1</span>], Zw[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画出连线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; poses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">      <span class="built_in">glBegin</span>(GL_LINES);</span><br><span class="line">      <span class="keyword">auto</span> p1 = poses[i], p2 = poses[i + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">glVertex3d</span>(p1.<span class="built_in">translation</span>()[<span class="number">0</span>], p1.<span class="built_in">translation</span>()[<span class="number">1</span>], p1.<span class="built_in">translation</span>()[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(p2.<span class="built_in">translation</span>()[<span class="number">0</span>], p2.<span class="built_in">translation</span>()[<span class="number">1</span>], p2.<span class="built_in">translation</span>()[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pangolin::<span class="built_in">FinishFrame</span>();</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">5000</span>);   <span class="comment">// sleep 5 ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机视觉】北邮机器视觉学习笔记</title>
    <url>/2021/10/18/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91%E5%8C%97%E9%82%AE%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习北邮鲁鹏老师《机器视觉》课程笔记。<br><span id="more"></span></p>
<h1 id="0-绪论"><a href="#0-绪论" class="headerlink" title="0.绪论"></a>0.绪论</h1><h2 id="0-1课程介绍"><a href="#0-1课程介绍" class="headerlink" title="0.1课程介绍"></a>0.1课程介绍</h2><p>本课程是斯坦福大学的课程，鲁鹏老师搬运发扬光大。北邮的计算机视觉有研究生和本科两版，本笔记是研究生版。</p>
<p><strong>CS131:Computer Vision:Foundations and Applications</strong></p>
<p>主要介绍了计算机视觉的基础（2012年之前的基础技术方法思路）对应的是北邮本科生的机器视觉课程。</p>
<p><strong>CS231a:Computer Vision,from 3D Reconstruction, segmentation, object recognition</strong></p>
<p>本课程主要介绍了三维重建的相关内容。</p>
<p><strong>CS230:Deep Learning</strong></p>
<p>吴恩达教授的深度学习课程。</p>
<p><strong>CS231n:Convolutional Neural NetWorks for Visual Recognition</strong></p>
<p>2012年以后以卷积神经网络为主的计算机视觉技术，也就是本课程的来源。</p>
<p>本课程具体内容：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000408.png" alt="image-20210914030924958" style="zoom: 67%;" /></p>
<h2 id="0-2什么是计算机视觉和机器视觉"><a href="#0-2什么是计算机视觉和机器视觉" class="headerlink" title="0.2什么是计算机视觉和机器视觉"></a>0.2什么是计算机视觉和机器视觉</h2><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000412.png" alt="image-20210914020613321" style="zoom:50%;" /></p>
<p>对于我们人类来说，我们可以看到一只小狗并知道它是一只小狗，需要以下过程，如上图所示，我们的眼睛先获取光源，在我们的视网膜上成像，然后视网膜上的信号传入到大脑，大脑进行分析，最终解释出这是一只小狗。</p>
<p>计算机视觉也同样是这个道理，由照相机捕获光源，得到图片，然后通过计算机处理计算解释出语义。</p>
<p>另外我们经常可以听到计算机视觉和机器视觉两个概念。实际上，计算机视觉和机器视觉所使用的技术都是相同的，但是用途上有一些区别。机器视觉主要是应用在机器系统上，例如机器人。而计算机视觉应用广泛，如网络上的图像分类，人脸识别等都是计算机视觉。</p>
<h2 id="0-3计算机视觉的目标"><a href="#0-3计算机视觉的目标" class="headerlink" title="0.3计算机视觉的目标"></a>0.3计算机视觉的目标</h2><p>照相机拍出来的图片在计算机上是以矩阵的形式表示的。每个像素点对应着矩阵中的一个元素，如果图片是黑白的，那么该元素就记录着对应像素点的灰度值，如果是彩色的，那么该元素就记录着对应像素点的彩色值（RGB值）。</p>
<p>具体可以如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000419.png" alt="image-20210914021716001" style="zoom:50%;" /></p>
<p>可以看出，计算机“看到”的是一个矩阵，这个矩阵人类是看不懂的。也就是用人类的大脑来处理计算机看到的东西，是理解不了的，所以就要用计算机的方式来处理。那么就引出了计算机视觉的目标：<strong>跨越语义鸿沟，建立像素到语义的映射。</strong></p>
<p>例如，当计算机看到这个矩阵时，就知道这是一个出轨的火车。</p>
<p>那么一张图像中究竟有什么信息呢？这大致分为两类信息：</p>
<ul>
<li>空间结构信息</li>
<li>语义信息</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000430.png" alt="image-20210914025224068"></p>
<p>计算机视觉的目标还可以理解为，从图像上获取这两类信息。</p>
<h2 id="0-4计算机视觉的历史"><a href="#0-4计算机视觉的历史" class="headerlink" title="0.4计算机视觉的历史"></a>0.4计算机视觉的历史</h2><ul>
<li><strong>1959年，Hubel 和 Wiesel</strong> </li>
</ul>
<p>两个人率先做了一个实验，让一只小猫来看各种各样的图片，来看小猫的大脑哪个地方来处理这个信号。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000519.png" alt="image-20210914022941515" style="zoom:50%;" /></p>
<p>当给猫看到鱼的图片时，发现小猫的大脑并没有什么反应。看其他的东西的时候，也是没有反应。</p>
<p>但当给小猫看一些简单的图形时，如直线，点，此时小猫的大脑皮层是有反应的。</p>
<p>因此他们得到了一个结论，就是人类视觉系统处理信息是分层的，处理图片的时候是从最简单的图形开始，如图片中物体的边沿。他们的这项工作后来获得了诺贝尔医学奖。</p>
<ul>
<li><strong>1963，Larry Roberts</strong></li>
</ul>
<p>从图片中计算出三维实体。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000523.png" alt="image-20210914023806789" style="zoom:67%;" /></p>
<ul>
<li><strong>1966，MIT暑期视觉项目</strong></li>
</ul>
<p>将计算机视觉和图像处理独立出来。</p>
<ul>
<li><strong>David Marr</strong></li>
</ul>
<p>计算机视觉的先驱，成为计算机视觉之父。</p>
<p>他将计算机问题分为三个层次：</p>
<p>计算理论：计算的目的是什么，该问题的已知和可以施加的约束是什么。</p>
<p>表达和算法：输入、输出和中间信息是如何表达的。使用哪些算法来计算所期望的结果。</p>
<p>硬件实现：表达和算法是如何映射到实际硬件上来进行处理的。</p>
<p>然后他又将视觉表达分为了三个阶段</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000528.png" alt="image-20210914024901001" style="zoom:67%;" /></p>
<p>输入一个图像，先提取出边缘图，然后到2.5D的简图，最后再恢复出3D图。</p>
<ul>
<li><strong>后续的研究</strong></li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000531.png" alt="image-20210914025049485"></p>
<h2 id="0-5计算机视觉的应用"><a href="#0-5计算机视觉的应用" class="headerlink" title="0.5计算机视觉的应用"></a>0.5计算机视觉的应用</h2><ul>
<li><p>动画产业</p>
</li>
<li><p>三维建模</p>
</li>
<li><p>摄影</p>
</li>
<li><p>生物识别（如人脸识别，指纹识别）</p>
</li>
<li><p>光学字符识别（OCR）</p>
</li>
<li><p>机器人和无人驾驶</p>
</li>
<li><p>增强现实</p>
</li>
<li><p>医学图像</p>
<p>……</p>
</li>
</ul>
<h2 id="0-6计算机视觉和其他学科的关系"><a href="#0-6计算机视觉和其他学科的关系" class="headerlink" title="0.6计算机视觉和其他学科的关系"></a>0.6计算机视觉和其他学科的关系</h2><p>此处就要放一张神图了</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000536.png" alt="image-20210914030046225"></p>
<p>计算机视觉和许多学科都有着密不可分的关系。如上图所示。</p>
<p><strong>物理学</strong>：光学传感器的研究设计为计算机视觉提供了图片输入。而图像处理领域也是为计算机视觉提供输入，可以先将照相机拍下来的图片进行预处理。</p>
<p><strong>生物学</strong>：该学科主要通过研究人类的大脑来为计算机视觉的研究提供启发。</p>
<p><strong>计算机科学</strong>：计算机科学为计算机视觉提供方法。如机器学习的方法。</p>
<p><strong>工程学</strong>：给计算机视觉提供应用平台，如计算机视觉可以应用在机器人上，可以用在语义识别上。</p>
<h1 id="1-分类问题"><a href="#1-分类问题" class="headerlink" title="1.分类问题"></a>1.分类问题</h1><h2 id="1-0介绍"><a href="#1-0介绍" class="headerlink" title="1.0介绍"></a>1.0介绍</h2><h3 id="1-0-1什么是图像分类任务"><a href="#1-0-1什么是图像分类任务" class="headerlink" title="1.0.1什么是图像分类任务"></a>1.0.1什么是图像分类任务</h3><p>图像分类任务是计算机视觉中的核心任务，目的是根据图像内容的不同，将图像分为不同的类别。</p>
<p>就是在已知类别标签集合的时候，为给定的输入图片选定一个类别标签。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000541.png" alt="image-20210914031800065"></p>
<h3 id="1-0-2分类任务的难点"><a href="#1-0-2分类任务的难点" class="headerlink" title="1.0.2分类任务的难点"></a>1.0.2分类任务的难点</h3><p>（1）语义鸿沟</p>
<p>跨越语义鸿沟是十分困难的。</p>
<p>（2）视角</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000548.png" alt="image-20210914032031443"></p>
<p>（3）光照</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000633.png" alt="image-20210914032109767"></p>
<p>（4）遮挡</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000630.png" alt="image-20210914032229114"></p>
<p>（5）多形态</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000638.png" alt="image-20210914032301581"></p>
<p>（6）背景杂波</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000641.png" alt="image-20210914032348744" style="zoom:67%;" /></p>
<p>（7）类内形变</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000645.png" alt="image-20210914032430556" style="zoom: 67%;" /></p>
<p>（8）运动模糊</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000651.png" alt="image-20210914032859717" style="zoom: 67%;" /></p>
<p>（9）尺度</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000649.png" alt="image-20210914032931255"></p>
<p>（10）种类众多</p>
<p>成百上千种类别很难区分开来。</p>
<h3 id="1-0-3数据驱动的图像分类方法"><a href="#1-0-3数据驱动的图像分类方法" class="headerlink" title="1.0.3数据驱动的图像分类方法"></a>1.0.3数据驱动的图像分类方法</h3><p>如果基于规则的方法，先进行边缘检测，找到角点，然后计算特征，这是很难实现的。比如一只猫，形态各异，不可能有一个确定的特征，若分为多个特征，那么如此巨大数量的特征，是不可能实现的。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000700.png" alt="image-20210914033722773" style="zoom:67%;" /></p>
<p>所以就要采用数据驱动的方法，通过机器学习来完成。</p>
<h4 id="a-数据驱动分类器的结构"><a href="#a-数据驱动分类器的结构" class="headerlink" title="a.数据驱动分类器的结构"></a>a.数据驱动分类器的结构</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000708.png" alt="image-20210914033547955"></p>
<p>一个数据驱动分类器的结构如上图所示，数据驱动分类器就是需要通过数据训练才能设计出一个分类器。</p>
<h4 id="b-分类器设计过程（有监督条件下）"><a href="#b-分类器设计过程（有监督条件下）" class="headerlink" title="b.分类器设计过程（有监督条件下）"></a>b.分类器设计过程（有监督条件下）</h4><p>在整个分类器的设计中，首先我们要有一个分类器模型，然后使用该模型对输入图像进行预测，得到预测值，再将该预测值和该图像在数据集中对应的真实值进行对比，来计算出损失函数得到损失值。再依据损失值来进行优化，使分类模型的参数得到更新。如此往复，直到所得到的分类器性能达到要求为止。</p>
<p>设计一个分类器，最关键的步骤就是设计分类模型、损失函数和训练过程。</p>
<p>常用的分类模型在后面（2）中列出。损失函数在（3）中列出。</p>
<p>而训练过程比较复杂，包括了训练要用到的数据集的划分，数据的预处理，数据增强，欠拟合和过拟合，超参数调整等问题。在后面会一一说明。</p>
<p>（1）图像表示</p>
<ul>
<li>像素表示（一般该方法就可以）</li>
<li>全局特征表示（如GIST）</li>
<li>局部特征表示（如SIFT特征+词袋模型）</li>
</ul>
<p>（2）分类模型</p>
<ul>
<li>近邻分类器</li>
<li>贝叶斯分类器</li>
<li><u>线性分类器</u></li>
<li>支撑向量机分类器</li>
<li><u>神经网络分类器</u></li>
<li>随机森林</li>
</ul>
<p>（3）损失函数</p>
<ul>
<li>0-1损失</li>
<li>多类支撑向量机损失</li>
<li>交叉熵损失</li>
</ul>
<p>（4）优化方法</p>
<p>一阶优化方法</p>
<ul>
<li>梯度下降</li>
<li>随机梯度下降</li>
<li>小批量随机梯度下降</li>
</ul>
<p>二阶方法</p>
<ul>
<li>牛顿法</li>
<li>BFGS</li>
<li>L-BFGS</li>
</ul>
<h3 id="1-0-4数据集介绍"><a href="#1-0-4数据集介绍" class="headerlink" title="1.0.4数据集介绍"></a>1.0.4数据集介绍</h3><p>CIFAR10数据集：包含50000张训练样本，10000张测试样本，共有10个类别的彩色图像，每张图像的大小是32*32。</p>
<h2 id="1-1线性分类器"><a href="#1-1线性分类器" class="headerlink" title="1.1线性分类器"></a>1.1线性分类器</h2><h3 id="1-1-1图像的表示方法"><a href="#1-1-1图像的表示方法" class="headerlink" title="1.1.1图像的表示方法"></a>1.1.1图像的表示方法</h3><h4 id="a-二进制图像"><a href="#a-二进制图像" class="headerlink" title="a.二进制图像"></a>a.二进制图像</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000716.png" alt="image-20210914142438086" style="zoom: 67%;" /></p>
<h4 id="b-灰度图"><a href="#b-灰度图" class="headerlink" title="b.灰度图"></a>b.灰度图</h4><p>每一个像素点有一个灰度值，其范围为0-255，就是对应二进制的00000000-11111111</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000720.png" alt="image-20210914142610282" style="zoom: 67%;" /></p>
<h4 id="c-彩色图"><a href="#c-彩色图" class="headerlink" title="c.彩色图"></a>c.彩色图</h4><p>每一个像素点由三个深度，分别是红色，绿色和蓝色，每一个深度方向上的数值范围为0-255，也就是用三个颜色叠加来表示出一种颜色。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000724.png" alt="image-20210914142805850" style="zoom:80%;" /></p>
<p>在线性分类器处理的过程中，我们将图片用向量的形式来表示。在CIFAR10数据集中，每一张图片是32*32的彩色图，因此用向量来表示就是将每一个像素点的RGB值依次排列成一个列向量。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000735.png" alt="image-20210914143340669" style="zoom:67%;" /></p>
<h3 id="1-1-2线性分类器模型"><a href="#1-1-2线性分类器模型" class="headerlink" title="1.1.2线性分类器模型"></a>1.1.2线性分类器模型</h3><h4 id="a-线性分类器的定义"><a href="#a-线性分类器的定义" class="headerlink" title="a.线性分类器的定义"></a>a.线性分类器的定义</h4><p><strong>ques：</strong>为什么从线性分类器开始？</p>
<p>因为线性分类器的形式简单易于理解，其次通过层级结构（后面说的神经网络）可以形成功能强大的非线性模型。</p>
<p>线性分类器最主要的就是其分类模型，分类模型如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
f_{i}\left(\boldsymbol{x}, \boldsymbol{w}_{i}\right)=\boldsymbol{w}_{i}^{T} \boldsymbol{x}+b_{i} \\
\mathrm{i}=1, \cdots, c
\end{gathered}\tag{1.1}</script><p>其中， $x$ 表示输入的图像的向量，$c$ 为类别个数，$w_i$ 表示第 $i$ 个类别的权值向量，$b_i$ 为第 $i$ 类的偏置。</p>
<p>决策规则为当输入一个图像后，每一个类通过自己的权值向量对其打分，得到 $f_i(x,w_i)$ ，谁的得分高，就属于哪一个类别。</p>
<p><strong>eg：</strong>$f_i(x)&gt;f_j(x)$ ，那么该图片就属于第 $i$ 类。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000744.png" alt="image-20210914144717161" style="zoom:67%;" /></p>
<p> 通过上图的过程，可以知道该图片为猫类。</p>
<h4 id="b-矩阵表示分类器模型"><a href="#b-矩阵表示分类器模型" class="headerlink" title="b.矩阵表示分类器模型"></a>b.矩阵表示分类器模型</h4><script type="math/tex; mode=display">
f(x,W)=Wx+b\tag{1.2}</script><p>其中，$x$ 为图片向量，其维度为d（例如CIFAR10数据集，$d=32\times32\times3=3072$ ）</p>
<p>W是权值矩阵，它的每一行都是一个类的权值向量，因此W的维数为共有c（类别数）行，d（图片维数）列。</p>
<p>b是一个c维的列向量，每一个元素是每一类的偏置。</p>
<p>最后的得分 $f$ 是一个c维的列向量，它的每一个元素代表着每一类别的得分。</p>
<h4 id="c-线性分类器的权值"><a href="#c-线性分类器的权值" class="headerlink" title="c.线性分类器的权值"></a>c.线性分类器的权值</h4><p>我们将训练好的线性分类器的权值向量 $w_i$ 拿出来，因为其维数和图片向量是一样的，所以我们也将其表现成图像的形式。可以发现一个很有意思的现象。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000749.png" alt="image-20210914150006890"></p>
<p>所以权值向量是有其物理意义的，它可以看作是一个模板，如果输入图像与评估模板的匹配程度越高，那么分类器在该类上的输出分数就越高。</p>
<h4 id="d-线性分类器的决策分界面"><a href="#d-线性分类器的决策分界面" class="headerlink" title="d.线性分类器的决策分界面"></a>d.线性分类器的决策分界面</h4><p>实际上，线性分类器和我们高中学习的线性规划一样，可以用图来表示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000759.png" alt="image-20210914150435415"></p>
<p>当分数为0时，就是决策的分界面，其中权值向量w控制着线的方向，偏置b控制着线的偏移。上图中箭头的方向代表分类器的正方向，沿着箭头的方向距离分界面越远的图片，得分越高，就说明线性分类器越肯定的知道该图片属于哪一类。但由于这个分界面是“直线”，所以，线性分类器并不能完全的将一些特殊的图片区分出来，这就是线性分类器的局限性，但后面会继续说明如何解决这类问题（要用到神经网络）</p>
<h3 id="1-1-3损失函数"><a href="#1-1-3损失函数" class="headerlink" title="1.1.3损失函数"></a>1.1.3损失函数</h3><p>前面我们说了分类器的权值向量，为图片进行打分，但是这个权值向量具体的数值是需要通过训练来得到的。那么如何用数学语言来描述该权值向量的性能呢，这就需要损失函数来描述。</p>
<p>损失函数搭建了模型性能和模型参数之间的桥梁，指导模型参数优化。</p>
<h4 id="a-损失函数的特点"><a href="#a-损失函数的特点" class="headerlink" title="a.损失函数的特点"></a>a.损失函数的特点</h4><ul>
<li>损失函数是一个函数，用于度量给定分类器的预测值和真实值的不一致程度，其输出通常是一个非负实值。</li>
<li>其输出的非负实值可以作为反馈信号，用来对分类器参数进行调整，从而降低当前的损失值，以提高分类效果。</li>
</ul>
<h4 id="b-损失函数的定义"><a href="#b-损失函数的定义" class="headerlink" title="b.损失函数的定义"></a>b.损失函数的定义</h4><script type="math/tex; mode=display">
L=\frac{1}{N} \sum_{i} L_{i}\left(f\left(x_{i}, W\right), y_{i}\right)\tag{1.3}</script><p>N为样本图片数量。</p>
<p>$i$ 表示输入的第 $i$ 张图片，$f(x_i,W)$ 是分类器对第 $i$ 张图片的打分，$y_i$ 是第 $i$ 张图片真实类别标签。</p>
<p>$L_i$ 是对第 $i$ 张图片的损失当前预测值，也就是预测值与真实值之间的差距。</p>
<p><strong>不同的损失函数，其$L_i$ 的具体形式不同。</strong></p>
<h4 id="c-多类支撑向量机损失"><a href="#c-多类支撑向量机损失" class="headerlink" title="c.多类支撑向量机损失"></a>c.多类支撑向量机损失</h4><p>对于同某一个样本图片i，分类器对其打分得到了一个分数向量 $f(x_i,W)=[s_{i1}\ s_{i2} …s_{ij}]^T$ ，那么 $s_{ij}$ 就是第i张图片在第j类上的分数。</p>
<script type="math/tex; mode=display">
s_{i j}=f_{j}\left(x_{\mathrm{i}}, w_{j}, b_{j}\right)=w_{j}^{T} x_{i}+b_{j}\tag{1.4}</script><p>下面定义多类支撑向量机损失：</p>
<script type="math/tex; mode=display">
\begin{aligned}
L_{i}=& \sum_{j \neq y}\left\{\begin{array}{l}
0 & \text { if } s_{iy} \geq s_{i j}+1 \\
s_{ij}-s_{iy}+1 & \text { otherwise }
\end{array}\right.\\
&=\sum_{j \neq y} \max \left(0, s_{i j}-s_{iy}+1\right)
\end{aligned}\tag{1.5}</script><p>这里，$y$ 表示样本图像 i 所在的真实类别。式（1.5）的意义就是，用图片在各个类别上的打分和其所在的真实类别上的打分进行比较，当真实类别上的打分 $s_{iy}$ 比其他类别的打分 $s_{ij}$ 高出1时，损失为0，如果不高出1，则损失 $s_{ij}+1-s_{iy}$ 。该损失函数也称为折页损失（hingeloss）。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000809.png" alt="image-20210914155617783" style="zoom:67%;" /></p>
<p>损失函数的范围是0到无穷，当损失函数很小时就说明所得到的参数性能很好了。</p>
<p>现在再来看一下线性分类器模型，有以下这种情况：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000814.png" alt="image-20210914160319600" style="zoom:67%;" /></p>
<p>这个例子可以看出，可以使最终损失函数为0的参数W并不唯一，那么如何在这些参数之间进行选择呢？</p>
<h4 id="d-正则项"><a href="#d-正则项" class="headerlink" title="d.正则项"></a>d.正则项</h4><p>在损失函数中加入正则项</p>
<script type="math/tex; mode=display">
L(W)=\frac{1}{N} \sum_{i} L_{i}\left(f\left(x_{i}, W\right), y_{i}\right)+\lambda R(W)\tag{1.6}</script><p>前面原来的项，称为数据损失，根据数据损失训练出来的参数和训练集相匹配。</p>
<p>后面的项，称为正则项，它是一个仅与权值有关，而与训练集无关的函数，它的作用就是防止模型在训练集上训练得太好。</p>
<p>如果训练的太好，只能说明对该训练集可以准确的分类，但对于未知的图片，性能可能会很差。</p>
<h5 id="（1）L2正则项"><a href="#（1）L2正则项" class="headerlink" title="（1）L2正则项"></a>（1）L2正则项</h5><script type="math/tex; mode=display">
R(W)=\sum_{k} \sum_{l} W_{k, l}^{2}\tag{1.7}</script><p>L2正则项是将所有的权值的平方相加到一起。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000820.png" alt="image-20210914161749420" style="zoom:67%;" /></p>
<p>由该例子可以看出，分类器所打的分数相同，此时数据损失是相同的，但是正则损失不同，便可以选出更合适的权值参数。</p>
<p>L2正则损失对大数值权值进行惩罚，喜欢分散权值，鼓励分类器将所有维度特征都用起来，而不是强烈的依赖其中少数几维特征。</p>
<h5 id="（2）L1正则项"><a href="#（2）L1正则项" class="headerlink" title="（2）L1正则项"></a>（2）L1正则项</h5><script type="math/tex; mode=display">
R(W)=\sum_{k} \sum_{l}\left|W_{k, l}\right|\tag{1.8}</script><h5 id="（3）Elastic-net-L1-L2"><a href="#（3）Elastic-net-L1-L2" class="headerlink" title="（3）Elastic net(L1+L2)"></a>（3）Elastic net(L1+L2)</h5><script type="math/tex; mode=display">
R(W)=\Sigma_{k} \sum_{l} \beta W_{k, l}^{2}+\left|W_{k, l}\right|\tag{1.9}</script><p>该损失函数就是将L1和L2损失函数结合起来，式中的 $\beta$ 是一个超参数。</p>
<h4 id="e-超参数"><a href="#e-超参数" class="headerlink" title="e.超参数"></a>e.超参数</h4><p>在式（1.6）中的 $\lambda$ 是一个超参数，它控制着正则损失在总损失中所占的比重。</p>
<p>超参数就是在开始学习过程之前，人为设置的参数，而不是学习得到的。</p>
<h3 id="1-1-4优化算法"><a href="#1-1-4优化算法" class="headerlink" title="1.1.4优化算法"></a>1.1.4优化算法</h3><p>损失函数搭建了模型性能和模型参数之间的桥梁，有了这个桥梁就需要用优化算法来进行优化了。</p>
<p>优化算法的目标就是找到使损失函数达到最优的那组参数。</p>
<h4 id="a-直接法"><a href="#a-直接法" class="headerlink" title="a.直接法"></a>a.直接法</h4><p>对损失函数直接求导，一般这种方法用不了，因为很难直接解出W。</p>
<h4 id="b-梯度下降算法"><a href="#b-梯度下降算法" class="headerlink" title="b.梯度下降算法"></a>b.梯度下降算法</h4><p>梯度下降算法是一种简单而高效的迭代优化算法。就是求出损失函数的梯度来，这就确定了参数更新的方向，然后给定一个步长（步长也叫做学习率），来更新参数。</p>
<p>更新后的权值=原权值-学习率*损失函数梯度</p>
<p>梯度下降算法的核心就是如何计算出梯度。</p>
<p>方法有以下两种：</p>
<h5 id="（1）数值法"><a href="#（1）数值法" class="headerlink" title="（1）数值法"></a>（1）数值法</h5><script type="math/tex; mode=display">
\frac{d L(w)}{d w}=\lim _{h \rightarrow 0} \frac{L(w+h)-L(w)}{h}\tag{1.10}</script><p>这种方法计算量大，不精确。</p>
<h5 id="（2）解析法"><a href="#（2）解析法" class="headerlink" title="（2）解析法"></a>（2）解析法</h5><p>对损失函数求导，求出梯度。</p>
<h4 id="c-随机梯度下降算法"><a href="#c-随机梯度下降算法" class="headerlink" title="c.随机梯度下降算法"></a>c.随机梯度下降算法</h4><p>如果把所有的样本图片都代入到分类器中，计算损失函数，然后再求导，计算量过大，速度很慢。因此我们可以只代入一个样本图片。这就是随机梯度下降算法。</p>
<p>每次随机的抽取一个图片 i ，然后计算出损失函数和损失函数的梯度。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&L(W)=L_{i}\left(x_{i}, y_{i}, W\right)+\lambda R(W) \\
&\nabla_{W} L(W)=\nabla_{W} L_{i}\left(x_{i}, y_{i}, W\right)+\lambda \nabla_{W} R(W)
\end{aligned}\tag{1.11}</script><p>更新权值参数，再进行下一轮的训练。</p>
<p>这样速度会大大提升，但是单样本训练会带来很多的噪声，不是每次迭代都向着整体最优化方向的。</p>
<h4 id="d-小批量梯度下降算法"><a href="#d-小批量梯度下降算法" class="headerlink" title="d.小批量梯度下降算法"></a>d.小批量梯度下降算法</h4><p>既然单个样本可能会含有噪声，那么就用一个折中的办法，小批量随机选取m（超参数）个样本，计算损失函数和其梯度。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&L(W)=\frac{1}{N} \sum_{i=1}^{N} L_{i}\left(x_{i}, y_{i}, W\right)+\lambda R(W) \\
&\nabla_{W} L(W)=\frac{1}{N} \sum_{i=1}^{N} \nabla_{W} L_{i}\left(x_{i}, y_{i}, W\right)+\lambda \nabla_{W} R(W)
\end{aligned}\tag{1.12}</script><p>在小批量处理中，有几个名词需要知道：</p>
<ul>
<li>iteration:表示1次迭代</li>
<li>batch-size:1次迭代所使用的样本量</li>
<li>epoch:1个epoch表示过了1遍训练集中的所有样本</li>
</ul>
<p>通常使用2的幂次方来作为样本数量。</p>
<h3 id="1-1-5数据集划分"><a href="#1-1-5数据集划分" class="headerlink" title="1.1.5数据集划分"></a>1.1.5数据集划分</h3><p>通常的数据集划分为两部分</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000827.png" alt="image-20210914170422717" style="zoom: 67%;" /></p>
<p>但当存在超参数时，如何找到泛化能力最好的超参数呢，要用验证集。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000829.png" alt="image-20210914170528769" style="zoom: 67%;" /></p>
<ul>
<li>训练集：用于 <strong>给定</strong> 的超参数时分类器参数的学习。</li>
<li>验证集：用于选择超参数。</li>
<li>测试集：用于评估泛化能力。</li>
</ul>
<p>如果数据很少，那么可能验证集里的样本太少，从而无法在统计上代表数据。接下来介绍一种方法。</p>
<p><strong>K折交叉验证</strong>：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000846.png" alt="image-20210914230810126" style="zoom: 67%;" /></p>
<p>过程是这样的，首先确定一个超参数，然后将数据分为K份（k折就是k份）。如上图所示，先用训练集训练，然后验证，得到一个分数。依此类推，最终得到K个分数，然后将其相加取平均，便得到了在该超参数的分值。</p>
<h3 id="1-1-6数据预处理"><a href="#1-1-6数据预处理" class="headerlink" title="1.1.6数据预处理"></a>1.1.6数据预处理</h3><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000841.png" alt="image-20210915001700872"></p>
<p>就与我们考试一样，看绝对的分数是没有用的，因为不同的题难易程度也不同。而看我们与平均分的差距才能体现出我们的真实水平。</p>
<p>图像也正是如此，例如当有许多张猫和狗的图片，我们可以先将这些向量去均值，只需知道每两张图片间的相对差异即可。</p>
<p>另外为了避免数量级的影响，还需要将数据进行归一化</p>
<script type="math/tex; mode=display">
Z=\frac{X-\bar{X}}{\sigma}\tag{1.13}</script><p>其中 $\bar{X}$ 为数据的均值，$\sigma$ 为数据的方差。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000856.png" alt="image-20210915003423872"></p>
<p>数据去相关可以达到降维的作用。</p>
<h2 id="1-2全连接神经网络分类器"><a href="#1-2全连接神经网络分类器" class="headerlink" title="1.2全连接神经网络分类器"></a>1.2全连接神经网络分类器</h2><h3 id="1-2-1全连接神经网络的提出"><a href="#1-2-1全连接神经网络的提出" class="headerlink" title="1.2.1全连接神经网络的提出"></a>1.2.1全连接神经网络的提出</h3><p>当出现较为复杂的图片时，单纯依靠线性分类器就很难划分分界面了（因为线性分类器的分界面只能是直的），所以需要建立一个非线性模型。那么全连接神经网络模型就是具有代表性的非线性模型。</p>
<p>如下图所示，分为线性可分和线性不可分：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000907.png" alt="image-20210915012437563"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000911.png" alt="image-20210915012535586"></p>
<p><strong>全连接神经网络级联了多个变换来实现输入到输出的映射。</strong></p>
<p>如两层神经网络模型：</p>
<script type="math/tex; mode=display">
f=W_{2} \max \left(0, W_{1} x+b_{1}\right)+b_{2}\tag{1.14}</script><p>两层神经网络结构有一层隐层。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000915.png" alt="image-20210915012838114"></p>
<p>三层神经网络模型：</p>
<script type="math/tex; mode=display">
f=\mathrm{W}_{3} \max \left(0, \mathrm{~W}_{2} \max \left(0, \mathrm{~W}_{1} \mathrm{x}+\mathrm{b}_{1}\right)+\mathrm{b}_{2}\right)\tag{1.15}</script><p>上面两式和线性分类模型形式十分相似，但稍稍有一些不同，其中在线性模型中，是权值向量直接乘以图片向量，而神经网络中出现了一个 $max()$ 函数，这是一个激活函数，我们后面会详细说明，那么为什么要加上激活函数呢？</p>
<p>如果不加上激活函数，如式（1.15），将其一层一层的乘开，最后该模型又会退化到线性模型上去，因此这里的激活函数是关键，正是因为激活函数的存在，才可以使神经网络称为一个非线性模型。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f&=W_{3}\left(W_{2}\left(W_{1} x+b_{1}\right)+b_{2}\right)+b_{3} \\
&=W_{3} W_{2} W_{1} x+\left(W_{3} W_{2} b_{1}+W_{3} b_{2}+b_{3}\right) \\
&=W^{\prime} x+b^{\prime}
\end{aligned}\tag{1.16}</script><p>至于整个神经网络有多少个隐层，每一层隐层有多少个神经元比较合适，这都没有统一的答案，但有一点可以证明：神经元的数量越多，分界面就可以越复杂，在这个集合上的分类能力就越强。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000921.png" alt="image-20210915014336677"></p>
<p>在设计神经网络的时候，所面对的任务越复杂，神经网络结构就应该越深，越宽。但也要注意，并不是越复杂的神经网络越好，因为在真实场景下未必是最好的，只是在训练集上的效果较好（过拟合）。</p>
<h3 id="1-2-2全连接神经网络的物理意义"><a href="#1-2-2全连接神经网络的物理意义" class="headerlink" title="1.2.2全连接神经网络的物理意义"></a>1.2.2全连接神经网络的物理意义</h3><p>通过1.1.2c的学习，我们知道线性分类器的分类模型是通过一个权值向量乘以图片向量加上偏置得出分数。其权值向量的物理意义是每一个权值向量都是一个图片模板。模版数量取决于类别的数量，即假如有10个类别，那么就有10个模板。</p>
<p>用一个模板来筛选一类未免太难了，如下图所示</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000927.png" alt="image-20210915010335392"></p>
<p>可以隐约的看出，这个模板中，有两个马头，这就是因为只用一个模板来表示整个类，那么这个模板就是该类的一个平均。但当有一个极其特殊的马时，那么便识别不出来了。而想要多用几个模板，又用不了，因为线性分类器的结构就是这样，有多少个类就有多少个模板。</p>
<p>然而在神经网络中，模板的数量可以人为的规定，为什么会这样呢？</p>
<script type="math/tex; mode=display">
f=W_{2} \max \left(0, W_{1} x+b_{1}\right)+b_{2}\tag{1.14}</script><p>现在以两层神经网络为例，如果共有10类，那么 $W_2$ 的行数应该为10，而至于 $W_2$ 的列数，等于 $W_1$ 的行数，对于 $W_1$ 的行数，并没有什么限制，我们可以随意的规定。 $W_1$ 的列数，是等于图像向量的维数的。再反过来看，和线性分类器一样，$W_1$ 的行向量也是一个权值向量，它的物理意义也是一样的，转化成图片也是一个模板，我们可以规定 $W_1$ 的某几行都是某一类的模板，然后再通过 $W_2$ 的权值对该类的这几个模板进行叠加。例如我们规定 $W_1$ 的前100行都是马的模板，有站着的马，跑着的马，吃饭的马，汗血宝马等等。当输入一个图像向量后，分别与这一百个模板进行比较打分，得到一个100维的分数向量，然后再将这个分数向量代入到第二层神经网络，进行权值叠加，得出各类的分数。</p>
<p>所以说，全连接神经网络的描述能力更强，因为调整 $W_1$ 行数等于增加模板数量。</p>
<h3 id="1-2-3常用的激活函数"><a href="#1-2-3常用的激活函数" class="headerlink" title="1.2.3常用的激活函数"></a>1.2.3常用的激活函数</h3><h4 id="a-Sigmoid"><a href="#a-Sigmoid" class="headerlink" title="a.Sigmoid"></a>a.Sigmoid</h4><script type="math/tex; mode=display">
1 /\left(1+e^{-x}\right)\tag{1.17}</script><p>函数图像：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000933.png" alt="image-20210915013453615"></p>
<p>值域为0到1。</p>
<h4 id="b-tanh"><a href="#b-tanh" class="headerlink" title="b.tanh"></a>b.tanh</h4><script type="math/tex; mode=display">
\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}\tag{1.18}</script><p>函数图像：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000942.png" alt="image-20210915013653611"></p>
<p>值域为-1到1。</p>
<h4 id="c-ReLU"><a href="#c-ReLU" class="headerlink" title="c.ReLU"></a>c.ReLU</h4><script type="math/tex; mode=display">
max(0,x)\tag{1.19}</script><p>函数图像：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000947.png" alt="image-20210915013904728"></p>
<p>值域为0到正无穷。</p>
<h4 id="d-Leaky-ReLU"><a href="#d-Leaky-ReLU" class="headerlink" title="d.Leaky ReLU"></a>d.Leaky ReLU</h4><script type="math/tex; mode=display">
max(0.1x,x)\tag{1.20}</script><p>函数图像：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215000954.png" alt="image-20210915014020529"></p>
<p>值域负无穷到正无穷。</p>
<h3 id="1-2-4损失函数"><a href="#1-2-4损失函数" class="headerlink" title="1.2.4损失函数"></a>1.2.4损失函数</h3><p>在这里，我们换一种损失函数的定义方法，使用SOFTMAX和交叉熵的方法。</p>
<h4 id="a-SOFTMAX"><a href="#a-SOFTMAX" class="headerlink" title="a.SOFTMAX"></a>a.SOFTMAX</h4><p>我们先对神经网络关于输入图片所打的分数进行一个处理，如下图所示</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001001.png" alt="image-20210915015044697" style="zoom:67%;" /></p>
<p>SOFTMAX就是对神经网络的输出值求指数得到 $t_i$，然后将其求和，再用 $t_i$ 比上这个总和，便得到了 $p_i$ 。</p>
<p>经过这个处理，就可以转化成概率分布的形式，即神经网络分类器对某一张图片进行分类，输出结果是图片为各个类别的概率。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001005.png" alt="image-20210915015406330" style="zoom:67%;" /></p>
<h4 id="b-交叉熵损失"><a href="#b-交叉熵损失" class="headerlink" title="b.交叉熵损失"></a>b.交叉熵损失</h4><p>然后我们来定义损失函数，和线性分类器类似，我们这里也用概率的形式定义真实值，例如一张图片的标签是鸟，那么我们就用其在鸟类的概率为1来定义。如下图所示</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001008.png" alt="image-20210915015639286" style="zoom:67%;" /></p>
<p>这种形式也叫做one-hot形式。</p>
<p>然后我们要想办法来描述预测值和真实值之间的差距，从而构建损失函数。</p>
<p>定义：</p>
<ul>
<li>熵：$H(p)=-\sum_{x} p(x) \log p(x)$</li>
<li>交叉熵：$H(p, q)=-\sum_{x} p(x) \log q(x)$</li>
<li>相对熵：$K L(p | q)=-\sum_{x} p(x) \log \frac{q(x)}{p(x)}$</li>
</ul>
<p>在概率中，用相对熵的概念来度量两个分布间的不相似性。相对熵也叫做KL散度。</p>
<p>这三者之间的关系为：</p>
<script type="math/tex; mode=display">
\begin{aligned} H(p, q) &=-\sum_{x} p(x) \log q(x) \\ &=-\sum_{x} p(x) \log p(x)-\sum_{x} p(x) \log \frac{q(x)}{p(x)} \\ &=H(p)+K L(p \| q) \end{aligned}\tag{1.21}</script><p>即交叉熵等于熵加上相对熵。</p>
<p>那么我们现在想要描述分类器预测的分布 $q(x)$ 和真实的分布 $p(x)$ 间的关系，我们将其带入到式（1.21）中，得到：</p>
<script type="math/tex; mode=display">
H(p, q)=-\sum_{i=1}^{c} \mathrm{p}\left(x_{i}\right) \log \left(\mathrm{q}\left(x_{i}\right)\right)\tag{1.22}</script><p>因为真实值p(x)是one-hot形式，只有x等于真实类别的时候才为1，那么 $H(p)=0$ ，此时P(x)和q(x)的概率分布的交叉熵和相对熵相等。</p>
<p>所以：</p>
<script type="math/tex; mode=display">
L_i=-log(q_j)\tag{1.23}\ \ \ j为真实类别</script><p>式（1.23）表明，在真实值为one-hot的形式时，第i张图片所得到的损失为预测值SOFTMAX形式在真实类别上的负对数。</p>
<p>为什么要引入交叉熵损失呢？看下面这个例子，有三组预测分数，其中第一个元素为真实类别所对应的预测分数</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001016.png" alt="image-20210915022451149" style="zoom:80%;" /></p>
<p>可以看到，此时的多类支撑向量机损失函数都是0，而交叉熵损失并不全是0。可以看出交叉熵损失更加精确。它们的意义是不一样的。多类支撑向量机损失是只要我自己高，那么损失就是0，而交叉熵损失是我自己高的同时，别人还要低。</p>
<h3 id="1-2-5计算图"><a href="#1-2-5计算图" class="headerlink" title="1.2.5计算图"></a>1.2.5计算图</h3><p>计算图是一种有向图，它用来表达输入和输出以及中间变量之间的计算关系，图中的每个节点代表着一种数学运算。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001024.png" alt="image-20210915022849400" style="zoom:80%;" /></p>
<h4 id="a-计算图的前向和反向计算"><a href="#a-计算图的前向和反向计算" class="headerlink" title="a.计算图的前向和反向计算"></a>a.计算图的前向和反向计算</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001029.png" alt="image-20210915023017458" style="zoom:80%;" /></p>
<ul>
<li>任意的复杂函数，都可以用计算图来表示。</li>
<li>在整个计算图中，每个门都会得到一个输入，然后需要计算两个东西，一个是这个门的输出值，另一个是计算这个输出值关于输入值的局部导数</li>
<li>利用链式求导法则，门单元可以将回传梯度和其上一个门单元的梯度进行相乘，从而得到整个网络的输出对每个输入值的梯度。</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001036.png" alt="image-20210915025136595" style="zoom: 33%;" /></p>
<p>反向计算时，先让各个门单元进行求导，得到局部导数，再将各个门单元的输入带入到局部导数中，得到导数具体数值，最后将所有局部导数相乘，便得到最后的输出对出入的导数。</p>
<h4 id="b-计算图的颗粒度"><a href="#b-计算图的颗粒度" class="headerlink" title="b.计算图的颗粒度"></a>b.计算图的颗粒度</h4><p>计算图的各个门单元可以是最基本的数学运算，但也可以由基本的数学运算合成的复杂数学运算，此时就是大颗粒度。当颗粒度较大时，计算速度较快，但是求导比较麻烦。而小颗粒度运算速度慢，但是求导很简单。</p>
<h4 id="c-梯度爆炸和梯度消失"><a href="#c-梯度爆炸和梯度消失" class="headerlink" title="c.梯度爆炸和梯度消失"></a>c.梯度爆炸和梯度消失</h4><p>现在我们再重新看激活函数</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001044.png" alt="image-20210915025950960"></p>
<p>当输入的数值较大时，sigmoid函数的梯度都为0，非常不利于梯度流在计算图中的反向传播，同样tanh函数也是如此。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001047.png" alt="image-20210915030131126"></p>
<p>而ReLU函数在较大时，梯度永远不会为0，比较有利于梯度的反向传播。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001050.png" alt="image-20210915030220960"></p>
<p>Leakly ReLU函数的梯度永远不会为0，但在输入为0处没有导数。</p>
<p>如果某一个门的局部梯度为0或者是某几个门的梯度都很小，此时相乘下去，就会造成输出对输入的梯度为0，这就是梯度消失，这就回造成参数无法获得更新。这就好比，损失函数是一座山，这个山有一个高海拔平原，生活在平原上的人就不知道还有比这个平原低的地方。这就会造成训练失败。</p>
<p>相反，梯度爆炸就是因为链式相乘，梯度越乘越大，这就会导致参数更新时学习率过大，从而导致算法不收敛。如果把步长限制到某一范围内，便可以解决这个问题，这种方法也称为梯度裁剪。</p>
<h3 id="1-2-6改进梯度算法"><a href="#1-2-6改进梯度算法" class="headerlink" title="1.2.6改进梯度算法"></a>1.2.6改进梯度算法</h3><h4 id="a-之前的算法存在的问题"><a href="#a-之前的算法存在的问题" class="headerlink" title="a.之前的算法存在的问题"></a>a.之前的算法存在的问题</h4><p>对于损失函数来说，有可能在一个维度上变化的缓慢，在另一个维度上又震荡，导致不能收敛。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001057.png" alt="image-20210916213136189"></p>
<p>就像这幅图所描述的那样。因此需要将原来的算法进行改进。</p>
<h4 id="b-动量法"><a href="#b-动量法" class="headerlink" title="b.动量法"></a>b.动量法</h4><p>利用累加历史梯度信息更新梯度。</p>
<p>为什么这种方法有效呢？</p>
<p>因为在震荡方向上，梯度可以相互抵消，在平坦方向上，梯度可以累加。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001103.png" alt="image-20210916214949919"></p>
<p>这里的 $\mu$ 是一个超参数，取值范围是0到1。它的作用是，当梯度为0时，它可以作为一个衰减系数，让速度更新值变为0 。</p>
<p>另外，在优化的过程中，经常会遇到局部最小值的问题，动量法还可以使其冲出局部最小值点或者是鞍点。</p>
<h4 id="c-自适应梯度与RMSProp"><a href="#c-自适应梯度与RMSProp" class="headerlink" title="c.自适应梯度与RMSProp"></a>c.自适应梯度与RMSProp</h4><p>自适应梯度法就是<strong>改变学习率</strong>（注意是改变学习率，也就是步长，根据梯度的幅值平方来调整学习率），通过减小震荡方向步长，增大平坦方向步长来使算法收敛的。</p>
<p>是如何区分震荡和平坦方向的呢？</p>
<p>梯度幅值的平方较大的方向是震荡方向，幅值的平方较小的方向是平坦方向。</p>
<p>RMSProp就是一种自适应梯度算法。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001129.png" alt="image-20210916221857515"></p>
<p>对于陡峭的时候，r就会很大，r作为分母，此时会使步长变得很小。对于平坦区域，r就会很小，此时的步长就会变得很大。</p>
<p>此处加上超参数 $\rho$ ，就是防止r无限增大， $\rho$ 的取值范围为0到1，当 $\rho$ 很大时，就表示历史的 r 考虑的较多。当 $\rho$ 很小时，表示历史的r</p>
<p>的影响较少。</p>
<h4 id="d-Adam方法"><a href="#d-Adam方法" class="headerlink" title="d.Adam方法"></a>d.Adam方法</h4><p>将动量法和自适应梯度方法结合在一起。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001134.png" alt="image-20210917000443472" style="zoom: 33%;" /></p>
<p>在这里有一个修正操作，是防止初始的时候的梯度过小。</p>
<h3 id="1-2-7权值初始化"><a href="#1-2-7权值初始化" class="headerlink" title="1.2.7权值初始化"></a>1.2.7权值初始化</h3><h4 id="a-不好的初始化"><a href="#a-不好的初始化" class="headerlink" title="a.不好的初始化"></a>a.不好的初始化</h4><h5 id="（1）全零初始化"><a href="#（1）全零初始化" class="headerlink" title="（1）全零初始化"></a>（1）全零初始化</h5><p>如果将所有权值参数都初始化为0或者是同一个常数，那么所有的神经元都是一样的。这是不可以的。</p>
<h5 id="（2）随机权值初始化"><a href="#（2）随机权值初始化" class="headerlink" title="（2）随机权值初始化"></a>（2）随机权值初始化</h5><p>例如：有10个隐层，1个输出层，每个隐层包含500个神经元，使用双曲正切激活函数。</p>
<p>此时我们采用随机初始化，权值参数的数值采样自 $N(0,0.01)$ 的高斯分布。</p>
<p>我们输入一组符合正态分布的向量。</p>
<p>现在看个层的输出，第一层的时候，还可以看到也是一个正态分布，但是当过了3层之后，每一层的输出都为0。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001212.png" alt="image-20210917001832779"></p>
<p>这就导致了信息无法正确的传到神经网络的最后面，就不会有反向的梯度来更新我们的权值参数。</p>
<p>现在我们把权值参数的采样更改一下，变为 $N(0,1)$ ，但是此时各层的输出如下：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001223.png" alt="image-20210917002841682"></p>
<p>几乎所有的神经元都饱和了，此时神经元的局部梯度都是0，最终参数也得不到更新。</p>
<p>所以初始化不好，网络是没有办法被训练的。有效的初始化方法就是正向的信息流能传到后面，反向的梯度能传回来。</p>
<h4 id="b-Xavier初始化"><a href="#b-Xavier初始化" class="headerlink" title="b.Xavier初始化"></a>b.Xavier初始化</h4><p>我们的目标就是使网络各层的激活值和局部梯度的 <strong>方差</strong> 在传播过程中尽量保持一致，也就是寻找权值 w 的分布，使得输出 y 和输入 z 的方差一致。</p>
<p>现在假设：</p>
<p><strong>一个</strong>神经元的输入为 $z_1,z_2,\cdots,z_n$ ，$z_i$ 是一个数。它们是独立同分布的。</p>
<p>这个神经元的权值 $w_1,w_2,\cdots,w_n$ ，他们也是独立同分布的。且w和z是独立的，均值为0。其激活函数为 $f$ ，最终的输出值为y。</p>
<script type="math/tex; mode=display">
y=f\left(w_{1} * z_{1}+\cdots+w_{n} * z_{n}\right)\tag{1.24}</script><p>继续假设激活函数 $f$ 为tanh，（1.24）括号内的值域为-2到2，此时 $f$ 就是一个正比例函数，即</p>
<script type="math/tex; mode=display">
y=w_{1} * z_{1}+\cdots+w_{n} * z_{n}\tag{1.25}</script><p>那么 y 的方差为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\operatorname{Var}(y) &=\operatorname{Var}\left(\sum_{i=1}^{n} w_{i} z_{i}\right)=\sum_{i=1}^{n} \operatorname{Var}\left(w_{i} z_{i}\right) \\
&=\sum_{i}^{n}\left[E\left(w_{i}\right)\right]^{2} \operatorname{Var}\left(\mathrm{z}_{i}\right)+\left[E\left(z_{i}\right)\right]^{2} \operatorname{Var}\left(w_{i}\right)+\operatorname{Var}\left(w_{i}\right) \operatorname{Var}\left(z_{i}\right) \\
&=\sum_{i}^{n} \operatorname{Var}\left(w_{i}\right) \operatorname{Var}\left(z_{i}\right) \\
&=n \operatorname{Var}\left(\mathrm{w}_{i}\right) \operatorname{Var}\left(z_{i}\right)
\end{aligned}\tag{1.26}</script><p>此时，如果想要使y的方差和输入z一样，就令w的方差为1/n。</p>
<p>所以，我们令权值的采样分布更改为 $N(0,1/n)$ ，那么就可以让输入和输出同分布。这就是Xavier初始化。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001232.png" alt="image-20210917021936600"></p>
<p>但是对ReLU激活函数，Xavier的效果不是很好。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001238.png" alt="image-20210917022213604"></p>
<p>此时用何凯明研究员提出的初始化方法。</p>
<p>权值的采样分布更改为 $N(0,2/n)$ 。效果如下：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001304.png" alt="image-20210917022258281"></p>
<h3 id="1-2-8批归一化（BN）"><a href="#1-2-8批归一化（BN）" class="headerlink" title="1.2.8批归一化（BN）"></a>1.2.8批归一化（BN）</h3><p>之前的权值初始化是为了在训练时，网络可以正常传递输入信息，现在我们试着改变一下网络的结构，来保证信息可以安全的传递。</p>
<p>批归一化的思想不是从权值初始化考虑的，而是对数据输出数据进行处理，因为我们最终的目标是使输出和输入同分布。</p>
<p>批归一化就是对神经元的输出（也就是下一层神经元的输入）直接进行批归一化，批归一化就是对输出减均值，除标准差。</p>
<p>例如，小批量梯度下降算法，每次迭代会输入一批数据，假如有32个样本，经过神经元后，会有32个输出值。我们求出这32个输出值的平均值和标准差，然后对每个输出值进行减平均值，除标准差的操作。然后处理后的数据作为下一层神经元的输入。</p>
<p>批归一化操作通常会插入到全连接层之后，非线性激活之前，这样效果更好。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001315.png" alt="image-20210917023105383" style="zoom:50%;" /></p>
<p>这里的FC就是加权计算，BN是批归一化操作。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001321.png" alt="image-20210917024344165" style="zoom:67%;" /></p>
<p>因为，输入数据经过正常全连接加权后，为进行激活函数计算之前，通常落在上面左图红色的区域，这个区域的数值输入到激活函数中，会得到-1或1，那么此时的局部梯度为0，不利于神经网络的反向梯度传播。而通过批归一化后，数据会落在上面右图中间的红色区域，激活函数在此处的梯度不为0。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001329.png" alt="image-20210917025237882" style="zoom: 50%;" /></p>
<p>上面的 $x_i$ 是上一层神经元的加权输出（还未经过激活函数处理），然后进行批归一化处理，但是请注意还有一步，就是对批归一化后的数据进行平移和放缩（也就是改变其均值和方差），然后通过训练，让神经网络自己找出合适的参数 $\gamma 和\beta$ 。因为0均值，1方差不一定对训练好，让网络自己选择。</p>
<p>上面都是在批量数据的计算时，可以计算出数据的均值和方差，但是当预测的时候，只输入一个样本，均值和方差该如何取呢？</p>
<p>这个均值和方差就是在训练时，每一次迭代所产生的均值和方差，进行累加求平均。</p>
<h3 id="1-2-9欠拟合和过拟合"><a href="#1-2-9欠拟合和过拟合" class="headerlink" title="1.2.9欠拟合和过拟合"></a>1.2.9欠拟合和过拟合</h3><p>欠拟合表示模型太简单，就好比一个小学生，去学大学数学，如果小学生能学明白，就幼儿园小朋友，他的大脑还没有发育完全，所以是学不了的。</p>
<p>而过拟合表示训练的太好，仅对训练集中的数据进行处理，可以获得较准确的数据。这就好比有两个学生，小李只会死记硬背，小蔡会学习做题方法。这样，在考试的时候，如果出了过去出过的题，小李就肯定占优势了，小蔡不一定能考过小李，但是当出过未出过的题，那么小李就傻了，因为他没有见过，所以铁定不会。小李就是过拟合现象，只记下了每张图片的样子，而没有学习到这些图片共同的特征。</p>
<p>在实际的应用中，欠拟合很好解决，只需要提高模型的复杂程度。而过拟合就不那么好解决了。</p>
<p>机器学习最根本的问题就是优化和泛化问题。</p>
<ul>
<li>优化—是指调节模型参数以在训练数据上得到最佳性能。</li>
<li>泛化—是指训练好的模型在未见过的数据上性能好坏。</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001333.png" alt="image-20210917042730226" style="zoom: 67%;" /></p>
<p>通常情况下，在训练初期，优化和泛化是相关的，训练集上的误差越小，验证集上的误差也小。这表明模型的泛化能力在增强。</p>
<p>但是到了后期，模型在验证集上的错误率开始增加，而在训练集上的误差仍在降低。此时就说明模型出现了过拟合，模型开始学习仅和训练数据有关的模式。</p>
<p>那么应对过拟合，从大方向来说有两种办法：</p>
<ul>
<li>最优方案：增加训练集规模。</li>
<li>次优方案：调节模型允许存储信息量或对模型允许存储的信息加以约束，该方法也称为正则化。</li>
</ul>
<h4 id="a-调节模型大小"><a href="#a-调节模型大小" class="headerlink" title="a.调节模型大小"></a>a.调节模型大小</h4><p>比如可以减少神经网络的层数或者是神经元的数量。</p>
<h4 id="b-约束模型权重"><a href="#b-约束模型权重" class="headerlink" title="b.约束模型权重"></a>b.约束模型权重</h4><p>也就是在损失函数中引入正则化项，鼓励模型的权重更加分散。</p>
<h4 id="c-随机失活（Dropout）"><a href="#c-随机失活（Dropout）" class="headerlink" title="c.随机失活（Dropout）"></a>c.随机失活（Dropout）</h4><p>就是在训练的时候，让某一层的一部分神经元不被激活，也就是该神经元的输出值为0。</p>
<p>这里有一个超参数，即随机失活比率，失活神经元所占的比例，通常为0.2—0.5。</p>
<p>那么随机失活为什么可以解决过拟合呢？</p>
<p>（1）随机失活可以使得每次更新梯度时，参与计算的网络参数减少，降低了模型容量，所以防止了过拟合。</p>
<p>（2）随机失活鼓励权重分散，就和损失函数引入正则项一样。当某一些神经元失活后，剩下的神经元就要记住更多的信息。</p>
<p>（3）一块神经网络，相当于多个神经网络。在神经元总数不变的情况下，分别训练不同的组合，使的每一个拿出来都可以起到全部的作用，这样在预测的时候，就相当于多个神经网络在做决策。</p>
<p>但在使用的时候，还需注意一些东西，例如有如下结构：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001339.png" alt="image-20210917044311722" style="zoom:50%;" /></p>
<p>假设失活比率为0.5，那么此时有可能会有x失活，y失活，x和y都失活。那么a的均值就为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E[a]&= \frac{1}{4}\left(w_{1} x+w_{2} y\right)+\frac{1}{4}\left(w_{1} x+0 y\right)+\frac{1}{4}\left(0 x+w_{2} y\right)+\frac{1}{4}(0 x+0 y) \\
&=\frac{1}{2}\left(w_{1} x+w_{2} y\right)
\end{aligned}\tag{1.27}</script><p>此时，在测试的时候，是没有失活的，因此测试的均值为：</p>
<script type="math/tex; mode=display">
E[a]=w_{1} x+w_{2} y
\tag{1.28}</script><p>测试时的输出值和训练时的输出值的范围是不一样的，所以在测试的时候，还需要将输出值乘上0.5。</p>
<h3 id="1-2-10超参数选取"><a href="#1-2-10超参数选取" class="headerlink" title="1.2.10超参数选取"></a>1.2.10超参数选取</h3><p>超参数就是我们需要设置的参数。</p>
<p>对于网络结构—有隐层神经元个数，网络层数，激活函数的选择等参数。</p>
<p>对于优化相关—有学习率，失活比率，正则化强度等参数。</p>
<p>我们就以学习率为例，来说明如何选参数。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001345.png" alt="image-20210917045142451" style="zoom:67%;" /></p>
<p>学习率要适中，才能快速收敛，性能良好。如果太大，不能收敛。偏大，最小值附近震荡。偏小，收敛时间太长。</p>
<h4 id="a-搜索方法"><a href="#a-搜索方法" class="headerlink" title="a.搜索方法"></a>a.搜索方法</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001350.png" alt="image-20210917045323101" style="zoom: 50%;" /></p>
<p>对于两个超参数，可以用规范的网格进行选取。带到模型中，比较性能。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001355.png" alt="image-20210917045450278" style="zoom:50%;" /></p>
<p>也可在某一范围随机选取几个点。</p>
<h4 id="b-搜索策略"><a href="#b-搜索策略" class="headerlink" title="b.搜索策略"></a>b.搜索策略</h4><p>先粗略，后精细。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001400.png" alt="image-20210917045648266" style="zoom:50%;" /></p>
<h4 id="c-参数的标尺空间"><a href="#c-参数的标尺空间" class="headerlink" title="c.参数的标尺空间"></a>c.参数的标尺空间</h4><p>学习率通常在0.00001到1之间，如果在正常的数轴下，由于量级相差太大，意义不大，所以要在log空间中，进行标尺。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001405.png" alt="image-20210917045759168" style="zoom:50%;" /></p>
<h1 id="2-卷积神经网络"><a href="#2-卷积神经网络" class="headerlink" title="2.卷积神经网络"></a>2.卷积神经网络</h1><h2 id="2-0补充知识"><a href="#2-0补充知识" class="headerlink" title="2.0补充知识"></a>2.0补充知识</h2><h3 id="2-0-1卷积与图像去噪"><a href="#2-0-1卷积与图像去噪" class="headerlink" title="2.0.1卷积与图像去噪"></a>2.0.1卷积与图像去噪</h3><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001410.png" alt="image-20210918182752556" style="zoom: 50%;" /></p>
<p>去除图像中的噪点，一个最直接的办法就是和周围的像素点的灰度值进行加权求和。如下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001415.png" alt="image-20210918183118727" style="zoom: 50%;" /></p>
<p>每一个像素点都经过该操作后，就得到了一张新的去噪后的图片。这里的操作就叫作卷积操作。</p>
<p>而卷积操作中的加权的权值，我们将其存储在一个模版中，我们称其为卷积核。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001422.png" alt="image-20210918183530686"></p>
<p>卷积操作的示意图：</p>
<p><img src="https://piggyhero.github.io/pic/img/20211216011650.gif" alt="20211215001528"></p>
<p>其中，下面蓝色的为输入图片，绿色的为卷积后的图片，下面灰色阴影部分即为卷积核。</p>
<h4 id="a-卷积的定义"><a href="#a-卷积的定义" class="headerlink" title="a.卷积的定义"></a>a.卷积的定义</h4><p>H为卷积核，F为输入图像，R为卷积操作后的图像，输出图像每一个像素点的灰度值为：</p>
<script type="math/tex; mode=display">
R_{ij}=\sum_{u,v}H_{i-u,j-v}F_{u,v}\tag{2.1}</script><p>式（2.1）表示，输出图像中的一个像素点的灰度值的计算方法。其中 $i,j$ 为输出图像中的像素点坐标，$u,v$ 为 $i,j$ 点和其周围 $n\times n$ （n为卷积核阶数）个点的坐标。</p>
<p>特别这里要注意的是，卷积操作是将卷积核旋转180度后，在与对应的像素点的灰度值相乘求和，如下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001557.png" alt="image-20210918191307439" style="zoom: 50%;" /></p>
<p>但实际过程中，我们的卷积核往往是对称的，我们常常忽略这个旋转，或者说，我们所说的卷积核是旋转过后的，但实际上是要经过一个旋转的，后面所说的卷积核就都为旋转后的。</p>
<h4 id="b-卷积的性质"><a href="#b-卷积的性质" class="headerlink" title="b.卷积的性质"></a>b.卷积的性质</h4><ul>
<li>叠加性：两个图像求和以后的卷积等于两个图像分别卷积再求和。</li>
<li>平移不变性：对于一张图片先平移再卷积和先卷积再平移的结果是一样的。（所有的平移操作都可以用卷积来实现）</li>
<li>交换律</li>
<li>结合律</li>
<li>分配律</li>
<li>标量</li>
</ul>
<p>卷积是一种基础的图像操作。</p>
<h4 id="c-边界填充"><a href="#c-边界填充" class="headerlink" title="c.边界填充"></a>c.边界填充</h4><p>在计算卷积的时候，边上的像素点的周围没有像素，所以要进行边界填充。如果不进行边界填充，卷积过后的图像会比原图像小一圈。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001602.png" alt="image-20210919014647237" style="zoom:50%;" /></p>
<p>（1）零填充（Zero padding)</p>
<p>填充周围像素点的值为0。在深度学习中常用。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001609.png" alt="image-20210919014817564" style="zoom:50%;" /></p>
<p>（2）拉伸和镜像</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001615.png" alt="image-20210919014942091" style="zoom: 67%;" /></p>
<p>拉伸填充就是把现有的图像边上拉出去一点，让扩充的像素点的值和图像的边缘的值相同。</p>
<p>镜像拉伸就是让左边的扩充像素值等于右边图片边界像素的值，右边和上下也是一样。</p>
<h4 id="d-卷积示例"><a href="#d-卷积示例" class="headerlink" title="d.卷积示例"></a>d.卷积示例</h4><p>（1）单位脉冲核</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001620.png" alt="image-20210919015416632"></p>
<p>（2）移动卷积核</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001626.png" alt="image-20210919015444298"></p>
<p>（3）平滑卷积核</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001632.png" alt="image-20210919015524376"></p>
<p>相当于磨皮，可以去噪，但是边缘也变得不明显了。</p>
<p>（4）锐化卷积核</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001638.png" alt="image-20210919015740224"></p>
<p>因为卷积的性质有分配律，所以该相减的两个卷积核的结果和图像卷积=这两个卷积核分别与图像卷积后再相减。</p>
<p>那么为什么会锐化呢？</p>
<p>我们先来看原图减去平滑图等于什么。</p>
<p>以灰度图为例：假设图像中某一像素点A的灰度值为100，周围其他点的灰度值为25。A点的灰度值相较于周围点明显不同。当卷积核为3*3，那么平滑后的图像A点的灰度值会变为$300\div9=30$，周围其他点的灰度值会稍稍变大，也为30，当原图减去平滑后的图像后，A点的灰度值为 $100-30=70$ ，周围其他点的灰度值为 $25-30=-5$ 。</p>
<p>而一像素点B，灰度值为100，周围点灰度值为90，平滑后B点灰度值为90多，其他点的灰度值也差不多，所以原图减去平滑后的图，B点的灰度值不到10，其他点的灰度值也很小。</p>
<p>此可见，整张图像的灰度值都降低，灰度值相较于周围其他点明显不同的地方，会将周边的灰度值降到很小，而灰度值原本很高的地方稍稍降低。但当灰度值变化不明显的地方，整体的灰度值都降到很低。因此，原图减去平滑后的图像得到的是边缘图像。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001644.png" alt="image-20210919030814947"></p>
<p>当边缘图再加上原图后，就可以让图像边缘的地方再次加深，得到锐化效果。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001652.png" alt="image-20210919030901732"></p>
<p>因此锐化卷积核的过程如下：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001657.png" alt="image-20210919030938561"></p>
<h4 id="e-高斯卷积核"><a href="#e-高斯卷积核" class="headerlink" title="e.高斯卷积核"></a>e.高斯卷积核</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001704.png" alt="image-20210919031204886" style="zoom:67%;" /></p>
<p>左边这幅图经过平滑卷积后，得到右边这幅图，但看右边的图，可以发现有上下左右的横线的感觉，这种现象叫做振铃，造成这种现象的原因是，在加权的时候，各个部分的权值都一样，即使远的地方，权值也一样。为了改变这种情况，引入高斯卷积核。</p>
<p>高斯卷积核就是让中心位置的权值最大，越往边缘，权值越小。</p>
<script type="math/tex; mode=display">
G_{\sigma}=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{\left(x^{2}+y^{2}\right)}{2 \sigma^{2}}}\tag{2.2}</script><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001719.png" alt="image-20210919031504756" style="zoom:67%;" /></p>
<h5 id="（1）生成步骤"><a href="#（1）生成步骤" class="headerlink" title="（1）生成步骤"></a>（1）生成步骤</h5><ul>
<li>确定卷积核的大小</li>
<li>设置高斯函数的标准差</li>
<li>通过式（2.2）计算卷积核各个位置的权值</li>
<li>对权重进行归一化，也就是所有权值之和为1</li>
</ul>
<p><strong>为什么权重要进行归一化？</strong></p>
<p>例如一张图，所有灰度值为255，如果权重没有归一化，之和为0.1，那么会对整张图片的灰度降低为原来的0.1，如果权重和为2，就会对整张图片的灰度值增长为原来的2倍。归一化的目的就是保证图像的灰度值在原来的范围内。</p>
<h5 id="（2）方差变化的影响"><a href="#（2）方差变化的影响" class="headerlink" title="（2）方差变化的影响"></a>（2）方差变化的影响</h5><p>当窗口大小一样时：</p>
<p>方差较小时，中间自身的权重较大，所以平滑的就不厉害。</p>
<p>而方差越大，中间自身的权重值较小，所以平滑的就不厉害。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001726.png" alt="image-20210919032407005"></p>
<h5 id="（3）窗口变化的影响"><a href="#（3）窗口变化的影响" class="headerlink" title="（3）窗口变化的影响"></a>（3）窗口变化的影响</h5><p>当方差一样时：</p>
<p>中间的高斯函数值虽然相同。但是窗口越大，归一化后，中间所占的权重越小，所以周围的影响较大，平滑效果越明显。</p>
<p>反之，窗口越小，归一化后，中间所占的权重越大，周围的影响越小，平滑效果越弱。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001810.png" alt="image-20210919032820648"></p>
<p>有一个经验法则：通常卷积模版的尺寸为 $2\times3\sigma+1$ ，如标准差为1，那么高斯卷积核的大小为 $7\times7$ 。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001816.png" alt="image-20210919033151354"></p>
<h5 id="（4）高斯卷积核的性质"><a href="#（4）高斯卷积核的性质" class="headerlink" title="（4）高斯卷积核的性质"></a>（4）高斯卷积核的性质</h5><ul>
<li>高斯卷积核的功能是一个低通滤波器，低通滤波器的意思就是可以过滤到高频噪声（高频噪声可以理解为噪点）。</li>
<li>两个高斯卷积核卷积后得到的还是高斯卷积核。</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001823.png" alt="image-20210919040224910" style="zoom: 33%;" /></p>
<ul>
<li>可分离性，可分解两个一维高斯的乘积（该性质可以极大减少计算量）。</li>
</ul>
<p>eg：不考虑扩充</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001828.png" alt="image-20210919040540464"></p>
<p><strong>为什么说可以减少计算量呢？</strong></p>
<p>用尺寸为 $m\times m$ 的卷积核卷积一个尺寸为 $n\times n$ 的图像，其计算复杂度为 $n^2m^2$ 。</p>
<p>如果用小方差的小模板来卷积，例如，两个卷积核的标准差为1，模板的尺寸为 $2\times3\times1+1=7$ ，此时的计算复杂度为 $49n^2$。</p>
<p>而如果直接用标准差为 $\sqrt{2}$ 的卷积模板，模板尺寸为 $2\times3\times\sqrt{2}+1=9$ ，此时计算复杂度为 $81n^2$ 。这两个卷积核的计算效果完全一样。</p>
<p>另外，如果将卷积核分离为两个一维的核，计算复杂度为  $n^2m$ 。</p>
<h4 id="f-图像噪声"><a href="#f-图像噪声" class="headerlink" title="f.图像噪声"></a>f.图像噪声</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001837.png" alt="image-20210919043141458" style="zoom:67%;" /></p>
<p>椒盐噪声：黑色像素核白色像素随机出现。</p>
<p>脉冲噪声：白色像素随机出现。</p>
<p>高斯噪声：噪声强度变化服从高斯分布。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001847.png" alt="image-20210919043430628"></p>
<script type="math/tex; mode=display">
\hat f(x,y)=f(x,y)+\eta(x,y)\quad\quad其中\eta(x,y)\rightarrow N(\mu,\sigma)\tag{2.3}</script><p>那么如何减少高斯噪声呢，当然是用高斯卷积核卷它了。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001857.png" alt="image-20210919044129815"></p>
<p>通过上图可以看出，方差越大，高斯噪声越明显。所以也需要方差更大的卷积核来平滑（当然方差增大，窗口也变大）。</p>
<h4 id="g-中值滤波"><a href="#g-中值滤波" class="headerlink" title="g.中值滤波"></a>g.中值滤波</h4><p>但是对于椒盐噪声和脉冲噪声，高斯卷积核的去噪效果就不好了。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001903.png" alt="image-20210919044510071"></p>
<p>此时需要使用中值滤波来处理。</p>
<p>中值滤波卷积核是空的，它是将窗口大小的数据都取出来，从小到大排列，然后取中间值为该像素点的灰度值。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001909.png" alt="image-20210919045017763"></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001916.png" alt="image-20210919045055087" style="zoom:67%;" /></p>
<h3 id="2-0-2卷积与边缘提取"><a href="#2-0-2卷积与边缘提取" class="headerlink" title="2.0.2卷积与边缘提取"></a>2.0.2卷积与边缘提取</h3><p>边缘是图像中亮度明显而急剧变化的点。</p>
<p>为什么要研究边缘呢？</p>
<ul>
<li>是图像中的语义与形状信息。</li>
<li>相对于像素表示，边缘表示显然更加紧凑。</li>
</ul>
<h4 id="a-边缘的种类"><a href="#a-边缘的种类" class="headerlink" title="a.边缘的种类"></a>a.边缘的种类</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001923.png" alt="image-20210919045422994"></p>
<h4 id="b-图像的导数"><a href="#b-图像的导数" class="headerlink" title="b.图像的导数"></a>b.图像的导数</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001929.png" alt="image-20210919045646382" style="zoom: 67%;" /></p>
<p>2维函数的求偏导公式为：</p>
<script type="math/tex; mode=display">
\frac{\partial f(x, y)}{\partial x}=\lim _{\varepsilon \rightarrow 0} \frac{f(x+\varepsilon, y)-f(x, y)}{\varepsilon}\tag{2.4}</script><p>因为这样求比较麻烦，要考虑无穷小量，所以图像求导公式为：</p>
<script type="math/tex; mode=display">
\frac{\partial f(x, y)}{\partial x}= \frac{f(x+1, y)-f(x, y)}{1}\tag{2.5}</script><p>也就是右边的像素值减去左边的像素值。也可以用卷积核来表示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001935.png" alt="image-20211018070901776" style="zoom:50%;" /></p>
<p>对x方向求导，得到的是y方向的边，对y方向求导，得到的是x方向的边。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001941.png" alt="image-20210919050343783" style="zoom:67%;" /></p>
<h4 id="c-图像的梯度"><a href="#c-图像的梯度" class="headerlink" title="c.图像的梯度"></a>c.图像的梯度</h4><p>图像的梯度指向灰度变化最快的方向（也就是从暗到亮）。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001948.png" alt="image-20210919050616424" style="zoom:67%;" /></p>
<p>梯度方向和边缘垂直。</p>
<p>梯度的模值越大，该点为边缘点的可能性越高。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001952.png" alt="image-20210919050743227" style="zoom:67%;" /></p>
<p>我们用梯度的模值来表示边缘信息，也就是边缘检测。</p>
<h4 id="d-噪声的影响"><a href="#d-噪声的影响" class="headerlink" title="d.噪声的影响"></a>d.噪声的影响</h4><p>如果图像存在噪声，边缘检测就会很难。所以需要先将图像平滑。根据噪声的种类选择平滑方法。</p>
<p>例如，如果是高斯噪声，就用高斯卷积核来处理。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215001959.png" alt="image-20210919051151686" style="zoom:67%;" /></p>
<p>因为图像的微分操作也是一个卷积，卷积符合交换律，所以可以将其处理顺序颠倒一下。</p>
<script type="math/tex; mode=display">
\frac{d(f*g)}{dx}=f*\frac{dg}{dx}\tag{2.6}</script><h4 id="e-高斯一阶偏导卷积核"><a href="#e-高斯一阶偏导卷积核" class="headerlink" title="e.高斯一阶偏导卷积核"></a>e.高斯一阶偏导卷积核</h4><p>（2.6）也叫做高斯一阶偏导卷积核。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002004.png" alt="image-20210919051605961" style="zoom:67%;" /></p>
<p>高斯一阶导只有一个参数，即标准差 $\sigma$ ，下面来看该参数对边缘提取的影响。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002011.png" alt="image-20210919051821817" style="zoom: 67%;" /></p>
<p>当标准差不同时，提取的边缘的粒度不同，如果小粒度细节，就采用标准差小的卷积核。</p>
<p>但是高斯一阶卷积核所提取的边缘有一个缺点，就是边缘过粗，这是因为像素灰度值变化通常是连续的，因此求导后，在一定范围内都有较大的导数值。如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002018.png" alt="image-20210919052444298" style="zoom: 50%;" /></p>
<p>此时引入一种方法，非最大值抑制。</p>
<h4 id="f-非最大值抑制"><a href="#f-非最大值抑制" class="headerlink" title="f.非最大值抑制"></a>f.非最大值抑制</h4><p>沿着边缘的梯度方向，保留边缘上值最大的点。</p>
<p>例如：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002025.png" alt="image-20210919052910609" style="zoom: 67%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002029.png" alt="image-20211111162057626" style="zoom: 25%;" /></p>
<p>找到边缘上的三个点p，q，r。现在就比较这三个点的梯度强度，保留梯度强度最大的点。</p>
<p>注意：通常情况下，q，r的坐标不是整数，需要插值。</p>
<h4 id="g-Canny边缘检测器"><a href="#g-Canny边缘检测器" class="headerlink" title="g.Canny边缘检测器"></a>g.Canny边缘检测器</h4><p>非最大值抑制以后，还有一个问题。</p>
<p>如果存在噪声，我们需要设置一个门限来过滤一下，如果门限过高， 许多细节边就显现不出来了；如果门限过低，就有太多的细节都出来。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002037.png" alt="image-20210919054109124" style="zoom:67%;" /></p>
<p>所以这个门限不太好设置。Canny算法选取双域值，先用高域值提取出主要的边缘，在用低域值，找出细节，保留和之前高域值提取出的边缘相连的边缘。</p>
<h3 id="2-0-3纹理表示"><a href="#2-0-3纹理表示" class="headerlink" title="2.0.3纹理表示"></a>2.0.3纹理表示</h3><p>纹理分为规则纹理和随机纹理。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002043.png" alt="image-20210919054648529" style="zoom: 67%;" /></p>
<p>想要表示这些纹理，规则的还好，形状大小都几乎相同。但是对于随机纹理的提取，就十分困难了。</p>
<p>有一个思路，就是用卷积核组来提取图像中的纹理，然后用基元的统计信息来表示图像中的纹理。</p>
<h4 id="a-卷积核组"><a href="#a-卷积核组" class="headerlink" title="a.卷积核组"></a>a.卷积核组</h4><p>由多个卷积核组成的一个卷积核组。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002050.png" alt="image-20210919150435866"></p>
<p>前面学过，高斯一阶卷积核，如上图左边，它可以提取出x方向的边缘。其他的卷积核也类似。特别的，最后一个卷积核可以提取出环形的边缘。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002056.png" alt="image-20210919160306939" style="zoom:67%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002105.png" alt="image-20211018064610184" style="zoom: 67%;" /></p>
<h4 id="b-基于卷积核组的图像表示"><a href="#b-基于卷积核组的图像表示" class="headerlink" title="b.基于卷积核组的图像表示"></a>b.基于卷积核组的图像表示</h4><p>在设计出一组卷积核组后，我们用这组卷积核来对图像进行卷积操作，获得对应的特征响应图组。然后再用特征响应图组的统计信息，来表示图像中的纹理。</p>
<p>eg：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002112.png" alt="image-20210919160721303"></p>
<p>$r_i$ 是将得到的一幅特征响应图拉成的向量，例如原图为$100\times 100$的尺寸，卷积后得到的特征响应图也为 $100\times 100$ ，拉成向量就是10000维的向量。在这个向量中，包括了提取出的边缘形状信息，也包括边缘所处的位置信息。但是我们是要表现出纹理特征，从而制定一种描述纹理特征的方式，所以位置信息是不重要的。因此采取的办法是将这个10000维的向量各个元素求平均，用平均值来表达该种边缘“有多少”。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002125.png" alt="image-20210919161306955" style="zoom:80%;" /></p>
<p>eg：有下面三幅图，分别用卷积核组进行上述处理，该卷积核组共有7个卷积核。卷积后得到了一个7维的向量。这个向量中的每一个元素都表示对应的边缘有多少。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002133.png" alt="image-20210919161538770" style="zoom:67%;" /></p>
<p>在这里，白色的代表值越大，就说明该种边缘在图中占据最多。</p>
<h4 id="c-卷积核组的设计"><a href="#c-卷积核组的设计" class="headerlink" title="c.卷积核组的设计"></a>c.卷积核组的设计</h4><p>卷积核组的设计要尽量包括各种边缘的类型，各种尺度，还有各个方向。</p>
<p>设计重点：</p>
<ul>
<li>卷积核类型</li>
<li>卷积核尺度</li>
<li>卷积核方向</li>
</ul>
<p>实际的例子：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002140.png" alt="image-20210919161909622" style="zoom:67%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002146.png" alt="image-20210919161944107" style="zoom:80%;" /></p>
<p>这样我们便可以将一张图的纹理特征表示出来。</p>
<p>从图像的纹理表示可以隐隐的知道，卷积神经网络的原理了，就是通过卷积核组，将一张图片的纹理描述出来（也就是各种边缘的统计信息），然后通过对纹理特征，来进行分类。</p>
<h2 id="2-1卷积神经网络结构"><a href="#2-1卷积神经网络结构" class="headerlink" title="2.1卷积神经网络结构"></a>2.1卷积神经网络结构</h2><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002152.png" alt="image-20210919213159199"></p>
<p>包括四个部分：</p>
<ul>
<li>CONV——卷积层</li>
<li>RELU——激活层</li>
<li>POOL——池化层</li>
<li>FC——全连接层</li>
</ul>
<h3 id="2-1-1全连接神经网络的瓶颈"><a href="#2-1-1全连接神经网络的瓶颈" class="headerlink" title="2.1.1全连接神经网络的瓶颈"></a>2.1.1全连接神经网络的瓶颈</h3><p>当图像太大时，需要训练的权值参数太多。</p>
<p>例如，CIFAR10图像尺寸为 $32\times32\times3$ ,隐层中的每个神经元的权值个数就为 3072个。</p>
<p>如果图像是 $200\times200\times3$ ，那么隐层中的每个神经元的权值个数就为120000个。</p>
<p>如果权值参数过多，计算量大不说，也很容易造成过拟合。</p>
<p>所以全连接神经网络仅适合处理小的图像。</p>
<p>怎么才能获得小图像呢，可以看到，当图像经过卷积核组卷积后，对输出值进行加权，就可以得到一个维度很小的向量，所以我们想将图像先经过卷积核组处理，然后得到一个维数较低的向量，在把这个向量作为全连接神经网络的输入。</p>
<h3 id="2-1-2卷积层"><a href="#2-1-2卷积层" class="headerlink" title="2.1.2卷积层"></a>2.1.2卷积层</h3><h4 id="a-卷积网络中的卷积核"><a href="#a-卷积网络中的卷积核" class="headerlink" title="a.卷积网络中的卷积核"></a>a.卷积网络中的卷积核</h4><p>与前面所学的卷积核不同的是，卷积神经网络中的卷积核是一个“立体的”。</p>
<p>因为图像通常是彩色的，每个像素点有RGB三个通道，所以卷积核需要对每个通道进行卷积操作，因此卷积核是一个立体的。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002158.png" alt="image-20210919165628361" style="zoom:67%;" /></p>
<p>另外一个不同时，卷积核还有一个偏置。也就是卷积过后，对得到的结果再加上一个偏置值。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002202.png" alt="image-20210919165853023" style="zoom:67%;" /></p>
<h4 id="b-卷积网络中的卷积操作"><a href="#b-卷积网络中的卷积操作" class="headerlink" title="b.卷积网络中的卷积操作"></a>b.卷积网络中的卷积操作</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002209.png" alt="image-20210919170339406" style="zoom:80%;" /></p>
<p>一个三通道图经过卷积核卷积后，就得到了一个特征响应图，该响应图为1个通道，在没有边界补充的情况下，得到的特征响应图是 $28\times28\times1$ 。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002215.png" alt="image-20210919171450381" style="zoom:67%;" /></p>
<p>如果用6个卷积核，卷积后就得到6个特征响应图。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002220.png" alt="image-20210919171610690" style="zoom:67%;" /></p>
<p>总结：</p>
<ul>
<li>特征响应图组深度等于卷积核的个数。</li>
<li>不同特征响应图反映了输入图像对不同卷积核的响应结果</li>
<li>同一特征响应图上不同位置的值表示输入图像上不同位置对同一卷积核的响应结果。</li>
</ul>
<h4 id="c-卷积步长"><a href="#c-卷积步长" class="headerlink" title="c.卷积步长"></a>c.卷积步长</h4><p>卷积神经网络中，卷积核可以按照指定的间隔进行卷积操作，这个间隔就是卷积步长。</p>
<p>卷积步长可以影响输出的特征响应图的大小。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002414.png" alt="image-20211215002414442" style="zoom: 33%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002537.png" alt="image-20211215002537453" style="zoom:33%;" /></p>
<script type="math/tex; mode=display">
\begin{aligned}
&W 2=(W 1-F) / S+1 \\
&H 2=(H 2-F) / S+1
\end{aligned}\tag{2.7}</script><p>其中，输入图片大小为：$W1\times H1$ ，输出图像大小为：$W2\times H2$ 。F为卷积的大小，S为卷积步长。</p>
<p>eg：输入图像为7，卷积核大小为3，步长为1。</p>
<p>输出图像大小=（7-3）/1 +1=5</p>
<h4 id="d-边界填充"><a href="#d-边界填充" class="headerlink" title="d.边界填充"></a>d.边界填充</h4><p>如果没有边界填充，如前面的例子，卷积操作后会使图像变小。</p>
<p>而卷积神经网络中常用的填充方式是零值填充。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002555.png" alt="image-20210919173529384" style="zoom:80%;" /></p>
<p>边界填充与输入输出图像大小还有卷积步长之间的关系为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&W 2=(W 1-F+2 P) / S+1 \\
&H 2=(H 2-F+2 P) / S+1
\end{aligned}\tag{2.8}</script><p>这里P是一边填充的层数，如上图就是填充了1层。</p>
<p>通过式（2.8）还可以已知输入和输出图像，反求出填充层数。</p>
<h4 id="e-特征响应图尺寸计算"><a href="#e-特征响应图尺寸计算" class="headerlink" title="e.特征响应图尺寸计算"></a>e.特征响应图尺寸计算</h4><p>由前面的学习，可知特征响应图的尺寸大小主要与以下几个参数有关：</p>
<ul>
<li>卷积核的宽，高；</li>
<li>是否采用边界填充操作；</li>
<li>卷积步长；</li>
<li>该层的卷积核个数（主要影响特征响应图的深度）</li>
</ul>
<p>以上这四个参数是超参数。</p>
<h3 id="2-1-3池化层"><a href="#2-1-3池化层" class="headerlink" title="2.1.3池化层"></a>2.1.3池化层</h3><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002601.png" alt="image-20210919213159199"></p>
<p>卷积神经网络的结构如上图所示，先一层卷积层，然后接一个RELU激活函数层，就是让卷积后的图像每一个像素点的值都经过RELU激活函数。然后再经过一层POOL层，也就是池化层。</p>
<h4 id="a-池化层的作用"><a href="#a-池化层的作用" class="headerlink" title="a.池化层的作用"></a>a.池化层的作用</h4><p>之前的卷积操作时，每张图片有三个通道，所以一个卷积核也是3维的，对三个通道一同处理。当有n个卷积核组成一个卷积核组时，得到n个特征响应图，因此这个特征响应图是有n个通道的。</p>
<p>池化操作是对每一个特征响应图独立进行，降低特征响应图组中每个特征响应图的宽度和高度，减少后续卷积层的参数的数量，降低计算资源耗费，控制过拟合。因此池化操作后，仍然有n个特征响应图。</p>
<p>另外一点，缩小图像，卷积核大小不变，此时就相当于卷积核变大，就可以看到更大的纹理。</p>
<h4 id="b-池化操作"><a href="#b-池化操作" class="headerlink" title="b.池化操作"></a>b.池化操作</h4><p>对特征响应图某个区域进行池化就是在该区域上指定一个值来代表整个区域。</p>
<p><strong>常见的池化操作：</strong></p>
<p>最大池化：使用区域内的最大值来代表这个区域。</p>
<p>平均池化：采用区域内所有值的均值作为代表。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002615.png" alt="image-20210920004702991" style="zoom:80%;" /></p>
<p>最大池化就相当于之前讲的非最大化值抑制，我们只保留一个区域的最大值，就是把最明显的特征表示出来。因此上图的最大池化操作后，特征响应图中的75%的响应信息都丢掉，但不改变特征响应图的个数。</p>
<p>在池化操作中，池化的步长和窗口大小是两个超参数。</p>
<p>在训练后的卷积神经网络中，前面的卷积层记录的是纹理基元信息，如边缘，圆环等等形状基元。越往后的卷积层记录的是高层的基元，可能是一个人脸的模版，只要图片中有人脸，它就会响应。</p>
<h2 id="2-2图像增强"><a href="#2-2图像增强" class="headerlink" title="2.2图像增强"></a>2.2图像增强</h2><h3 id="2-2-1图像增强的提出"><a href="#2-2-1图像增强的提出" class="headerlink" title="2.2.1图像增强的提出"></a>2.2.1图像增强的提出</h3><p>存在问题：过拟合的原因是学习样本太少，导致无法训练出能够泛化到新数据的模型。</p>
<p>于是采用数据增强的办法，就是从现有的训练样本中生成更多的训练数据，其方法是利用多种能够生成可信图片的随机变换来增加样本。</p>
<p>数据增强的目标：模型在训练时不会两次查看完全相同的图像。这能够让模型观察到数据的更多内容，从而具有更好的泛化能力。</p>
<h3 id="2-2-2样本增强的方法"><a href="#2-2-2样本增强的方法" class="headerlink" title="2.2.2样本增强的方法"></a>2.2.2样本增强的方法</h3><h4 id="a-翻转"><a href="#a-翻转" class="headerlink" title="a.翻转"></a>a.翻转</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002626.png" alt="image-20210920010950446" style="zoom: 67%;" /></p>
<h4 id="b-随机缩放和抠图"><a href="#b-随机缩放和抠图" class="headerlink" title="b.随机缩放和抠图"></a>b.随机缩放和抠图</h4><p>得到一张图以后，对其进行缩放再截取抠图。相当于从多个视角看原有的图像中的内容。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002632.png" alt="image-20210920012602034"></p>
<p><strong>以残差网络中的样本增强方法为例：</strong></p>
<p>输入要求：$224\times224$ 的彩色图片。</p>
<p>在训练的时候：在不同尺度、不同区域随机扣取。</p>
<p>对于现有的训练数据集，有很多的图片，我们这样做：</p>
<ul>
<li>先在[256,480]之间随机选择一个尺寸L。</li>
<li>将训练数据集中的图拍呢缩放至短边为L的图像。</li>
<li>在该缩放后的样本图像中，随机采样一个$224\times224$ 的图像区域。</li>
</ul>
<p>在测试的时候：按照一套预先定义的方式扣取</p>
<ul>
<li>将图像缩放成5种尺寸：{224,256,384,480,640}。</li>
<li>对每一个尺度的图像及其镜像图片，分别在四个角和中间位置扣取$224\times224$ 区域。</li>
</ul>
<h4 id="c-色彩抖动"><a href="#c-色彩抖动" class="headerlink" title="c.色彩抖动"></a>c.色彩抖动</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002638.png" alt="image-20210920012629968"></p>
<h1 id="3-经典网络分析"><a href="#3-经典网络分析" class="headerlink" title="3.经典网络分析"></a>3.经典网络分析</h1><p>按照时间的顺序，介绍5种经典的卷积神经网络。这5种卷积神经网络在ImageNet大赛上都取得了跨越式的成绩。</p>
<h2 id="3-1AlexNet"><a href="#3-1AlexNet" class="headerlink" title="3.1AlexNet"></a>3.1AlexNet</h2><p>2012年提出的该网络。其主要贡献有：</p>
<ul>
<li>提出了一种卷积层和全连接层的神经网络结构</li>
<li>首次使用ReLU函数作为激活函数</li>
<li>首次提出Dropout正则化来控制过拟合</li>
<li>使用加入动量的小批量梯度下降算法加速了训练过程的收敛</li>
<li>使用数据增强策略极大的抑制了训练过程的过拟合</li>
<li>利用GPU并行计算，加速了网络的训练和推断</li>
</ul>
<p>网络结构</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002645.png" alt="image-20210921162339688" style="zoom:50%;" /></p>
<p>AlexNet共有卷积层，池化层，局部响应归一化层，全连接层四部分组成，如上图所示。</p>
<blockquote>
<p>补充：在计算神经网络层数时，仅统计卷积层和全连接层，因为池化层与归一化层仅对前面的卷积层的输出的特征图进行后处理，不单独算做一层。</p>
</blockquote>
<p>AlexNet共有5个卷积层和3个全连接层。</p>
<h3 id="3-1-1卷积层"><a href="#3-1-1卷积层" class="headerlink" title="3.1.1卷积层"></a>3.1.1卷积层</h3><p>第一层卷积（CONV1）：96个 $11\times11$ 的卷积核，步长为4，没有零填充。</p>
<p><strong>ques：如果输入的是 $227\times227\times3$ 的图像，输出的特征响应图的个数和尺寸？</strong></p>
<p>$(227-11)/4+1=96$ 个，因此输出的特征响应图是 $96\times96\times1$ ，共有96个。</p>
<p><strong>ques：这层共有多少个参数？</strong></p>
<p>$96\times(11\times11\times3+1)=35k$ ，因为每一个卷积核还有一个偏置。</p>
<p>所以经过该层卷积后，得到96个 $96\times96$ 的特征响应图，然后特征响应图的每一个元素经过ReLU激活函数处理。</p>
<p>第二层卷积（CONV2）：256个 $5\times5$ 的卷积核，步长为1，使用零填充p=2。</p>
<p>另外需要注意的是，第二层卷积层处理的图像大小相对于第一层处理的图像大小，小了很多，这样就好比第二层的卷积层在原图上有着更大的视野。</p>
<p>第三层和第四层（CONV3，CONV4）：384个 $3\times3$ 卷积核，步长为1，使用零填充p=1。</p>
<p>第五层卷积（CONV5）：256个 $3\times3$ 的卷积核，步长为1，使用零填充p=1。</p>
<p>然后通过最大池化层进一步缩小特征图尺寸。</p>
<h3 id="3-1-2池化层"><a href="#3-1-2池化层" class="headerlink" title="3.1.2池化层"></a>3.1.2池化层</h3><p>Max POOL1:窗口大小为 $3\times3$ ，步长为2</p>
<p>它的作用是降低特征响应图的尺寸，对抗轻微的目标偏移带来的影响。这个对抗目标偏移就是在一定的区域内，选择数值最大的数作为该像素点的值，因为即使这个最大值偏移到该区域的别的像素，也会被采集，作为该点的值。</p>
<p>还要注意的是，窗口大小为  $3\times3$ ，步长是2，这在池化的过程中，会使窗口产生重叠，这样能够对抗过拟合。</p>
<p>ques:输入图片为 $55\times55$ ，池化后的尺寸？<br>$(55-3)/2+1=27$ ,特征响应图的个数不变。</p>
<p>该层的参数个数为0。</p>
<h3 id="3-1-3局部归一化层"><a href="#3-1-3局部归一化层" class="headerlink" title="3.1.3局部归一化层"></a>3.1.3局部归一化层</h3><p>作用：</p>
<ul>
<li>对局部神经元的活动创建竞争机制</li>
<li>响应比较大的值变得相对更大</li>
<li>抑制其他反馈小的神经元</li>
<li>增强模型的泛化能力</li>
</ul>
<p>该方法现在的网络通常不用。</p>
<h3 id="3-1-4全连接层"><a href="#3-1-4全连接层" class="headerlink" title="3.1.4全连接层"></a>3.1.4全连接层</h3><p>全连接神经网络分类器。</p>
<p>输入是特征响应图组，输出为图像类别概率。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002651.png" alt="image-20210921165054112" style="zoom: 67%;" /></p>
<p>将特征响应图组中的每一个特征响应图展开成一个向量，然后作为输入，输入到全连接层。</p>
<p>注意：卷积层和全连接层是共同训练的</p>
<h3 id="3-1-5卷积层的作用"><a href="#3-1-5卷积层的作用" class="headerlink" title="3.1.5卷积层的作用"></a>3.1.5卷积层的作用</h3><p>卷积层的作用就是提取图像的特征，低层的卷积层提取的是低等的结构基元，越高层的卷积层越具有语义信息，将这些基元进行组合，得到某种类别的结构信息。然后输入到全连接层进行分类。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002656.png" alt="image-20210921165633179" style="zoom:67%;" /></p>
<h2 id="3-2-ZFNet"><a href="#3-2-ZFNet" class="headerlink" title="3.2 ZFNet"></a>3.2 ZFNet</h2><p>ZFNet神经网络的结构与AlexNet的结构基本一致。</p>
<p>主要的改进有：</p>
<ul>
<li>将第一个卷积层的卷积核大小改为7</li>
<li>将第二和第三个卷积层的卷积步长都设置为2</li>
<li>增加了第三和第四个卷积层的卷积核数量</li>
</ul>
<p>第一层的卷积核改小，是防止细粒度信息丢失。</p>
<p>步长改小，防止图像的尺寸降低过快。</p>
<p>因为在后面的卷积层已经出现了语义信息，所以增加卷积核个数，有助于增强描述能力。</p>
<h2 id="3-3-VGG"><a href="#3-3-VGG" class="headerlink" title="3.3 VGG"></a>3.3 VGG</h2><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002702.png" alt="image-20210921170404131" style="zoom:67%;" /></p>
<p>VGG卷积神经网络主要有两种结构，一个是16层，一个是19层。19层的精度略高，但是会占用计算资源，所以VGG16常用。</p>
<p>VGG16共有13个卷积层，3个全连接层。</p>
<p>共分为5段，CONV1——CONV5，每段的卷积层的卷积核个数都相同。</p>
<p>卷积层均采用大小为3的卷积核核ReLU激活函数。</p>
<p>池化层采用最大池化，窗口大小为2，步长为2。</p>
<p>每经过一次池化，后层的卷积核个数就增大一倍，直到512。</p>
<p>全连接层中采用了Dropout策略。</p>
<p><strong>ques：小卷积核有哪些优势？</strong></p>
<p>多个小尺寸卷积核串联可以得到与大尺寸卷积核相同的感受野。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002707.png" alt="image-20210921173002501" style="zoom: 67%;" /></p>
<p>同时，使用小卷积核串联，构建的神经网络更深，非线性更强，参数也更少。</p>
<p>假设，输入和输出的图像的个数均为C，这个C也就是深度值。</p>
<p>那么3个小卷积核串联的总参数为：$(3\times3\times C)\times C\times3=27C^2$ ，就是尺寸 $\times$ 尺寸 $\times$ 深度 $\times$ 卷积核个数 $\times$ 3。</p>
<p>而用一个尺寸为7的大卷积核的参数个数为：$(7\times7\times C)\times C=49C^2$ 。</p>
<p><strong>ques：为什么前四段的卷积层，每经过一次池化操作，卷积核个数就增加一倍？</strong></p>
<p> 池化操作可以减少特征图尺寸，降低显存占用。</p>
<p>增加卷积核个数有助于学习更多的结构特征，但会增加网络参数数量以及内存消耗。</p>
<p>一增一减的设计平衡了识别精度与存储计算的开销。</p>
<p><strong>ques：为什么卷积核个数增加到512后就不再增加了？</strong></p>
<p>最后一层卷积层与全连接层相连，第一层全连接层的参数个数为102M，占总参数的75%。</p>
<p>全连接网络第一层的参数个数是最后一层卷积层输出的特征图尺寸乘以个数。</p>
<h2 id="3-4-GoogleNet"><a href="#3-4-GoogleNet" class="headerlink" title="3.4 GoogleNet"></a>3.4 GoogleNet</h2><p>GoogleNet的创新点：</p>
<ul>
<li><p>提出了一种Inception结构，它能保留输入信号中的更多特征信息。</p>
</li>
<li><p>去掉了AlexNet的前两个全连接层，并采用了平均池化，这一设计可以使参数大大减少。</p>
</li>
<li>在网络中引入辅助分类器，克服了训练过程中的梯度消失问题。</li>
</ul>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002713.png" alt="image-20210921174439835" style="zoom:67%;" /></p>
<p>首先说一下纯串联结构的问题：</p>
<p>就是后层的卷积层只能处理前层输出的特征响应图，前层可能因为某些原因（比如感受野受限）丢失重要的信息，后层无法找回。</p>
<p>所以GoogleNet提出的Inception结构可以尽量保留输入信号更多的信息。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002718.png" alt="image-20210921174802435" style="zoom:67%;" /></p>
<p>这个模块就是在该层设置不同尺寸大小的卷积核组，对输入图像进行处理，来提取不同尺度的特征，从而获得更多的信息。而MaxPOOL的作用是对原图数值比较大的地方进行扩张，就是让那一像素点周围的像素值都和它相同。</p>
<p>在该网络中，这个模块的结构如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002723.png" alt="image-20210921175222312" style="zoom:67%;" /></p>
<p>在大尺寸的卷积核前加上一层尺寸为1的卷积核组，对图像进行压缩处理，使图像的深度变为1。如下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002731.png" alt="image-20210921175625286" style="zoom:67%;" /></p>
<p>可以看出，参数数量大约下降3倍。所以该结构的优点是<strong>层数更深，参数更少，计算效率更高，非线性表达能力更强。</strong></p>
<p>GoogleNet共堆叠了9个Inception  V1模块。</p>
<p>然后再卷积层核全连接层链接的地方，加入了一个平均池化模块，可以有效的降低全连接层的参数。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002754.png" alt="image-20210921180124503" style="zoom:67%;" /></p>
<p>另外，在该神经网络中，还加入了辅助分类损失。如下图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002800.png" alt="image-20210921180315580" style="zoom:67%;" /></p>
<p>虽然ReLU激活函数可以一定程度的解决梯度消失的问题，但并不能完全解决深层网络难以训练的问题。离输出远的层就不如离输出近的层训练得好。所以让低层的卷积层也有损失函数，可以让低层的卷积层更好的被训练，也能加速整个网络的收敛速度。</p>
<p>在预测时，仅利用网络的最后的输出作为预测结果，忽略辅助分类器的输出。</p>
<p><strong>ques：平均池化向量核直接展开向量化有什么区别？</strong></p>
<p>特征响应图上的每个位置的值反映了图像对应位置的结构与卷积核记录的语义结构的相似程度。平均池化丢失了语义结构的空间位置信息。这样有利于提升卷积层提取到的特征的平移不变性。</p>
<p><strong>ques：利用尺寸为1的卷积核进行压缩会损失信息么？</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002806.png" alt="image-20210921181011718" style="zoom:67%;" /></p>
<h2 id="3-5-ResNet"><a href="#3-5-ResNet" class="headerlink" title="3.5 ResNet"></a>3.5 ResNet</h2><p>首先考虑一个问题：持续的向一个基础的神经网络结构上面叠加更深的层数会发生什么？</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002811.png" alt="image-20210921181415315" style="zoom:67%;" /></p>
<p>如上图所示：测试集的误差增多，是因为过拟合造成的。但是训练集的误差不应该增加呀。</p>
<p>原因是当网络的层数增加，会造成正向信息流核反向梯度流传播不顺畅，使一些参数得不到训练。</p>
<p>ResNet卷积神经网络就是主要解决这样一个问题。</p>
<p>主要贡献：</p>
<ul>
<li>提出了一种残差模块，通过堆叠残差模块可以构建任意深度的神经网络，而不会出现退化的情况。</li>
<li>提出了批归一化方法来对抗梯度消失，该方法降低了网络训练过程对于权重初始化的依赖。</li>
<li>提出了一种针对ReLU激活函数的初始化方法。</li>
</ul>
<p>后两个问题前面都已经讲过，现在主要说第一点。</p>
<p>研究人员考虑这样一个问题，就是浅层网络学习了有效的分类模式后，如何有效的向上堆积新层来建立更深的网络，使其满足即使不能提升浅层网络的性能，深层网络也不应该降低性能。</p>
<p>这就引出了残差模块：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002816.png" alt="image-20210921182150081" style="zoom:67%;" /></p>
<p>就是对输入图像进行卷积处理，然后与未经处理的输入图像进行叠加，这样做即使卷积操作后的输出是0，但是仍可以保证X继续输入到下一层。这样就保证了信息流的正向传递。这就有点像锐化操作，在保留原图的基础上，把感兴趣的特征再次叠加到原图上。</p>
<p>卷积层学习的变换为F(X)，残差结构的输出为 H(X)。</p>
<script type="math/tex; mode=display">
H(X)=F(X)+X\tag{3.1}</script><p>在反向梯度传递时：</p>
<script type="math/tex; mode=display">
\frac{\partial{H(X)}}{\partial{X}}=\frac{\partial{F(X)}}{\partial X}+1\tag{3.2}</script><p>即使前面一项为0，但是梯度也不为0。</p>
<script type="math/tex; mode=display">
F(X)=H(X)-X\tag{3.3}</script><p>其中 F(X) 为残差项，训练就是对该项进行训练。所以叫做残差模块。</p>
<p><strong>ques：残差网络为什么性能这么好？</strong></p>
<p>残差网络可以看作是一种集成模型。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002823.png" alt="image-20210921182857292" style="zoom:67%;" /></p>
<p>残差网络和Inception V4是公认的推广性能最好的两个分类模型</p>
<h1 id="4-其他任务"><a href="#4-其他任务" class="headerlink" title="4.其他任务"></a>4.其他任务</h1><p>前面我们学习的都是针对图像分类任务提出的解决方案，现在讨论在应对其他任务时的解决方案。</p>
<ul>
<li>分类问题：分类问题是对每一张图片进行分类，是整张图片的类别。</li>
<li>语义分割：本质上也是分类问题，与分类问题不同的是，需要对一张图片上的每一个像素点都进行分类，是像素级别的分类问题。</li>
<li>目标检测：是一个区域级别的分类问题。</li>
<li>实例分割： 对实例进行分割。类似于语义分割，但不同的是语义分割中，同一个类别的东西，标签都一样，例如有两只猫，这两只猫的标签是一样的。而实例分割中，这两只猫的标签是不同的。</li>
</ul>
<h2 id="4-1语义分割"><a href="#4-1语义分割" class="headerlink" title="4.1语义分割"></a>4.1语义分割</h2><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002830.png" alt="image-20210922235321815" style="zoom:67%;" /></p>
<h3 id="4-1-1滑动窗口"><a href="#4-1-1滑动窗口" class="headerlink" title="4.1.1滑动窗口"></a>4.1.1滑动窗口</h3><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002838.png" alt="image-20210922235444838" style="zoom:67%;" /></p>
<p>该方法是，取一个滑动窗口，让每一个像素点和其周围的像素点作为一张图片，进行分类。</p>
<p>但是该方法有一个问题，就是滑动窗口，有很多重叠的区域的特征被反复计算，因此效率太低。</p>
<h3 id="4-1-2-全卷积"><a href="#4-1-2-全卷积" class="headerlink" title="4.1.2 全卷积"></a>4.1.2 全卷积</h3><p>采用全卷积神经网络进行学习。在卷积层中，卷积操作不改变图像的大小，即对每个像素点都进行分类，特征响应图的深度等于类别的数量。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002845.png" alt="image-20210923000057185" style="zoom:67%;" /></p>
<p>但是该方法也存在一个弊端，那就是在卷积操作中，因为不改变图像的大小，所以会占用大量的显存，导致硬件条件不允许。</p>
<p>改进的方法就是改变卷积的结构，采用下采样和上采样过程。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002852.png" alt="image-20210923000227495" style="zoom:67%;" /></p>
<p>所谓下采样，就是我们之前所说的，每经过一次卷积或者是池化，都会使图像的尺寸减小。</p>
<p>而上采样，与这个过程正好相反。上采样就是经过一次这样的处理，使图像尺寸变大。</p>
<p>经过这样的操作，就可以在中间层减小图像尺寸，从而降低显存的占用。而有可以满足对每个像素点进行分类。</p>
<h3 id="4-1-3上采样方法"><a href="#4-1-3上采样方法" class="headerlink" title="4.1.3上采样方法"></a>4.1.3上采样方法</h3><h4 id="a-反池化操作"><a href="#a-反池化操作" class="headerlink" title="a.反池化操作"></a>a.反池化操作</h4><p>（1）Nearest Neighbor</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002857.png" alt="image-20210923001003199" style="zoom:67%;" /></p>
<p>就是对周围的像素赋予一样的值。</p>
<p>（2）Bed of Nails</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002902.png" alt="image-20210923001044839" style="zoom:67%;" /></p>
<p>对周围像素补0。</p>
<p>（3）Max Unpooling</p>
<p>这个与（2）不同的是，在池化时，记住每一个值的位置。反池化时，把这个值填到原来的位置上，其余的补0。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002910.png" alt="image-20210923001325387" style="zoom: 67%;" /></p>
<p>以上的方法在程序中，程序是固定的，也没有什么参数。</p>
<p>我们就想，可不可以通过加权的方式对周围的像素赋值，使其尺寸变大呢？加权的参数可不可以通过训练的方法得到呢？</p>
<p>这就引出了转置卷积的方法。</p>
<h4 id="b-转置卷积"><a href="#b-转置卷积" class="headerlink" title="b.转置卷积"></a>b.转置卷积</h4><p>现在我们回顾一下卷积操作：<br>尺寸为3的卷积核，步长为2，零填充为1，输入一个尺寸为4的图像。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002916.png" alt="image-20210923002017235" style="zoom:67%;" /></p>
<p>可以看到中间有两个窗口重叠的地方。</p>
<p>那么现在反过来，输入图像尺寸为2，输出为4。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002921.png" alt="image-20210923002202360" style="zoom:67%;" /></p>
<p>可以知道，在卷积中，红色方块的值是从红色窗口中来的，蓝色方框的值是从蓝色窗口来的。重叠部分就表明，该部分的值既参与了红色方块值的计算，也参加了蓝色方块的计算。</p>
<p>所以重叠部分的值要经过这两个方块值的加权，才能还原回来，这个加权的参数就可以通过训练得到。</p>
<p><strong>eg：一个一维的例子</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002926.png" alt="image-20210923002921998" style="zoom:67%;" /></p>
<p>还是一维的例子，假设有一个向量 $[a,b,c,d]^T$ ，现在有一个一维的卷积核 $\vec x=[x,y,z]$ ，步长为1，零填充为1， 对其卷积，写成矩阵的形式为</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccccc}
x & y & z & 0 & 0 & 0 \\
0 & x & y & z& 0 & 0 \\
0 & 0 & x & y & z & 0 \\
0 & 0 & 0 & x & y & z
\end{array}\right]\left[\begin{array}{l}
0 \\
a \\
b \\
c \\
d \\
0
\end{array}\right]=\left[\begin{array}{c}
a y+b z \\
a x+b y+c z \\
b x+c y+d z \\
c x+d y
\end{array}\right]\tag{4.1}</script><p>（4.1）还可以写成：</p>
<script type="math/tex; mode=display">
X*\vec a=\vec b\tag{4.2}</script><p>当我们想上采样时，只需要将（4.1）左边的矩阵进行转置，就可以得到大尺寸的图像。</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccc}
x & 0 & 0 & 0 \\
y & x & 0 & 0 \\
z & y & x & 0 \\
0 & z & y & x \\
0 & 0 & z & y \\
0 & 0 & 0 & z
\end{array}\right]\left[\begin{array}{c}
a \\
b \\
c \\
d
\end{array}\right]=\left[\begin{array}{c}
a x \\
a y+b x \\
a z+b y+c x \\
b z+c y+d x \\
c z+d y \\
d z
\end{array}\right]\tag{4.3}</script><p><strong>eg：二维的例子</strong></p>
<p>就是我们图像处理的卷积核，有一个图像大小为4，卷积核大小为3，步长为1，零填充为1。</p>
<p>卷积核可以写成：</p>
<script type="math/tex; mode=display">
C=\left[\begin{array}{ccc}
x_1&x_2&x_3\\
y_1&y_2&y_3\\
z_1&z_2&z_3
\end{array}\right]=[\vec v_1\ \vec v_2\ \vec v_3]\tag{4.4}</script><p>零填充后的图像可以写成：</p>
<script type="math/tex; mode=display">
I=\left[\begin{array}{cccccc}
0&0&0&0&0&0 \\
0&a_1&a_2&a_3&a_4&0 \\
0&b_1&b_2&b_3&b_4&0 \\
0&c_1&c_2&c_3&c_4&0 \\
0&d_1&d_2&d_3&d_4&0 \\
0&0&0&0&0&0
\end{array}\right]=[\vec i_1\ \vec i_2\ \vec i_3\ \vec i_4\ \vec i_5\ \vec i_6]\tag{4.5}</script><p>那么卷积核中的向量 $\vec v_i$ 对应的卷积矩阵为 $X_i是{4\times 6}$维 ，所以图像的卷积可以表示成：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}
C*I&=[X_1\vec i_n+X_2\vec i_{n+1}+X_3\vec i_{n+2}]_{4\times4}\\
&=[X_1\quad X_2\quad X_3]_{4\times 18}
\left[\begin{array}{l}
\vec i_n\\\vec i_{n+1}\\ \vec i_{n+2}
\end{array}\right]_{18\times1}
\end{aligned}
\quad n=1,2,3,4\tag{4.6}</script><h2 id="4-2目标检测"><a href="#4-2目标检测" class="headerlink" title="4.2目标检测"></a>4.2目标检测</h2><h3 id="4-2-1单目标检测"><a href="#4-2-1单目标检测" class="headerlink" title="4.2.1单目标检测"></a>4.2.1单目标检测</h3><p>目标检测包含了两个问题，一个是分类问题，就是知道图像中有什么东西，另一个是定位问题，确定这个东西在哪。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002935.png" alt="image-20210923014451462" style="zoom:67%;" /></p>
<p>如上图的例子，卷积层输出一个4096维的向量，将其连接在全连接层，输出一个1000维的向量，进行分类。</p>
<p>另外一个方向，将4096维向量映射为一个4维的向量，进行定位，和标出方框大小。</p>
<p>在这里，损失函数由两部分组成，一个是分类的损失函数，另一个是预测坐标和正确坐标的损失函数。</p>
<h3 id="4-2-2多目标检测"><a href="#4-2-2多目标检测" class="headerlink" title="4.2.2多目标检测"></a>4.2.2多目标检测</h3><p>目标个数不确定，不知道输出多少个坐标。所以不能提前给定神经网络应该输出多少维的向量。</p>
<p>所以采用滑动窗口的思路，把每个窗口都当成一张图片。就相当于穷举一张图片所有的区域，分别进行计算。但是这种方法计算了巨大，神经网络不能正常运行。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002941.png" alt="image-20210923015722221" style="zoom:67%;" /></p>
<h4 id="a-区域建议"><a href="#a-区域建议" class="headerlink" title="a.区域建议"></a>a.区域建议</h4><p>提前对图像处理，找出所有潜在可能包含目标的区域。然后再进行分类。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002947.png" alt="image-20210923020227305" style="zoom:67%;" /></p>
<p>区域建议的方法叫做<strong>Selective Search</strong> 。这种方法的主要思想如下：</p>
<ul>
<li>使用一种过分割手段，将图像分割成小区域（1k-2k个）</li>
<li>查看现有的小区域，按照合并规则合并出可能性最高的相邻的两个区域。直至合并成整张图大小的一个区域。</li>
<li>输出所有曾经合并过程的区域，成为候选区域。</li>
</ul>
<h4 id="b-R-CNN"><a href="#b-R-CNN" class="headerlink" title="b.R-CNN"></a>b.R-CNN</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002953.png" alt="image-20210923034448871" style="zoom:67%;" /></p>
<p>主要思路如上图所示：</p>
<ul>
<li>先通过Selective Search方法选出候选区域，大约2k左右个。</li>
<li>由于各个区域大小不同，对各个区域进行缩放，得到尺寸为224的图片。</li>
<li>将尺寸一样的各区域图片输入到卷积神经网络中，进行特征提取。</li>
<li>卷积输出的特征图输入到SVMs线性分类器中进行分类。</li>
<li>特征图还输入到Bbox reg中，可以对之前Selective Search得到的特征框进行修正，从而输出正确的特征框。</li>
</ul>
<p>但是R-CNN的弊病就是计算效率低下，在一张图像中，需要对许多区域都进行特征提取。</p>
<p>所以后来进行改进。</p>
<h4 id="c-Fast-R-CNN"><a href="#c-Fast-R-CNN" class="headerlink" title="c.Fast R-CNN"></a>c.Fast R-CNN</h4><p>与之前的R-CNN不同，该方法是先提取图像的特征，然后再进行Selective Search。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215002959.png" alt="image-20210923040423808" style="zoom:67%;" /></p>
<p>这样就可以避免多次进行特征提取。将特征进行裁剪缩放后，输入到全连接层，进行分类和特征框修正。</p>
<p>在这里需要对特征进行裁剪缩放，是很重要的，为了保证整个神经网络前向信息和反向信息正常传递。全连接层的输入大小应该是一样的。</p>
<h5 id="（1）区域裁剪：Rol-Pool"><a href="#（1）区域裁剪：Rol-Pool" class="headerlink" title="（1）区域裁剪：Rol Pool"></a>（1）区域裁剪：Rol Pool</h5><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003004.png" alt="image-20210923041011020" style="zoom:67%;" /></p>
<p>首先将候选区域映射到特征图上（此处也可以理解为在特征图上直接选择候选区域）</p>
<p>但是候选区域往往不是在整数像素点上，可能是在两个像素点之间。Rol Pool方法就是将这些区域进行微调，调整到像素点上。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003008.png" alt="image-20210923041208609" style="zoom:67%;" /></p>
<p>然后将候选区域粗略的分成面积相等的 $2\times2$ 个子区域。然后对每个子区域做最大池化。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003016.png" alt="image-20210923041414784" style="zoom:67%;" /></p>
<p>最终可以使所有区域的特征尺寸一样。</p>
<p>但是该方法会使特征区域有一点对不齐，会影响效率。</p>
<h5 id="（2）区域裁剪：Rol-Align"><a href="#（2）区域裁剪：Rol-Align" class="headerlink" title="（2）区域裁剪：Rol Align"></a>（2）区域裁剪：Rol Align</h5><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003026.png" alt="image-20210923041715989" style="zoom:67%;" /></p>
<p>与Rol Pool方法不同的是，不进行归整，利用插值求出个点的值。</p>
<p>也是平均分成4块，每块选取4个点，每个点的值利用插值来计算，在每个点周围选取四个整数像素点，然后通过下面公式进行计算：</p>
<script type="math/tex; mode=display">
f_{x y}=\sum_{i, j=1}^{2} f_{i, j} \max \left(0,1-\left|x-x_{i}\right|\right) \max \left(0,1-\left|y-y_{j}\right|\right)\tag{4.7}</script><p>然后在进行最大池化。</p>
<h4 id="d-Faster-R-CNN"><a href="#d-Faster-R-CNN" class="headerlink" title="d.Faster R-CNN"></a>d.Faster R-CNN</h4><p>在中间特征层后加入区域建议网络RPN（Region Proposal Network），产生候选区域。其他部分保持不变。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003033.png" alt="image-20210923043240791" style="zoom:67%;" /></p>
<p>区域建议：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003039.png" alt="image-20210923043409441" style="zoom:67%;" /></p>
<p>一个直接的思路是，在特征图上直接进行分类。因为特征图尺寸很小，即使每个点都计算，也就是对 $20\times15=300$ 个位置进行分类。但是又有一个问题，就是这个框选取多大。</p>
<p>在每一个位置选取k个不同的尺寸框，共有 $20\times 15k$ 个，分别进行预测，然后对这300k个区域进行是不是目标打分，选取前300个区域作为输入，再输入到全连接层，得到分类结果和预测位置。</p>
<p>这个过程就可以用不同尺寸的卷积核来完成。对特征图的各个锚点进行不同尺度的卷积，得到一个高维的向量，然后将这个高维的向量输入到另一个全连接层，进行打分，判断是否是目标区域。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003044.png" alt="image-20210923045506180" style="zoom:67%;" /></p>
<p>在该网络结构中，共有四个损失：</p>
<ul>
<li>RPN分类损失（目标/非目标）</li>
<li>RPN边界框坐标回归损失</li>
<li>候选区域分类损失</li>
<li>最终边界框坐标回归损失</li>
</ul>
<h3 id="4-2-3总结"><a href="#4-2-3总结" class="headerlink" title="4.2.3总结"></a>4.2.3总结</h3><p>主干网络（特征提取）：</p>
<ul>
<li>VGG</li>
<li>ResNet-101</li>
<li>Inception V2</li>
<li>Inception V3</li>
<li>Iception </li>
<li>ResNet</li>
<li>MobileNet</li>
</ul>
<p>基础框架：</p>
<ul>
<li>两阶段：Faster R-CNN</li>
<li>一阶段：YOLO，SSD</li>
<li>混合：R-FCN</li>
</ul>
<p>一些经验结论：</p>
<ul>
<li>Faster R-CNN的速度偏慢，但精度更高</li>
<li>SSD速度快，相对于Faster R-CNN精度较低</li>
<li>主干网络越宽，深度越深，对性能帮助就越大</li>
</ul>
<h2 id="4-3实例分割"><a href="#4-3实例分割" class="headerlink" title="4.3实例分割"></a>4.3实例分割</h2><p>相对于目标检测，更精确。相对于语义分割，多了实例的概念。</p>
<p>Mask R-CNN</p>
<p>就是对目标检测的区域再进行一次卷积，然后上采样，对每一个像素点进行分类。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003052.png" alt="image-20210923051730140" style="zoom:67%;" /></p>
<h1 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5.可视化"></a>5.可视化</h1><p>本章是弄清楚卷积神经网络在干什么。</p>
<h2 id="5-1第一层卷积核"><a href="#5-1第一层卷积核" class="headerlink" title="5.1第一层卷积核"></a>5.1第一层卷积核</h2><p>第一层卷积核从图像上抽取了许多基元。</p>
<p>由于网络第一层的卷积核深度是3维的，因此我们可以将其作为RGB图来看待，而对于深层的网络，卷积核深度不止是3维，那么我们只能将其作为灰度图处理，对于高维特征，我们可能就比较难看出它在原图中寻找什么东西了，因为它是许多低维特征的集合</p>
<p>第一层卷积核可视化：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003059.png" alt="image-20210923052225841" style="zoom: 50%;" /></p>
<h2 id="5-2最后一层"><a href="#5-2最后一层" class="headerlink" title="5.2最后一层"></a>5.2最后一层</h2><p>对于网络的最后一层的特征往往就是一副图像整体的特征，如果我们对于一副测试的图片，寻找在特征空间最相近的图，那么我们一般能得到同一类的物体。假设卷积网络最后一层输出的是一个4096维的向量，然后我们在数据集中，把和一张图片向量相近的图片放在一起，如下图所示</p>
<p><img src="https://piggyhero.github.io/pic/img/20211216014144.png" alt="20211018065310.png"></p>
<p>可以看到都是同一类东西。然后再通过降维的方法，把这个4096向量降为2维，在平面上用坐标轴表示出来</p>
<p><img src="https://piggyhero.github.io/pic/img/20211216013644.png" alt="20211018065323.png?raw=true"></p>
<p>我们可以看出色调偏绿的图像都集中在了左下角，偏蓝的图像都集中在了右上角，这也意味着网络确实学习到了图像中的某些特征，并能利用特征进行分类。</p>
<h2 id="5-3-探究中间层的卷积"><a href="#5-3-探究中间层的卷积" class="headerlink" title="5.3 探究中间层的卷积"></a>5.3 探究中间层的卷积</h2><p>如果我们取网络中某一层某一个特征图的某一个特定神经元比较大的值，那么它会对应一个作用域，如果我们将这个作用域对应在原图的部分取出来，我们会发现这些部分是类似的，原因就是这个神经元是在图像中寻找某些特定的特征</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003134.png" alt="image-20210923163638688" style="zoom:67%;" /></p>
<p>除此以外我们还能做遮挡实验，将一副图像进行遮挡，然后观察最后分类值的变化。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003148.png" alt="image-20210923054405208" style="zoom: 33%;" /></p>
<p>不同的卷积核关注图像中不同的部分。上面这幅图说明了，卷积核是感受大象的面部信息。</p>
<h3 id="5-3-1输出对输入求导"><a href="#5-3-1输出对输入求导" class="headerlink" title="5.3.1输出对输入求导"></a>5.3.1输出对输入求导</h3><p>为了求得不同像素对图像分类的影响，我们可以求显著图，也就是改变一个像素点，看其对分类结果有多大的影响（实际的方法是求出分类输出值对每个像素的梯度），然后将这些点用二值化图标注出来。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003208.png" alt="image-20210923054841282" style="zoom:33%;" /></p>
<p>我们不仅可以求最终分类值对每个像素的梯度，还可以求某个神经元对作用域内所有像素的梯度，代表着像素对神经元输出值的影响程度。</p>
<h3 id="5-3-2改变输入值"><a href="#5-3-2改变输入值" class="headerlink" title="5.3.2改变输入值"></a>5.3.2改变输入值</h3><p>前面的方法是求输出值对输入值的梯度，来可视化梯度。但是这种方法的可视化还是不那么明显。现在我们用输出值对输入值求导，得到梯度，然后按照梯度方向改变输入值，这样可以得到当某个神经元输出最大值时，输入图像的样子。</p>
<p>具体的方法是应用梯度上升：输出函数是某个神经元的输出值加上正则项，求出它对每个像素的梯度，然后按梯度上升的方向改变像素的值。正则化的作用是使得图像能更加像真实的图。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003219.png" alt="image-20210923164436588" style="zoom:50%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003409.png" alt="image-20211018071615381" style="zoom: 33%;" /></p>
<p>如果我们最大化最终的分类值，可以得到以下结果，我们可以看到图像确实具有一些该分类的形状。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003225.png" alt="image-20210923164650811" style="zoom:67%;" /></p>
<h2 id="5-4改变图像风格"><a href="#5-4改变图像风格" class="headerlink" title="5.4改变图像风格"></a>5.4改变图像风格</h2><p>另外我们还可以求出一副图像的分类，然后改变像素值，最大化其他分类的值，我们期望的是图像能够由一个分类变为另外一个分类。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003237.png" alt="image-20210923164939985" style="zoom:67%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003232.png" alt="image-20211018065441124" style="zoom:67%;" /></p>
<p>如上图所示，最大化其他分类，就是让这幅图像中包含其他类别的信息，在原图的基础上，就可以得到上图的效果。</p>
<p>想变成这种效果有两种方法。</p>
<h3 id="5-4-1特征反演"><a href="#5-4-1特征反演" class="headerlink" title="5.4.1特征反演"></a>5.4.1特征反演</h3><p>特征反演与上述方法不同，这种方法针对某个特定特征，会寻找一副图像，使得其特征向量与给定的特征向量距离最小。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003243.png" alt="image-20210923165416169" style="zoom:50%;" /></p>
<p>下面是这种方法的结果。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003248.png" alt="image-20210923165450104" style="zoom:67%;" /></p>
<h3 id="5-4-2纹理合成"><a href="#5-4-2纹理合成" class="headerlink" title="5.4.2纹理合成"></a>5.4.2纹理合成</h3><p>纹理合成是计算机视觉中一个经典的算法，随着深度学习的发展，我们也有了更好的解决方案，我们取某一层网络中纵向的两个向量，每个向量代表同一个位置的不同特征，再将这两个向量相乘得到一个矩阵。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003256.png" alt="img" style="zoom:67%;" /></p>
<p>我们两两遍历特征图中的向量，再取平均值，得到的矩阵叫做Gram矩阵，由于我们的矩阵是所有位置的向量相乘取平均的结果，因此我们消除了空间位置信息，保留了特征之间的相关关系（特征数为C）。</p>
<p>人工纹理合成算法与特征反演不同的地方就在此。特征转换的目标是让两个图像的特定层特征最相似，而人工纹理合成是将特征转换为Gram矩阵，然后使得两张图像Gram矩阵最相似。在实际应用的过程中，我们往往会将多层网络的Gram矩阵相似性都考虑进最终结果。</p>
<p>一旦有了神经网络上进行纹理合成，就可以通过梯度上升来合成与原始图像纹理相匹配的新的图像。</p>
<h3 id="5-4-3风格转换"><a href="#5-4-3风格转换" class="headerlink" title="5.4.3风格转换"></a>5.4.3风格转换</h3><p>结合了以上两点我们就能做风格转换了。</p>
<p>当把格拉姆矩阵匹配的纹理合成方法与特征匹配的特征反演法结合起来会产生非常棒的风格迁移算法；在风格迁移中，把两张图像作为输入图像，第一步选取其中一张图像作为内容图像，它引导我们生成图像的主体，同样的风格图像负责生成图像的纹理或风格，然后共同做特征识别，通过最小化内容图像的特征重构损失以及风格图像的格拉姆矩阵损失，就能得到非常棒的图像。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003304.png" alt="image-20210923235300467" style="zoom:67%;" /></p>
<h1 id="6-生成网络"><a href="#6-生成网络" class="headerlink" title="6.生成网络"></a>6.生成网络</h1><h2 id="6-1有监督学习与无监督学习"><a href="#6-1有监督学习与无监督学习" class="headerlink" title="6.1有监督学习与无监督学习"></a>6.1有监督学习与无监督学习</h2><p>有监督学习我们都很熟悉了，我们有数据x和标签y，我们在有监督学习中学习到一个函数可以将数据x映射到标签y，标签可以有很多形式。典型的监督学习有：分类问题中输入一张图片，输出图片的分类；目标检测中输入一张图片，输出目标物体的边框；语义分割中，给每个像素都打上标签。下面说一下无监督学习。</p>
<p>无监督学习在我们只有一些没有标签的训练数据的情况下，学习数据中隐含的结构。</p>
<h3 id="6-1-1聚类"><a href="#6-1-1聚类" class="headerlink" title="6.1.1聚类"></a>6.1.1聚类</h3><p>聚类是找到数据的分组，组内数据在某种度量方式下是相似的。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003310.png" alt="image-20210924014900654" style="zoom:67%;" /></p>
<h3 id="6-1-2降维"><a href="#6-1-2降维" class="headerlink" title="6.1.2降维"></a>6.1.2降维</h3><p>把高维数据降到低维。在低维空间中保留高维空间中的主要信息。</p>
<p>常用方法，主成分分析：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003317.png" alt="image-20210924015151567" style="zoom:67%;" /></p>
<p>左图可以看见，在3D空间中，有一些数据在平面垂直方向变化不大。因此可以将该方向的数据忽略掉，仅保留一些显著变化的数据。</p>
<p>另一种方法，特征学习，采用自编码器的结构</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003323.png" alt="image-20210924015451169" style="zoom:67%;" /></p>
<p>在这里前半部分和神经网络类似，提取出特征。不同的是，还可以把低维数据还原回去。该方法可以进行非线性的降维，之前主成分分析是线性的降维。</p>
<h3 id="6-1-3密度估计"><a href="#6-1-3密度估计" class="headerlink" title="6.1.3密度估计"></a>6.1.3密度估计</h3><p>通过样本数据，来估计数据的内在概率分布情况。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003328.png" alt="image-20210924020048964" style="zoom:67%;" /></p>
<h2 id="6-2生成模型"><a href="#6-2生成模型" class="headerlink" title="6.2生成模型"></a>6.2生成模型</h2><p>给定训练集，产生与训练集同分布的新样本。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211215003334.png" alt="image-20210924020532869" style="zoom:67%;" /></p>
<p>我们希望可以学到一个模型 $p_{model}(x)$ ，其与样本的分布 $p_{data}(x)$ 相近。</p>
<p>无监督学习里的一个核心问题就是<strong>密度估计</strong>问题。</p>
<p>有两种思路：</p>
<ul>
<li>显示的密度估计：显示的定义并求解分布 $p_{model}(x)$ 。</li>
<li>隐式的密度估计：学习一个模型 $p_{model}(x)$ ，而无需显示的定义它。</li>
</ul>
<h2 id="6-3PixelRNN与PixelCNN"><a href="#6-3PixelRNN与PixelCNN" class="headerlink" title="6.3PixelRNN与PixelCNN"></a>6.3PixelRNN与PixelCNN</h2><h2 id="6-4变分自编码器"><a href="#6-4变分自编码器" class="headerlink" title="6.4变分自编码器"></a>6.4变分自编码器</h2><h2 id="6-5GAN"><a href="#6-5GAN" class="headerlink" title="6.5GAN"></a>6.5GAN</h2>]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>【三维重建】三维重建课程笔记</title>
    <url>/2021/10/18/%E3%80%90%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E3%80%91%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习北邮鲁鹏老师《机器视觉》笔记。<br>三维重建的目标就是从单张或多张场景图片中重构出三维场景的结构信息。<br><span id="more"></span></p>
<h2 id="一、摄像机几何"><a href="#一、摄像机几何" class="headerlink" title="一、摄像机几何"></a>一、摄像机几何</h2><h3 id="A-针孔摄像机模型"><a href="#A-针孔摄像机模型" class="headerlink" title="A.针孔摄像机模型"></a>A.针孔摄像机模型</h3><p>首先，我们要知道三维世界中的点是如何映射到像素平面的，完成这个映射过程就是摄像机。</p>
<p>如果直接让胶片放置在物体的前方，如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014942.png" alt="image-20210818224820393"></p>
<p>那么此时胶片上的一个点会记录真实世界多个点的信息。这样是不行的，于是我们采用针孔模型：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014947.png" alt="image-20210818224930850"></p>
<p>通过一个带有小孔的屏障，我们便可以使像素平面上的点与真实世界上的点形成一一对应的关系，这就是针孔相机模型。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216014955.png" alt="image-20210818225105759"></p>
<p>下面具体描述一下<strong>针孔摄像机模型：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015003.png" alt="image-20210818230044519"></p>
<blockquote>
<p>要注意三个坐标系：</p>
<p>1.相机坐标系：以针孔为原点，建立的三维坐标系，其坐标轴单位是米</p>
<p>2.像平面坐标系：以像平面中心为原点的三维坐标系，坐标轴单位是米</p>
<p>3.像素坐标系：与像平面重合的二维坐标系，其坐标轴单位是像素</p>
</blockquote>
<p>根据三角形相似法则，最终可以得到相机坐标系下的P点到像平面坐标系的P‘点的映射关系：</p>
<script type="math/tex; mode=display">
P=\left[\begin{array}{l}
x \\
y \\
z
\end{array}\right] \rightarrow P^{\prime}=\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]\tag{1.1}</script><script type="math/tex; mode=display">
\quad\left\{\begin{array}{l}
x^{\prime}=f \frac{x}{z} \\
y^{\prime}=f \frac{y}{z}
\end{array}\right.\tag{1.2}</script><h3 id="B-摄像机和透镜"><a href="#B-摄像机和透镜" class="headerlink" title="B.摄像机和透镜"></a>B.摄像机和透镜</h3><p>光圈就是针孔模型中的小孔，小孔的大小决定了像的清晰程度和亮度</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015010.png" alt="image-20210818231502207"></p>
<p>如果光圈太大，像中的一个点会对应真实世界中的多个点，此时图像会模糊，但是光圈太小，又会使透过的光变少，像变暗。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015013.png" alt="image-20210818231844139"></p>
<p>那么如何才能使像既清晰又明亮呢？</p>
<p>增加透镜！！！</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015018.png" alt="image-20210818232135974"></p>
<p>透镜的特点：</p>
<p>1.所有平行于光轴的光线都会会聚到焦点，焦点到透镜中心的距离称为焦距</p>
<p>2.穿过中心的光线的方向不发生改变</p>
<h4 id="1-加上透镜后的针孔模型"><a href="#1-加上透镜后的针孔模型" class="headerlink" title="1.加上透镜后的针孔模型"></a>1.加上透镜后的针孔模型</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015021.png" alt="image-20210818232418455"></p>
<p>该模型与之前的针孔模型区别不大，只是针孔模型中的 $f$ 变为 $z’$ </p>
<script type="math/tex; mode=display">
z^{\prime}=f+z_{0} \quad\left\{\begin{array}{l}
x^{\prime}=z^{\prime} \frac{x}{z} \\
y^{\prime}=z^{\prime} \frac{y}{z}
\end{array}\right.\tag{1.3}</script><p>此处的 $f$ 是透镜的焦距，其与透镜的自身性质有关。</p>
<h4 id="2-透镜引起的问题"><a href="#2-透镜引起的问题" class="headerlink" title="2.透镜引起的问题"></a>2.透镜引起的问题</h4><h5 id="a-失焦"><a href="#a-失焦" class="headerlink" title="a.失焦"></a>a.失焦</h5><p>可以看到加上了透镜好处多多，但是也会引起一个问题，在一定的范围内，光线会会聚到像平面上，但是当超过了这个范围，光线就不会会聚到像平面上，此时便发生失焦。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015027.png" alt="image-20210818233432270"></p>
<h5 id="b-径向畸变"><a href="#b-径向畸变" class="headerlink" title="b.径向畸变"></a>b.径向畸变</h5><p>图像像素点以畸变中心为中心点，沿着径向产生位置偏差，从而导致图像中所成的像发生形变</p>
<p>枕形畸变：畸变像点相对于理想像点沿径向向外偏移，远离中心</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015032.png" alt="image-20210818233754147"></p>
<p>桶形畸变：畸变像点相对于理想像点沿径向向内偏移，向中心靠拢</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015038.png" alt="image-20210818233846093"></p>
<h3 id="C-摄像机几何"><a href="#C-摄像机几何" class="headerlink" title="C.摄像机几何"></a>C.摄像机几何</h3><p>在我们分析图像时，是在像素坐标系下分析的，像素坐标系和像平面坐标系的区别是，像素坐标系</p>
<p>是二维的，其坐标轴单位是像素，且其坐标原点一般不是在最中心，这就会发生一个坐标的偏移。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015042.png" alt="image-20210818234715959" style="zoom: 67%;" /></p>
<p>因此，需要根据像平面坐标系中点的坐标，求出该点在像素坐标系下的坐标：</p>
<script type="math/tex; mode=display">
P=(x, y, z) \rightarrow P^{\prime}=\left(u,v\right)\\
\left\{\begin{array}{l}
u=\alpha \frac{x}{z}+c_{x}\\
v=\beta \frac{y}{z}+c_{y}
\end{array}\right.\tag{1.4}</script><p>可是此时，空间点 $P$ 到 像素点 $P’$ 的坐标变换并不是一个线性变换，如果想变成一个线性变换，需要引入齐次坐标来表达。</p>
<h4 id="1-齐次坐标"><a href="#1-齐次坐标" class="headerlink" title="1.齐次坐标"></a>1.齐次坐标</h4><p>我们之前所使用的都是欧式坐标，例如三维空间中的一点，可以用 $(x,y,z)$ 来表示，此时在原有维数的基础上再添一维，就变成了齐次坐标。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015050.png" alt="image-20211004222903357" style="zoom:50%;" /></p>
<p>对于齐次坐标 $(1,1,1)$ 和 $(2,2,2)$ ，其所对应的欧式坐标都是 $(1,1)$ ，所以，对于齐次坐标 P 和 Q，如果P=kQ，那么 P 和 Q 对应同一个欧式坐标。</p>
<h4 id="2-齐次坐标的投影变换"><a href="#2-齐次坐标的投影变换" class="headerlink" title="2.齐次坐标的投影变换"></a>2.齐次坐标的投影变换</h4><p>引入齐次坐标后，空间点的齐次坐标与所对应的像素点的齐次坐标可以用一个线性变换来表达：</p>
<script type="math/tex; mode=display">
P_{h}^{\prime}=\left[\begin{array}{c}
\alpha x+c_{x} z \\
\beta y+c_{y} z \\
z
\end{array}\right]=\left[\begin{array}{cccc}
\alpha & 0 & c_{x} & 0 \\
0 & \beta & c_{y} & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
z \\
1
\end{array}\right]=MP_h\tag{1.5}</script><script type="math/tex; mode=display">
\overbrace{P_{h}^{\prime}}^{\text {齐次坐标 }} \rightarrow \overbrace{P^{\prime}=\left(\alpha \frac{x}{z}+c_{x}, \beta \frac{y}{z}+c_{y}\right)}^{\text {欧式坐标}}\tag{1.6}</script><p>M矩阵是摄像机的投影矩阵。</p>
<h4 id="3-摄像机偏斜"><a href="#3-摄像机偏斜" class="headerlink" title="3.摄像机偏斜"></a>3.摄像机偏斜</h4><p>有的时候，像素坐标系的两个坐标轴不是垂直的</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015057.png" alt="image-20210819004057419"></p>
<p>此时投影矩阵M为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{cccc}
\alpha & -\alpha \cot \theta & c_{x} & 0 \\
0 & \frac{\beta}{\sin \theta} & c_{y} & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\tag{1.7}</script><h4 id="4-摄像机内参数矩阵"><a href="#4-摄像机内参数矩阵" class="headerlink" title="4.摄像机内参数矩阵"></a>4.摄像机内参数矩阵</h4><p>上文提到的M前三列所构成的3*3矩阵称为摄像机的内参数矩阵K，它由摄像机的制作工艺决定。</p>
<script type="math/tex; mode=display">
M=K[I\ 0]\tag{1.8}</script><p>摄像机的内参数决定了空间点到图像点的映射。</p>
<p>摄像机的内参数矩阵共有5个自由度。</p>
<p>当K矩阵为单位阵时，此时的相机称为规范化相机，其变换叫做规范化投影变换。</p>
<blockquote>
<p>小结：当已知空间点坐标和相机内参时，一定可以求出像素点坐标。而仅知道像素点坐标和内参时，反求不出空间点坐标。因为像素点的欧式坐标对应无数个齐次坐标（尺度不确定问题）</p>
</blockquote>
<h4 id="5-世界坐标系的点到像素坐标系"><a href="#5-世界坐标系的点到像素坐标系" class="headerlink" title="5.世界坐标系的点到像素坐标系"></a>5.世界坐标系的点到像素坐标系</h4><p>在世界坐标系下，同一个点在不同相机的坐标系下坐标不同。</p>
<p>世界坐标系的坐标到相机坐标系的坐标可由下面式子来描述：</p>
<script type="math/tex; mode=display">
P=\left[\begin{array}{ll}
R & T \\
0 & 1
\end{array}\right] P_{w}=\left[\begin{array}{ll}
R & T \\
0 & 1
\end{array}\right] \left[\begin{array}{c}
x_{w} \\
y_{w} \\
z_{w} \\
1
\end{array}\right]\tag{1.9}</script><p>已知世界坐标系一点坐标，映射到像素坐标系中为：</p>
<script type="math/tex; mode=display">
P^{\prime}=K\left[\begin{array}{ll}
I & 0
\end{array}\right] P=K\left[\begin{array}{ll}
I & 0
\end{array}\right]\left[\begin{array}{cc}
R & T \\
0 & 1
\end{array}\right] P_{w}=\overbrace{K}^{内部参数}
\overbrace{[R \quad T]}^{外部参数}
P_{w}=M P_{w}\tag{1.10}</script><p>此时的投影矩阵M，既包含相机的内参信息，又包含了相机的运动信息（外部参数），M共有11个自由度。</p>
<h4 id="6-透视投影相机"><a href="#6-透视投影相机" class="headerlink" title="6.透视投影相机"></a>6.透视投影相机</h4><p>之前所得到的M矩阵叫做投影矩阵，它代表着透视投影模型，也就是三维真实空间到图像上的投影过程。符合该模型的相机称为透视投影相机，我们生活中的大多数相机都是透视投影相机，人类的眼睛也符合该模型。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015104.jpg" alt="img"></p>
<p>透视投影有以下几个特点：</p>
<ol>
<li>点投影为点</li>
<li>线投影为线</li>
<li>近大远小</li>
<li>角度不再保持</li>
<li>平行线相交</li>
</ol>
<h4 id="7-Faugeras定理"><a href="#7-Faugeras定理" class="headerlink" title="7.Faugeras定理"></a>7.Faugeras定理</h4><p>我们知道投影矩阵M是3 <em> 4的矩阵，当已知任意3 </em> 4的矩阵时，是否是投影矩阵呢？可以用Faugeras定理来进行判断。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015109.png" alt="image-20210819012316783"></p>
<h3 id="D-其他摄像机模型"><a href="#D-其他摄像机模型" class="headerlink" title="D.其他摄像机模型"></a>D.其他摄像机模型</h3><h4 id="1-弱透视投影摄像机"><a href="#1-弱透视投影摄像机" class="headerlink" title="1.弱透视投影摄像机"></a>1.弱透视投影摄像机</h4><p>当空间点的深度相差不多时，即相对场景深度小于其与相机的距离。可以简化为在同一深度。此时便是弱透视投影相机模型。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015117.png" alt="image-20210819101236994" style="zoom: 67%;" /></p>
<p>这里与透视投影相机的不同是其各点的深度是一个定值，且相同</p>
<script type="math/tex; mode=display">
\left\{\begin{array} { l } 
{ x ^ { \prime } = \frac { f ^ { \prime } } { z } x } \\
{ y ^ { \prime } = \frac { f ^ { \prime } } { z } y }
\end{array} \rightarrow \left\{\begin{array}{l}
x^{\prime}=\frac{f^{\prime}}{z_{0}} x \\
y^{\prime}=\frac{f^{\prime}}{z_{0}} y
\end{array}\right.\right.\tag{1.11}</script><p>通过这个简化后，投影矩阵的第三行变成了 $[0,0,0,1]$ </p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015123.png" alt="image-20210819103539119" style="zoom:67%;" /></p>
<p>当物体较小且较远时准确，常用于图像识别任务。</p>
<h4 id="2-正交投影摄像机"><a href="#2-正交投影摄像机" class="headerlink" title="2.正交投影摄像机"></a>2.正交投影摄像机</h4><p>摄像机中心到像平面的距离无限远时</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015130.png" alt="image-20210819104040178" style="zoom: 50%;" /></p>
<p>此时像平面上投影点的x，y方向的坐标等于实际空间点的坐标。</p>
<p>该模型常用于CAD制图时使用。</p>
<h2 id="二、摄像机标定"><a href="#二、摄像机标定" class="headerlink" title="二、摄像机标定"></a>二、摄像机标定</h2><p>摄像机标定就是求解摄像机的内外参数，更为准确的说，一般的相机内参数是不变的，而外参代表着相机的运动，是时刻改变的，所以一般的相机标定是对相机的内参的计算。</p>
<h3 id="A-标定方法-PnP的直接线性变换解法"><a href="#A-标定方法-PnP的直接线性变换解法" class="headerlink" title="A.标定方法(PnP的直接线性变换解法)"></a>A.标定方法(PnP的直接线性变换解法)</h3><h4 id="1-标定设备"><a href="#1-标定设备" class="headerlink" title="1.标定设备"></a>1.标定设备</h4><p> 如下图所示，有一个标定板，上面的每个点的坐标都已知。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015135.png" alt="image-20210820145956320"></p>
<p>然后对该标定板拍照，得到图像，可以得到空间点的坐标 $P_i$ 和其对应点的像素坐标 $p_i$ 。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015141.png" alt="image-20210820150231966"></p>
<h4 id="2-建立线性方程组"><a href="#2-建立线性方程组" class="headerlink" title="2.建立线性方程组"></a>2.建立线性方程组</h4><p>由上文提到，投影矩阵M是一个3*4的矩阵，可以表示为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{l}
m_1\\
m_2\\
m_3\\
\end{array}\right]\tag{2.1}</script><p>其中 $m_i$ 是一个4阶的行向量。</p>
<p>根据前面的透视投影关系，可以得到像素坐标和世界坐标的关系：</p>
<script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=\left[\begin{array}{l}
\frac{m_{1} P_{i}}{m_{3} P_{i}} \\
\frac{m_{2} P_{i}}{m_{3} P_{i}}
\end{array}\right]\tag{2.2}</script><p>知道一对对应点（ $P_i$ 和 $p_i$ 为已知），就可以得到两个方程，而M矩阵共有11个自由度，理论上用6对点便可以求解。但实际中会选6对以上的点来计算，这样可以提高结果的鲁棒性。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&u_{i}=\frac{m_{1} P_{i}}{m_{3} P_{i}} \rightarrow u_{i}\left(m_{3} P_{i}\right)=m_{1} P_{i} \rightarrow u_{i}\left(m_{3} P_{i}\right)-m_{1} P_{i}=0 \\
&v_{i}=\frac{m_{2} P_{i}}{m_{3} P_{i}} \rightarrow v_{i}\left(m_{3} P_{i}\right)=m_{2} P_{i} \rightarrow v_{i}\left(m_{3} P_{i}\right)-m_{2} P_{i}=0
\end{aligned}\tag{2.3}</script><p>可以将每个点的方程整理成(2.3)的形式，便可以得到一个线性方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
u_{1}\left(m_{3} P_{1}\right)-m_{1} P_{1}=0 \\
v_{1}\left(m_{3} P_{1}\right)-m_{2} P_{1}=0 \\
\vdots \\
u_{i}\left(m_{3} P_{i}\right)-m_{1} P_{i}=0 \\
v_{i}\left(m_{3} P_{i}\right)-m_{2} P_{i}=0 \\
\vdots \\
u_{n}\left(m_{3} P_{n}\right)-m_{1} P_{n}=0 \\
v_{n}\left(m_{3} P_{n}\right)-m_{2} P_{n}=0
\end{array}\right.\tag{2.4}</script><p>然后将上式写成矩阵的形式：</p>
<script type="math/tex; mode=display">
Pm=0\tag{2.5}\\
\begin{aligned}
P \stackrel{\text { def }}{=}\left(\begin{array}{ccc}
P_{1}^{T} & 0^{T} & -u_{1} P_{1}^{T} \\
0^{T} & P_{1}^{T} & -v_{1} P_{1}^{T} \\
& \vdots & \\
P_{n}{ }^{T} & 0^{T} & -u_{n} P_{n}{ }^{T} \\
0^{T} & P_{n}^{T} & -v_{n} P_{n}{ }^{T}
\end{array}\right)_{2 n \times 12}m \stackrel{\text { def }}{=}\left(\begin{array}{c}
{m_{1}^{T}} \\
{m_{2}^{T}} \\
m_{3}^{T}
\end{array}\right)_{12 \times 1}
\end{aligned}</script><blockquote>
<p>注意这里的 $P_i$ 是空间点的齐次坐标</p>
</blockquote>
<h4 id="3-求解方程组"><a href="#3-求解方程组" class="headerlink" title="3.求解方程组"></a>3.求解方程组</h4><p>P矩阵中所有的元素是已知的，下面求解该线性方程：P的行数有2n个，列数有12个。</p>
<p>当P的秩小于12时，该方程组有非零解。</p>
<p>当P的秩大于等于12时，此时为超定方程，该方程组只有0解。</p>
<p>通常情况下，P矩阵的秩都大于12，这样就解不了该方程。</p>
<p><strong>现在该怎么办呢？答案是采用优化的思想，找到合适的m， 让其$||m||$为1 ，使 $||Pm||$ 最小。</strong></p>
<p>对于该优化问题的解，先对P矩阵进行奇异值分解，可以得到：</p>
<script type="math/tex; mode=display">
P=U_{2n\times12}D_{12\times12}V_{12\times12}^T\tag{2.6}</script><p>m为P矩阵最小奇异值的右奇异向量，且 $||m||=1$ ，求得m后，便可以得到投影矩阵M。</p>
<script type="math/tex; mode=display">
\boldsymbol{m} \stackrel{\text { def }}{=}\left(\begin{array}{c}
m_{1}^{T} \\
m_{2}^{T} \\
m_{3}^{T}
\end{array}\right) \rightarrow M=\left[\begin{array}{c}
m_{1} \\
m_{2} \\
m_{3}
\end{array}\right]=[A\ b]\tag{2.7}</script><h4 id="4-提取摄像机参数"><a href="#4-提取摄像机参数" class="headerlink" title="4.提取摄像机参数"></a>4.提取摄像机参数</h4><p>我们知道，投影矩阵M包括相机的内参和外参信息，当得到M后，需要提取出内参和外参的信息。</p>
<p>先来看看已知R，T，K后，如何得到M</p>
<script type="math/tex; mode=display">
M=K[R\ \ T]_{3\times4}\tag{2.8}</script><script type="math/tex; mode=display">
K=\left[\begin{array}{ccc}
\alpha & -\alpha \cot \theta & u_{0} \\
0 & \frac{\beta}{\sin \theta} & v_{0} \\
0 & 0 & 1
\end{array}\right] \quad R=\left[\begin{array}{c}
r_{1}^{T} \\
r_{2}^T \\
r_{3} ^T
\end{array}\right] \quad T=\left[\begin{array}{c}
t_{x} \\
t_{y} \\
t_{z}
\end{array}\right]\tag{2.9}</script><p>所以：</p>
<script type="math/tex; mode=display">
M=K[R\ \ T]=\left(\begin{array}{cc}
\alpha r_{1}^{T}-\alpha \cot \theta r_{2}^{T}+u_{0} r_{3}^{T} & \alpha t_{x}-\alpha \cot \theta t_{y}+u_{0} t_{z} \\
\frac{\beta}{\sin \theta} r_{2}^{T}+v_{0} r_{3}^{T} & \frac{\beta}{\sin \theta} t_{y}+v_{0} t_{z} \\
r_{3}^{T} & t_{z}
\end{array}\right)_{3 \times 4}\tag{2.10}</script><p>因为我们之前规定了m向量的模长为1，所以我们求出的M和真实的M相差一个系数 $\rho$ </p>
<script type="math/tex; mode=display">
\rho M=\rho[A\ \ b]=K[R\ \ T]\tag{2.11}</script><p>令：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{l}
a_{1}{ }^{T} \\
a_{2}{ }^{T} \\
a_{3}{ }^{T}
\end{array}\right] \quad \mathbf{b}=\left[\begin{array}{l}
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right]\tag{2.12}</script><p>则：</p>
<script type="math/tex; mode=display">
\rho A=\rho\left(\begin{array}{c}
a_{1}^{T} \\
a_{2}{ }^{T} \\
a_{3}{ }^{T}
\end{array}\right)=\left(\begin{array}{c}
\alpha r_{1}^{T}-\alpha \cot \theta r_{2}^{T}+u_{0} r_{3}^{T} \\
\frac{\beta}{\sin \theta} r_{2}^{T}+v_{0} r_{3}^{T} \\
r_{3}{ }^{T}
\end{array}\right)=K R\tag{2.13}</script><h5 id="a-提取内参数"><a href="#a-提取内参数" class="headerlink" title="a.提取内参数"></a>a.提取内参数</h5><p>从(2.13)最后一行可以看出：</p>
<script type="math/tex; mode=display">
\rho a_3=r_3\\\tag{2.14}</script><p>因为 $r_3$ 是旋转矩阵的列向量，其模长为1，因此可以得到：</p>
<script type="math/tex; mode=display">
\rho=\frac{\pm 1}{\left|a_{3}\right|}\tag{2.15}</script><p>然后分别将(2.13)左右两侧第3行的向量和第1行的向量点乘，第3行的向量和第2行的向量点乘，因为旋转矩阵的列向量互相正交，所以可以得到：</p>
<script type="math/tex; mode=display">
\quad \begin{aligned}
&u_{0}=\rho^{2}\left(a_{1} \cdot a_{3}\right) \\
&v_{0}=\rho^{2}\left(a_{2} \cdot a_{3}\right)
\end{aligned}\tag{2.16}</script><p>同理再将(2.13)的行向量进行叉乘，可以得到下面的式子：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{ l } 
{ \rho ^ { 2 } ( a _ { 1 } \times a _ { 3 } ) = \alpha r _ { 2 } - \alpha \operatorname { cot\theta} r _ { 1 } } \\
{ \rho ^ { 2 } ( a _ { 2 } \times a _ { 3 } ) = \frac { \beta } { \operatorname { sin } \theta } r _ { 1 } }
\end{array} 
\right.\tag{2.17}</script><p>在将(2.17)上下两行进行点乘，可以得到</p>
<script type="math/tex; mode=display">
\rho^4(a_1 \times a_3)(a_2 \times a_3)=- \frac{\alpha \beta \cos{\theta}}{\sin\theta^2} \tag{2.18}</script><p>然后对(2.17)的向量两边取模：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\rho^{2}\left|a_{1} \times a_{3}\right|=\frac{|\alpha|}{\sin \theta} \\
\rho^{2}\left|a_{2} \times a_{3}\right|=\frac{|\beta|}{\sin \theta}
\end{array}\right.\tag{2.19}</script><p>最后可以得到内参矩阵中的所有参数：</p>
<script type="math/tex; mode=display">
\cos \theta=-\frac{\left(a_{1} \times a_{3}\right) \cdot\left(a_{2} \times a_{3}\right)}{\left|a_{1} \times a_{3}\right| \cdot\left|a_{2} \times a_{3}\right|}\\
\begin{array}{l}
\alpha=\rho^{2}\left|a_{1} \times a_{3}\right| \sin \theta \\
\beta=\rho^{2}\left|a_{2} \times a_{3}\right| \sin \theta
\end{array}\tag{2.20}</script><p>到此，摄像机的内参数全部求出。</p>
<h5 id="b-提取外参数"><a href="#b-提取外参数" class="headerlink" title="b.提取外参数"></a>b.提取外参数</h5><p>根据(2.14)和(2.17)可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&r_{1}=\frac{\left(a_{2} \times a_{3}\right)}{\left|a_{2} \times a_{3}\right|}\\
&r_{3}=\frac{\pm a_{3}}{\left|a_{3}\right|} \\
&r_{2}=r_{3} \times r_{1}\end{aligned}\tag{2.21}</script><p>下面再计算T，根据：</p>
<script type="math/tex; mode=display">
\rho b=KT\tag{2.22}</script><p>可以得到：</p>
<script type="math/tex; mode=display">
T=\rho K^{-1}b\tag{2.23}</script><blockquote>
<p>注意：选取的点不能在同一平面</p>
</blockquote>
<h3 id="B-径向畸变标定"><a href="#B-径向畸变标定" class="headerlink" title="B.径向畸变标定"></a>B.径向畸变标定</h3><h4 id="1-径向畸变的描述"><a href="#1-径向畸变的描述" class="headerlink" title="1.径向畸变的描述"></a>1.径向畸变的描述</h4><p>在原有的透视投影矩阵M基础上，加上一个缩放矩阵 $S_\lambda$ ，如下：</p>
<script type="math/tex; mode=display">
{\left[\begin{array}{ccc}
\frac{1}{\lambda} & 0 & 0 \\
0 & \frac{1}{\lambda} & 0 \\
0 & 0 & 1
\end{array}\right]}
M P_{i} \rightarrow\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=p_{i}\quad 其中
\lambda=1 \pm \sum_{p=1}^{3} k_pd^{2p} \quad (d^2=u^{2}+v^{2})\tag{2.24}</script><p>当 $\lambda=1$ 时，真实的像和理想的像重叠，此时无畸变</p>
<p>当 $\lambda&lt;1$时，真实的像比理想的像的位置靠外，枕形畸变</p>
<p>当$\lambda&gt;1$ 时，真实的像比理想的像的位置靠里，桶形畸变</p>
<h4 id="2-径向畸变的标定"><a href="#2-径向畸变的标定" class="headerlink" title="2.径向畸变的标定"></a>2.径向畸变的标定</h4><p>令</p>
<script type="math/tex; mode=display">
S_\lambda M=Q=
\left[\begin{array}{}
q_1\\
q_2\\
q_3
\end{array}{}\right]_{3\times 4}\tag{2.25}</script><script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{l}
u_{i} \\
v_{i}
\end{array}\right]=\left[\begin{array}{l}
\frac{q_{1} p_{i}}{q_{3} p_{i}} \\
\frac{q_{2} p_{i}}{q_{3} p_{i}}
\end{array}\right] \quad \longrightarrow \quad\left\{\begin{array}{l}
u_{i} q_{3} P_{i}=q_{1} P_{i} \\
v_{i} q_{3} P_{i}=q_{2} P_{i}
\end{array}\right.\tag{2.26}</script><p>(2.26)右边的方程组并不是线性方程组，因为 $q_i$ 是变化的，如果想要求解该方程，需要采用非线性优化方法，使观测值和理论值的误差最小，可以采用牛顿法或LM方法。</p>
<p>但是可以求解出系统的线性部分以找到近似解，然后使用该解作为整个系统的初始条件，再使用数值方法进行求解。</p>
<p>根据(2.23)和(2.25)，Q矩阵的前两行等于 $\frac{1}\lambda M$ 的前两行，于是可以将 $\lambda$ 约去</p>
<script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=\frac{1}{\lambda}\left[\begin{array}{l}
\frac{m_{1} p_{i}}{m_{3} p_{i}} \\
\frac{m_{2} p_{i}}{m_{3} p_{i}}
\end{array}\right] \quad \longrightarrow \quad \frac{u_{i}}{v_{i}}=\frac{\frac{1}{\lambda} \frac{\left(m_{1} P_{i}\right)}{\left(m_{3} p_{i}\right)}}{\frac{1}{\lambda} \frac{\left(m_{2} p_{i}\right)}{\left(m_{3} p_{i}\right)}}=\frac{m_{1} p_{i}}{m_{2} p_{i}}\tag{2.27}</script><p>建立如下的线性方程组</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
v_{1}\left(m_{1} P_{1}\right)-u_{1}\left(m_{2} P_{1}\right)=0  \\
v_{i}\left(m_{1} P_{i}\right)-u_{i}\left(m_{2} P_{i}\right)=0 
\\
\vdots \\
v_{n}\left(m_{1} P_{n}\right)-u_{n}\left(m_{2} P_{n}\right)=0
\end{array} \longrightarrow\quad 
\\ L \boldsymbol{n}=0 \\

\right. \\\tag{2.28}</script><p>其中</p>
<script type="math/tex; mode=display">
L \stackrel{\operatorname{dec}}{=}\left(\begin{array}{cc}
v_{1} p_{1}^{T} & -u_{1} p_{1}^{T} \\
v_{2} p_{2}^{T} & -u_{2} p_{2}^{T} \\
\vdots & \vdots \\
v_{n} p_{n}^{T} & -u_{n} p_{n}^{T}
\end{array}\right)\tag{2.29}\\\\
n=\left[\begin{array}{c}
m_{1}{ }^{T} \\
m_{2}{ }^{T}
\end{array}\right]</script><p>和(2.6)的方法类似，可以通过奇异值分解求出 $m_1$和 $m_2$ 。然后再通过非线性优化的方法求出 $k_p$ 和 $m_3$。</p>
<h2 id="三、单视图几何"><a href="#三、单视图几何" class="headerlink" title="三、单视图几何"></a>三、单视图几何</h2><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015151.png" alt="image-20210820213946776"></p>
<p>已知摄像机的内参和外部参数，是否可以根据单个图片的测量值p去估计空间点P呢？</p>
<p>ans：是不能的，只能确定P点位于c和p的连线上的任意位置。原因是单目相机无法获得深度信息，在这条线上的任意点的投影都位于该像素点上，当对空间有一些先验的信息时，是可以获得空间点P的位置信息的。</p>
<h3 id="A-2D变换"><a href="#A-2D变换" class="headerlink" title="A.2D变换"></a>A.2D变换</h3><h4 id="1-等距变换"><a href="#1-等距变换" class="headerlink" title="1.等距变换"></a>1.等距变换</h4><p>等距变换也叫做欧式变换，是将平面上的点经过旋转平移，不改变图形的形状，面积。仅仅改变图形的位置和朝向。</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{l}
R & \boldsymbol{t} \\
0 & 1\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1\end{array}\right]=H_{e}\left[\begin{array}{l}
x \\
y \\
1\end{array}\right]\tag{3.1}</script><p>有3个自由度(1个旋转角度+2个平移量)</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015156.png" alt="image-20210823171132345"></p>
<h4 id="2-相似变换"><a href="#2-相似变换" class="headerlink" title="2.相似变换"></a>2.相似变换</h4><p>在等距变换的基础上，如式(3.1)所示，增加了一个S矩阵(对角阵)，对原图形进行缩放。</p>
<p>它不改变图形长度的比值，还有线段间的角度。</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
S R & \boldsymbol{t} \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=H_{S}\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right] \quad S=\left[\begin{array}{ll}
s & 0 \\
0 & s
\end{array}\right]\tag{3.2}</script><p>有4个自由度(1个缩放系数+1个旋转角度+2个平移量)</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015200.png" alt="image-20210823171619104"></p>
<h4 id="3-仿射变换"><a href="#3-仿射变换" class="headerlink" title="3.仿射变换"></a>3.仿射变换</h4><p>（直观意义后续再学习，现在先搞懂数学表达）</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
A & \boldsymbol{t} \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]=H_{a}\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]\tag{3.3}</script><p>注意这里的矩阵与(3.1)和(3.2)不同，A矩阵是任意的一个2阶方阵，有4个自由度。整个矩阵共有6个自由度(4个自由度+2个平移量)</p>
<p><strong>特点</strong>：它不改变图形中的平行线关系，还有面积比值。但不能保持线段之间的夹角关系。</p>
<h4 id="4-透视变换-射影变换"><a href="#4-透视变换-射影变换" class="headerlink" title="4.透视变换(射影变换)"></a>4.透视变换(射影变换)</h4><p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
A & \boldsymbol{t} \\
v & 1
\end{array}\right]\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]=H_{p}\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]\tag{3.4}</script><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015207.png" alt="image-20210823233103207"></p>
<p><strong>特点</strong>：</p>
<p>共线性，原来在一条直线上的点变换后还在一条直线上。</p>
<p>四共线点的交比</p>
<p>交比的定义为：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015213.png" alt="image-20210823225125021" style="zoom:50%;" /></p>
<script type="math/tex; mode=display">
\frac{|| P_{3}-P_{1}||\left\|P_{4}-P_{2}\right\|}{|| P_{3}-P_{2}||\left\|P_{4}-P_{1}\right\|} \quad P_{i}=\left[\begin{array}{c}
X_{i} \\
Y_{i} \\
Z_{i} \\
1
\end{array}\right]\tag{3.5}</script><h3 id="B-二维空间点和直线的投影变换"><a href="#B-二维空间点和直线的投影变换" class="headerlink" title="B.二维空间点和直线的投影变换"></a>B.二维空间点和直线的投影变换</h3><p>我们的目的是用单张图像来重建三维场景，就要建立图像上几何元素和三维空间中的几何元素的对应关系。</p>
<p>我们先通过<strong><u>二维空间中</u></strong>的点和线来学习。</p>
<h4 id="1-平面上的线"><a href="#1-平面上的线" class="headerlink" title="1.平面上的线"></a>1.平面上的线</h4><p>我们可以用ax+by+c=0来表示一条平面上的线。我们可以用向量的形式来表达这个式子：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
x \\
y \\
1
\end{array}\right]^{T}\left[\begin{array}{l}
a \\
b \\
c
\end{array}\right]=0\tag{3.6}</script><p>(3.6)左边第一项是直线上点的齐次坐标，右边是直线的参数，所以直线可以表示成向量的形式：</p>
<script type="math/tex; mode=display">
l=\left[\begin{array}{l}
a\\
b\\
c
\end{array}\right]\tag{3.7}</script><h4 id="2-两条直线的交点"><a href="#2-两条直线的交点" class="headerlink" title="2.两条直线的交点"></a>2.两条直线的交点</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015219.png" alt="image-20210823231412876"></p>
<p>两条直线的交点可以用式(3.7)的叉积来表示：</p>
<script type="math/tex; mode=display">
x=l\times l'\tag{3.8}</script><p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&l \times l^{\prime} \perp l \rightarrow\left(l \times l^{\prime}\right) \cdot l=0 \rightarrow x \in l \\
&l \times l^{\prime} \perp l' \rightarrow\left(l \times l^{\prime}\right) \cdot l'=0 \rightarrow x \in l^{\prime}
\end{aligned}\tag{3.9}</script><p>(3.9)中，两个表示直线的向量叉乘，与这两个直线向量的点乘为0，这说明了如果叉乘表示一个点，那么这个点在这两条直线上，所以该点为交点。</p>
<h4 id="3-无穷远点"><a href="#3-无穷远点" class="headerlink" title="3.无穷远点"></a>3.无穷远点</h4><p>首先定义无穷远点：平面上一个点的齐次坐标的第三维为0，该点为无穷远点。</p>
<p>因为转化成欧式坐标后，前两维都除以第三维0，为无穷大，所以是无穷远点。</p>
<script type="math/tex; mode=display">
x_\infty =\left[\begin{array}{}
x_1\\
x_2\\
0
\end{array}\right]\tag{3.10}</script><p>两条平行线的交点就是无穷远点。 </p>
<h4 id="4-无穷远直线"><a href="#4-无穷远直线" class="headerlink" title="4.无穷远直线"></a>4.无穷远直线</h4><p>无穷远点集位于无穷远线上。</p>
<p>无穷远线的向量表示为：</p>
<script type="math/tex; mode=display">
l_\infty =\left[\begin{array}{}
0\\
0\\
1
\end{array}\right]\tag{3.11}</script><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015224.png" alt="image-20210823233249621" style="zoom: 67%;" /></p>
<h4 id="5-无穷远点的透视变换"><a href="#5-无穷远点的透视变换" class="headerlink" title="5.无穷远点的透视变换"></a>5.无穷远点的透视变换</h4><p>透视变换矩阵：</p>
<script type="math/tex; mode=display">
H=\left[ \begin{array}{l}
A & t \\
v & b
\end{array}\right] \tag{3.12}</script><p>无穷远点的<strong>透视变换</strong>：</p>
<script type="math/tex; mode=display">
p^{\prime}=Hp_\infty=\left[\begin{array}{l}
A & t \\
v & b
\end{array}\right]\left[\begin{array}{l}
1 \\
1 \\
0
\end{array}\right]=\left[\begin{array}{c}
p_{x}^{\prime} \\
p_{y}^{\prime} \\
p_{z}^{\prime}
\end{array}\right]\longrightarrow
\left[\begin{array}{}
\frac{p_x'}{p_z'}\\
\frac{p_y'}{p_z'}
\end{array}\right]\tag{3.13}</script><p>无穷远点的透视变换后，就不再是一个无穷远点了。</p>
<p>而无穷远点的<strong>仿射变换</strong>：</p>
<script type="math/tex; mode=display">
H_{A} p_{\infty}=\left[\begin{array}{cc}
A & t \\
0 & b
\end{array}\right]\left[\begin{array}{l}
1 \\
1 \\
0
\end{array}\right]=\left[\begin{array}{c}
p_{x}^{\prime} \\
p_{y} \\
0
\end{array}\right]\tag{3.14}</script><p>仍然是无穷远点。</p>
<h4 id="6-无穷远线的透视变换"><a href="#6-无穷远线的透视变换" class="headerlink" title="6.无穷远线的透视变换"></a>6.无穷远线的透视变换</h4><p>线的变换和点的变换不同，不能直接对直线向量进行变换。</p>
<p>我们知道对线的变换，等价于对线上所有的点的变换。</p>
<p>变换前的直线方程为：</p>
<script type="math/tex; mode=display">
x^Tl=0\tag{3.15}</script><p>对直线上的点的变换为：</p>
<script type="math/tex; mode=display">
Hx\tag{3.16}</script><p>则变换后的直线方程为：</p>
<script type="math/tex; mode=display">
(Hx)^Tl'=0\longrightarrow x^TH^Tl'=0\tag{3.17}</script><p>如果让(3.17)成立，则：</p>
<script type="math/tex; mode=display">
l'=H^{-T}l\tag{3.18}</script><p>所以直线的变换如式(3.18)所示。</p>
<p>无穷远线经过<strong>透视变换</strong>为：</p>
<script type="math/tex; mode=display">
H^{-T} l_{\infty}=\left[\begin{array}{ll}
A & t \\
v & b
\end{array}\right]^{-T}\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{c}
t_{x} \\
t_{y} \\
b
\end{array}\right]\tag{3.19}</script><p>显然变换后不再是无穷远线了。</p>
<p>无穷远线在<strong>仿射变换</strong>后：</p>
<script type="math/tex; mode=display">
{H}^{-T} l_{\infty}=\left[\begin{array}{cc}
A & t \\
0 & b
\end{array}\right]^{-T}\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{cc}
A^{-T} & 0 \\
-t^{T} A^{-T} & 1
\end{array}\right]\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]\tag{3.20}</script><p>仍是无穷远线。</p>
<h3 id="C-三维空间中的变换"><a href="#C-三维空间中的变换" class="headerlink" title="C.三维空间中的变换"></a>C.三维空间中的变换</h3><p>学完了二维空间中的点和线以及变换关系，接下来学习三维空间的点和线以及变换关系。</p>
<h4 id="1-空间中的点和面"><a href="#1-空间中的点和面" class="headerlink" title="1.空间中的点和面"></a>1.空间中的点和面</h4><p>与二维空间不同的是，三维空间是点和面可以用方程来表示。而直线用两个平面的交线来表示。</p>
<p>和二维空间中的直线的表示类似，三维空间中的平面表示为：</p>
<script type="math/tex; mode=display">
ax+by+cz+d=0\tag{3.21}</script><p>用向量的形式表示为：</p>
<script type="math/tex; mode=display">
x^T\Pi=0\quad\Pi=\left[\begin{array}{}
a\\
b\\
c\\d
\end{array}\right]\tag{3.22}</script><h4 id="2-空间中的线"><a href="#2-空间中的线" class="headerlink" title="2.空间中的线"></a>2.空间中的线</h4><p>如上所说，空间中的线不容易直接用方程来表示，但可以用向量表示出直线的方向。</p>
<script type="math/tex; mode=display">
d=\left[\begin{array}{}
a\\
b\\
c
\end{array}\right]\tag{3.23}</script><h4 id="3-影消点"><a href="#3-影消点" class="headerlink" title="3.影消点"></a>3.影消点</h4><p>影消点是三维空间中的无穷远点在二维平面上的投影点。</p>
<p>前面的二维空间中的无穷远点，经过投影变换后，变为一个有限点。那么三维空间中的无穷远点，经过投影变换后，在二维平面上，也为有限点。 </p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015232.png" alt="image-20210824001710255" style="zoom:67%;" /></p>
<h4 id="4-影消点和直线方向的关系"><a href="#4-影消点和直线方向的关系" class="headerlink" title="4.影消点和直线方向的关系"></a>4.影消点和直线方向的关系</h4><p>影消点的齐次坐标为v，影消点和直线方向有如下关系</p>
<script type="math/tex; mode=display">
v=Kd\tag{3.24}</script><p>该式成立的条件是，相机坐标系和世界坐标系重合，否则和直线方向向量相差一个旋转平移的关系。</p>
<p>证明：</p>
<p>无穷远点坐标为：</p>
<script type="math/tex; mode=display">
X_\infty=\left[\begin{array}{}
a\\
b\\
c\\
0
\end{array}\right]\tag{3.25}</script><p>经过摄像机投影变换后</p>
<script type="math/tex; mode=display">
v=MX_\infty=K[I\ \ 0]\left[\begin{array}{}
a\\
b\\
c\\
0
\end{array}\right]=K\left[\begin{array}{}
a\\
b\\
c\\

\end{array}\right]\tag{3.26}</script><p>所以知道直线的方向就可以知道影消点，反过来知道影消点也可以知道直线的方向。</p>
<h4 id="5-影消线（视平线）"><a href="#5-影消线（视平线）" class="headerlink" title="5.影消线（视平线）"></a>5.影消线（视平线）</h4><p>三维空间中的无穷远线在二维空间中的投影。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015238.png" alt="image-20210824003405552"></p>
<h4 id="6-影消线和平面法向量"><a href="#6-影消线和平面法向量" class="headerlink" title="6.影消线和平面法向量"></a>6.影消线和平面法向量</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015242.png" alt="image-20210824003743383"></p>
<p>这个平面是指影消线所对应的平行线所在的平面。</p>
<p>平面法向量为n，影消线和平面法向量的关系为：</p>
<script type="math/tex; mode=display">
n=K^Tl_{horiz}\tag{3.27}</script><p>证明：</p>
<p>这里还是仅考虑相机坐标系和世界坐标系重合的情况。</p>
<p>设某一平面有一无穷远点x，其所在平面的方程为：</p>
<script type="math/tex; mode=display">
x^T\Pi=0\tag{3.28}</script><p>该点经过投影变换后，在影消线上，影消线方程为：</p>
<script type="math/tex; mode=display">
(Mx)^Tl_{horiz}=0\\
x^TM^Tl_{horiz}=0\tag{3.29}</script><p>比较(3.28)和(3.29)可知：</p>
<script type="math/tex; mode=display">
\Pi=M^Tl_{horiz}\tag{3.30}\\
因为M=K[I\ \ 0],\Pi\ 就是平面的法向量，所以有：
n=K^Tl_{horiz}</script><h4 id="7-无穷远平面"><a href="#7-无穷远平面" class="headerlink" title="7.无穷远平面"></a>7.无穷远平面</h4><p>影消线所在的平面。</p>
<p>表示向量的形式为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}
0\\
0\\
0\\
1
\end{array}\right]\tag{3.31}</script><h4 id="8-两组平行线的夹角和影消点的关系"><a href="#8-两组平行线的夹角和影消点的关系" class="headerlink" title="8.两组平行线的夹角和影消点的关系"></a>8.两组平行线的夹角和影消点的关系</h4><p>两平行线夹角：</p>
<script type="math/tex; mode=display">
co s\theta=\frac{d_1d_2}{|d_1||d_2|}\tag{3.32}</script><p>由式(3.24)可知，知道影消点坐标和相机内参矩阵后，可以反求出平行线方向向量d。</p>
<p>将 $d_1和d_2$ 代入(3.32)，可得：</p>
<script type="math/tex; mode=display">
co s\theta=\frac{d_1d_2}{|d_1||d_2|}=\frac{(K^{-1}v_1)^T(K^{-1}v_2)}{\sqrt{(K^{-1}v_1)^T(K^{-1}v_1)}\sqrt{(K^{-1}v_2)^T(K^{-1}v_2)}}\\
=\frac{v_{1}^{T} \omega v_{2}}{\sqrt{v_{1}^{T} \omega v_{1}} \sqrt{v_{2}^{T} \omega v_{2}}}\quad \omega= (KK^T)^{-1}\tag{3.33}</script><script type="math/tex; mode=display">
当\theta=90^{\circ} \rightarrow v_{1}^{T} \omega v_{2}=0\tag{3.34}</script><p>$\omega$ 的性质：</p>
<script type="math/tex; mode=display">
\omega=\left[\begin{array}{lll}
\omega_{1} & \omega_{2} & \omega_{4} \\
\omega_{2} & \omega_{3} & \omega_{5} \\
\omega_{4} & \omega_{5} & \omega_{6}
\end{array}\right]\tag{3.35}</script><p>对称阵</p>
<p>有5个自由度</p>
<p>$\omega _2=0$ ，无倾斜</p>
<p>$\omega_2=0,\omega_1=\omega_3$ ，方形像素</p>
<h3 id="D-单视图重构"><a href="#D-单视图重构" class="headerlink" title="D.单视图重构"></a>D.单视图重构</h3><h4 id="1-标定内参数"><a href="#1-标定内参数" class="headerlink" title="1.标定内参数"></a>1.标定内参数</h4><p>首先根据图像上的信息，可以标定出相机的内参数矩阵</p>
<p>如图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015254.png" alt="image-20210824015723059"></p>
<p>找到图像上两组垂直的平行线，可以找到两个影消点，根据影消点的坐标，以及式(3.34)可以得到一组方程。因为 $\omega $ 有5个自由度，所以还需要增加限制方程来求解。</p>
<p>我们找到三组平行线，可以得到三个方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
v_{1}^{T} \omega v_{2}=0 \\
v_{1}^{T} \omega v_{3}=0 \\
v_{2}^{T} \omega v_{3}=0
\end{array}\right.\tag{3.36}</script><p>我们可以再添加上两个限制方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\omega _{2}=0 \\
 \omega_1=\omega_3
\end{array}\right.\tag{3.37}</script><p>便可以求解出 $\omega$ 矩阵。</p>
<h4 id="2-恢复面的信息"><a href="#2-恢复面的信息" class="headerlink" title="2.恢复面的信息"></a>2.恢复面的信息</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015300.png" alt="image-20210824020434618"></p>
<p>然后连接两个影消点，可以得到影消线，从而得到影消线的方程。然后由式(3.27)可知，该平面的空间方程。这样就可以求得三个平面的方程。</p>
<blockquote>
<p>单视图恢复的场景，是无法知道场景尺寸的。而且必须要有场景的先验信息。</p>
</blockquote>
<h2 id="四、三维重建基础和极几何"><a href="#四、三维重建基础和极几何" class="headerlink" title="四、三维重建基础和极几何"></a>四、三维重建基础和极几何</h2><h3 id="A-三维重建基础"><a href="#A-三维重建基础" class="headerlink" title="A.三维重建基础"></a>A.三维重建基础</h3><h4 id="1-三角化"><a href="#1-三角化" class="headerlink" title="1.三角化"></a>1.三角化</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015305.png" alt="image-20210824021622264"></p>
<p>三角化的适用条件：用两个摄像机来感受外部空间。</p>
<p>如图所示，现在有两个摄像机，分别在 $O_1和O_2$ 点，空间点p在两个相机的成像平面上投影分别为 $p和p’$ 。</p>
<p>通常情况下，P点的坐标通过l和l’的叉乘来求得。</p>
<p>但是由于噪声的存在，$l和l’$ 一般是不相交的。现在想求P点的三维坐标。</p>
<p>ques：已知 $p和p’$ ，$K和K’$ ，以及R，T，求解P点的三维坐标。</p>
<p>非线性解法：建模成最小化问题。我们要找到一个点 $P^*$ ，使其投影到两个成像平面上的点和观测点的距离最小。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015308.png" alt="image-20210824022452348"></p>
<p>解法：寻找 $P^{\star}$ ，最小化 $d\left(p, M P^{\star}\right)+d\left(p^{\prime}, M^{\prime} P^{\star}\right)$ 。</p>
<h4 id="2-多视图几何的关键问题"><a href="#2-多视图几何的关键问题" class="headerlink" title="2.多视图几何的关键问题"></a>2.多视图几何的关键问题</h4><ol>
<li>摄像机几何：从一张或者多张图片中求解摄像机的内外参数</li>
<li>场景几何：从二至多幅图中找到场景的三维坐标</li>
<li>对应关系：已知一个图像的p点，如何在另一张图中找到p‘点</li>
</ol>
<h3 id="B-极几何—解决对应关系问题"><a href="#B-极几何—解决对应关系问题" class="headerlink" title="B.极几何—解决对应关系问题"></a>B.极几何—解决对应关系问题</h3><h4 id="1-极几何"><a href="#1-极几何" class="headerlink" title="1.极几何"></a>1.极几何</h4><p>极几何描述了同一场景或者物体在两个视点的几何关系。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015313.png" alt="image-20210824024244259"></p>
<p>极线：极平面与成像平面的交线</p>
<p>极点：极线与成像平面的交点</p>
<h5 id="a-极几何的特点："><a href="#a-极几何的特点：" class="headerlink" title="a.极几何的特点："></a>a.极几何的特点：</h5><ol>
<li>极平面相交于基线</li>
<li>极线相交于极点</li>
<li>$p$ 的对应点在极线 $l’$ 上</li>
<li>$p’$ 的对应点在极线 $l$ 上</li>
</ol>
<h5 id="b-极几何的两个特例："><a href="#b-极几何的两个特例：" class="headerlink" title="b.极几何的两个特例："></a>b.极几何的两个特例：</h5><h6 id="1-平行视图"><a href="#1-平行视图" class="headerlink" title="(1)平行视图"></a><strong>(1)平行视图</strong></h6><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015318.png" alt="image-20210824024726436"></p>
<p>特点：</p>
<ol>
<li>两个图像平面平行；</li>
<li>基线平行于成像平面，极点在无穷远处；</li>
<li>基线平行于像素坐标系u轴</li>
</ol>
<h6 id="2-前向平移（无旋转）"><a href="#2-前向平移（无旋转）" class="headerlink" title="(2)前向平移（无旋转）"></a><strong>(2)前向平移（无旋转）</strong></h6><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015322.png" alt="image-20210824024950629"></p>
<p>两个图像的极点有着相同的像素坐标</p>
<h4 id="2-本质矩阵"><a href="#2-本质矩阵" class="headerlink" title="2.本质矩阵"></a>2.本质矩阵</h4><p>本质矩阵：对规范化摄像机拍摄的两个视点图像间的极几何关系进行代数描述。</p>
<h5 id="a-规范化摄像机"><a href="#a-规范化摄像机" class="headerlink" title="a.规范化摄像机"></a>a.规范化摄像机</h5><p>摄像机的内参数K是单位矩阵</p>
<script type="math/tex; mode=display">
P^{\prime}=\left[\begin{array}{l}x \\ y \\ z\end{array}\right]=\left[\begin{array}{llll}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0\end{array}\right]\left[\begin{array}{l}x \\ y \\ z \\ 1\end{array}\right]\tag{4.1}</script><p>三维点的欧式坐标=像素点的齐次坐标</p>
<h5 id="b-极几何关系推导—对应点关系推导"><a href="#b-极几何关系推导—对应点关系推导" class="headerlink" title="b.极几何关系推导—对应点关系推导"></a>b.极几何关系推导—对应点关系推导</h5><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015329.png" alt="image-20210824025523590"></p>
<p>我们现在已经知道，K=K‘，且为规范化相机，p和p’的像素坐标。</p>
<p>由规范化相机还可以知道，空间点 $p$ 在 $O_1$ 坐标系下的欧式坐标为 $(u,v,1)$ ，以及 $p’$ 在 $O_2$ 坐标系下的欧式坐标 $(u’,v’,1)$</p>
<blockquote>
<p>因为是规范化相机，空间点的欧式坐标等于像素点的齐次坐标。已知p的空间坐标为(x,y,1)，p的像素齐次坐标为(u,v,1)，可以知道x=u,y=v。</p>
</blockquote>
<p>现在我们来求p和p‘的代数关系。</p>
<p>先把.$O_2$ 和 p‘的坐标转化到 $O_1$ 坐标系中为 $p’_{o_1}$：</p>
<p>因为</p>
<script type="math/tex; mode=display">
p'=Rp'_{o_1}+T\tag{4.2}</script><p>所以</p>
<script type="math/tex; mode=display">
p'_{o_1}=R^T(p'-T)\tag{4.3}</script><p>同理可得 $O_2$ 在 $O_1$ 坐标系下的坐标为：</p>
<script type="math/tex; mode=display">
O_2'=-R^TT\tag{4.4}</script><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015336.png" alt="image-20210824031818767"></p>
<p>现在如上图找到几何关系： $O_1p’ 和 O_1O_2$向量的叉积与 $O_1p$ 向量垂直，则有如下方程：</p>
<script type="math/tex; mode=display">
[R^T(p'-T)\times R^TT]\cdot p=0\tag{4.5}</script><p>最终可得到两个对应点的约束关系：</p>
<script type="math/tex; mode=display">
p^{\prime T}[T \times R] p=0\tag{4.6}</script><p>我们将中间的矩阵记作E，E就是本质矩阵。</p>
<script type="math/tex; mode=display">
p^{\prime T} E p=0\tag{4.7}</script><p>上面p‘和p都是三维坐标，它与像素坐标的齐次形式相同。</p>
<blockquote>
<blockquote>
<p> 补充：两个向量的叉乘可以写成矩阵的表示形式</p>
</blockquote>
<script type="math/tex; mode=display">
a \times b=\left[\begin{array}{ccc}
0 & -a_{z} & a_{y} \\
a_{z} & 0 & -a_{x} \\
-a_{y} & a_{x} & 0
\end{array}\right]\left[\begin{array}{l}
b_{x} \\
b_{y} \\
b_{z}
\end{array}\right]=\left[a_{\times}\right] b\tag{4.8}</script><blockquote>
<p> 这里的 $\left[a_{\times}\right]$ 的秩为2。</p>
</blockquote>
</blockquote>
<h5 id="c-本质矩阵的特点"><a href="#c-本质矩阵的特点" class="headerlink" title="c.本质矩阵的特点"></a>c.本质矩阵的特点</h5><ol>
<li>p对应的极线是 $l’$ （$l’=Ep$）这里的 $l’$ 是二维空间中的直线向量，表示直线方程</li>
<li>p’对应的极线是 $l$ （$l=E^Tp’$）</li>
<li>$Ee=0$ 与 $E^Te’=0$</li>
<li>E 的秩为2</li>
<li>E有5个自由度（三个旋转+三个平移，det(E)=0去掉了一个自由度）</li>
</ol>
<h4 id="3-基础矩阵"><a href="#3-基础矩阵" class="headerlink" title="3.基础矩阵"></a>3.基础矩阵</h4><p>对一般透视相机在两个视点的图像间的极几何关系的代数描述</p>
<p>此时相机不再是规范化相机。</p>
<h5 id="a-基础矩阵推导"><a href="#a-基础矩阵推导" class="headerlink" title="a.基础矩阵推导"></a>a.基础矩阵推导</h5><p>思路：把相机转化为规范化相机</p>
<script type="math/tex; mode=display">
p=K[I\ \ 0]P\tag{4.9}</script><script type="math/tex; mode=display">
p_c=K^{-1} p=K^{-1} K[I\ \  0] P=\left[\begin{array}{llll}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0
\end{array}\right] P\tag{4.10}</script><p>同理</p>
<script type="math/tex; mode=display">
p'_c=K'^{-1}p'\tag{4.11}</script><p>于是有：</p>
<script type="math/tex; mode=display">
p_{c}^{\prime T} E p_{c}=p_{c}^{\prime T}\left[T_{\times}\right] R p_{c}=\left(K^{\prime-1} p^{\prime}\right)^{T} \cdot\left[T_{\times}\right] R K^{-1} p=p^{\prime T} K^{\prime-T}\left[T_{x}\right] R K^{-1} p=0\tag{4.12}</script><p>令中间的部分为F，F即为基础矩阵</p>
<script type="math/tex; mode=display">
p^{\prime T} F p=0\tag{4.13}</script><script type="math/tex; mode=display">
F=K^{\prime-T}\left[T_{x}\right] R K^{-1}\tag{4.14}</script><h5 id="b-基础矩阵性质"><a href="#b-基础矩阵性质" class="headerlink" title="b.基础矩阵性质"></a>b.基础矩阵性质</h5><ol>
<li>p对应的极线是 $l’$ （$l’=Fp$）这里的 $l’$ 是二维空间中的直线向量，表示直线方程</li>
<li>p’对应的极线是 $l$ （$l=F^Tp’$）</li>
<li>$Fe=0$ 与 $F^Te’=0$</li>
<li>F 的秩为2</li>
<li>F 有7个自由度（尺度无法确定，det(F)=0去掉了一个自由度）</li>
</ol>
<h4 id="4-基础矩阵的估计"><a href="#4-基础矩阵的估计" class="headerlink" title="4.基础矩阵的估计"></a>4.基础矩阵的估计</h4><p>已知对应点的像素坐标，来求解F矩阵。</p>
<h5 id="a-八点算法"><a href="#a-八点算法" class="headerlink" title="a.八点算法"></a>a.八点算法</h5><p>首先，对应点间有以下关系</p>
<script type="math/tex; mode=display">
p^{\prime T} F p=0 \quad p=\left[\begin{array}{l}
u \\
v \\
1
\end{array}\right] \quad p^{\prime}=\left[\begin{array}{l}
u^{\prime} \\
v^{\prime} \\
1
\end{array}\right]\tag{4.15}</script><script type="math/tex; mode=display">
\\

\left(u^{\prime}, v^{\prime}, 1\right)\left(\begin{array}{lll}
F_{11} & F_{12} & F_{13} \\
F_{21} & F_{22} & F_{23} \\
F_{31} & F_{32} & F_{33}
\end{array}\right)\left(\begin{array}{l}
u \\
v \\
1
\end{array}\right)=0 \\\tag{4.16}</script><p>将(4.16)写成另外一种形式，如下式：</p>
<script type="math/tex; mode=display">
\left(u u^{\prime}, v u^{\prime}, u^{\prime}, u v^{\prime}, v v^{\prime}, v^{\prime}, u, v, 1\right)\left(\begin{array}{l}
F_{11} \\
F_{12} \\
F_{13} \\
F_{21} \\
F_{22} \\
F_{23} \\
F_{31} \\
F_{32} \\
F_{33}
\end{array}\right)=0\tag{4.17}</script><p>我们要求的就是后面的列向量，前面是对应点的坐标构成的一个行向量，一对对应点可列得一个(4.17)方程。</p>
<p>现在来看式(4.17)，这是一个齐次线性方程，虽然有9个未知数，当确定8个未知数后，第9个便可以确定。因此，仅需要8对点即可求解出基础矩阵F。</p>
<p>选取8对对应点后，可得到下式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}
u_{1} u_{1}^{\prime} & v_{1} u_{1}^{\prime} & u_{1}^{\prime} & u_{1} v_{1}^{\prime} & v_{1} v_{1}^{\prime} & v_{1}^{\prime} & u_{1} & v_{1} & 1 \\
u_{2} u_{2}^{\prime} & v_{2} u_{2}^{\prime} & u_{2}^{\prime} & u_{2} v_{2}^{\prime} & v_{2} v_{2}^{\prime} & v_{2}^{\prime} & u_{2} & v_{2} & 1 \\
u_{3} u_{3}^{\prime} & v_{3} u_{3}^{\prime} & u_{3}^{\prime} & u_{3} v_{3}^{\prime} & v_{3} v_{3}^{\prime} & v_{3}^{\prime} & u_{3} & v_{3} & 1 \\
u_{4} u_{4}^{\prime} & v_{4} u_{4}^{\prime} & u_{4}^{\prime} & u_{4} v_{4}^{\prime} & v_{4} v_{4}^{\prime} & v_{4}^{\prime} & u_{4} & v_{4} & 1 \\
u_{5} u_{5}^{\prime} & v_{5} u_{5}^{\prime} & u_{5}^{\prime} & u_{5} v_{5}^{\prime} & v_{5} v_{5}^{\prime} & v_{5}^{\prime} & u_{5} & v_{5} & 1 \\
u_{6} u_{6}^{\prime} & v_{6} u_{6}^{\prime} & u_{6}^{\prime} & u_{6} v_{6}^{\prime} & v_{6} v_{6}^{\prime} & v_{6}^{\prime} & u_{6} & v_{6} & 1 \\
u_{7} u_{7}^{\prime} & v_{7} u_{7}^{\prime} & u_{7}^{\prime} & u_{7} v_{7}^{\prime} & v_{7} v_{7}^{\prime} & v_{7}^{\prime} & u_{7} & v_{7} & 1 \\
u_{8} u_{8}^{\prime} & v_{8} u_{8}^{\prime} & u_{8}^{\prime} & u_{8} v_{8}^{\prime} & v_{8} v_{8}^{\prime} & v_{8}^{\prime} & u_{8} & v_{8} & 1
\end{array}\right]\left[\begin{array}{c}
F_{11} \\
F_{12} \\
F_{13} \\
F_{21} \\
F_{22} \\
F_{23} \\
F_{31} \\
F_{32} \\
F_{33}
\end{array}\right]=0\tag{4.18}</script><p>(4.18)还可以写成：</p>
<script type="math/tex; mode=display">
Wf=0\tag{4.19}</script><p>当W的秩为8时，存在唯一非零解。</p>
<p>而实际中，我们会选取超过8对点，来估计F矩阵，以防止个别点出现偏差时影响F的估计。</p>
<p>当选取超过8个点的时候，会变成一个超定方程组，超定方程组只有0解。此时我们需要用非线性优化的方法来求解。</p>
<script type="math/tex; mode=display">
\begin{gathered}
\min _{\boldsymbol{f}}\|\boldsymbol{W} \boldsymbol{f}\| \\
\text { s. } t .\|\boldsymbol{f}\|=1
\end{gathered}\longrightarrow \hat{F}\tag{4.20}</script><p>当f的模为1时(因为这是一个齐次线性方程组，f的模可以是任意的，在这里我们取1)，使Wf最小。具体的过程就是奇异值分解，和式(2.7)求法相同。</p>
<p>这里 $\hat{F}$ 并不是我们要求的基础矩阵，因为基础矩阵的秩为2，此处的 $\hat{F}$ 的秩为3 。</p>
<p>继续用最优化思想来求解。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\text { 寻找F最小化 }\|F-\widehat{F}\|_{\mathrm{F}}\\
&\text { s.t. } \operatorname{det}(F)=0
\end{aligned}</script><p>具体过程也很简单，就是对 $\hat{F}$ 进行奇异值分解。</p>
<script type="math/tex; mode=display">
S V D(\hat{F})=U\left[\begin{array}{ccc}
s_{1} & 0 & 0 \\
0 & s_{2} & 0 \\
0 & 0 & s_{3}
\end{array}\right] V^{T} \Rightarrow F=U\left[\begin{array}{ccc}
s_{1} & 0 & 0 \\
0 & s_{2} & 0 \\
0 & 0 & 0
\end{array}\right] V^{T}\tag{4.21}</script><h5 id="b-八点算法的问题"><a href="#b-八点算法的问题" class="headerlink" title="b.八点算法的问题"></a>b.八点算法的问题</h5><p>精度低！！！</p>
<p>因为W矩阵中的各个元素的数值差异过大</p>
<h5 id="c-归一化八点法"><a href="#c-归一化八点法" class="headerlink" title="c.归一化八点法"></a>c.归一化八点法</h5><p>对每幅图施加变换T(平移与缩放)，让其满足以下条件：</p>
<ol>
<li>新原点=图像上点的重心</li>
<li>每个像点到坐标原点的均方根距离为 $\sqrt {2}$</li>
</ol>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015347.png" alt="image-20210825010953797"></p>
<p>归一化八点算法的步骤：</p>
<ol>
<li>先计算左图和右图的T和T‘</li>
<li>坐标归一化$q_{i}=T p_{i} \quad q^{\prime}{ }_{i}=T^{\prime} p_{i}{ }^{\prime}$</li>
<li>通过八点算法计算 $F_q$</li>
<li>逆归一化$F=T^{\prime T} F_{q} T$</li>
</ol>
<h2 id="五、双目立体视觉系统"><a href="#五、双目立体视觉系统" class="headerlink" title="五、双目立体视觉系统"></a>五、双目立体视觉系统</h2><h3 id="A-平行视图下的极几何"><a href="#A-平行视图下的极几何" class="headerlink" title="A.平行视图下的极几何"></a>A.平行视图下的极几何</h3><p>利用两个视点来观察物体，和人的眼睛一样。</p>
<p>可以让对应点搜索和深度求解更加简单。</p>
<h4 id="0-补充："><a href="#0-补充：" class="headerlink" title="0.补充："></a>0.补充：</h4><h5 id="a-极点坐标"><a href="#a-极点坐标" class="headerlink" title="a.极点坐标"></a>a.极点坐标</h5><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015354.png" alt="image-20210825160039966" style="zoom:50%;" /></p>
<p>我们前面说过，极点是基线和成像平面的交点。从另外一个角度来看，极点还可以是相机中心在成像平面上的投影点。那么如上图所示，极点 $e$ 是点 $O_2$ 在成像平面的投影。极点 $e’$ 是 $O_1$ 在成像平面的投影。</p>
<p>那么点 $O_1$ 在坐标系 $O_1$ 中的齐次坐标为 $[0\ 0\ 0\ 1]^T$ ，其在坐标系 $O_2$ 中的欧式坐标为：</p>
<script type="math/tex; mode=display">
[R\ T]\left[\begin{array}{}0\\0\\0\\1\end{array}\right]\tag{5.1}</script><p>所以 $e’$ 的齐次坐标就为：</p>
<script type="math/tex; mode=display">
e'=K'[R\ T]\left[\begin{array}{}0\\0\\0\\1\end{array}\right]=K'T\tag{5.2}</script><h5 id="b-叉乘性质"><a href="#b-叉乘性质" class="headerlink" title="b.叉乘性质"></a>b.叉乘性质</h5><p>对于任意向量t，如果M可逆，相差一个尺度的情况下，有如下关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&{\left[t_{\times}\right] M=M^{-T}\left[\left(M^{-1} t\right)_{\times}\right]} \\

\end{aligned}\tag{5.3}</script><p>然后我们令$ t=T, M=K^{\prime-1}$ ，代入到式(5.3)中</p>
<script type="math/tex; mode=display">
{\left[T_{\times}\right] K^{\prime-1}=K^{\prime T}\left[\left(K^{\prime} T\right)_{x}\right]} \\\tag{5.4}</script><p>便可以得到：</p>
<script type="math/tex; mode=display">
\left[T_{\times}\right]=K^{\prime T}\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime}\tag{5.5}</script><p>然后将式(5.5)代入基础矩阵(4.14)中：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F&=K^{\prime-T}\left[T_{x}\right] R K^{-1}\\
&=K^{\prime-T} K^{\prime T}\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime} R K^{-1}\\
&=\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime} R K^{-1}\\
&=\left[e_{x}^{\prime}\right] K^{\prime} R K^{-1}
\end{aligned}\tag{5.6}</script><h4 id="1-平行视图的基础矩阵"><a href="#1-平行视图的基础矩阵" class="headerlink" title="1.平行视图的基础矩阵"></a>1.平行视图的基础矩阵</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015401.png" alt="image-20210825164325338" style="zoom:50%;" /></p>
<p>两个成像平面平行</p>
<p>基线平行于成像平面，极点 $e$ 和 $e’$ 位于无穷远处</p>
<p>我们假定两个摄像机的内参是一样的，$K=K’$。旋转矩阵 $R=I$ 。平移向量$T=[T\ 0\ 0]^T$ 和极点坐标 $e’=[1\ 0\ 0]^T$ 。</p>
<p>将上面的表达式代入到(5.6)中：</p>
<script type="math/tex; mode=display">
F=\left[e_{x}^{\prime}\right] K^{\prime} R K^{-1}=\left[e^{\prime}{ }_{x}\right]=\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & -1 \\
0 & 1 & 0
\end{array}\right]\tag{5.7}</script><p>这就是平行视图的基础矩阵。</p>
<h4 id="2-平行视图下的极线"><a href="#2-平行视图下的极线" class="headerlink" title="2.平行视图下的极线"></a>2.平行视图下的极线</h4><p>一对对应点p和p‘，像素坐标为：$\left(p_{u}, p_{v}\right) 和<br>\left(p_{u}^{\prime}, p_{v}^{\prime}\right)$</p>
<p>极线的方程为：</p>
<script type="math/tex; mode=display">
l=F^{T} p^{\prime}=\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & 1 \\
0 & -1 & 0
\end{array}\right]\left[\begin{array}{c}
p_{u}^{\prime} \\
p_{v}^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{c}
0 \\
1 \\
-p_{v}^{\prime}
\end{array}\right]\tag{5.8}</script><p>可以看出，该极线是平行于u轴的。</p>
<h4 id="3-对应点关系"><a href="#3-对应点关系" class="headerlink" title="3.对应点关系"></a>3.对应点关系</h4><script type="math/tex; mode=display">
p'^TFp=0\tag{5.9}</script><p>即：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{lll}
p_{u}^{\prime} & p_{v}^{\prime} & 1
\end{array}\right)\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & -1 \\
0 & 1 & 0
\end{array}\right]\left[\begin{array}{l}
p_u \\
p_v \\
1
\end{array}\right]=0\tag{5.10}</script><p>最后得到：</p>
<script type="math/tex; mode=display">
p_v=p_v'\tag{5.11}</script><p>这说明对应点的v坐标是一样的。寻找对应点时，直接在扫描线上找即可。</p>
<h4 id="4-平行视图的三角测量"><a href="#4-平行视图的三角测量" class="headerlink" title="4.平行视图的三角测量"></a>4.平行视图的三角测量</h4><p>因为对应点的v坐标相同，所以可以很方便的测量P点的深度值。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015408.png" alt="image-20210825171253726" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
p_{u}-p_{u}^{\prime}=\frac{B \cdot f}{z}\tag{5.12}</script><p>知道视差和基线长度后，便可以计算出深度。</p>
<h3 id="B-图像校正"><a href="#B-图像校正" class="headerlink" title="B.图像校正"></a>B.图像校正</h3><p>平行视图让我们寻找对应点和三角化更加简单，但通常情况下我们构建的双目立体视觉系统是很难得到平行视图的。我们可以将非平行视图转化到平行视图，这就是图像校正。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015415.png" alt="image-20210825175411272" style="zoom: 33%;" /></p>
<p>完成校正这一目标需要构建两个矩阵H和H‘，我们可以通过以下5个步骤来求得这两个矩阵。</p>
<ol>
<li><p>找8个以上的匹配点对。</p>
</li>
<li><p>计算基础矩阵F，然后来求解两幅图像中的极点。具体可以通过上一步的匹配点通过八点算法求出基础矩阵F，然后可以通过基础矩阵的性质求得极线方程。再根据所有极线都经过极点这一性质，求得极点的齐次坐标。</p>
</li>
<li><p>选择透视变换 $H’$ 将 $e’$ 映射到无穷远点 $(f,0,0)$。其中 $H’=T^{-1}GRT$ 。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015418.png" alt="image-20210825180734367" style="zoom:50%;" /></p>
</li>
<li><p>寻找透视变换矩阵H，使得 $\sum_{i} d\left(H p_{i}, H^{\prime} p_{i}^{\prime}\right)$ 最小。</p>
</li>
<li><p>分别用H和H‘对左右两幅图进行重采样。</p>
</li>
</ol>
<p><strong>图像校正例子：</strong></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015450.png" alt="image-20210825181026118" style="zoom: 33%;" /></p>
<h3 id="C-对应点搜索"><a href="#C-对应点搜索" class="headerlink" title="C.对应点搜索"></a>C.对应点搜索</h3><p>给定一个空间点P，在左右图像中找到相应的观测值，也称为双目融合问题。 </p>
<p>图像经过校正后，对应点在扫描线上搜索即可。</p>
<h4 id="1-相关法"><a href="#1-相关法" class="headerlink" title="1.相关法"></a>1.相关法</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015434.png" style="zoom:50%;" /></p>
<p>首先建立一个窗口</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015430.png" alt="image-20210825193829734" style="zoom:50%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015502.png" alt="image-20211009194933364" style="zoom: 33%;" /></p>
<h4 id="2-归一化相关法"><a href="#2-归一化相关法" class="headerlink" title="2.归一化相关法"></a>2.归一化相关法</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015506.png" alt="image-20210825194834081" style="zoom:50%;" /></p>
<p>当两幅图在光照不同的情况下，会使其像素点的灰度值发生剧烈变化。</p>
<p>此时只需要将窗口内的像素点的灰度值进行去均值即可。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015513.png" alt="image-20210825195133785" style="zoom:150%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015518.png" alt="image-20210825195236089"></p>
<p>窗口大小的影响：上面我们选取的是 $3\times 3$ 窗口，当选取其他大小窗口的时候会有什么样的变化呢？</p>
<p>ans：较小的窗口，细节丰富，但噪声较大。较大的窗口，视差图更为平滑，但是细节丢失。</p>
<p>例如下图所示，右边两幅图为视差图：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015528.png" alt="image-20210825195947480"></p>
<h4 id="3-相关法存在的问题"><a href="#3-相关法存在的问题" class="headerlink" title="3.相关法存在的问题"></a>3.相关法存在的问题</h4><h5 id="a-透视缩短"><a href="#a-透视缩短" class="headerlink" title="a.透视缩短"></a>a.透视缩短</h5><p>一个物体的长度在一个成像平面上是正常的，但可能在另一成像平面上非常的短。此时在相同范围邻域的内容有很大的不同。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015537.png" alt="image-20210825235305290" style="zoom:50%;" /></p>
<h5 id="b-遮挡"><a href="#b-遮挡" class="headerlink" title="b.遮挡"></a>b.遮挡</h5><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015541.png" alt="image-20210825235332461" style="zoom:50%;" /></p>
<p>以上两种问题的解决办法：</p>
<p>合理的选择基线与深度的比值。</p>
<script type="math/tex; mode=display">
\frac{B}{z}\tag{5.13}</script><p>减小B/z时，可以有效的避免透视缩短和遮挡的问题。用我们最直观的感受就是离物体远点，就看的更全了。</p>
<p>但缩小B/z，也会造成一个问题，就是当匹配点有很小的误差时，就会造成深度估算的大误差。</p>
<p>如下面两幅图所示，红色的点就是根据对应点估算空间点的位置。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015548.png" alt="image-20210825235821706" style="zoom: 25%;" /></p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015556.png" alt="image-20210825235841876" style="zoom: 50%;" /></p>
<p>可以看到，当B/z较小时，所估算的深度误差和真实的相差很大。</p>
<h5 id="c-同质区域"><a href="#c-同质区域" class="headerlink" title="c.同质区域"></a>c.同质区域</h5><p>有多个地方与要匹配的点相似。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015603.png" alt="image-20210826000100677" style="zoom:50%;" /></p>
<h5 id="d-重复模式"><a href="#d-重复模式" class="headerlink" title="d.重复模式"></a>d.重复模式</h5><p>和上面的问题类似。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015613.png" alt="image-20210826000215422" style="zoom:50%;" /></p>
<p>容易产生误匹配。所以对应点匹配问题是一个很难的问题。</p>
<p>要解决这些问题，我们需要增加约束来解决对应点匹配问题。</p>
<h4 id="4-其他约束"><a href="#4-其他约束" class="headerlink" title="4.其他约束"></a>4.其他约束</h4><ol>
<li>唯一性约束：一张图像中的任何点，在另一张图像中最多只有一个匹配点。</li>
<li>顺序约束/单调性约束：左右视图中对应点的次序一致</li>
<li>平滑性约束：视差函数通常是平滑的（除了边界遮挡）</li>
</ol>
<p>这些方法可以参考：《计算机视觉：一种现代方法》</p>
<h2 id="六、多视图几何"><a href="#六、多视图几何" class="headerlink" title="六、多视图几何"></a>六、多视图几何</h2><h3 id="A-运动恢复结构问题"><a href="#A-运动恢复结构问题" class="headerlink" title="A.运动恢复结构问题"></a>A.运动恢复结构问题</h3><p>通过三维场景的多张图像，恢复出该场景的三维结构信息以及每张图片所对应的摄像机参数。这也就是SLAM，恢复机构等价于建图，求对应的摄像机参数等价于定位，因为摄像机参数包括内参和外参，外参数就是摄像机的运动信息。</p>
<h4 id="1-问题的具体描述"><a href="#1-问题的具体描述" class="headerlink" title="1.问题的具体描述"></a>1.问题的具体描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$ </p>
<p>且 $x_{ij}=M_iX_j$ ，其中 $M_i$ 为第 $i$ 张图片对应的摄像机投影矩阵</p>
<p><strong>求解</strong>：$m$ 个摄像机的投影矩阵 $M_i$ ；<strong>运动</strong></p>
<p>​            $n$ 个三维点 $X_j$ 的坐标；<strong>三维结构</strong></p>
<p>该类问题也称作运动恢复结构问题。</p>
<h4 id="2-三种典型的运动恢复结构任务"><a href="#2-三种典型的运动恢复结构任务" class="headerlink" title="2.三种典型的运动恢复结构任务"></a>2.三种典型的运动恢复结构任务</h4><h5 id="a-欧式结构恢复"><a href="#a-欧式结构恢复" class="headerlink" title="a.欧式结构恢复"></a>a.欧式结构恢复</h5><p>摄像机内参已知，外参未知。</p>
<p>应用场景：扫地机器人，无人驾驶汽车</p>
<h5 id="b-仿射结构恢复"><a href="#b-仿射结构恢复" class="headerlink" title="b.仿射结构恢复"></a>b.仿射结构恢复</h5><p>摄像机为仿射相机，内、外参数均未知。</p>
<p>应用场景：待重构场景离摄像机较远，而且场景的深度变化不大。</p>
<h5 id="c-透视结构恢复"><a href="#c-透视结构恢复" class="headerlink" title="c.透视结构恢复"></a>c.透视结构恢复</h5><p>摄像机为透视相机，内、外参数均未知。</p>
<p>应用场景：只知道图片，还不能忽略深度变化。</p>
<h3 id="B-欧式结构恢复"><a href="#B-欧式结构恢复" class="headerlink" title="B.欧式结构恢复"></a>B.欧式结构恢复</h3><h4 id="0-问题描述"><a href="#0-问题描述" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>$m$ 张图片对应的摄像机内参数矩阵 $K_i\ (i=1,…m)$</p>
<p>有$x_{ij}=M_iX_j=K_i[R_i\ T_i]X_j$ </p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的外参数 $R_i$ 和 $T_i$ 。</p>
<p>先来看两视图情况，令 $O_1$ 坐标系与世界坐标系固定。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015622.png" alt="image-20210826014140627" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
\begin{aligned}
&x_{1j}=M_{1} X_{j}=K_{1}\left[\begin{array}{ll}
I & 0
\end{array}\right] X_{j} \\
&x_{2 j}=M_{2} X_{j}=K_{2}\left[\begin{array}{ll}
R \ \ \ T
\end{array}\right] X_{j}
\end{aligned}\tag{6.1}</script><h4 id="1-基本求法"><a href="#1-基本求法" class="headerlink" title="1.基本求法"></a>1.基本求法</h4><p>可以分为四步：</p>
<ol>
<li>求解基础矩阵F，归一化八点法</li>
<li>利用F与摄像机内参数求解本质矩阵E，$E=K_{2}^{T} F K_{1}$</li>
<li>分解本质矩阵获得R和T</li>
<li>三角化求解三维点 $X_j$ 的坐标。$X_{j}^{*}=\underset{X_{j}}{\operatorname{argmin}}\left(d\left(x_{1 j}, M_{1} X_{j}\right)+d\left(x_{2 j}, M_{2} X_{j}\right)\right)$</li>
</ol>
<p>这里要说明一下步骤1，2之前都已经学过，而最重要的本质矩阵分解将在下面介绍。</p>
<h4 id="2-本质矩阵分解"><a href="#2-本质矩阵分解" class="headerlink" title="2.本质矩阵分解"></a>2.本质矩阵分解</h4><h5 id="a-本质矩阵推导"><a href="#a-本质矩阵推导" class="headerlink" title="a.本质矩阵推导"></a>a.本质矩阵推导</h5><blockquote>
<p>重要说明：在我们使用八点法求解基础矩阵F时，是无法确定F的符号和尺度的。求解F的方程为 $x_2^TFx_1=0$ ，而-F和kF都满足这个方程，所以说解出来的F可能不是真正的F。同理由F得到的E也是无法确定符号和尺度的。</p>
</blockquote>
<p>先定义两个矩阵：</p>
<script type="math/tex; mode=display">
W=\left[\begin{array}{ccc}
0 & -1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1
\end{array}\right] \quad Z=\left[\begin{array}{ccc}
0 & 1 & 0 \\
-1 & 0 & 0 \\
0 & 0 & 0
\end{array}\right]\tag{6.2}</script><p>这两个矩阵有一个重要的性质：</p>
<script type="math/tex; mode=display">
Z=-diag(1,1,0)W=diag(1,1,0)W^T\tag{6.3}</script><p>本质矩阵E中的 $[T_{\times}]$ 可以写成：</p>
<script type="math/tex; mode=display">
\left[T_{\times}\right]=k U Z U^{T}\tag{6.4}</script><p>其中U是单位正交阵。(6.4)中的Z用W来表示：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}

\left[T_{\times}\right]&=k U Z U^{T}\\
&=-kUdiag(1,1,0)WU^T\\
&=kUdiag(1,1,0)W^TU^T
\end{aligned}\tag{6.5}</script><p>当忽略尺度和符号的情况下，可以认为(6.5)为：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}

\left[T_{\times}\right]&=k U Z U^{T}\\
&=Udiag(1,1,0)WU^T\\
&=Udiag(1,1,0)W^TU^T
\end{aligned}\tag{6.6}</script><p>所以本质矩阵为：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}
E&=[T_{\times}]R\\
&=Udiag(1,1,0)(WU^TR)\\
&=Udiag(1,1,0)(W^TU^TR)
\end{aligned}\tag{6.7}</script><h5 id="b-本质矩阵分解"><a href="#b-本质矩阵分解" class="headerlink" title="b.本质矩阵分解"></a>b.本质矩阵分解</h5><p>现在我们有通过八点法计算出来的本质矩阵E，我们对其进行奇异值分解：</p>
<script type="math/tex; mode=display">
E=Udiag(1,1,0)V^T\tag{6.8}</script><p>(6.8)和(6.7)进行比较，可以得到：</p>
<script type="math/tex; mode=display">
\quad V^T=WU^TR\\
or\quad V^T=W^TU^TR\tag{6.9}</script><p>因为W矩阵和U矩阵都是可逆矩阵，所以可以求得R为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R&=(WU^T)^{-1}V^T\\
&=-UWV^T
\\
or\quad R&=(W^TU^T)^{-1}V^T\\
&=-UW^TV^T
\end{aligned}\tag{6.10}</script><blockquote>
<p>这里：$W^{-1}=-W\ and \ W^{-T}=W^T$</p>
</blockquote>
<p>忽略正负号，最终可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R&=UWV^T
\\
or\quad R
&=UW^TV^T
\end{aligned}\tag{6.11}</script><p>(6.11)中R有两个值，分别对应着在E推导的过程中，使用 $W\ and \ W^T$ 的两种情况。</p>
<p>然后我们再来求解平移向量T。首先根据叉乘性质：</p>
<script type="math/tex; mode=display">
T\times T=[T_{\times}]T=UZU^TT=0\tag{6.12}</script><p>因为U是单位正交阵，将U矩阵写出：</p>
<script type="math/tex; mode=display">
U=[u_1\ u_2 \ u_3]\quad note:u_i\ 是单位列向量\tag{6.13}</script><p>(6.12)展开可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
UZU^TT&=[u_1\ u_2 \ u_3]diag(1,1,0)W
\left[\begin{array}{l}
u_1^T\\
u_2^T\\
u_3^T
\end{array}\right]T
\\
&=(u_2u_1^T-u_1u_2^T)T=0
\end{aligned}\tag{6.14}</script><p>因为 $u_i$  间两两正交，所以当 $T=\pm ku_3$ 时，式(6.14)成立。</p>
<p>现在R和T对应着两个结果，而两两组合就会出现四种情况。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left\{\begin{array}{lc}
R= U W V^{T} &T=u_{3} \\
R= U W V^{T} &T=-u_{3} \\
R=U W^{T} V^{T} &T=u_{3} \\
R=U W^{T} V^{T} &T=-u_{3}
\end{array}\right.
\end{aligned}\tag{6.15}</script><p>分别对应着下面的四种情况：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015630.png" alt="image-20210828023242724" style="zoom:50%;" /></p>
<p>选择一个或多个点，分别用不同的R和T进行三角化计算，只有深度值都为正的R和T才为最终所求。</p>
<h4 id="3-欧式结构恢复存在的问题"><a href="#3-欧式结构恢复存在的问题" class="headerlink" title="3.欧式结构恢复存在的问题"></a>3.欧式结构恢复存在的问题</h4><p>正如我们在2.a中的推导，是忽略了尺度上差异和正负号差异的基础上建立的，通过求目标点的深度我们可以去除掉正负号的影响，但是尺度上的差异是去除不掉的。对于单目相机来说，凭借序列图是无法重构出正确尺度下的三维场景。</p>
<p>例如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015638.png" alt="image-20210828030716063"></p>
<p>从上图可以看出，两个空间点在两成像平面的像素坐标都是相同的，但两个空间点的深度不同，两个视点间的变换也不同，右边的平移矩阵T与左边的T相差一个系数k。另外，在真实空间中P1和P2的朝向也是不同的，这通过欧式重构也是求解不出来的。</p>
<p>我们可以这样认为，恢复出来的欧式结构和真实场景相差一个相似变换(旋转+平移+缩放)。这个相似变换的重构被称为度量重构。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015645.png" alt="image-20210828031302492" style="zoom:50%;" /></p>
<p>所以在没有先验知识的情况下，仅凭单目相机是不能恢复出三维空间结构的。</p>
<h3 id="C-仿射结构恢复"><a href="#C-仿射结构恢复" class="headerlink" title="C.仿射结构恢复"></a>C.仿射结构恢复</h3><p>由(3.3)知道，仿射变换矩阵为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{l}
m_{1} \\
m_{2} \\
m_{3}
\end{array}\right]=\left[\begin{array}{cc}
A_{2 \times 3} & b_{2 \times 1} \\
0_{1 \times 3} & 1
\end{array}\right]=\left[\begin{array}{ccc}
&m_{1} \\
&m_{2} \\
0&0&0&1
\end{array}\right]\tag{6.16}</script><p>则空间中的三维点经过仿射变换到像素坐标系中：</p>
<script type="math/tex; mode=display">
x=\left[\begin{array}{l}u\\
v\\
1\end{array}\right]=MX=M\left[\begin{array}{l}x\\
y\\
z\\
1\end{array}\right]=AX^E+b\quad(X^E为空间点的欧式坐标)\tag{6.17}</script><h4 id="0-问题描述-1"><a href="#0-问题描述-1" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>有$x_{ij}=A_iX_j+b_i$ </p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的投影矩阵 $A_i\ and\ b_i$ 。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015652.png" alt="image-20210829191114401"></p>
<h4 id="1-因式分解法"><a href="#1-因式分解法" class="headerlink" title="1.因式分解法"></a>1.因式分解法</h4><h5 id="a-数据中心化"><a href="#a-数据中心化" class="headerlink" title="a.数据中心化"></a>a.数据中心化</h5><p>中心化就是减去图像点的质心。</p>
<script type="math/tex; mode=display">
\hat{x}_{i j}=x_{i j}-\bar{x}_{i} \\ 其中：\begin{aligned}\bar{x}_{i}=\frac{1}{n} \sum_{k=1}^{n} x_{i k} \\ 
x_{\mathrm{ij}}=A_{i} X_{j}+b_{i}\end{aligned}\tag{6.18}</script><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015657.png" alt="image-20210829191737903"></p>
<p>然后可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{x}_{i j}=x_{i j}-\frac{1}{n} \sum_{k=1}^{n} x_{i k} &=A_{i} X_{j}+b_{i}-\frac{1}{n} \sum_{k=1}^{n} A_{i} X_{k}-\frac{1}{n} \sum_{k=1}^{n} b_{i} \\
&=A_{i}\left(X_{j}-\frac{1}{n} \sum_{k=1}^{n} X_{k}\right)\\&=A_{i}\left(X_{j}-\bar{X}\right)\\&=A_{i} \hat{X}_{j}
\end{aligned}\tag{6.19}</script><p>如果令三维空间点的质心=世界坐标系的远点。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015705.png" alt="image-20210829191948530"></p>
<p>那么：</p>
<script type="math/tex; mode=display">
\hat{x}_{i j}=A_{i} \hat{X}_{j}=A_{i} X_{j}\tag{6.20}</script><h5 id="b-因式分解"><a href="#b-因式分解" class="headerlink" title="b.因式分解"></a>b.因式分解</h5><p>现在我们把去均值以后的 $m\times n$ 个测量值写成矩阵的形式：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{cccc}
\hat{x}_{11} & \hat{x}_{12} & \cdots & \hat{x}_{1 n} \\
\hat{x}_{21} & \hat{x}_{22} & \cdots & \hat{x}_{2 n} \\
& & \ddots & \\
\hat{x}_{m 1} & \hat{x}_{m 2} & \cdots & \hat{x}_{m n}
\end{array}\right]\tag{6.21}</script><p>其中每个 $\hat{x}_{ij}$ 是一个 $2\times1$ 的向量，它是图像点的像素坐标。</p>
<p>根据式(6.20)，可以推导出D的由来：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{llll}
\hat{x}_{11} & \hat{x}_{12} & \cdots & \hat{x}_{1 n} \\
\hat{x}_{21} & \hat{x}_{22} & \cdots & \hat{x}_{2 n} \\
& & \ddots & \\
\hat{x}_{m 1} & \hat{x}_{m 2} & \cdots & \hat{x}_{m n}
\end{array}\right]=\left[\begin{array}{c}
A_{1} \\
A_{2} \\
\vdots \\
A_{m}
\end{array}\right]
\left[\begin{array}{c} X_{1} & X_{2} & \cdots & X_{n}
\end{array}\right]=MS\tag{6.22}</script><p>下面对D进行奇异值分解：</p>
<script type="math/tex; mode=display">
D=UWV^T\tag{6.23}</script><p>(6.22)中，M矩阵的最大秩为3，S矩阵的最大秩也为3。所以D的最大秩为3</p>
<p>那么我们就可以选择前三个最大的奇异值来进行分解，如图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015711.png" style="zoom: 67%;" /></p>
<p>所以：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015717.png" alt="image-20210829193956389" style="zoom:67%;" /></p>
<script type="math/tex; mode=display">
D=U_3W_3V_3^T=U_3(W_3V_3^T)=M^\star S^\star \tag{6.24}</script><p>(6.24)中，我们用后面 $W_3V_3^T$ 来重构S矩阵，当然也可以用 $V_3^T$ 来重构S。</p>
<p>这就引出了一个问题，对于同一结构，为什么可以有不同种恢复机构呢？</p>
<p>这个问题就是仿射结构的恢复歧义。</p>
<h5 id="c-因式分解法的问题"><a href="#c-因式分解法的问题" class="headerlink" title="c.因式分解法的问题"></a>c.因式分解法的问题</h5><p>当我们构建D矩阵时，是假设所有的三维点在图像上都能找得到，但当三维点被遮挡后，图像上找不到它的投影点，此时D矩阵中的元素就会空缺。这就会造成求解失败。</p>
<h4 id="2-仿射结构恢复歧义"><a href="#2-仿射结构恢复歧义" class="headerlink" title="2.仿射结构恢复歧义"></a>2.仿射结构恢复歧义</h4><p>先来看看D矩阵的推导过程，可用下图来表示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015723.png" alt="image-20210829194730339"></p>
<p>当我们在M矩阵和S矩阵间乘上一个可逆矩阵H和它的逆后：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015728.png" alt="image-20210829194843158"></p>
<p>最后的结果还是D矩阵，但是M和S矩阵却不相同了。其中H矩阵可以是任意的可逆的 $3\times3$ 的矩阵</p>
<p>所以必须利用其他的约束条件来解决歧义的问题。</p>
<p>仿射歧义的可视化如下图所示：</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015734.png" alt="image-20210829195044317"></p>
<p>真实的三维结构和恢复的三维结构之间相差了一个任意的 $3\times 3$ 的可逆矩阵H。</p>
<h3 id="D-透视结构恢复"><a href="#D-透视结构恢复" class="headerlink" title="D.透视结构恢复"></a>D.透视结构恢复</h3><h4 id="0-问题描述-2"><a href="#0-问题描述-2" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>有$x_{ij}=M_iX_j$ </p>
<p>$M_i$ 是第i张图片对应的摄像机投影矩阵</p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的投影矩阵 $M_i$ 。</p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015739.png" alt="image-20210829195526866"></p>
<h4 id="1-透视结构恢复歧义"><a href="#1-透视结构恢复歧义" class="headerlink" title="1.透视结构恢复歧义"></a>1.透视结构恢复歧义</h4><p>根据透视相机投影规律，当不知道相机的内参和外参时，可用M矩阵来表示透视投影关系，M是一个 $3\times4$ 矩阵，透视关系如下：</p>
<script type="math/tex; mode=display">
x_{ij}=M_iX_j\tag{6.25}</script><p>当 $M_i$ 和 $X_j$ 之间，可以加上任意一个 $4\times 4$ 的可逆矩阵H和其逆矩阵的乘积。</p>
<script type="math/tex; mode=display">
x_{ij}=M_iHH^{-1}X_j\tag{6.26}</script><p>这样，在恢复结构的时候，所恢复出的 $M_i$ 和真实的 $M_i$ 可能会相差一个H投影变换矩阵。这就是透视结构恢复歧义。</p>
<p>所以我们恢复透视结构时，是在相差一个 $4\times4$ 的可逆变换的情况下，恢复摄像机运动和场景结构的。</p>
<h4 id="2-代数方法（通过基础矩阵）"><a href="#2-代数方法（通过基础矩阵）" class="headerlink" title="2.代数方法（通过基础矩阵）"></a>2.代数方法（通过基础矩阵）</h4><p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015748.png" alt="image-20210829202031145"></p>
<p>代数方法主要用于两视图情况，尽管我们要使用的是一个图像序列，但是我们可以将其分成多个两视图情况来进行求解。</p>
<p>具体求解有三个步骤：</p>
<p>(1) 八点算法来求得基础矩阵F</p>
<p>(2)由基础矩阵F求得摄像机的投影矩阵。</p>
<p>(3)用三角化计算三维点的坐标。</p>
<h5 id="a-基础矩阵和投影矩阵的关系"><a href="#a-基础矩阵和投影矩阵的关系" class="headerlink" title="a.基础矩阵和投影矩阵的关系"></a>a.基础矩阵和投影矩阵的关系</h5><p>在这里，第(2)步中，<strong>如何通过F矩阵来求投影矩阵M我们之前没有说过</strong>。下面介绍该步骤的解法。</p>
<p>由于透视歧义的存在，我们总是可以找到一个可逆矩阵H，使得：</p>
<script type="math/tex; mode=display">
M_{1} H^{-1}=[I \mid 0] \quad M_{2} H^{-1}=[A \mid b]\tag{6.27}</script><p>用X表示三维点，$x\ and \ x’$ 分别称为摄像机1和2的对应观测值。</p>
<p>令：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\widetilde{M}_{1}=M_{1} H^{-1}=\left[\begin{array}{ll}
I & 0
\end{array}\right] \\
\widetilde{M}_{2}=M_{2} H^{-1}=\left[\begin{array}{ll}
A & b
\end{array}\right] \\
\widetilde{X}=H X
\end{array}\right.\tag{6.28}</script><p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x=M_{1} X=M_{1} H^{-1} H X=[I \mid 0] \tilde{X} \\
&x^{\prime}=M_{2} X=M_{2} H^{-1} H X=[A \mid b] \tilde{X}
\end{aligned}\tag{6.29}</script><p>对于摄像机1和2的观测值 $x\ and \ x’$ 有如下关系：</p>
<script type="math/tex; mode=display">
x^{\prime}=[A \mid b] \widetilde{X}=[A \mid b]\left[\begin{array}{c}
\widetilde{X}_{1} \\
\widetilde{X}_{2} \\
\widetilde{X}_{3} \\
1
\end{array}\right]=A[I \mid 0]\left[\begin{array}{c}
\widetilde{X}_{1} \\
\widetilde{X}_{2} \\
\widetilde{X}_{3} \\
1
\end{array}\right]+b=A[I \mid 0] \widetilde{X}+b=A x+b\tag{6.30}</script><p>然后我们将(6.30)中的  $x’$ 叉乘b：</p>
<script type="math/tex; mode=display">
x'\times b=(Ax+b)\times b=Ax\times b\tag{6.31}</script><p>再用 $x’$ 点乘 $x’\times b$ ，它的结果为0，所以：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x'^T \cdot(x'\times b)&=x'^T\cdot(Ax\times b)\\
&=-x'^T\cdot(b\times Ax)\\
&=-x'^T[b_{\times}]Ax=0
\end{aligned}\tag{6.32}</script><p>由极几何关系，可以知道两个视图的对应点的像素坐标的关系是：</p>
<script type="math/tex; mode=display">
x'^TFx=0\tag{6.33}</script><p>所以比较(6.32)和(6.33)，有：</p>
<script type="math/tex; mode=display">
F=[b_{\times}]A\tag{6.34}</script><p><strong>有了这个关系，我们现在就可以用八点法得到的基础矩阵F来分解出A矩阵和b</strong></p>
<h5 id="b-计算投影矩阵中的b"><a href="#b-计算投影矩阵中的b" class="headerlink" title="b.计算投影矩阵中的b"></a>b.计算投影矩阵中的b</h5><p>考虑：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F^Tb&=([b_{\times}]A)^Tb\\
&=A^T[b_{\times}]^Tb\\
&=-A^T[b_{\times}]b\\
&=0
\end{aligned}\tag{6.35}</script><p>所以可通过(6.35)的线性方程组来求解出b</p>
<p>b为 $F^T$ 矩阵的最小奇异值的右奇异向量，且 $||b||=1$ 。</p>
<h5 id="c-计算A矩阵"><a href="#c-计算A矩阵" class="headerlink" title="c.计算A矩阵"></a>c.计算A矩阵</h5><p>直接定义：</p>
<script type="math/tex; mode=display">
A'=-[b_{\times}]F\tag{6.36}</script><p>下面来验证 $[b_{\times}]A’$ 是否等于 $F$ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\ [b_{\times}]A'&=-[b_\times][b_\times]F\\
&=-(bb^T-|b|^2I)F\\
&=-bb^TF+|b|^2F\\
&=-b(F^Tb)^T+|b|^2F\\
&=1\cdot F\\
&=F
\end{aligned}\tag{6.37}</script><p>所以可以得到：</p>
<script type="math/tex; mode=display">
A=A'=-[b_\times]F\tag{6.38}</script><p>最后我们就可以计算出两个投影矩阵了：</p>
<script type="math/tex; mode=display">
\widetilde{M}_{1}=\left[\begin{array}{ll}
I & 0
\end{array}\right] \quad \widetilde{M}_{2}=\left[-\left[b_{\times}\right] F \quad b\right]</script><blockquote>
<p>这里的b是有具体的几何含义的，在第四章3小节b中，基础矩阵的性质可知，$F^Te=0$ ，而这里的 $F^Tb=0$ ，所以b是一个极点。</p>
</blockquote>
<h5 id="d-代数法的问题"><a href="#d-代数法的问题" class="headerlink" title="d.代数法的问题"></a>d.代数法的问题</h5><p>在实际的应用中，我们拥有的是一个图像序列，我们需要在两两视图间进行求解，然后再将得到的结果累加，例如求得了 $M_1$ 和 $M_2$ ，然后再求 $M_2 \ and \ M_3$ 之间的关系，最后再进行累加得到 $M_1\ and \ M_3$ 的关系，这样一点一点累积，但凡每步都有一点点小误差，但当不断积累后，就会变成一个较大的误差。</p>
<h4 id="3-捆绑调整"><a href="#3-捆绑调整" class="headerlink" title="3.捆绑调整"></a>3.捆绑调整</h4><p>考虑到因式分解法和代数法的缺点，我们又提出了一种新的方法，捆绑法。</p>
<p>捆绑法主要采用非线性优化方法，通过最小化重投影误差，来优化得到 $X_j\ and\ M_i$ </p>
<p><img src="https://github.com/piggyhero/pic/raw/master/img/20211216015800.png" alt="image-20210829232507094"></p>
<p>最小化重投影误差：</p>
<script type="math/tex; mode=display">
E(M, X)=\sum_{i=1}^{m} \sum_{j=1}^{n} D\left(x_{i j}, M_{i} X_{j}\right)^{2}\tag{6.39}</script><p>我们可以使用牛顿法或列文伯格-马夸尔特方法来进行非线性优化。</p>
<p>该方法的优势是可以同时处理大量视图，处理丢失的数据。</p>
<p>但该方法的弊端也十分致命，就是需要优化的参数过多，所以需要良好的初始条件。</p>
<p>因此在实际的应用中，常用作结构恢复SFM(structure from motion)的最后一步，通过因式分解法或代数法来求的优化问题的初始解，然后在通过捆绑法进行优化。</p>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM5】李群和李代数</title>
    <url>/2022/07/18/%E3%80%90%E8%A7%86%E8%A7%89SLAM5%E3%80%91%E6%9D%8E%E7%BE%A4%E5%92%8C%E6%9D%8E%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<p>在学习了旋转和平移的表示方法之后，我们可以描述相机的位姿。但是在视觉SLAM中，相机的位姿是我们想要求得的，例如我们得到了一个旋转矩阵，但是该矩阵并不是最佳的结果，还需要进行优化。对一个矩阵优化是很复杂的，如三维旋转矩阵，有9个参数，这9个参数中还要满足一些条件，如旋转矩阵的行列式为1，且正交。这给优化问题带来了额外的约束，十分复杂。</p>
<p>因此，引入李群和李代数的知识，来使优化问题变得简单。</p>
<span id="more"></span>
<h2 id="I-李群和李代数基础"><a href="#I-李群和李代数基础" class="headerlink" title="I. 李群和李代数基础"></a>I. 李群和李代数基础</h2><h3 id="1-群的定义"><a href="#1-群的定义" class="headerlink" title="1. 群的定义"></a>1. 群的定义</h3><p>群是一种集合加上一种运算的代数结构，我们把集合记作 $A$ ，运算记作 $·$ ，那么群可以记作 $G=(A,·)$ ，群要求这个运算满足下列条件：</p>
<p> <img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220718165122.png" alt="image-20220718165122499" style="zoom: 50%;" /></p>
<p>这个条件看似复杂，我们可以不用管。总之，我们前面所学的<strong>旋转矩阵</strong>和<strong>变换矩阵</strong>都属于群。</p>
<ul>
<li>$SO(3)$ ：旋转矩阵群</li>
<li>$SE(3)$：欧式变换群</li>
</ul>
<p><strong>李群</strong>是指具有连续性质的群。旋转矩阵和变换矩阵群在实数空间上是连续的，所以属于李群。</p>
<h3 id="2-李代数的引出"><a href="#2-李代数的引出" class="headerlink" title="2. 李代数的引出"></a>2. 李代数的引出</h3><p>实际上，每一个李群都对应一个李代数，下面我们来看李代数是如何得到的。</p>
<p>对于任意的旋转矩阵 $R$ ，满足：</p>
<script type="math/tex; mode=display">
\boldsymbol{R} \boldsymbol{R}^{\mathrm{T}}=\boldsymbol{I} \tag{1}</script><p>$R$ 表示相机的旋转，随时间的变化，用 $R(t)$ 来表示，所以有：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}(t) \boldsymbol{R}(t)^{\mathrm{T}}=\boldsymbol{I}\tag{2}</script><p>对两边同时对时间求导：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{R}}(t) \boldsymbol{R}(t)^{\mathrm{T}}+\boldsymbol{R}(t) \dot{\boldsymbol{R}}(t)^{\mathrm{T}}=0\tag{3}</script><p>移项得：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{R}}(t) \boldsymbol{R}(t)^{\mathrm{T}}=-\left(\dot{\boldsymbol{R}}(t) \boldsymbol{R}(t)^{\mathrm{T}}\right)^{\mathrm{T}}\tag{4}</script><p>可以看到，矩阵 $\dot{\boldsymbol{R}}(t) \boldsymbol{R}(t)^{\mathrm{T}}$ 是一个反对称矩阵，在向量进行叉积时，我们可以将其转换成反对称矩阵的形式，那么当我们有一个反对称矩阵时，也可以转换成其向量的形式与之对应，$\dot{\boldsymbol{R}}(t) \boldsymbol{R}(t)^{\mathrm{T}}$ 是一个三维的反对称矩阵，因此我们可以找到一个三维向量 $\phi(t)$ 与之对应：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{R}}(t) \boldsymbol{R}(t)^{\mathrm{T}}=\boldsymbol{\phi}(t)^{\wedge}\tag{5}</script><p>现在我们在等式两边右乘 $R(t)$ ，有：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{R}}(t)=\phi(t)^{\wedge} \boldsymbol{R}(t)=\left[\begin{array}{ccc}
0 & -\phi_{3} & \phi_{2} \\
\phi_{3} & 0 & -\phi_{1} \\
-\phi_{2} & \phi_{1} & 0
\end{array}\right] \boldsymbol{R}(t)\tag{6}</script><p>可以看到，<strong>对 $R(t)$ 每求一次导，就相当于在其左边乘上一个 $\phi(t)^{\wedge}$ 即可。</strong> </p>
<p>我们再假设在 $t_0$ 附近，$\phi(t_0) = \phi_0$ 是一个常数，则根据式（6）有：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{R}}(t)=\boldsymbol{\phi}\left(t_{0}\right)^{\wedge} \boldsymbol{R}(t)=\boldsymbol{\phi}_{0}^{\wedge} \boldsymbol{R}(t)\tag{7}</script><p>这是一个关于 $R(t)$ 的微分方程，且初始值为 $R(0)=I$ ，解得：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}(t)=\exp \left(\phi_{0}^{\wedge} t\right)\tag{8}</script><p><strong>这说明在 $t=0$ 附近，旋转矩阵可以由 $\exp \left(\phi_{0}^{\wedge} t\right)$ 计算出来。</strong></p>
<blockquote>
<p>这个结论也适用于 $t\neq0$ 的其他任何情况，当 $R(t_0)\neq I$ 时，$R(t)=R(t_0)\exp(\phi_0^{\wedge}t)$ </p>
</blockquote>
<p>现在假设在 $t_0 = 0$ 时，旋转矩阵 $R(t_0)=I$ ，按照导数的定义，可以把 $R(t)$ 在 $t=0$ 附近进行一阶泰勒展开：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{R}(t) & \approx \boldsymbol{R}\left(t_{0}\right)+\dot{\boldsymbol{R}}\left(t_{0}\right)\left(t-t_{0}\right) \\
&=\boldsymbol{I}+\boldsymbol{\phi}\left(t_{0}\right)^{\wedge}\boldsymbol{R}(t_0)(t-t_0)\\
&=\boldsymbol{I}+\boldsymbol{\phi}\left(t_{0}\right)^{\wedge}(t)
\end{aligned}\tag{9}</script><p>这里可以看到 $\phi$ 反映了 $R$ 的导数性质，固称它为在 $SO(3)$ <strong>原点附近</strong>的正切空间。</p>
<p>通过上面的推导，我们可以知道：</p>
<ul>
<li>给定某时刻的 $R$ ，我们就可以求得一个 $\phi$ ，它描述了 $R$ 在局部的导数性质。这里的 $\phi$ 正是对应到 $SO(3)$ 上的李代数 $\mathfrak{s o}(3)$ 。</li>
<li>我们可以通过指数/对数映射来完成李群和李代数之间的转化。</li>
</ul>
<h3 id="3-李代数的定义"><a href="#3-李代数的定义" class="headerlink" title="3. 李代数的定义"></a>3. 李代数的定义</h3><p>每个李群都有与之对应的李代数，李代数描述了李群的局部性质。李代数的定义也十分抽象，李代数由一个集合 $\mathbb{V}$ ，一个数域 $\mathbb{F}$ 和一个二元运算[ ，]组成，满足以下性质：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220719092825.png" alt="image-20220719092825479" style="zoom:50%;" /></p>
<p>则 $(\mathbb{V},\mathbb{F},[,])$ 为一个李代数，记为 $\mathfrak{g}$。</p>
<p>同样看似复杂的性质我们先不用管，我们只需知道，三维向量的叉积是一种李括号，因此 $\mathfrak{g}=(\mathbb{R}^3,\mathbb{R},\times)$ 构成了一个李代数。</p>
<h4 id="1-李代数-mathfrak-so-3"><a href="#1-李代数-mathfrak-so-3" class="headerlink" title="(1)李代数 $\mathfrak{so(3)}$"></a>(1)李代数 $\mathfrak{so(3)}$</h4><p>$SO(3)$ 对应的李代数是定义在 $\mathbb{R}^3$ 上的向量，记为 $\phi$ ，每一个 $\phi$ 对应着一个反对称矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{\Phi}=\phi^{\wedge}=\left[\begin{array}{ccc}
0 & -\phi_{3} & \phi_{2} \\
\phi_{3} & 0 & -\phi_{1} \\
-\phi_{2} & \phi_{1} & 0
\end{array}\right] \in \mathbb{R}^{3 \times 3}</script><p>在此定义下，两个向量 $\phi_1$ ，$\phi_2$ 的李括号定义为：</p>
<script type="math/tex; mode=display">
\left[\phi_{1}, \phi_{2}\right]=\left(\Phi_{1} \Phi_{2}-\Phi_{2} \Phi_{1}\right)^{\vee}</script><blockquote>
<p>由于向量 $\phi$ 和反对称矩阵是一一对应的，我们可以认为李代数 $\mathfrak{so(3)}$ 的元素是三维向量或者是三维反对称矩阵。</p>
<script type="math/tex; mode=display">
\mathfrak{s o}(3)=\left\{\phi \in \mathbb{R}^{3}, \Phi=\phi^{\wedge} \in \mathbb{R}^{3 \times 3}\right\}</script></blockquote>
<p>它与 $SO(3)$ 的关系可以有指数映射给定：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}=\exp \left(\phi^{\wedge}\right)</script><h4 id="2-李代数-mathfrak-se-3"><a href="#2-李代数-mathfrak-se-3" class="headerlink" title="(2) 李代数 $\mathfrak{se(3)}$"></a>(2) 李代数 $\mathfrak{se(3)}$</h4><p>对于 $SE(3)$ ，也有对应的李代数 $\mathfrak{se(3)}$ 。它位于 $\mathbb{R}^6$ 空间中：</p>
<script type="math/tex; mode=display">
\mathfrak{s e}(3)=\left\{\boldsymbol{\xi}=\left[\begin{array}{c}
\rho \\
\phi
\end{array}\right] \in \mathbb{R}^{6}, \rho \in \mathbb{R}^{3}, \phi \in \mathfrak{s o}(3), \xi^{\wedge}=\left[\begin{array}{cc}
\phi^{\wedge} & \rho \\
\mathbf{0}^{\mathrm{T}} & 0
\end{array}\right] \in \mathbb{R}^{4 \times 4}\right\}</script><p>我们把每个 $\mathfrak{se(3)}$ 的元素记为 $\boldsymbol{\xi}$ ，它是一个6维向量，前三维表示平移（但含义和变换矩阵中的平移不同），记为 $\rho$  。后三维为旋转，记为 $\phi$ ，实质上是 $\mathfrak{so(3)}$ 中的元素。</p>
<p>还有我们要拓展符号 <code>^</code> 的含义，之前三维的时候表示一个向量对应的反对称矩阵，这里我们还是保留这种概念，但此处不是反对称矩阵，而是表示：</p>
<script type="math/tex; mode=display">
\boldsymbol{\xi}^{\wedge}=\left[\begin{array}{ll}
\phi^{\wedge} & \rho \\
\mathbf{0}^{\mathrm{T}} & 0
\end{array}\right] \in \mathbb{R}^{4 \times 4}</script><p>但是它们依然是一一对应的关系。此时的李括号的定义和 $\mathfrak{so(3)}$ 的类似，为：</p>
<script type="math/tex; mode=display">
\left[\boldsymbol{\xi}_{1}, \boldsymbol{\xi}_{2}\right]=\left(\boldsymbol{\xi}_{1}^{\wedge} \boldsymbol{\xi}_{2}^{\wedge}-\boldsymbol{\xi}_{2}^{\wedge} \boldsymbol{\xi}_{1}^{\wedge}\right)^{\vee}</script><h2 id="II-指数映射和对数映射"><a href="#II-指数映射和对数映射" class="headerlink" title="II. 指数映射和对数映射"></a>II. 指数映射和对数映射</h2><h3 id="1-SO-3-上的指数映射和对数映射"><a href="#1-SO-3-上的指数映射和对数映射" class="headerlink" title="1. $SO(3)$ 上的指数映射和对数映射"></a>1. $SO(3)$ 上的指数映射和对数映射</h3><p>由李代数到李群，为指数映射；由李群到李代数，为对数映射。</p>
<h4 id="1-指数映射"><a href="#1-指数映射" class="headerlink" title="(1) 指数映射"></a>(1) 指数映射</h4><p>我们如何来求 $\exp \left(\phi^{\wedge}\right)$ 呢？</p>
<p>任意矩阵的指数映射可以写成一个泰勒展开，但只有在收敛的情况下才会有结果，结果仍为一个矩阵：</p>
<script type="math/tex; mode=display">
\exp (\boldsymbol{A})=\sum_{n=0}^{\infty} \frac{1}{n !} A^{n}</script><p>因此，对于 $\exp \left(\phi^{\wedge}\right)$ ，有：</p>
<script type="math/tex; mode=display">
\exp \left(\boldsymbol{\phi}^{\wedge}\right)=\sum_{n=0}^{\infty} \frac{1}{n !}\left(\phi^{\wedge}\right)^{n}</script><p>尽管我们有了这个公式，理论上可以求出来，但是这里面有无穷次幂，是很难计算的。因此我们寻求其他方式来计算。我们用模长和方向向量来表示每一个 $\boldsymbol{\phi}$ ，即 $\boldsymbol{\phi}=\theta\boldsymbol{a}$ 。这里的 $\boldsymbol {a}$ 是一个长度为1 的单位向量。对于 $\boldsymbol{a}^{\wedge}$ 有如下性质：</p>
<script type="math/tex; mode=display">
\boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}=\left[\begin{array}{ccc}
-a_{2}^{2}-a_{3}^{2} & a_{1} a_{2} & a_{1} a_{3} \\
a_{1} a_{2} & -a_{1}^{2}-a_{3}^{2} & a_{2} a_{3} \\
a_{1} a_{3} & a_{2} a_{3} & -a_{1}^{2}-a_{2}^{2}
\end{array}\right]=\boldsymbol{aa ^ { \mathrm { T } } - \boldsymbol { I }}</script><p>以及：</p>
<script type="math/tex; mode=display">
\boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}=\boldsymbol{a}^{\wedge}\left(\boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}-\boldsymbol{I}\right)=-\boldsymbol{a}^{\wedge}</script><p>这两个式子提供了处理  $\boldsymbol{a}^{\wedge}$ 高阶项的方法，因此我们可以把指数映射 $\exp \left(\boldsymbol{\phi}^{\wedge}\right)$ 写成：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\exp \left(\boldsymbol{\phi}^{\wedge}\right)=\exp \left(\theta \boldsymbol{a}^{\wedge}\right)=\sum_{n=0}^{\infty} \frac{1}{n !}\left(\theta \boldsymbol{a}^{\wedge}\right)^{n}

&=\boldsymbol{I}+\theta \boldsymbol{a}^{\wedge}+\frac{1}{2 !} \theta^{2} \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}+\frac{1}{3 !} \theta^{3} \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}+\frac{1}{4 !} \theta^{4}\left(\boldsymbol{a}^{\wedge}\right)^{4}+\cdots \\
&=\boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}-\boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}+\theta \boldsymbol{a}^{\wedge}+\frac{1}{2 !} \theta^{2} \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}-\frac{1}{3 !} \theta^{3} \boldsymbol{a}^{\wedge}-\frac{1}{4 !} \theta^{4}\left(\boldsymbol{a}^{\wedge}\right)^{2}+\cdots \\
&=\boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}+\underbrace{\left(\theta-\frac{1}{3 !} \theta^{3}+\frac{1}{5 !} \theta^{5}-\cdots\right)}_{\sin \theta} \boldsymbol{a}^{\wedge}-\underbrace{\left(1-\frac{1}{2 !} \theta^{2}+\frac{1}{4 !} \theta^{4}-\cdots\right)}_{\cos \theta} \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge} \\
&=\boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}+\boldsymbol{I}+\sin \theta \boldsymbol{a}^{\wedge}-\cos \theta \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge} \\
&=(1-\cos \theta) \boldsymbol{a}^{\wedge} \boldsymbol{a}^{\wedge}+\boldsymbol{I}+\sin \theta \boldsymbol{a}^{\wedge} \\
&=\cos \theta \boldsymbol{I}+(1-\cos \theta) \boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}+\sin \theta \boldsymbol{a}^{\wedge} .
\end{aligned}</script><p>即：</p>
<script type="math/tex; mode=display">
\exp \left(\theta \boldsymbol{a}^{\wedge}\right)=\cos \theta \boldsymbol{I}+(1-\cos \theta) \boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}+\sin \theta \boldsymbol{a}^{\wedge}</script><p>这个式子我们似曾相识，这就是在刚体运动描述中旋转向量转化成旋转矩阵的<strong>罗德里格斯</strong>公式。所以我们现在可以明白，其实李代数 $\mathfrak{so(3)}$ 实际上就是由所谓的<strong>旋转向量</strong>组成的向量空间，而<strong>指数映射即罗德里格斯公式</strong>。我们可以通过该公式把 $\mathfrak{so(3)}$ 中的任意一个向量对应到一个位于 $SO(3)$ 中的旋转矩阵。</p>
<h4 id="2-对数映射"><a href="#2-对数映射" class="headerlink" title="(2) 对数映射"></a>(2) 对数映射</h4><p>反之，通过定义对数映射，即可把 $SO(3)$ 中的元素对应到 $\mathfrak{so(3)}$ 中：</p>
<script type="math/tex; mode=display">
\phi=\ln (\boldsymbol{R})^{\vee}=\left(\sum_{n=0}^{\infty} \frac{(-1)^{n}}{n+1}(\boldsymbol{R}-\boldsymbol{I})^{n+1}\right)^{\vee}</script><p>但实际上，我们没有必要再通过计算该式来求旋转向量了，我们可以根据：</p>
<script type="math/tex; mode=display">
\begin{aligned}\operatorname{tr}(\boldsymbol{R}) &=\cos \theta \operatorname{tr}(\boldsymbol{I})+(1-\cos \theta) \operatorname{tr}\left(\boldsymbol{n} \boldsymbol{n}^{\mathrm{T}}\right)+\sin \theta \operatorname{tr}\left(\boldsymbol{n}^{\wedge}\right) \\&=3 \cos \theta+(1-\cos \theta) \\&=1+2 \cos \theta\end{aligned}</script><script type="math/tex; mode=display">
\theta=\arccos \frac{\operatorname{tr}(\boldsymbol{R})-1}{2}</script><p>然后根据旋转轴旋转后不变的性质，可以求出旋转轴上的单位向量：</p>
<script type="math/tex; mode=display">
R \boldsymbol n=\boldsymbol n</script><p>这两个式子，利用迹的性质来求得旋转向量。</p>
<p><strong>注意：</strong></p>
<p><strong>关于指数映射有什么性质呢？是否对于任意的 $R$ 都能找到唯一的 $\phi$ 与之对应呢？</strong></p>
<p>事实上，指数映射只是一个满射，并不是单射，即每一个旋转矩阵 $R$ 都可以找到一个旋转向量与之对应，但是可能存在多个旋转向量对应着同一个旋转矩阵（例如一个旋转向量，旋转角度是30°和30°+360°）。但是如果我们把旋转角度固定在$\pm\pi$ 中时，此时的李群和李代数是一一对应的。</p>
<p>根据指数映射，我们知道旋转矩阵和旋转向量的关系就是一对李群和李代数的关系。<strong>因此旋转矩阵的导数可以由旋转向量指定，指导着如何在旋转矩阵中进行微积分运算。</strong></p>
<h3 id="2-SE-3-上的指数映射和对数映射"><a href="#2-SE-3-上的指数映射和对数映射" class="headerlink" title="2. $SE(3)$ 上的指数映射和对数映射"></a>2. $SE(3)$ 上的指数映射和对数映射</h3><h4 id="1-指数映射-1"><a href="#1-指数映射-1" class="headerlink" title="(1) 指数映射"></a>(1) 指数映射</h4><p>$\mathfrak{se(3)}$ 上的指数映射形式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\exp \left(\boldsymbol{\xi}^{\wedge}\right) &=\left[\begin{array}{cc}
\sum_{n=0}^{\infty} \frac{1}{n !}\left(\phi^{\wedge}\right)^{n} & \sum_{n=0}^{\infty} \frac{1}{(n+1) !}\left(\phi^{\wedge}\right)^{n} \boldsymbol{\rho} \\
\mathbf{0}^{\mathrm{T}}
\end{array}\right] \\
& \triangleq\left[\begin{array}{cc}
\boldsymbol{R} & \boldsymbol{J} \boldsymbol{\rho} \\
\mathbf{0}^{\mathrm{T}} & 1
\end{array}\right]=\boldsymbol{T} 
\end{aligned}</script><p>这里定义：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{n=0}^{\infty} \frac{1}{(n+1) !}\left(\phi^{\wedge}\right)^{n} &=\boldsymbol{I}+\frac{1}{2 !} \theta \boldsymbol{a}^{\wedge}+\frac{1}{3 !} \theta^{2}\left(\boldsymbol{a}^{\wedge}\right)^{2}+\frac{1}{4 !} \theta^{3}\left(\boldsymbol{a}^{\wedge}\right)^{3}+\frac{1}{5 !} \theta^{4}\left(\boldsymbol{a}^{\wedge}\right)^{4} \cdots \\
&=\frac{1}{\theta}\left(\frac{1}{2 !} \theta^{2}-\frac{1}{4 !} \theta^{4}+\cdots\right)\left(\boldsymbol{a}^{\wedge}\right)+\frac{1}{\theta}\left(\frac{1}{3 !} \theta^{3}-\frac{1}{5} \theta^{5}+\cdots\right)\left(\boldsymbol{a}^{\wedge}\right)^{2}+\boldsymbol{I} \\
&=\frac{1}{\theta}(1-\cos \theta)\left(\boldsymbol{a}^{\wedge}\right)+\frac{\theta-\sin \theta}{\theta}\left(\boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}-\boldsymbol{I}\right)+\boldsymbol{I} \\
&=\frac{\sin \theta}{\theta} \boldsymbol{I}+\left(1-\frac{\sin \theta}{\theta}\right) \boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}+\frac{1-\cos \theta}{\theta} \boldsymbol{a}^{\wedge} \stackrel{\text { def }}{=} \boldsymbol{J}
\end{aligned}</script><p>可以从结果上看出，$\boldsymbol{\xi}$ 的指数映射左上角的 $\boldsymbol{R}$ 是我们熟知的 $SO(3)$ 中的元素，而右上角的平移部分，发生了一次以 $\boldsymbol{J}$ </p>
<p>为系数的线性变换。</p>
<h4 id="2-对数映射-1"><a href="#2-对数映射-1" class="headerlink" title="(2) 对数映射"></a>(2) 对数映射</h4><p>对于对数映射，在已知 $\boldsymbol T$ 后，我们可以知道其右上角的表示平移的向量：</p>
<script type="math/tex; mode=display">
t=J \rho</script><p>而这个 $\boldsymbol{J}$ 是和 $\phi$ 有关。因此可以先根据左上角的旋转矩阵 $\boldsymbol R$ 先求出 $\phi$ ，再求出  $\boldsymbol{J}$ ，最后求解方程得到 $\rho$ 。</p>
<h2 id="III-李代数求导与扰动模型"><a href="#III-李代数求导与扰动模型" class="headerlink" title="III. 李代数求导与扰动模型"></a>III. 李代数求导与扰动模型</h2><h3 id="1-BCH公式与近似形式"><a href="#1-BCH公式与近似形式" class="headerlink" title="1. BCH公式与近似形式"></a>1. BCH公式与近似形式</h3><p>我们学习李代数的动机就是在优化矩阵的时候，可以方便的求出矩阵的导数。</p>
<p>我们已经知道在 $SO(3)$ 和 $SE(3)$ 上李群和李代数的关系，但是还有一件事没有明确，例如在 $SO(3)$ 中完成两个矩阵的乘法时，所对应的李代数在 $\mathfrak{so(3)}$ 上发生了什么改变呢？是否有如下式子成立：</p>
<script type="math/tex; mode=display">
\exp \left(\phi_{1}^{\wedge}\right) \exp \left(\phi_{2}^{\wedge}\right)=\exp \left(\left(\phi_{1}+\phi_{2}\right)^{\wedge}\right) ?</script><p>或：</p>
<script type="math/tex; mode=display">
\ln (\exp (\boldsymbol{A}) \exp (\boldsymbol{B}))=\boldsymbol{A}+\boldsymbol{B} ?</script><p>如果 $\phi$ 是标量，这是成立的。但 $\boldsymbol\phi$ 表示一个向量时，是不成立的。</p>
<p>根据 <strong><em>baker-Campbell-Hausdorff</em></strong> 公式，矩阵的指数函数与矩阵的指数函数相乘：</p>
<script type="math/tex; mode=display">
\ln (\exp (\boldsymbol{A}) \exp (\boldsymbol{B}))=\boldsymbol{A}+\boldsymbol{B}+\frac{1}{2}[\boldsymbol{A}, \boldsymbol{B}]+\frac{1}{12}[\boldsymbol{A},[\boldsymbol{A}, \boldsymbol{B}]]-\frac{1}{12}[\boldsymbol{B},[\boldsymbol{A}, \boldsymbol{B}]]+\cdots</script><p>其中[]表示李括号。该公式告诉我们，当求两个矩阵指数函数之积时，<strong>会产生一些李括号组成的余项</strong>。</p>
<p>现在我们考虑在 $SO(3)$ 上的李代数 $\ln \left(\exp \left(\phi_{1}^{\wedge}\right) \exp \left(\phi_{2}^{\wedge}\right)\right)^{\vee}$ ，当 $\phi_1$ 和 $\phi_2$ 为小量时，小量二次以上的项都可以忽略，此时 <strong>BCH</strong> 公式拥有线性近似表达：</p>
<script type="math/tex; mode=display">
\ln \left(\exp \left(\phi_{1}^{\wedge}\right) \exp \left(\phi_{2}^{\wedge}\right)\right)^{\vee} \approx \begin{cases}J_{l}\left(\phi_{2}\right)^{-1} \phi_{1}+\phi_{2} & \text { 当 } \phi_{1} \text { 为小量, } \\ J_{r}\left(\phi_{1}\right)^{-1} \phi_{2}+\phi_{1} & \text { 当 } \phi_{2} \text { 为小量. }\end{cases}</script><p>该式说明了：</p>
<ul>
<li>当对一个旋转矩阵 $R_2$ （李代数为 $\phi_2$ ）左乘一个微小旋转矩阵 $R_1$ （李代数为 $\phi_1$ ）时，可以近似看作，在原有的李代数 $\phi_2$ 上加上了一项 $\boldsymbol J_l(\phi_2)^{-1}\phi_1$ 。</li>
<li>当对一个旋转矩阵 $R_1$ （李代数为 $\phi_1$ ）右乘一个微小旋转矩阵 $R_2$ （李代数为 $\phi_2$ ）时，可以近似看作，在原有的李代数 $\phi_1$ 上加上了一项 $\boldsymbol J_r(\phi_1)^{-1}\phi_2$ 。</li>
</ul>
<p>于是李代数在<strong>BCH</strong>近似下，分成了左乘和右乘近似两种，所以我们要注意是左乘模型还是右乘模型。</p>
<p>左乘近似雅可比矩阵为：</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_{l}=\boldsymbol{J}=\frac{\sin \theta}{\theta} \boldsymbol{I}+\left(1-\frac{\sin \theta}{\theta}\right) \boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}+\frac{1-\cos \theta}{\theta} \boldsymbol{a}^{\wedge}</script><p>它的逆为：</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_{l}^{-1}=\frac{\theta}{2} \cot \frac{\theta}{2} \boldsymbol{I}+\left(1-\frac{\theta}{2} \cot \frac{\theta}{2}\right) \boldsymbol{a} \boldsymbol{a}^{\mathrm{T}}-\frac{\theta}{2} \boldsymbol{a}^{\wedge}</script><p>而右乘雅可比矩阵为：</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_{r}(\boldsymbol{\phi})=\boldsymbol{J}_{l}(-\boldsymbol{\phi})</script><p><strong>这样，我们就可以谈论李群乘法与李代数加法的关系了。</strong></p>
<p>我们重新叙述一下 BCH 的意义：</p>
<p>假设某个旋转 $R$ ，对应的李代数为 $\phi$ ，我们给它左乘一个微笑的旋转，记为 $\Delta R$ ，对应的李代数为 $\Delta \phi$ ，那么在李群上得到的结果就是 $\Delta R ·R$ ，而在李代数上，根据 BCH公式，为$J_{l}^{-1}(\phi) \Delta \phi+\phi$ 。可以写成：</p>
<script type="math/tex; mode=display">
\exp \left(\Delta \phi^{\wedge}\right) \exp \left(\phi^{\wedge}\right)=\exp \left(\left(\phi+J_{l}^{-1}(\phi) \Delta \phi\right)^{\wedge}\right)</script><p>反之，我们在李代数进行加法，让 $\phi$ 加上 $\Delta \phi$ ，那么可以近似为李群上带左右雅可比的乘法：</p>
<script type="math/tex; mode=display">
\exp \left((\boldsymbol{\phi}+\Delta \boldsymbol{\phi})^{\wedge}\right)=\exp \left(\left(\boldsymbol{J}_{l} \Delta \boldsymbol{\phi}\right)^{\wedge}\right) \exp \left(\boldsymbol{\phi}^{\wedge}\right)=\exp \left(\boldsymbol{\phi}^{\wedge}\right) \exp \left(\left(\boldsymbol{J}_{r} \Delta \boldsymbol{\phi}\right)^{\wedge}\right)</script><p>同样，对于 $SE(3)$ 来说，也有类似的BCH公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\exp \left(\Delta \boldsymbol{\xi}^{\wedge}\right) \exp \left(\boldsymbol{\xi}^{\wedge}\right) \approx \exp \left(\left(\mathcal{J}_{l}^{-1} \Delta \boldsymbol{\xi}+\boldsymbol{\xi}\right)^{\wedge}\right) \\
&\exp \left(\boldsymbol{\xi}^{\wedge}\right) \exp \left(\Delta \boldsymbol{\xi}^{\wedge}\right) \approx \exp \left(\left(\mathcal{J}_{r}^{-1} \Delta \boldsymbol{\xi}+\boldsymbol{\xi}\right)^{\wedge}\right)
\end{aligned}</script><p>这里 $\mathcal{J}_{l}$ 稍微复杂，是一个 6维方阵。</p>
<h3 id="2-SO-3-上的李代数求导"><a href="#2-SO-3-上的李代数求导" class="headerlink" title="2. $SO(3)$ 上的李代数求导"></a>2. $SO(3)$ 上的李代数求导</h3><p>下面来讨论一个带有李代数的函数，以及关于该李代数函数求导的问题。这个问题有很强的实际背景，就是在SLAM中，我们要估计相机的位姿，而位姿通常是由 $SO(3)$ 和 $SE(3)$ 中的矩阵来描述的。</p>
<p>假设世界坐标系下一点的坐标为 $\boldsymbol p$ ，产生了一个观测数据 $\boldsymbol z$ ，由坐标变换关系可知：</p>
<script type="math/tex; mode=display">
\boldsymbol z=\boldsymbol{T} \boldsymbol p+\boldsymbol w</script><p>这里的 $\boldsymbol w$ 为随机噪声。因为它的存在，我们的观测值一定是不准确的，所以我们想要计算理想的观测与实际观测值的误差为：</p>
<script type="math/tex; mode=display">
\boldsymbol e=\boldsymbol z-\boldsymbol{T} \boldsymbol{p}</script><p>假设有N个这样的路标点和观测，我们要考虑这N个点的误差，让它们的误差和最小，从而得到一个最优的 $T$ ，则：</p>
<script type="math/tex; mode=display">
\min _{\boldsymbol{T}} J(\boldsymbol{T})=\sum_{i=1}^{N}\left\|\boldsymbol{z}_{i}-\boldsymbol{T}{\boldsymbol{p}_i}\right\|_{2}^{2}</script><p>这里的 $J(T)$ 就是一个关于李群或李代数的函数。我们要计算它的最小值，就要使目标函数 $J$ 关于变换矩阵 $T$ 进行求导。在SLAM中，我们会经常构建与位姿相关的函数，然后求其导数。</p>
<p>然而，在 $SO(3)$ 和 $SE(3)$ 中，并没有良好定义的加法，它们只是群。而从李代数的角度来说，由于李代数由向量组成，具有良好的加法运算，因此使用李代数解决求导问题的思路分为两种：</p>
<ul>
<li>用李代数表示位姿，然后根据李代数加法对李代数求导</li>
<li>对李群左乘或右乘微小扰动，然后对该扰动进行求导，称为左扰动和右扰动模型。</li>
</ul>
<h4 id="1-李代数求导"><a href="#1-李代数求导" class="headerlink" title="(1) 李代数求导"></a>(1) 李代数求导</h4><p>首先考虑 $SO(3)$ 上，假设我们对一个空间点 $\boldsymbol p$ 进行了旋转，得到了 $R\boldsymbol p$ 。现在要计算旋转后点的坐标相对于旋转的导数，我们非正式地记为：</p>
<script type="math/tex; mode=display">
\frac{\partial(\boldsymbol{R} \boldsymbol{p})}{\partial \boldsymbol{R}}</script><blockquote>
<p>这里不能按照矩阵微分来定义导数，只是一个记号</p>
</blockquote>
<p>由于 $SO(3)$ 没有加法，所以该导数无法按照导数的定义进行计算，设矩阵 $R$ 对应的李代数为 $\phi$ ，我们转而计算：</p>
<script type="math/tex; mode=display">
\frac{\partial\left(\exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}\right)}{\partial \boldsymbol{\phi}}</script><p>按照导数的定义，有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial\left(\exp \left(\phi^{\wedge}\right) \boldsymbol{p}\right)}{\partial \boldsymbol{\phi}} &=\lim _{\delta \boldsymbol{\phi} \rightarrow \mathbf{0}} \frac{\exp \left((\boldsymbol{\phi}+\delta \boldsymbol{\phi})^{\wedge}\right) \boldsymbol{p}-\exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}}{\delta \boldsymbol{\phi}} \\
&=\lim _{\delta \boldsymbol{\phi} \rightarrow \mathbf{0}} \frac{\exp \left(\left(\boldsymbol{J}_{l} \delta \boldsymbol{\phi}\right)^{\wedge}\right) \exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}-\exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}}{\delta \boldsymbol{\phi}} \\
&=\lim _{\delta \boldsymbol{\phi} \rightarrow \mathbf{0}} \frac{\left(\boldsymbol{I}+\left(\boldsymbol{J}_{l} \delta \boldsymbol{\phi}\right)^{\wedge}\right) \exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}-\exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}}{\delta \boldsymbol{\phi}} \\
&=\lim _{\delta \boldsymbol{\phi} \rightarrow \mathbf{0}} \frac{\left(\boldsymbol{J}_{l} \delta \boldsymbol{\phi}\right)^{\wedge} \exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}}{\delta \boldsymbol{\phi}} \\
&=\lim _{\delta \boldsymbol{\phi} \rightarrow \mathbf{0}} \frac{-\left(\exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}\right)^{\wedge} \boldsymbol{J}_{l} \delta \boldsymbol{\phi}}{\delta \boldsymbol{\phi}}=-(\boldsymbol{R} \boldsymbol{p})^{\wedge} \boldsymbol{J}_{l}
\end{aligned}</script><p>于是我们推出了旋转后的点相对于李代数的导数为：</p>
<script type="math/tex; mode=display">
\frac{\partial(\boldsymbol{R} \boldsymbol{p})}{\partial \boldsymbol{\phi}}=(-\boldsymbol{R} \boldsymbol{p})^{\wedge} \boldsymbol{J}_{l}</script><p>这里仍包含形式复杂的 $\boldsymbol J_l$ ，可以通过先求出 $\phi$ 再求出它。但是我们不太希望计算它，接下来我们会看到扰动模型提供了简单的导数计算方式。</p>
<h4 id="2-扰动模型（左乘）"><a href="#2-扰动模型（左乘）" class="headerlink" title="(2) 扰动模型（左乘）"></a>(2) 扰动模型（左乘）</h4><p>另一种求导方式是对 $R$ 进行一次扰动 $\Delta R$ ，这个扰动可以乘在左边也可以在右边，最后的结果会有一点微小的差异，设左扰动 $\Delta R$ 对应的李代数为 $\boldsymbol\varphi$ ，然后对 $\boldsymbol\varphi$ 求导，即：</p>
<script type="math/tex; mode=display">
\frac{\partial(\boldsymbol{R} \boldsymbol{p})}{\partial \varphi}=\lim _{\boldsymbol{\varphi} \rightarrow \mathbf{0}} \frac{\exp \left(\boldsymbol{\varphi}^{\wedge}\right) \exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}-\exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}}{\boldsymbol{\varphi}}</script><p>计算：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial(\boldsymbol{R} \boldsymbol{p})}{\partial \boldsymbol{\varphi}} &=\lim _{\boldsymbol{\varphi} \rightarrow 0} \frac{\exp \left(\boldsymbol{\varphi}^{\wedge}\right) \exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}-\exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}}{\boldsymbol{\varphi}} \\
&=\lim _{\varphi \rightarrow 0} \frac{\left(\boldsymbol{I}+\boldsymbol{\varphi}^{\wedge}\right) \exp \left(\phi^{\wedge}\right) \boldsymbol{p}-\exp \left(\phi^{\wedge}\right) \boldsymbol{p}}{\boldsymbol{\varphi}} \\
&=\lim _{\boldsymbol{\varphi} \rightarrow 0} \frac{\boldsymbol{\varphi}^{\wedge} \boldsymbol{R} \boldsymbol{p}}{\boldsymbol{\varphi}}=\lim _{\boldsymbol{\varphi} \rightarrow \mathbf{0}} \frac{-(\boldsymbol{R} \boldsymbol{p})^{\wedge} \boldsymbol{\varphi}}{\boldsymbol{\varphi}}=-(\boldsymbol{R} \boldsymbol{p})^{\wedge}
\end{aligned}</script><p>该方法的结果省去了一个雅可比矩阵 $J_l$ 。</p>
<h3 id="3-SE-3-上的李代数求导"><a href="#3-SE-3-上的李代数求导" class="headerlink" title="3. $SE(3)$ 上的李代数求导"></a>3. $SE(3)$ 上的李代数求导</h3><p>李代数求导就不介绍了，直接介绍扰动模型。</p>
<p>$\Delta T = \exp(\delta\boldsymbol{\xi}^{\wedge})$ ，我们设扰动项的李代数为$\delta \boldsymbol{\xi}=[\delta \boldsymbol{\rho}, \delta \boldsymbol{\phi}]^{\mathrm{T}}$ ，则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial(\boldsymbol{T} \boldsymbol{p})}{\partial \delta \boldsymbol{\xi}}&=\lim _{\delta \boldsymbol{\xi} \rightarrow 0} \frac{\exp \left(\delta \boldsymbol{\xi}^{\wedge}\right) \exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{p}-\exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{p}}{\delta \boldsymbol{\xi}}\\

&=\lim _{\delta \xi \rightarrow 0} \frac{\left(\boldsymbol{I}+\delta \boldsymbol{\xi}^{\wedge}\right) \exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{p}-\exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{p}}{\delta \boldsymbol{\xi}} \\
&=\lim _{\delta \boldsymbol{\xi} \rightarrow 0} \frac{\delta \boldsymbol{\xi}^{\wedge} \exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{p}}{\delta \boldsymbol{\xi}} \\
&=\lim _{\delta \boldsymbol{\xi} \rightarrow 0} \frac{\left[\begin{array}{cc}
\delta \boldsymbol{\phi}^{\wedge} & \delta \boldsymbol{\rho} \\
\mathbf{0}^{\mathrm{T}} & 0
\end{array}\right]\left[\begin{array}{c}
\boldsymbol{R} \boldsymbol{p}+\boldsymbol{t} \\
1
\end{array}\right]}{\delta \boldsymbol{\xi}} \\
&=\lim _{\delta \boldsymbol{\xi} \rightarrow 0} \frac{\left[\begin{array}{c}
\delta \boldsymbol{\phi}^{\wedge}(\boldsymbol{R} \boldsymbol{p}+\boldsymbol{t})+\delta \boldsymbol{\rho} \\
\mathbf{0}^{\mathrm{T}}
\end{array}\right]}{[\delta \boldsymbol{\rho}, \delta \boldsymbol{\phi}]^{\mathrm{T}}}=\left[\begin{array}{cc}
\boldsymbol{I} & -(\boldsymbol{R} \boldsymbol{p}+\boldsymbol{t})^{\wedge} \\
\mathbf{0}^{\mathrm{T}} & \mathbf{0}^{\mathrm{T}}
\end{array}\right] \stackrel{\text { def }}{=}(\boldsymbol{T} \boldsymbol{p})^{\odot}
\end{aligned}</script><p>这个形式很复杂，但只要记住最后的结论就是该扰动模型的结果是一个矩阵，这个矩阵是 $4\times 6$ 维的。</p>
<h2 id="IV-总结"><a href="#IV-总结" class="headerlink" title="IV. 总结"></a>IV. 总结</h2><p>前面讲了李群李代数的由来，现在进行简单的总结，该总结仅建立在个人理解上，并没有证明过程。</p>
<ol>
<li>李群和李代数的引入是为了解决矩阵求导问题。因为求导需要进行加减，而旋转矩阵的加法运算不封闭，所以要借助李代数来进行。对李群求导，可以转化为对其对应的李代数求导。对于求导过程中，增量的表示可以用扰动模型表示或是利用李代数的加法运算来表示。</li>
<li><strong>李群和李代数的引入的一个重大原因就是简化了矩阵相乘的运算</strong>。根据BCH近似公式，两个李群相乘，等于其对应的两个李代数乘其中一个乘以一个雅可比矩阵，再加上另一个对应的李代数。（具体看左乘和右乘）。</li>
<li>旋转矩阵和变换矩阵就是李群，每一个矩阵都对应着一个李代数，李代数是一个向量。特别地对于一个旋转矩阵对应的李代数是一个旋转向量。</li>
<li>李代数可以描述李群的局部性质。</li>
<li>李群和李代数之间由指数映射和对数映射来转换。如旋转向量所对应的反对称矩阵的指数函数就是一个旋转矩阵，而旋转矩阵求对数再变化成向量（这里旋转矩阵求对数之后还是一个矩阵，要根据反对称矩阵的关系变换一下），就是一个旋转向量。</li>
</ol>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM6】Sophus库的使用</title>
    <url>/2022/07/19/%E3%80%90%E8%A7%86%E8%A7%89SLAM6%E3%80%91Sophus%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>一个较好的李代数库是 Sophus 库。</p>
<span id="more"></span>
<h2 id="I-Sophus库的简单使用"><a href="#I-Sophus库的简单使用" class="headerlink" title="I. Sophus库的简单使用"></a>I. Sophus库的简单使用</h2><p><code>slambook/ch4/useSophus.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sophus/se3.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 本程序演示sophus的基本用法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 沿Z轴转90度的旋转矩阵</span></span><br><span class="line">  Matrix3d R = <span class="built_in">AngleAxisd</span>(M_PI / <span class="number">2</span>, <span class="built_in">Vector3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)).<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">  <span class="comment">// 或者四元数</span></span><br><span class="line">  <span class="function">Quaterniond <span class="title">q</span><span class="params">(R)</span></span>;</span><br><span class="line">  <span class="function">Sophus::SO3d <span class="title">SO3_R</span><span class="params">(R)</span></span>;              <span class="comment">// Sophus::SO3d可以直接从旋转矩阵构造</span></span><br><span class="line">  <span class="function">Sophus::SO3d <span class="title">SO3_q</span><span class="params">(q)</span></span>;              <span class="comment">// 也可以通过四元数构造</span></span><br><span class="line">  <span class="comment">// 二者是等价的</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;SO(3) from matrix:\n&quot;</span> &lt;&lt; SO3_R.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;SO(3) from quaternion:\n&quot;</span> &lt;&lt; SO3_q.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;they are equal&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用对数映射获得它的李代数</span></span><br><span class="line">  Vector3d so3 = SO3_R.<span class="built_in">log</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;so3 = &quot;</span> &lt;&lt; so3.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// hat 为向量到反对称矩阵</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;so3 hat=\n&quot;</span> &lt;&lt; Sophus::SO3d::<span class="built_in">hat</span>(so3) &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 相对的，vee为反对称到向量</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;so3 hat vee= &quot;</span> &lt;&lt; Sophus::SO3d::<span class="built_in">vee</span>(Sophus::SO3d::<span class="built_in">hat</span>(so3)).<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增量扰动模型的更新</span></span><br><span class="line">  <span class="function">Vector3d <span class="title">update_so3</span><span class="params">(<span class="number">1e-4</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>; <span class="comment">//假设更新量为这么多</span></span><br><span class="line">  Sophus::SO3d SO3_updated = Sophus::SO3d::<span class="built_in">exp</span>(update_so3) * SO3_R;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;SO3 updated = \n&quot;</span> &lt;&lt; SO3_updated.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;*******************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 对SE(3)操作大同小异</span></span><br><span class="line">  <span class="function">Vector3d <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;           <span class="comment">// 沿X轴平移1</span></span><br><span class="line">  <span class="function">Sophus::SE3d <span class="title">SE3_Rt</span><span class="params">(R, t)</span></span>;           <span class="comment">// 从R,t构造SE(3)</span></span><br><span class="line">  <span class="function">Sophus::SE3d <span class="title">SE3_qt</span><span class="params">(q, t)</span></span>;            <span class="comment">// 从q,t构造SE(3)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;SE3 from R,t= \n&quot;</span> &lt;&lt; SE3_Rt.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;SE3 from q,t= \n&quot;</span> &lt;&lt; SE3_qt.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 李代数se(3) 是一个六维向量，方便起见先typedef一下</span></span><br><span class="line">  <span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Vector6d;</span><br><span class="line">  Vector6d se3 = SE3_Rt.<span class="built_in">log</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;se3 = &quot;</span> &lt;&lt; se3.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 观察输出，会发现在Sophus中，se(3)的平移在前，旋转在后.</span></span><br><span class="line">  <span class="comment">// 同样的，有hat和vee两个算符</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;se3 hat = \n&quot;</span> &lt;&lt; Sophus::SE3d::<span class="built_in">hat</span>(se3) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;se3 hat vee = &quot;</span> &lt;&lt; Sophus::SE3d::<span class="built_in">vee</span>(Sophus::SE3d::<span class="built_in">hat</span>(se3)).<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后，演示一下更新</span></span><br><span class="line">  Vector6d update_se3; <span class="comment">//更新量</span></span><br><span class="line">  update_se3.<span class="built_in">setZero</span>();</span><br><span class="line">  <span class="built_in">update_se3</span>(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">1e-4</span>;</span><br><span class="line">  Sophus::SE3d SE3_updated = Sophus::SE3d::<span class="built_in">exp</span>(update_se3) * SE3_Rt;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;SE3 updated = &quot;</span> &lt;&lt; endl &lt;&lt; SE3_updated.<span class="built_in">matrix</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="II-例子：评估轨迹误差"><a href="#II-例子：评估轨迹误差" class="headerlink" title="II. 例子：评估轨迹误差"></a>II. 例子：评估轨迹误差</h2><p>我们需要一个评估指标来评价一个算法的精度。考虑一条估计轨迹 $T_{esti,i}$ 和真实轨迹 $T_{gt,i}$ ，其中 $i=1,2,\cdots,N$，我们可以定义如下几个指标：</p>
<h3 id="1-绝对轨迹误差"><a href="#1-绝对轨迹误差" class="headerlink" title="1. 绝对轨迹误差"></a>1. 绝对轨迹误差</h3><p>Absolute Trajectory Error(ATE)</p>
<script type="math/tex; mode=display">
\mathrm{ATE}_{\mathrm{all}}=\sqrt{\frac{1}{N} \sum_{i=1}^{N}\left\|\log \left(\boldsymbol{T}_{\mathrm{gt}, i}^{-1} \boldsymbol{T}_{\mathrm{esti}, i}\right)^{\vee}\right\|_{2}^{2}}</script><p>这实际上是每个位子<strong>李代数的均方根</strong>误差，这种误差可以刻画两条轨迹的<strong>旋转</strong>和<strong>平移</strong>误差。</p>
<h3 id="2-绝对平移误差"><a href="#2-绝对平移误差" class="headerlink" title="2. 绝对平移误差"></a>2. 绝对平移误差</h3><p>Average Translational Error</p>
<p>同样，我们也可以仅考虑平移误差，因为如果旋转错了，平移也一定估计错。</p>
<script type="math/tex; mode=display">
\mathrm{ATE}_{\text {trans }}=\sqrt{\frac{1}{N} \sum_{i=1}^{N}\left\|\operatorname{trans}\left(\boldsymbol{T}_{\mathrm{gt}, i}^{-1} \boldsymbol{T}_{\text {esti, } i}\right)\right\|_{2}^{2}}</script><p>其中 <code>trans</code> 表示取括号内部变量的平移部分。</p>
<h3 id="3-相对位姿误差"><a href="#3-相对位姿误差" class="headerlink" title="3. 相对位姿误差"></a>3. 相对位姿误差</h3><p>Relative Pose Error</p>
<p>如果仅考虑时刻 $t$ 到 $t+\Delta t$ 时刻的运动，那么可以定义为：</p>
<script type="math/tex; mode=display">
\mathrm{RPE}_{\mathrm{all}}=\sqrt{\left.\frac{1}{N-\Delta t} \sum_{i=1}^{N-\Delta t} \| \log \left(\left(\boldsymbol{T}_{\mathrm{gt}, i}^{-1} \boldsymbol{T}_{\mathrm{gt}, i+\Delta t}\right)\right)^{-1}\left(\boldsymbol{T}_{\text {esti }, i}^{-1} \boldsymbol{T}_{\text {esti }, i+\Delta t}\right)\right)^{\vee} \|_{2}^{2}}</script><p>例如我们考虑时间段 $\Delta t = 5$ ，那么就要求在时间5个单位内的变换矩阵。在第3个单位时刻时的运动为 $T_{esti,3}$ ，在第8个单位时刻时的运动为 $T_{esti,8}$ ，所以要求这个5个单位时段内的运动就为：</p>
<script type="math/tex; mode=display">
T_{esti,3}^{-1}T_{esti,3+5}</script><p>同理，我们也可以仅考虑这段时间内的平移：</p>
<script type="math/tex; mode=display">
\mathrm{RPE}_{\mathrm{all}}=\sqrt{\left.\frac{1}{N-\Delta t} \sum_{i=1}^{N-\Delta t} \| \log \left(\left(\boldsymbol{T}_{\mathrm{gt}, i}^{-1} \boldsymbol{T}_{\mathrm{gt}, i+\Delta t}\right)\right)^{-1}\left(\boldsymbol{T}_{\text {esti }, i}^{-1} \boldsymbol{T}_{\text {esti }, i+\Delta t}\right)\right)^{\vee} \|_{2}^{2}}</script><h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pangolin/pangolin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/se3.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Sophus;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string groundtruth_file = <span class="string">&quot;./example/groundtruth.txt&quot;</span>;</span><br><span class="line">string estimated_file = <span class="string">&quot;./example/estimated.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;Sophus::SE3d, Eigen::aligned_allocator&lt;Sophus::SE3d&gt;&gt; TrajectoryType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTrajectory</span><span class="params">(<span class="keyword">const</span> TrajectoryType &amp;gt, <span class="keyword">const</span> TrajectoryType &amp;esti)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TrajectoryType <span class="title">ReadTrajectory</span><span class="params">(<span class="keyword">const</span> string &amp;path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  TrajectoryType groundtruth = <span class="built_in">ReadTrajectory</span>(groundtruth_file);</span><br><span class="line">  TrajectoryType estimated = <span class="built_in">ReadTrajectory</span>(estimated_file);</span><br><span class="line">  <span class="built_in">assert</span>(!groundtruth.<span class="built_in">empty</span>() &amp;&amp; !estimated.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="built_in">assert</span>(groundtruth.<span class="built_in">size</span>() == estimated.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compute rmse</span></span><br><span class="line">  <span class="keyword">double</span> rmse = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; estimated.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Sophus::SE3d p1 = estimated[i], p2 = groundtruth[i];</span><br><span class="line">    <span class="keyword">double</span> error = (p2.<span class="built_in">inverse</span>() * p1).<span class="built_in">log</span>().<span class="built_in">norm</span>();</span><br><span class="line">    rmse += error * error;</span><br><span class="line">  &#125;</span><br><span class="line">  rmse = rmse / <span class="built_in"><span class="keyword">double</span></span>(estimated.<span class="built_in">size</span>());</span><br><span class="line">  rmse = <span class="built_in">sqrt</span>(rmse);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;RMSE = &quot;</span> &lt;&lt; rmse &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DrawTrajectory</span>(groundtruth, estimated);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TrajectoryType <span class="title">ReadTrajectory</span><span class="params">(<span class="keyword">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(path)</span></span>;</span><br><span class="line">  TrajectoryType trajectory;</span><br><span class="line">  <span class="keyword">if</span> (!fin) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;trajectory &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot; not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> trajectory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!fin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    <span class="keyword">double</span> time, tx, ty, tz, qx, qy, qz, qw;</span><br><span class="line">    fin &gt;&gt; time &gt;&gt; tx &gt;&gt; ty &gt;&gt; tz &gt;&gt; qx &gt;&gt; qy &gt;&gt; qz &gt;&gt; qw;</span><br><span class="line">    <span class="function">Sophus::SE3d <span class="title">p1</span><span class="params">(Eigen::Quaterniond(qw, qx, qy, qz), Eigen::Vector3d(tx, ty, tz))</span></span>;</span><br><span class="line">    trajectory.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> trajectory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTrajectory</span><span class="params">(<span class="keyword">const</span> TrajectoryType &amp;gt, <span class="keyword">const</span> TrajectoryType &amp;esti)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// create pangolin window and plot the trajectory</span></span><br><span class="line">  pangolin::<span class="built_in">CreateWindowAndBind</span>(<span class="string">&quot;Trajectory Viewer&quot;</span>, <span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">  <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">  <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line">  <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"></span><br><span class="line">  <span class="function">pangolin::OpenGlRenderState <span class="title">s_cam</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      pangolin::ProjectionMatrix(<span class="number">1024</span>, <span class="number">768</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">512</span>, <span class="number">389</span>, <span class="number">0.1</span>, <span class="number">1000</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">      pangolin::ModelViewLookAt(<span class="number">0</span>, <span class="number">-0.1</span>, <span class="number">-1.8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line"></span><br><span class="line">  pangolin::View &amp;d_cam = pangolin::<span class="built_in">CreateDisplay</span>()</span><br><span class="line">      .<span class="built_in">SetBounds</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, pangolin::Attach::<span class="built_in">Pix</span>(<span class="number">175</span>), <span class="number">1.0</span>, <span class="number">-1024.0f</span> / <span class="number">768.0f</span>)</span><br><span class="line">      .<span class="built_in">SetHandler</span>(<span class="keyword">new</span> pangolin::<span class="built_in">Handler3D</span>(s_cam));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (pangolin::<span class="built_in">ShouldQuit</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    d_cam.<span class="built_in">Activate</span>(s_cam);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; gt.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">glColor3f</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);  <span class="comment">// blue for ground truth</span></span><br><span class="line">      <span class="built_in">glBegin</span>(GL_LINES);</span><br><span class="line">      <span class="keyword">auto</span> p1 = gt[i], p2 = gt[i + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">glVertex3d</span>(p1.<span class="built_in">translation</span>()[<span class="number">0</span>], p1.<span class="built_in">translation</span>()[<span class="number">1</span>], p1.<span class="built_in">translation</span>()[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(p2.<span class="built_in">translation</span>()[<span class="number">0</span>], p2.<span class="built_in">translation</span>()[<span class="number">1</span>], p2.<span class="built_in">translation</span>()[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; esti.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">glColor3f</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);  <span class="comment">// red for estimated</span></span><br><span class="line">      <span class="built_in">glBegin</span>(GL_LINES);</span><br><span class="line">      <span class="keyword">auto</span> p1 = esti[i], p2 = esti[i + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">glVertex3d</span>(p1.<span class="built_in">translation</span>()[<span class="number">0</span>], p1.<span class="built_in">translation</span>()[<span class="number">1</span>], p1.<span class="built_in">translation</span>()[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glVertex3d</span>(p2.<span class="built_in">translation</span>()[<span class="number">0</span>], p2.<span class="built_in">translation</span>()[<span class="number">1</span>], p2.<span class="built_in">translation</span>()[<span class="number">2</span>]);</span><br><span class="line">      <span class="built_in">glEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pangolin::<span class="built_in">FinishFrame</span>();</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">5000</span>);   <span class="comment">// sleep 5 ms</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM7】相机模型</title>
    <url>/2022/07/19/%E3%80%90%E8%A7%86%E8%A7%89SLAM7%E3%80%91%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>介绍相机的成像过程</p>
<span id="more"></span>
<p>相机模型主要用来描述将三维世界中的坐标点（单位为米）映射到二维图像平面（单位为像素）的过程。对于常见的相机，我们可以用针孔模型和畸变模型来描述整个投影过程。</p>
<h2 id="I-针孔模型"><a href="#I-针孔模型" class="headerlink" title="I. 针孔模型"></a>I. 针孔模型</h2><p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220719205915.png" alt="image-20220719205914876" style="zoom:50%;" /></p>
<p>现在对针孔模型进行数学建模。设 $O-x-y-z$ 为相机坐标系，习惯上我们让 $z$ 轴指向前方，如上图所示。现实世界中有一 $P$ 点，经过小孔 $O$ 投影后，落在成像平面 $O’-x’-y’$上， 成像点为 $P’$ 。设 $P=[X,Y,Z]^T$，$P’=[X’,Y’,Z’]^T$ ，并且设物理成像平面到小孔的距离为 $f$ （焦距），那么根据三角形相似关系，有：</p>
<script type="math/tex; mode=display">
\frac{Z}{f}=-\frac{X}{X^{\prime}}=-\frac{Y}{Y^{\prime}}\tag{1}</script><p>其中负号表示成像是倒的，不过实际上成像并不是倒的，因此我们可以把负号去掉，使式子更加简介（实际上相机已经帮我们把倒立的像正过来了）：</p>
<script type="math/tex; mode=display">
\frac{Z}{f}=\frac{X}{X^{\prime}}=\frac{Y}{Y^{\prime}}\tag{2}</script><p>整理可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X^{\prime} &=f \frac{X}{Z} \\
Y^{\prime} &=f \frac{Y}{Z}
\end{aligned}\tag{3}</script><p>此刻的 $X’, Y’$ 的单位都是米，也就是在相机成像平面上，距离成像中心的真实距离。但图像终究是由一个个像素构成的，所以我们还要将  $X’, Y’$ 转化成对应的像素坐标 $[u,v]^T$。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220719215156.png" alt="image-20220719215155983" style="zoom: 33%;" /></p>
<p>像素坐标系与成像平面之间，相差了一个缩放和一个原点的平移，如上图所示，我们设像素坐标在 $u$ 轴上缩放了 $\alpha$ 倍，在 $v$ 轴上缩放了 $\beta$ 倍，同时原点平移了 $[c_x,c_y]^T$ ，那么，$P’$ 的坐标与像素坐标 $[u,v]^T$ 的关系为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
u=\alpha X^{\prime}+c_{x} \\
v=\beta Y^{\prime}+c_{y}
\end{array}\right.\tag{4}</script><p>把（3）式带入到（4）中，并令 $\alpha f=f_x,\beta f= f_y$  ，可得：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
u=f_{x} \frac{X}{Z}+c_{x} \\
v=f_{y} \frac{Y}{Z}+c_{y}
\end{array}\right.</script><p>其中 $f$ 的单位是米，$\alpha,\beta$ 的单位为像素/米，所以 $f_x,f_y,c_x,c_y$ 的单位为像素，把该式写成矩阵形式会更加简洁，不过左侧需要用齐次坐标，右侧为非齐次坐标：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{l}
u \\
v \\
1
\end{array}\right)=\frac{1}{Z}\left(\begin{array}{ccc}
f_{x} & 0 & c_{x} \\
0 & f_{y} & c_{y} \\
0 & 0 & 1
\end{array}\right)\left(\begin{array}{l}
X \\
Y \\
Z
\end{array}\right) \stackrel{\operatorname{def}}{=} \frac{1}{Z} \boldsymbol{K} \boldsymbol{P}</script><p>习惯性地把Z移到左侧：</p>
<script type="math/tex; mode=display">
Z\left(\begin{array}{c}
u \\
v \\
1
\end{array}\right)=\left(\begin{array}{ccc}
f_{x} & 0 & c_{x} \\
0 & f_{y} & c_{y} \\
0 & 0 & 1
\end{array}\right)\left(\begin{array}{c}
X \\
Y \\
Z
\end{array}\right) \stackrel{\text { def }}{=} \boldsymbol{K} \boldsymbol{P}</script><p>也可以写为：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{c}
u \\
v \\
1
\end{array}\right)=\left(\begin{array}{ccc}
f_{x} & 0 & c_{x} \\
0 & f_{y} & c_{y} \\
0 & 0 & 1
\end{array}\right)\left(\begin{array}{c}
\frac{X}{Z} \\
\frac{Y}{Z} \\
1
\end{array}\right)</script><p>从这个式子可以看出，只要 $\frac{X}{Z}， \frac{Y}{Z}$ 的比值保持不变时，像素坐标就不变，因此可以从另一个角度来知道，单目丢失了深度信息，即当仅仅知道一点的像素坐标时，是无法还原出其真实的空间位置的，只是知道它在哪一条射线上。这里的 $[\frac{X}{Z},\frac{Y}{Z},1]^T$ 称为归一化坐标，表示相机坐标系下，$Z=1$ 平面与这条射线相交的点。</p>
<p>我们把中间的 $K$ 矩阵称为相机的内参矩阵，通常认为相机的内参在出厂之后是固定的，不会在使用过程中发生变化。</p>
<p>另外，有内参自然相对的有外参，在之前的推导中，我们使用的 $P$ 点是相机坐标系下的坐标，但实际上由于相机在运动，所以 $P$ 的相机系下的坐标应该是它的世界坐标（记为 $P_w$ ）根据相机的当前位姿变换到相机坐标系下的结果。则有：</p>
<script type="math/tex; mode=display">
Z \boldsymbol{P}_{u v}=Z\left[\begin{array}{l}
u \\
v \\
1
\end{array}\right]=\boldsymbol{K}\left(\boldsymbol{R} \boldsymbol{P}_{\mathrm{w}}+\boldsymbol{t}\right)=\boldsymbol{K} \boldsymbol{T} \boldsymbol{P}_{\mathrm{w}}</script><p>这里的 $R$ 和 $t$ 称为相机的外参数。</p>
<h2 id="II-畸变模型"><a href="#II-畸变模型" class="headerlink" title="II. 畸变模型"></a>II. 畸变模型</h2><p>相机中加入透镜会导致图片发生畸变，畸变分为两种：</p>
<ul>
<li>有透镜自身对光线传播的影响，导致的<strong>径向畸变</strong>。</li>
<li>由透镜与成像平面不完全平行造成的<strong>切向畸变</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220719230611.png" alt="image-20220719230611310" style="zoom:50%;" /></p>
<p>径向畸变分为桶形畸变和枕形畸变两种，桶形畸变中，图像放大倍率随着与光轴之间的距离增大而减小，而枕形畸变则恰好相反。穿过图像中心和光轴有交点的直线还能保持形状不变。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220719231120.png" alt="image-20220719231120811" style="zoom: 50%;" /></p>
<p>切向畸变如上图所示。我们现在用更严格的数学形式对两者进行描述，考虑归一化平面上的一点 $P=[x,y]^T$ ，极坐标形式为 $[r,\theta]^T$ ，径向畸变中，坐标点随着该点距离原点的长度发生变化，切向畸变可以看成坐标点沿着切线方向发生了变化，也就是水平夹角发生了变化。通常假设这些畸变呈多项式关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x_{\text {distorted }}=x\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\right) \\
&y_{\text {distorted }}=y\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\right)
\end{aligned}</script><p>其中，$[x_{distorted},y_{distorted}]^T$ 是畸变后点的归一化坐标。对于切向畸变，我们使用另外两个参数 $p_1,p_2$ 进行纠正：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x_{\text {distorted }}=x+2 p_{1} x y+p_{2}\left(r^{2}+2 x^{2}\right) \\
&y_{\text {distorted }}=y+p_{1}\left(r^{2}+2 y^{2}\right)+2 p_{2} x y
\end{aligned}</script><p>因此，对于相机坐标系中的任意一点 $P$ ，我们能够通过5个畸变系数找到这个点在像素平面上的正确位置，即：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
x_{\text {distorted }}=x\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\right)+2 p_{1} x y+p_{2}\left(r^{2}+2 x^{2}\right) \\
y_{\text {distorted }}=y\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\right)+p_{1}\left(r^{2}+2 y^{2}\right)+2 p_{2} x y
\end{array}\right.</script><p>对于去畸变，可以这样做：</p>
<ol>
<li>任选畸变图象上的一点 $[u,v]^T$ ，计算该像素点对应归一化平面上的坐标 $[x,y]^T$ 。</li>
<li>计算 $r = \sqrt{x^2+y^2}$ ，然后带入到畸变方程中，求出畸变后的归一化平面上的坐标 $[x_{distorted},y_{distorted}]^T$ 。</li>
<li>然后根据$[x_{distorted},y_{distorted}]^T$和相机的内参计算出像素平面上的坐标 $[u_{distorted},v_{distorted}]^T$ </li>
<li>将$[u_{distorted},v_{distorted}]^T$ 处的像素值赋给$[u,v]^T$ 处的像素。</li>
</ol>
<p>该方法就是找这个像素点本应该对应的像素值，因为畸变，本应该投影到该点的点被投到别处，所以要找到这个投到别处的点。</p>
<h2 id="III-双目相机模型"><a href="#III-双目相机模型" class="headerlink" title="III. 双目相机模型"></a>III. 双目相机模型</h2><p>双目相机和人眼一样，可以根据视差来计算出深度。双目相机的几何模型如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220720012007.png" alt="image-20220720012007271" style="zoom:50%;" /></p>
<p>两个相机中心间的距离称为基线，是双目相机重要的参数，记为 $b$ 。假设空间中有一点 $P$ ，在左眼相机和右眼相机上各成一个像，记为 $P_L$ 和 $P_R$ ，由于观看角度不同，这两个点的成像位置也不同。理想情况下，由于左右相机仅在 $x$ 轴上有位移，所以 $P$ 的像也只在 $x$ 轴上有差异。记它在左边相机上的坐标为 $u_L$ ，右边相机上的坐标为 $u_R$ （注意这里的 $u_L , u_R$ 是相机坐标系的坐标，单位是米）。根据几何关系，可以得到：</p>
<script type="math/tex; mode=display">
\frac{z-f}{z}=\frac{b-u_{\mathrm{L}}+u_{\mathrm{R}}}{b}</script><p>这里的 $u_R$ 是负数，所以表示距离时取负。整理可得：</p>
<script type="math/tex; mode=display">
z=\frac{f b}{d}, \quad d \stackrel{\text { def }}{=} u_{\mathrm{L}}-u_{\mathrm{R}}</script><p>其中 $d$ 定义为左右图的横坐标之差，称为视差。由上式可以知道，视差越小，深度越大。因为视差最小也就是一个像素所表示的长度，所以所能探测到的深度是有一定范围的，由 $fb$ 来确定。因此基线越长，探测的范围越大。</p>
<p>虽然双目相机可以直接指导深度，但是也有很多问题，我们需要确切知道哪两个像素点是同一物体的投影，这就需要进行像素点匹配，而这又很占用计算资源，且精度不高。</p>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM10】g2o库</title>
    <url>/2022/07/25/%E3%80%90%E8%A7%86%E8%A7%89SLAM10%E3%80%91g2o%E5%BA%93/</url>
    <content><![CDATA[<p>g2o优化库是一个基于图优化的库，在SLAM领域广泛使用。它是将非线性优化和图论结合的理论。</p>
<span id="more"></span>
<h2 id="I-图优化理论简介"><a href="#I-图优化理论简介" class="headerlink" title="I. 图优化理论简介"></a>I. 图优化理论简介</h2><p>非线性最小二乘问题的代价函数由很多个误差项的平方之和组成。但是代价函数仅描述了<strong>优化变量</strong>和许多个<strong>误差项</strong>，但我们<strong>尚不清楚它们之间的关联</strong>。例如, 某个优化变 量 $x_{j}$ 存在于多少个误差项中呢? 我们能保证对它的优化是有意义的吗? 进一步, 我们希望能够直观地看到该优化问题长什么样，于是, 就牵涉到了图优化。</p>
<p><strong>图优化是把优化问题表现成图的一种方式。</strong>这里的图指的是图论意义上的图。图包括：</p>
<ul>
<li>顶点：表示优化变量</li>
<li>边：表示误差项</li>
</ul>
<p>所以对于任意一个非线性最小二乘问题，都可以构建与之对应的一个图。也可以称为<strong>贝叶斯图</strong>和<strong>因子图</strong>。</p>
<p>我们可以把SLAM中优化的代价函数，即下式：</p>
<script type="math/tex; mode=display">
\min J(\boldsymbol{x}, \boldsymbol{y})=\sum_{k} e_{\boldsymbol{u}, k}^{\mathrm{T}} \boldsymbol{R}_{k}^{-1} e_{\boldsymbol{u}, k}+\sum_{k} \sum_{j} e_{\boldsymbol{z}, k, j}^{\mathrm{T}} \boldsymbol{Q}_{k, j}^{-1} \boldsymbol{e}_{\boldsymbol{z}, k, j}</script><p>从数学形式转换成图优化的关系。我们用<strong>三角形表示相机位姿节点，用圆形表示路标点</strong>，它们构成了图优化的顶点。实线表示相机的运动模型（即运动误差），虚线表示观测模型（即观测误差），它们构成了图优化的边。有了图关系，我们可以直观地看到问题的结构了。 也可以去掉孤立顶点或优先优化边数较多 (或按图论的术语, 度数较大) 的顶点这样的改进。但是最基本的图优化是用图模型来表达一个非线性最小二乘的优化问题。<strong>我们可以利用图模型的某些性质做更好的优化</strong>。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220726021009.png" alt="image-20220726021009065" style="zoom:50%;" /></p>
<p><strong>注意：</strong></p>
<p>图优化中的边可以只连接一个顶点，称为一元边，也为此时可能只有一个优化变量。一条边也可以连接多个顶点，这称为超边。</p>
<p>在使用g2o库时，主要步骤为：</p>
<ol>
<li>定义顶点和边的类型</li>
<li>构建图</li>
<li>选择优化算法</li>
<li>调用g2o进行优化，返回结果</li>
</ol>
<h2 id="II-例子"><a href="#II-例子" class="headerlink" title="II. 例子"></a>II. 例子</h2><p>第9节的曲线近似例子。</p>
<p>代码：</p>
<p><code>\slambook2\ch6\g2oCurveFitting.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/g2o_core_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的顶点，模板参数：优化变量维度和数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingVertex</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *update)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    _estimate += Eigen::<span class="built_in">Vector3d</span>(update);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 误差模型 模板参数：观测值维度，类型，连接顶点类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingEdge</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="keyword">double</span>, CurveFittingVertex&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">CurveFittingEdge</span><span class="params">(<span class="keyword">double</span> x)</span> : BaseUnaryEdge(), _x(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CurveFittingVertex *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">    _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>, <span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算雅可比矩阵</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CurveFittingVertex *v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">exp</span>(abc[<span class="number">0</span>] * _x * _x + abc[<span class="number">1</span>] * _x + abc[<span class="number">2</span>]);</span><br><span class="line">    _jacobianOplusXi[<span class="number">0</span>] = -_x * _x * y;</span><br><span class="line">    _jacobianOplusXi[<span class="number">1</span>] = -_x * y;</span><br><span class="line">    _jacobianOplusXi[<span class="number">2</span>] = -y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">double</span> _x;  <span class="comment">// x 值， y 值为 _measurement</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;         <span class="comment">// 真实参数值</span></span><br><span class="line">  <span class="keyword">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;        <span class="comment">// 估计参数值</span></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">100</span>;                                 <span class="comment">// 数据点</span></span><br><span class="line">  <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;                        <span class="comment">// 噪声Sigma值</span></span><br><span class="line">  <span class="keyword">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">  cv::RNG rng;                                 <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">double</span>&gt; x_data, y_data;      <span class="comment">// 数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">    x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">    y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.<span class="built_in">gaussian</span>(w_sigma * w_sigma));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建图优化，先设定g2o</span></span><br><span class="line">  <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; BlockSolverType;  <span class="comment">// 每个误差项优化变量维度为3，误差值维度为1</span></span><br><span class="line">  <span class="keyword">typedef</span> g2o::LinearSolverDense&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType; <span class="comment">// 线性求解器类型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 梯度下降方法，可以从GN, LM, DogLeg 中选</span></span><br><span class="line">  <span class="keyword">auto</span> solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(</span><br><span class="line">    g2o::make_unique&lt;BlockSolverType&gt;(g2o::make_unique&lt;LinearSolverType&gt;()));</span><br><span class="line">  g2o::SparseOptimizer optimizer;     <span class="comment">// 图模型</span></span><br><span class="line">  optimizer.<span class="built_in">setAlgorithm</span>(solver);   <span class="comment">// 设置求解器</span></span><br><span class="line">  optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>);       <span class="comment">// 打开调试输出</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往图中增加顶点</span></span><br><span class="line">  CurveFittingVertex *v = <span class="keyword">new</span> <span class="built_in">CurveFittingVertex</span>();</span><br><span class="line">  v-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(ae, be, ce));</span><br><span class="line">  v-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">  optimizer.<span class="built_in">addVertex</span>(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往图中增加边</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    CurveFittingEdge *edge = <span class="keyword">new</span> <span class="built_in">CurveFittingEdge</span>(x_data[i]);</span><br><span class="line">    edge-&gt;<span class="built_in">setId</span>(i);</span><br><span class="line">    edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, v);                <span class="comment">// 设置连接的顶点</span></span><br><span class="line">    edge-&gt;<span class="built_in">setMeasurement</span>(y_data[i]);      <span class="comment">// 观测数值</span></span><br><span class="line">    edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>() * <span class="number">1</span> / (w_sigma * w_sigma)); <span class="comment">// 信息矩阵：协方差矩阵之逆</span></span><br><span class="line">    optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行优化</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;start optimization&quot;</span> &lt;&lt; endl;</span><br><span class="line">  chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  optimizer.<span class="built_in">initializeOptimization</span>();</span><br><span class="line">  optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);</span><br><span class="line">  chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;solve time cost = &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds. &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出优化值</span></span><br><span class="line">  Eigen::Vector3d abc_estimate = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;estimated model: &quot;</span> &lt;&lt; abc_estimate.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM8】非线性优化</title>
    <url>/2022/07/20/%E3%80%90%E8%A7%86%E8%A7%89SLAM8%E3%80%91%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在SLAM的数学描述中，我们知道了运动方程和观测方程，但是这两个方程并不是精确成立的，因为包含了噪声的影响，所以要想得到精确的相机和路标点的位姿估计，就需要想办法来应对含噪声的数据。</p>
<span id="more"></span>
<h2 id="I-状态估计问题"><a href="#I-状态估计问题" class="headerlink" title="I. 状态估计问题"></a>I. 状态估计问题</h2><p>运动和观测方程如下：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\boldsymbol{x}_{k}=f\left(\boldsymbol{x}_{k-1}, \boldsymbol{u}_{k}\right)+\boldsymbol{w}_{k} \\
\boldsymbol{z}_{k, j}=h\left(\boldsymbol{y}_{j}, \boldsymbol{x}_{k}\right)+\boldsymbol{v}_{k, j}
\end{array}\right.\tag{1}</script><p>我们知道，$\boldsymbol x_k$ 是相机的位姿，可以用 $T_k\in SE(3)$ 来描述。 而观测方程由针孔模型给定，假设在 $\boldsymbol{x_k}$ 处对路标 $\boldsymbol y_j$ 进行了一次观测，对应到图像上的像素位置 $\boldsymbol {z_{k,j}}$ ，那么观测方程可以表示为：</p>
<script type="math/tex; mode=display">
s \boldsymbol{z}_{k, j}=\boldsymbol{K}\left(\boldsymbol{R}_{k} \boldsymbol{y}_{j}+\boldsymbol{t}_{k}\right)\tag{2}</script><p>在实际中，式（2）并不成立，因为存在噪声项。在运动和观测方程中，我们通常假设两个噪声项 $\boldsymbol {w}_{k}$ 和 $\boldsymbol{v}_{k,j}$ 满足均值为0的高斯分布：</p>
<script type="math/tex; mode=display">
\boldsymbol{w}_{k} \sim \mathcal{N}\left(\mathbf{0}, \boldsymbol{R}_{k}\right), \boldsymbol{v}_{k} \sim \mathcal{N}\left(\mathbf{0}, \boldsymbol{Q}_{k, j}\right)\tag{3}</script><p>其中$\boldsymbol{R}_{k}, \boldsymbol{Q}_{k, j}$ 为协方差矩阵。<strong>因此我们希望从这些含噪声的数据 $\boldsymbol{z}$和 $\boldsymbol u$ 中，可以推断出位姿 $\boldsymbol{x}$ 和路标点 $\boldsymbol{y}$ ，这构成了一个状态估计问题。</strong></p>
<p>下面我们将以批量处理的方法，即考虑全部时刻的状态，来进行状态估计的推导。</p>
<p>考虑从 1 到 N 的所有时刻，并假设有 M 个路标点，定义所有时刻机器人位姿和路标点的坐标为：</p>
<script type="math/tex; mode=display">
\boldsymbol{x}=\left\{\boldsymbol{x}_{1}, \ldots, \boldsymbol{x}_{N}\right\}, \quad \boldsymbol{y}=\left\{\boldsymbol{y}_{1}, \ldots, \boldsymbol{y}_{M}\right\}</script><p>用不带下标的  $\boldsymbol{u}$ 和 $\boldsymbol{z}$ 表示所有时刻的输入和观测数据，所以状态估计的概率表示为：</p>
<script type="math/tex; mode=display">
P(\boldsymbol{x}, \boldsymbol{y} \mid \boldsymbol{z}, \boldsymbol{u})\tag{4}</script><p>也就是在已知输入数据和观测数据 $\boldsymbol{u}$ 和 $\boldsymbol{z}$ 的情况下，求状态 $\boldsymbol x$ 和 $\boldsymbol{y}$ 的条件概率分布。</p>
<blockquote>
<p>这里的输入 $\boldsymbol u$ 在视觉SLAM中，要根据实际情况而定，如果有其他传感器可以测出，我们就可以得到。但是如果没有额外的传感器，那么这里的 $\boldsymbol u$ 实际上也是一个观测量，可以由前端计算出来。</p>
</blockquote>
<p>这里利用<strong>贝叶斯法则</strong>，有：</p>
<script type="math/tex; mode=display">
P(\boldsymbol{x}, \boldsymbol{y} \mid \boldsymbol{z}, \boldsymbol{u})=\frac{P(\boldsymbol{z}, \boldsymbol{u} \mid \boldsymbol{x}, \boldsymbol{y}) P(\boldsymbol{x}, \boldsymbol{y})}{P(\boldsymbol{z}, \boldsymbol{u})}\tag{5}</script><p>这里的状态 $\boldsymbol x$ 和 $\boldsymbol{y}$ 是要估计出来的参数，式（5）左侧称为状态 $\boldsymbol x$ 和 $\boldsymbol{y}$ 的后验概率，我们要求得它们的概率分布是很困难的，但是求出 $\boldsymbol x$ 和 $\boldsymbol{y}$ 取多少时概率最大则是可以的。所以左边最大等于右边最大，右边的分母是取得当前观测值的概率，是一个常数，因此在最大化的过程中可以省略。而 $P(\boldsymbol{x},\boldsymbol{y})$ 表示先验概率，实际上我们可以认为 $\boldsymbol x$ 和 $\boldsymbol{y}$ 是一个确定的值，只不过这个值我们不知道是多大而已，因此可以认为$P(\boldsymbol{x},\boldsymbol{y})=1$ 。</p>
<p>现在只剩下最后一项为 $P(\boldsymbol{z}, \boldsymbol{u} \mid \boldsymbol{x}, \boldsymbol{y})$ ，这一项叫做似然概率，即表示在当前状态  $\boldsymbol x$ 和 $\boldsymbol{y}$  下，观测量 $\boldsymbol{u}$ 和 $\boldsymbol{z}$ 的概率分布，我们已经知道 $\boldsymbol{u}$ 和 $\boldsymbol{z}$ 的具体数值，因此 $P(\boldsymbol{z}, \boldsymbol{u} \mid \boldsymbol{x}, \boldsymbol{y})$ 是关于状态量  $\boldsymbol x$ 和 $\boldsymbol{y}$  的函数，因此有让左边最大等价于让这个函数的取值最大：</p>
<script type="math/tex; mode=display">
(\boldsymbol{x}, \boldsymbol{y})^{*}{ }_{\mathrm{MLE}}=\arg \max P(\boldsymbol{z}, \boldsymbol{u} \mid \boldsymbol{x}, \boldsymbol{y})\tag{6}</script><p>式（6）就是最大似然估计。该式我们可以理解为，<strong>在什么样的状态下，最可能产生现在观测到的数据。</strong></p>
<h2 id="II-最小二乘的引出"><a href="#II-最小二乘的引出" class="headerlink" title="II. 最小二乘的引出"></a>II. 最小二乘的引出</h2><p>在确立了用最大似然估计来估计出相机或机器人的位置和路标点位置后，我们来讨论如何进行最大似然估计呢。</p>
<p><strong>在某一位置，对某一路标点</strong>的观测方程：</p>
<script type="math/tex; mode=display">
\boldsymbol{z}_{k, j}=h\left(\boldsymbol{y}_{j}, \boldsymbol{x}_{k}\right)+\boldsymbol{v}_{k, j}\tag{7}</script><p>这里的噪声项$\boldsymbol{v}_{k} \sim \mathcal{N}\left(\mathbf{0}, \boldsymbol{Q}_{k, j}\right)<br>$为高斯分布，所以观测数据的条件概率为：</p>
<script type="math/tex; mode=display">
P\left(\boldsymbol{z}_{j, k} \mid \boldsymbol{x}_{k}, \boldsymbol{y}_{j}\right)=N\left(h\left(\boldsymbol{y}_{j}, \boldsymbol{x}_{k}\right), \boldsymbol{Q}_{k, j}\right)\tag{8}</script><p>所以观测数据依然符合高斯分布。</p>
<p>我们可以<strong>最小化负对数</strong>来求一个高斯分布的最大似然，现有任意高维高斯分布$\boldsymbol{x} \sim \mathcal{N}(\boldsymbol{\mu}, \boldsymbol{\Sigma})$ ，它的<strong>概率密度函数</strong>展开形式为：</p>
<script type="math/tex; mode=display">
P(\boldsymbol{x})=\frac{1}{\sqrt{(2 \pi)^{N} \operatorname{det}(\boldsymbol{\Sigma})}} \exp \left(-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{\mathrm{T}} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right)\tag{9}</script><p>对其取负对数，变为：</p>
<script type="math/tex; mode=display">
-\ln (P(\boldsymbol{x}))=\frac{1}{2} \ln \left((2 \pi)^{N} \operatorname{det}(\boldsymbol{\Sigma})\right)+\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{\mathrm{T}} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\tag{10}</script><p>因为对数函数是单调递增的，所以<strong>对原函数求最大化相当于对负对数求最小化</strong>。第一项与 $\boldsymbol x$ 无关，可以略去。<strong>于是只要最小化右侧的二次型项，就得到了对状态的最大似然估计</strong>，代入SLAM的观测模型，相当于求：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left(\boldsymbol{x}_{k}, \boldsymbol{y}_{j}\right)^{*} &=\arg \max \mathcal{N}\left(h\left(\boldsymbol{y}_{j}, \boldsymbol{x}_{k}\right), \boldsymbol{Q}_{k, j}\right) \\
&=\arg \min \left(\left(\boldsymbol{z}_{k, j}-h\left(\boldsymbol{x}_{k}, \boldsymbol{y}_{j}\right)\right)^{\mathrm{T}} \boldsymbol{Q}_{k, j}^{-1}\left(\boldsymbol{z}_{k, j}-h\left(\boldsymbol{x}_{k}, \boldsymbol{y}_{j}\right)\right)\right)
\end{aligned} \tag{11}</script><blockquote>
<p>我们发现，该式等价于最小化噪声项的二次型。这个二次型称为马哈拉诺比斯距离，又叫马氏距离。他可以看成由 $\boldsymbol{Q}_{k, j}^{-1}$ 加权之后的欧氏距离，$\boldsymbol{Q}_{k, j}^{-1}$ 称为信息矩阵，即高斯分布协方差矩阵之逆。</p>
</blockquote>
<p>如式（11）所示，我们就是通过找到合适的 $\boldsymbol{x}_k$ 和 $\boldsymbol{y}_j$ ，来使上述值最小。</p>
<p>同样，我们考虑<strong>批量时刻</strong>的数据。通常假设各个时刻的输入和观测是相互独立的，这意味着各个输入之间是独立的，各个观测之间是独立的，并且输入和观测也是独立的。于是我们可以对联合分布进行因式分解：</p>
<script type="math/tex; mode=display">
P(\boldsymbol{z}, \boldsymbol{u} \mid \boldsymbol{x}, \boldsymbol{y})=\prod_{k} P\left(\boldsymbol{u}_{k} \mid \boldsymbol{x}_{k-1}, \boldsymbol{x}_{k}\right) \prod_{k, j} P\left(\boldsymbol{z}_{k, j} \mid \boldsymbol{x}_{k}, \boldsymbol{y}_{j}\right)\tag{12}</script><p>这说明我们可以独立的处理各时刻的运动和观测，定义各个时刻的输入和观测数据与模型之间的误差：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{e}_{\boldsymbol{u}, k} &=\boldsymbol{x}_{k}-f\left(\boldsymbol{x}_{k-1}, \boldsymbol{u}_{k}\right) \\
\boldsymbol{e}_{\boldsymbol{z}, j, k} &=\boldsymbol{z}_{k, j}-h\left(\boldsymbol{x}_{k}, \boldsymbol{y}_{j}\right)
\end{aligned}\tag{13}</script><p>那么最小化所有时刻估计值与真实读数之间的马氏距离，等价于求最大似然估计，负对数将乘积变成求和：</p>
<script type="math/tex; mode=display">
\min J(\boldsymbol{x}, \boldsymbol{y})=\sum_{k} e_{\boldsymbol{u}, k}^{\mathrm{T}} \boldsymbol{R}_{k}^{-1} e_{\boldsymbol{u}, k}+\sum_{k} \sum_{j} e_{\boldsymbol{z}, k, j}^{\mathrm{T}} \boldsymbol{Q}_{k, j}^{-1} \boldsymbol{e}_{\boldsymbol{z}, k, j}\tag{14}</script><p>这样就得到了一个<strong>最小二乘问题</strong>，它等价于状态的最大似然估计。由于噪声的存在，我们把估计的轨迹和地图带入到SLAM的运动和观测方程中，并不会完美的成立，所以我们要对轨迹和地图进行微调，使整体的误差下降一些。当然这个下降也是有限的，一般会达到一个极小值，这就是一个典型的非线性优化的过程。</p>
<p>式（14）可以代表着SLAM中最小二乘问题具有一些特定的结构：</p>
<ul>
<li>尽管优化变量的维度很高（因为有许多的位置点和路标点），但是要注意，每个观测误差都很简单，仅与一两个状态变量有关。例如运动误差仅与 $\boldsymbol{x_{k-1},x_k}$ 有关，观测误差仅与 $\boldsymbol{x_k,y_j}$ 有关，这种关系会让整个问题有一种稀疏的形式。</li>
<li>如果用李代数表示增量，则该问题是无约束的最小二乘问题。</li>
</ul>
<h2 id="III-非线性最小二乘"><a href="#III-非线性最小二乘" class="headerlink" title="III. 非线性最小二乘"></a>III. 非线性最小二乘</h2><p>我们建立好了代价函数，如何来优化呢？本节就来讨论具体的优化方法。</p>
<p>一个简单的最小二乘问题：</p>
<script type="math/tex; mode=display">
\min _{\boldsymbol{x}} F(\boldsymbol{x})=\frac{1}{2}\sum\|f_i(\boldsymbol{x})\|_{2}^{2}\tag{15}</script><p>其中自变量 $\boldsymbol{x} \in \mathbb{R}^{n}$ ，<strong>$|f_i|^2$ 是任意标量非线性函数 $|f_i(x)|^2: \mathbb{R}^{n} \mapsto \mathbb{R}$ ，它描述每一个观测数据 $i$ 与要估计值间的误差。</strong></p>
<blockquote>
<p>对于视觉SLAM中，式（15）对应的公式是式（14），这里$\boldsymbol f_i(\boldsymbol{x})=\boldsymbol{e}$ ，$|f_i(\boldsymbol{x})|_{2}^{2}=\boldsymbol{e}^TR^{-1}{\boldsymbol e}$ ，这里的 $R^{-1}$ 表示信息矩阵。</p>
</blockquote>
<p>如果 $f_i$ 是个数学形式很简单的函数，那么该问题可以用解析形式来求。令目标函数的导数为零，然后求解 $\boldsymbol {x}$ 的最优值，和求解二元函数的极值一样，即：</p>
<script type="math/tex; mode=display">
\frac{\mathrm{d} F}{\mathrm{~d} \boldsymbol{x}}=\mathbf{0}\tag{16}</script><p>解此方程，得到了导数为0的点，它可能是极大值、极小值或鞍点处的值，只需要逐个比较它们的函数大小即可。<strong>当 $f$ 为简单的线性函数，那么这个问题就是简单的线性最小二乘问题。</strong>但如果 $f$ 的形式复杂，使得该方程不能直接求解，此时我们使用<strong>迭代</strong>的方法，从一个初值出发，不断地更新当前的优化变量，使目标函数下降。</p>
<p>具体步骤：</p>
<ol>
<li>给定某个初始值 $\boldsymbol {x}_0$ </li>
<li>对于第 $k$ 次迭代，寻找一个增量 $\Delta\boldsymbol{x}_k$ ，使得 $\sum\left|f_i\left(\boldsymbol{x}_{k}+\Delta \boldsymbol{x}_{k}\right)\right|_{2}^{2}$ 达到极小值</li>
<li>若 $\Delta\boldsymbol{x}_k$ 足够小，则停止</li>
<li>否则，令 $\boldsymbol{x}_{k+1}=\boldsymbol{x}_k+\Delta\boldsymbol{x}_k$ ，然后返回第二步</li>
<li></li>
</ol>
<blockquote>
<p>该方法就是不断寻找让代价函数变小的增量 $\Delta\boldsymbol{x}_k$ ，由于可以对 $f$ 进行线性化，增量的计算将简单很多。当函数下降直到增量非常小的时候，可以认为算法收敛。</p>
</blockquote>
<p><strong>找到增量是一个局部问题，我们只需要关心函数 $f$ 在迭代处的局部性质即可。</strong></p>
<h3 id="1-一阶和二阶梯度法"><a href="#1-一阶和二阶梯度法" class="headerlink" title="1. 一阶和二阶梯度法"></a>1. 一阶和二阶梯度法</h3><h4 id="1-最速下降法（一阶梯度）"><a href="#1-最速下降法（一阶梯度）" class="headerlink" title="(1)最速下降法（一阶梯度）"></a>(1)最速下降法（一阶梯度）</h4><p>现在考虑第 $k$ 次迭代，假设我们在 $\boldsymbol{x}_k$ 处，想要寻找增量$\Delta\boldsymbol{x}_k$ ，<strong>那么最直观的方法就是将代价函数在  $\boldsymbol{x}_k$ 处进行泰勒展开</strong>：</p>
<script type="math/tex; mode=display">
F\left(\boldsymbol{x}_{k}+\Delta \boldsymbol{x}_{k}\right) \approx F\left(\boldsymbol{x}_{k}\right)+\boldsymbol{J}\left(\boldsymbol{x}_{k}\right)^{\mathrm{T}} \Delta \boldsymbol{x}_{k}+\frac{1}{2} \Delta \boldsymbol{x}_{k}^{\mathrm{T}} \boldsymbol{H}\left(\boldsymbol{x}_{k}\right) \Delta \boldsymbol{x}_{k}\tag{17}</script><p>这里的 $\boldsymbol{J}(\boldsymbol{x}_{k})$ 是 $F\left(\boldsymbol{x}_{k}\right)$ 关于 $\boldsymbol{x}$ 的一阶导数，也叫雅可比矩阵（表示梯度），$\boldsymbol{H}\left(\boldsymbol{x}_{k}\right) $ 则是二阶导数，称为海塞矩阵。<strong>如果仅保留一阶梯度</strong>，那么取增量为反向梯度，即可保证函数下降，即：</p>
<script type="math/tex; mode=display">
\Delta \boldsymbol{x}^{*}=-\boldsymbol{J}\left(\boldsymbol{x}_{k}\right)\tag{18}</script><p>现在的 $\Delta \boldsymbol{x}$ 还仅是一个方向，我们还要指定一个步长 $\lambda$ 。这种方法称为<strong>最速下降法</strong>。</p>
<h4 id="2-牛顿法（二阶梯度）"><a href="#2-牛顿法（二阶梯度）" class="headerlink" title="(2)牛顿法（二阶梯度）"></a>(2)牛顿法（二阶梯度）</h4><p>我们每次讨论的都是第 $k$ 次迭代，为了简化，省略下标 $k$ 。 另外我们还可以保留二阶梯度信息，此时的增量方程为：</p>
<script type="math/tex; mode=display">
\Delta \boldsymbol{x}^{*}=\arg \min \left(F(\boldsymbol{x})+\boldsymbol{J}(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}+\frac{1}{2} \Delta \boldsymbol{x}^{\mathrm{T}} \boldsymbol{H} \Delta \boldsymbol{x}\right)\tag{19}</script><p>即找到一个 $\Delta\boldsymbol{x}_k$ ，让泰勒展开后近似的 $F(\boldsymbol{x}_k+\Delta\boldsymbol{x}_k)$ 最小。我们可以令式（19）对 $\Delta\boldsymbol{x}_k$ 求导，并令其为0，得到：</p>
<script type="math/tex; mode=display">
\boldsymbol{J}+\boldsymbol{H} \Delta \boldsymbol{x}=\mathbf{0} \Rightarrow \boldsymbol{H} \Delta \boldsymbol{x}=-\boldsymbol{J}\tag{20}</script><p>求解这个线性方程，即可得到增量 $\Delta\boldsymbol{x}_k$ ，该方法称为牛顿法。</p>
<p><strong>总结：</strong></p>
<p>一阶和二阶梯度方法实际上就是对原代价函数进行泰勒展开，用一个一次或二次的函数近似原函数，然后用近似函数的最小值来猜测原函数的极小值。但这类方法也有一定的问题，一个是最速下降方法过于贪心，容易走出锯齿路线，反而增加了迭代次数。而牛顿法需要计算代价函数的 $H$ 矩阵，这在问题规模较大时非常困难计算出来。</p>
<h3 id="2-高斯牛顿法"><a href="#2-高斯牛顿法" class="headerlink" title="2. 高斯牛顿法"></a>2. 高斯牛顿法</h3><p>为了避免计算 $H$ 矩阵，采用高斯牛顿法。它的思想就是将 $f_i(x)$ 进行一阶泰勒展开：</p>
<script type="math/tex; mode=display">
f_i(\boldsymbol{x}+\Delta \boldsymbol{x}) \approx f_i(\boldsymbol{x})+\boldsymbol{J}_i(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}\tag{21}</script><p>这里的 $J_i(\boldsymbol x)^T$ 为 $f_i(\boldsymbol x)$ 关于 $\boldsymbol x$ 的导数，为 $n\times 1$ 的列向量。</p>
<p><strong>现在的目标是寻找 $\Delta\boldsymbol x$ 使得 $\sum|f_i(\boldsymbol{x}+\Delta \boldsymbol{x})|^{2}$ 达到最小。</strong> 为了找到这个增量，我们知道这个增量可以使线性化后的代价函数最小，所以有：</p>
<script type="math/tex; mode=display">
\Delta \boldsymbol{x}^{*}=\arg \min _{\Delta \boldsymbol{x}} F(\boldsymbol x)=\arg \min _{\Delta \boldsymbol{x}} \frac{1}{2}\sum\left\|f_i(\boldsymbol{x})+\boldsymbol{J}_i(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}\right\|^{2}\tag{22}</script><p>我们使式（22）右边的平方项展开，得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{1}{2}\left\|f_i(\boldsymbol{x})+\boldsymbol{J_i}(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}\right\|^{2} &=\frac{1}{2}\left(f_i(\boldsymbol{x})+\boldsymbol{J}_i(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}\right)^{\mathrm{T}}{R}_i^{-1}\left(f_i(\boldsymbol{x})+\boldsymbol{J}_i(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}\right) \\
&=\frac{1}{2}\left(\|f_i(\boldsymbol{x})\|_{2}^{2}+2\boldsymbol{J}_i(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}{R}_i^{-1}f_i(\boldsymbol{x})+\Delta \boldsymbol{x}^{\mathrm{T}} \boldsymbol{J}_i(\boldsymbol{x}) {R}_i^{-1}\boldsymbol{J}_i(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}\right)
\end{aligned}\tag{23}</script><p><strong>注意：</strong> 这里的 $R_i^{-1}$ 为信息矩阵，也就是噪声的协方差矩阵，它在估计前已经确定，和噪声项有关。</p>
<p>令式（23）对 $\Delta\boldsymbol x$ 求导并令其为零：</p>
<script type="math/tex; mode=display">
\sum\left[\boldsymbol{J}_i(\boldsymbol{x})R_i^{-1} f_i(\boldsymbol{x})+\boldsymbol{J}_i(\boldsymbol{x}) R_i^{-1}\boldsymbol{J}_i^{\mathrm{T}}(\boldsymbol{x}) \Delta \boldsymbol{x}\right]=\mathbf{0}\tag{24}</script><p>可以得到如下方程组：</p>
<script type="math/tex; mode=display">
\underbrace{\sum\boldsymbol{J}_i(\boldsymbol{x})R_i^{-1} \boldsymbol{J}_i^{\mathrm{T}}(\boldsymbol{x})}_{\boldsymbol{H}(\boldsymbol{x})} \Delta \boldsymbol{x}=\underbrace{-\sum\boldsymbol{J}_i(\boldsymbol{x})R_i^{-1}f_i(\boldsymbol{x})}_{\boldsymbol{g}(\boldsymbol{x})}\tag{25}</script><p>这个方程是关于变量 $\Delta\boldsymbol x$ 的线性方程组，我们称为<strong>增量方程</strong>，也可以称为高<strong>斯牛顿方程</strong>（Gauss-Newton equation）或<strong>正规方程</strong>（Normal equation）。</p>
<p>式（25）中，把左边的系数部分定义为 $H$ ，右边定义为 $\boldsymbol{g}$ ，则式（25）变为：</p>
<script type="math/tex; mode=display">
\boldsymbol{H} \Delta \boldsymbol{x}=\boldsymbol{g}\tag{26}</script><p><strong>这里把左边记为 $H$ 是有意义的，对比牛顿法可见，高斯牛顿法是用 $\sum\boldsymbol{J}\boldsymbol{J}^{\mathrm{T}}$ 来作为牛顿法中的二阶海塞矩阵的近似。</strong>从而省略了 $H$ 矩阵的计算过程。</p>
<p>那么高斯牛顿法的算法步骤为：</p>
<ol>
<li>给定初始值 $\boldsymbol {x}_0$ </li>
<li>对于第 $k$ 次迭代，求出当前的雅可比矩阵 $J_i(\boldsymbol{x}_k)$ 和误差 $f_i(\boldsymbol{x}_k)$ </li>
<li>求解增量方程 $\boldsymbol{H} \Delta \boldsymbol{x}=\boldsymbol{g}$</li>
<li><p>若 $\Delta\boldsymbol{x}_k$ 足够小，则停止。否则，令 $\boldsymbol{x}_{k+1}=\boldsymbol{x}_k+\Delta\boldsymbol{x}_k$ ，然后返回第二步</p>
<p><strong>注意：</strong></p>
</li>
</ol>
<p>为了求解增量方程，我们需要求解 $H^{-1}$ ，但实际中计算得到的 $\sum \boldsymbol{J}\boldsymbol{J}^{\mathrm{T}}$ 只有半正定性。因此 $\sum \boldsymbol{J}\boldsymbol{J}^{\mathrm{T}}$ 可能为奇异矩阵或者病态的情况，此时增量的稳定性较差，导致算法不收敛。直观地说，原函数在这个点的局部近似不像一个二次函数，更重要的是即使 $H$ 非奇异也非病态，如果求出的步长太大，也会导致我们局部近似不够准确，这样一来我们无法保证它迭代收敛。</p>
<p>在一些算法中，为了保证合适的步长，采用一些其他的方法，例如<strong>线搜索法</strong>，加入了一个步长 $\alpha$ ，在确定了 $\Delta\boldsymbol{x}$ 后，还要找到一个合适的 $\alpha$ 使 $\sum |f_i(x+\alpha \Delta x)|^{2}$ 最小。</p>
<h3 id="3-列文伯格—马夸尔特法"><a href="#3-列文伯格—马夸尔特法" class="headerlink" title="3. 列文伯格—马夸尔特法"></a>3. 列文伯格—马夸尔特法</h3><p>列文伯格—马夸尔特是建立在高斯牛顿法的基础上，该方法也叫作<strong>阻尼牛顿法</strong> ，它的主要思想是，给 $\Delta\boldsymbol{x}$ 添加了一个范围，称为<strong>信赖区间</strong> 。<strong>这个范围定义了在什么情况下二阶近似是有效的。</strong> 在这个区域里，我们认为近似是有效的，除了这个区域，近似可能会出问题。</p>
<p>我们<strong>通过近似模型和实际函数之间的差异来确定区域的范围。</strong>如果差异小，说明近似效果好，我们扩大近似的范围。反之如果差异大，就缩小范围，我们定义了一个指标 $\rho$ 来刻画近似的好坏程度：</p>
<script type="math/tex; mode=display">
\rho=\frac{\sum \left[f_i(\boldsymbol{x}+\Delta \boldsymbol{x})-f_i(\boldsymbol{x})\right]}{\sum\boldsymbol{J}_i(\boldsymbol{x})^{\mathrm{T}} \Delta \boldsymbol{x}}\tag{27}</script><p>$\rho$ 的分子是实际函数下降的值，分母是近似模型下降的值。如果 $\rho$ 接近于1，则近似是好的。<strong>如果 $\rho$ 太小</strong>，则说明实际下降的值远小于近似模型下降的值，则认为近似比较差，<strong>需要缩小范围</strong>。相反，如果 $\rho$ 太大，则说明近似模型下降的少，而实际函数下降的大，这是件好事，所以我们可以放大近似范围。</p>
<p>所以该算法的步骤为：</p>
<ol>
<li><p>给定初始值 $\boldsymbol {x}_0$ ，以及初始优化半径 $µ$ </p>
</li>
<li><p>对于第 $k$ 次迭代，在高斯牛顿法的基础上（先求当前的雅可比矩阵 $J(\boldsymbol{x}_k)$ 和误差 $f(\boldsymbol{x}_k)$ ），加上信赖区域，求解增量：</p>
<script type="math/tex; mode=display">
\min _{\Delta \boldsymbol{x}_{k}} \frac{1}{2}\sum\left\|f_i\left(\boldsymbol{x}_{k}\right)+\boldsymbol{J}_i\left(\boldsymbol{x}_{k}\right)^{\mathrm{T}} \Delta \boldsymbol{x}_{k}\right\|^{2}, \quad \text { s.t. } \quad\left\|\boldsymbol{D} \Delta \boldsymbol{x}_{k}\right\|^{2} \leqslant \mu\tag{28}</script></li>
</ol>
<p>​       这里的 $D$ 是系数矩阵，$µ$ 是信赖区域半径</p>
<ol>
<li>计算 $\rho$</li>
<li>若 $\rho&gt;\frac{3}{4}$, 则设置 $\mu=2 \mu$ </li>
<li>若$\rho&lt;\frac{1}{4}$, 则设置 $\mu=0.5 \mu$</li>
<li>如果 $\rho $ 大于某阈值, 则认为近似可行。令 $x_{k+1}=x_{k}+\Delta x_{k}$</li>
<li>判断算法是否收敛，如不收敛则返回第2步，否则结束</li>
</ol>
<p><strong>注意：</strong></p>
<p>这里近似范围扩大的倍数和阈值都是经验值，可以替换成别的。在式（28）中，我们把增量限制于一个半径为 $µ$ 的球中，带上 $D$ 之后，这个球可以看成一个椭球。列文伯格提出的优化方法中，$D=I$ ，相当于把增量 $\Delta\boldsymbol{x}$ 约束在一个球内；而马夸尔特提出 $D$ 取非负数对角阵，实际中通常用 $J^TJ$ 的对角元素平方根。</p>
<p>在式（28）中，我们要求解一个带不等式约束的优化问题，我们用拉格朗日乘子把约束项放到代价函数中，构成拉格朗日函数：</p>
<script type="math/tex; mode=display">
\mathcal{L}\left(\Delta \boldsymbol{x}_{k}, \lambda\right)=\frac{1}{2}\sum\left\|f_i\left(\boldsymbol{x}_{k}\right)+\boldsymbol{J}_i\left(\boldsymbol{x}_{k}\right)^{\mathrm{T}} \Delta \boldsymbol{x}_{k}\right\|^{2}+\frac{\lambda}{2}\left(\left\|\boldsymbol{D} \Delta \boldsymbol{x}_{k}\right\|^{2}-\mu\right)\tag{29}</script><p>令式（29）对  $\Delta\boldsymbol{x}$ 求导并等于0，得到：</p>
<script type="math/tex; mode=display">
\left(\boldsymbol{H}+\lambda \boldsymbol{D}^{\mathrm{T}} \boldsymbol{D}\right) \Delta \boldsymbol{x}_{k}=\boldsymbol{g}\tag{30}</script><p>可以看到，相比于高斯牛顿法，增量方程多了一项 $\lambda \boldsymbol{D}^{T} \boldsymbol{D}$ ，如果考虑简化形式，即 $D=I$ ，那么式（30）可以写为：</p>
<script type="math/tex; mode=display">
(\boldsymbol{H}+\lambda \boldsymbol{I}) \Delta \boldsymbol{x}_{k}=\boldsymbol{g}\tag{31}</script><p>我们看到一方面, <strong>当参数 $\lambda$ 比较小时</strong>, $\boldsymbol{H}$ 占主要地位, 这说明二次近似模型在该范围内是比较好的, <strong>列文伯格一马夸尔特方法更接近于高斯牛顿法</strong>。另一方面, <strong>当 $\lambda$ 比较大时</strong>, $\lambda \boldsymbol{I}$ 占据主要地位, <strong>列文伯格一马夸尔特方法更接近于一阶梯度下降法 (即最速下降),</strong> 这说明附近的二次近似不够好。列文伯格一马夸尔特方法的求解方式, 可在一定程度上避免线性方程组的系数矩阵的奇异和病态问题，提供更稳定、更准确的增量 $\Delta \boldsymbol{x}$ 。</p>
<h2 id="IV-总结"><a href="#IV-总结" class="headerlink" title="IV. 总结"></a>IV. 总结</h2><ol>
<li>在批量法求得SLAM中的状态变量时，使用最大似然估计，<strong>该方法最终转化为一个最小二乘问题</strong>。其代价函数是由误差项（包括实际观测值与观测方程计算求得的观测量的差，和实际运动量与运动方程计算出来的运动值的差）和协方差矩阵（观测协方差矩阵和运动协方差矩阵）组成。</li>
<li>在非线性优化时，可以直接将代价函数进行泰勒展开，利用泰勒展开来近似在某一点处的代价函数，从而可以求出增量。但是仅用一阶项（最速下降法）来求会导致算法更加贪心，反复震荡。而考虑二阶项的方法称为牛顿法，需要求海塞矩阵，这是很难求的。</li>
<li>使用高斯牛顿法，就是用 $f$ 函数（注意不是 $F$ 函数）的一阶梯度来近似二阶的海塞矩阵。但是这里要求近似出来的海塞矩阵的逆，这个矩阵是半正定的，所以有时候没有逆，会造成算法失效。而且，即使近似的海塞矩阵有逆，也不能说明近似模型近似的好，有可能效果很差。为了解决这一问题，在高斯牛顿算法的基础上，提出列文伯格—马夸尔特方法。</li>
<li>列文伯格—马夸尔特方法就是在求解增量时，给增量限定在一定的范围内，然后看近似的效果，如果好就放大这个增量的范围。</li>
<li>求解增量的方程是线性方程，我们需要求矩阵的逆来解这个方程，但是由于增量 $\Delta x$ 的维度特别大（通常是成百上千，或是几十万），所以直接求逆是不现实的，我们可以采用矩阵分解的方式（如QR分解，Cholesky分解等）来求解线性方程。</li>
<li>系数矩阵（雅可比矩阵）是稀疏的，这位优化问题提供了可能性。如果是稠密的，视觉SLAM可能就没有发展的必要了。</li>
<li>我们发现，在做优化之前，都需要提供变量的初值，这不是随意给的，一个良好的初值是十分重要的。<strong>不同的初始值可能会有不同的结果。</strong>在视觉SLAM中，我们会用前端算法（如ICP，PnP算法）提供优化的初始值。事实上，这些前端算法也需要优化的方法来求解，然后得到后端优化的初始值，然后再进行优化。</li>
</ol>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM9】Ceres库</title>
    <url>/2022/07/25/%E3%80%90%E8%A7%86%E8%A7%89SLAM9%E3%80%91Ceres%E5%BA%93/</url>
    <content><![CDATA[<p>Ceres是一个广泛使用的最小二乘问题求解库。我们只需按照一定步骤定义待解的优化问题，然后交给求解器计算。</p>
<span id="more"></span>
<p>Ceres求解的最小二乘问题最一般形式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min _{x} \frac{1}{2} \sum_{i} \rho_{i}\left(\left\|f_{i}\left(x_{i_{1}}, \cdots, x_{i_{n}}\right)\right\|^{2}\right) \\
&\text { s.t. } l_{j} \leqslant x_{j} \leqslant u_{j} .
\end{aligned}</script><p>这里有以下一些定义：</p>
<ul>
<li>参数块：也就是优化变量 $x_{1}, \cdots, x_{n}$ </li>
<li>残差块：也就是代价函数 $f_i$</li>
<li>$l_j$ 和 $u_j$ 为第 $j$ 个优化变量的上限和下限</li>
<li>核函数 $\rho_j$ ，代价函数由许多平方项经过一个核函数之后求和组成</li>
</ul>
<p>我们要做的：</p>
<ol>
<li>定义每个参数块：参数块通常为平凡的向量，但是在SLAM中也可以定义为四元数、李代数这种特殊结构，如果是向量，我们为每个参数块分配一个double数组来存储变量的值</li>
<li>定义残差块：残差块通常关联若干参数块，对它们进行一些定义的计算，然后返回残差值，Ceres对它们求平方和之后，作为代价函数的值</li>
<li>定义雅可比矩阵的计算方式。可以设置自动求导，也可以手动求导。</li>
<li>把所有参数块和残差块加入Ceres定义的Problem对象中，调用Solve函数求解，求解之前我们可以设置一些配置信息。</li>
</ol>
<h2 id="I-例子"><a href="#I-例子" class="headerlink" title="I. 例子"></a>I. 例子</h2><p>一条曲线方程为：</p>
<script type="math/tex; mode=display">
y=\exp \left(a x^{2}+b x+c\right)+w</script><p>我们现在要估计 $a,b,c$ ，$w$ 为噪声项，满足 $w \sim\left(0, \sigma^{2}\right)$ 。现在我们有 $N$ 个关于 $x,y$ 的观测数据点，想根据这些点来求出曲线的参数。那么可以转化成最小二乘问题：</p>
<script type="math/tex; mode=display">
\min _{a, b, c} \frac{1}{2} \sum_{i=1}^{N}\left\|y_{i}-\exp \left(a x_{i}^{2}+b x_{i}+c\right)\right\|^{2}</script><p>这里带估计的变量就是 $a,b,c$ ，定义误差为：</p>
<script type="math/tex; mode=display">
e_{i}=y_{i}-\exp \left(a x_{i}^{2}+b x_{i}+c\right)</script><p>求出每个误差项对状态变量的导数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\frac{\partial e_{i}}{\partial a}=-x_{i}^{2} \exp \left(a x_{i}^{2}+b x_{i}+c\right) \\
&\frac{\partial e_{i}}{\partial b}=-x_{i} \exp \left(a x_{i}^{2}+b x_{i}+c\right) \\
&\frac{\partial e_{i}}{\partial c}=-\exp \left(a x_{i}^{2}+b x_{i}+c\right)
\end{aligned}</script><p>于是 $\boldsymbol{J}_{i}=\left[\frac{\partial e_{i}}{\partial a}, \frac{\partial e_{i}}{\partial b}, \frac{\partial e_{i}}{\partial c}\right]^{\mathrm{T}}$, 高斯牛顿法的增量方程为</p>
<script type="math/tex; mode=display">
\left(\sum_{i=1}^{100} \boldsymbol{J}_{i}\left(\sigma^{2}\right)^{-1} \boldsymbol{J}_{i}^{\mathrm{T}}\right) \Delta \boldsymbol{x}_{k}=\sum_{i=1}^{100}-\boldsymbol{J}_{i}\left(\sigma^{2}\right)^{-1} e_{i}</script><p>代码：</p>
<p><code>slambook2/ch6/ceresCurveFitting</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">`<span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by xiang on 18-11-19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代价函数的计算模型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CURVE_FITTING_COST</span> &#123;</span></span><br><span class="line">  <span class="built_in">CURVE_FITTING_COST</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 残差的计算</span></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> T *<span class="keyword">const</span> abc, <span class="comment">// 模型参数，有3维</span></span></span></span><br><span class="line"><span class="params"><span class="function">    T *residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    residual[<span class="number">0</span>] = <span class="built_in">T</span>(_y) - ceres::<span class="built_in">exp</span>(abc[<span class="number">0</span>] * <span class="built_in">T</span>(_x) * <span class="built_in">T</span>(_x) + abc[<span class="number">1</span>] * <span class="built_in">T</span>(_x) + abc[<span class="number">2</span>]); <span class="comment">// y-exp(ax^2+bx+c)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> _x, _y;    <span class="comment">// x,y数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;         <span class="comment">// 真实参数值</span></span><br><span class="line">  <span class="keyword">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;        <span class="comment">// 估计参数值</span></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">100</span>;                                 <span class="comment">// 数据点</span></span><br><span class="line">  <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;                        <span class="comment">// 噪声Sigma值</span></span><br><span class="line">  <span class="keyword">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">  cv::RNG rng;                                 <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">double</span>&gt; x_data, y_data;      <span class="comment">// 数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">    x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">    y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.<span class="built_in">gaussian</span>(w_sigma * w_sigma));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> abc[<span class="number">3</span>] = &#123;ae, be, ce&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建最小二乘问题</span></span><br><span class="line">  ceres::Problem problem;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(     <span class="comment">// 向问题中添加误差项</span></span><br><span class="line">      <span class="comment">// 使用自动求导，模板参数：误差类型，输出维度，输入维度，维数要与前面struct中一致</span></span><br><span class="line">      <span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;CURVE_FITTING_COST, <span class="number">1</span>, <span class="number">3</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">CURVE_FITTING_COST</span>(x_data[i], y_data[i])</span><br><span class="line">      ),</span><br><span class="line">      <span class="literal">nullptr</span>,            <span class="comment">// 核函数，这里不使用，为空</span></span><br><span class="line">      abc                 <span class="comment">// 待估计参数</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置求解器</span></span><br><span class="line">  ceres::Solver::Options options;     <span class="comment">// 这里有很多配置项可以填</span></span><br><span class="line">  options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;  <span class="comment">// 增量方程如何求解</span></span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;   <span class="comment">// 输出到cout</span></span><br><span class="line"></span><br><span class="line">  ceres::Solver::Summary summary;                <span class="comment">// 优化信息</span></span><br><span class="line">  chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  ceres::<span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);  <span class="comment">// 开始优化</span></span><br><span class="line">  chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;solve time cost = &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds. &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出结果</span></span><br><span class="line">  cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;estimated a,b,c = &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> a:abc) cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中需要说明的地方均已加注释。可以看到, 我们利用 OpenCV 的噪声生成器生成了 100 个带高斯噪声的数据, 随后利用 Ceres 进行拟合。这里演示的 Ceres 用法有如下几项:</p>
<ol>
<li>定义残差块的类。方法是书写一个类（或结构体), 并在类中定义带模板参数的 () 运算符, 这样该类就成为了一个拟函数 ( Functor) 。这种定义方式使得 Ceres 可以像调用函数一样, 对该类的某个对象（比如 a ) 调用 $a&lt;$ double&gt;()方法。事实上, Ceres 会把雅可比矩阵作为类型参数传入此函数, 从而实现自动求导的功能。</li>
<li>程序中的 double abc[3] 即参数块, 而对于残差块, 我们对每一个数据构造 CURVE_FITTING_COST 对象, 然后调用 AddResidualBlock 将误差项添加到目标函数中。由于优化需要梯度, 我们有若干种选择：（1）使用 Ceres 的自动求导（Auto Diff）；（2）使用数值 编码上是最方便的, 于是我们使用自动求导。</li>
<li>自动求导需要指定误差项和优化变量的维度。这里的误差是标量, 维度为 1 ; 优化的是 $a, b, c$ 三个量, 维度为 3 。于是, 在自动求导类 AutoDiffCostFunction 的模板参数中设定变 量维度为 $1 、 3$ 。</li>
<li>设定好问题后, 调用 Solve 函数进行求解。你可以在 options 里配置（非常详细的) 优化 选项。例如, 可以选择使用 Line Search 还是 Trust Region、迭代次数、步长, 等等。读者 可以查看 Options 的定义, 看看有哪些优化方法可选, 当然默认的配置已经可用于很广泛 的问题了。</li>
</ol>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM11】前端——特征点匹配</title>
    <url>/2022/07/26/%E3%80%90%E8%A7%86%E8%A7%89SLAM11%E3%80%91%E5%89%8D%E7%AB%AF%E2%80%94%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>一个视觉SLAM系统包括前端和后端，前端能够粗略地得到相机的位姿，给后端提供较好的初值。</p>
<span id="more"></span>
<p>视觉SLAM中，由前端估计出相机的位姿大致分为两个思路：</p>
<ul>
<li>特征点法：先匹配图像上的特征点，然后根据匹配的特征点计算相机的位姿</li>
<li>直接法：直接根据图像求解相机位姿</li>
</ul>
<p>所以可以看出特征点匹配在一路中占有重要的用处。要想匹配出特征点，就得先要知道什么是特征点。</p>
<h2 id="I-ORB特征点"><a href="#I-ORB特征点" class="headerlink" title="I. ORB特征点"></a>I. ORB特征点</h2><h3 id="1-什么是特征点"><a href="#1-什么是特征点" class="headerlink" title="1. 什么是特征点"></a>1. 什么是特征点</h3><p>我们需要找到一些图像上有代表的点，这些点在相机视角发生少量变化后回保持不变。这些点我们称为<strong>路标</strong>，也称为<strong>图像特征</strong>。一开始人们用角点来作为图像的特征，但是该方法不稳定，例如很多远处看上去是角点的地方，当相机离近之后，可能就不显示为角点了。因此，计算机视觉领域的研究者们在长年的研究中设计了许多更加稳定的<strong>局部图像特征</strong>。</p>
<p>这些特征有如下性质：</p>
<ol>
<li>可重复性（Repeatability ）相同的特征可以在不同的图像中找到。</li>
<li>可区别性（Distinctiveness )：不同的特征有不同的表达。</li>
<li>高效率 (Efficiency)：同一图像中, 特征点的数量应远小于像素的数量。</li>
<li>本地性 (Locality )：特征仅与一小片图像区域相关。</li>
</ol>
<p>特征点由<strong>关键点</strong>和<strong>描述子</strong>两部分组成。所以提取特征点包括<strong>确定关键点位置和计算描述子</strong>两件事。描述子的设计原则是外观相似的特征应该有相似的描述子，因此只要两个描述子在向量空间上距离相近，就可以认为他们是同样的特征点。</p>
<h3 id="2-ORB特征点"><a href="#2-ORB特征点" class="headerlink" title="2. ORB特征点"></a>2. ORB特征点</h3><p>ORB特征由<strong>关键点</strong>和<strong>描述子</strong>两部分组成。它的关键点是一种<strong>改进的FAST角点</strong>，而<strong>描述子称为BRIEF</strong>。</p>
<h4 id="1-FAST角点"><a href="#1-FAST角点" class="headerlink" title="(1) FAST角点"></a>(1) FAST角点</h4><p>FAST 是一种角点，主要检测<strong>局部像素灰度变化明显</strong>的地方，以速度快著称。它的思想是：如果一个像素与邻域的像素差别较大 (过亮或过暗)，那么它更可能是角点。相比于其他角点检测算法， FAST 只需比较像素亮度的大小，十分快捷。它的检测过程如下：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220727171721.png" alt="image-20220727171721537" style="zoom:50%;" /></p>
<ol>
<li>在图像中选取像素 $p$, 假设它的亮度为 $I_{p}$ 。</li>
<li>设置一个阈值 $T\left(\right.$ 比如, $I_{p}$ 的 $20 \%$ )。</li>
<li>以像素 $p$ 为中心, 选取半径为 3 的圆上的 16 个像素点。</li>
<li>假如选取的圆上有连续的 $N$ 个点的亮度大于 $I_{p}+T$ 或小于 $I_{p}-T$, 那么像素 $p$ 可以被 认为是特征点 ( $N$ 通常取 12, 即 FAST-12。其他常用的 $N$ 取值为 9 和 11 , 它们分别被 称为 FAST-9 和 FAST-11)。</li>
<li>循环以上四步, 对每一个像素执行相同的操作。</li>
</ol>
<p><strong>注：</strong> 为了提高提取速度，可以加上一步<strong>预测试</strong>，具体操作为直接检测当前像素临域圆上的第1，5，9，13个像素的亮度。只有这4个中的3个像素同时大于$I_{p}+T $ 或小于 $I_{p}-T$ 时，当前像素才有可能是一个角点。如果检测到的角点扎堆，还需要非极大值抑制，保留响应极大值的角点。</p>
<p>ORB为了解决FAST角点的<strong>尺度问题</strong>和<strong>旋转问题</strong>，添加了尺度方向和旋转方向的描述。尺度不变由通过构建图像金字塔，并在其每一层上检测角点来实现。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220727172001.png" alt="image-20220727172000938" style="zoom:50%;" /></p>
<p>金字塔是计算图视觉中常用的一种处理方法。金字塔底层是原始图像， 每往上一层，就对图像进行一个<strong>固定倍率的缩放</strong>，这样我们就有了不同分辨率的图像。较小的图像可以看成是远处看过来的场景。<strong>在特征匹配算法中，我们可以匹配不同层上的图像</strong>， 从而实现尺度不变性。例如，如果相机在后退，那么我们应该能够在上一个图像金字塔的上层和下一个图像金字塔的下层中找到匹配。</p>
<p>在旋转方面，我们可以计算特征点附近的<strong>图像灰度质心</strong>，所谓质心就是以图像块灰度值作为权重的中心。具体的计算过程为：</p>
<ol>
<li><p>在一个小的图像块 $B$ 中，定义图像块的矩为 </p>
<script type="math/tex; mode=display">
m_{p q}=\sum_{x, y \in B} x^{p} y^{q} I(x, y), \quad p, q=\{0,1\}</script></li>
<li><p>通过拒可以找到图像块的质心</p>
<script type="math/tex; mode=display">
C=\left(\frac{m_{10}}{m_{00}}, \frac{m_{01}}{m_{00}}\right)</script></li>
<li><p>连接图像块的几何中心 $O$ 与质心 $C$, 得到一个方向向量 $\overrightarrow{O C}$, 于是特征点的方向可以定义为</p>
<script type="math/tex; mode=display">
\theta=\arctan \left(m_{01} / m_{10}\right)</script></li>
</ol>
<h4 id="2-BRIEF描述子"><a href="#2-BRIEF描述子" class="headerlink" title="(2) BRIEF描述子"></a>(2) BRIEF描述子</h4><p>BRIEF 是一种二进制描述子， 其描述向量由许多个 0 和 1 组成，这里的 0 和 1 编码了关键点附近两个随机像素（比如 $p$ 和 $q$ ）的大小关系：如果 $p$ 比 $q$ 大，则取 1 ，反之就取 0 。如果我们取 了 128 个这样的 $p，q$ ，则最后得到 128 维由 $0 、 1$ 组成的向量。BRIEF 使用了随机选点的比较，速度非常快，而且由于使用了二进制表达，存储起来也十分方便，适用于实时的图像匹配。原始 的 BRIEF 描述子不具有旋转不变性，因此在图像发生旋转时容易丢失。而 ORB 在 FAST 特征点提取阶段计算了关键点的方向，所以可以利用方向信息，计算旋转之后的 “Steer BRIEF” 特征使 ORB 的描述子具有较好的旋转不变性。</p>
<h2 id="II-特征点匹配"><a href="#II-特征点匹配" class="headerlink" title="II. 特征点匹配"></a>II. 特征点匹配</h2><p>匹配的方法就是计算描述子间的距离，来刻画特征点间的相似程度。这些距离可以使用不同的范数来度量，例如可以使用欧氏距离来进行度量，对于二进制描述子，如BRIEF，可以使用<strong>汉明距离</strong>来度量，两个二进制串的汉明距离就是指不同位数的个数。</p>
<p>而对于如何匹配，最简单最直接的就是<strong>暴力匹配（Brute-Force Matcher）</strong>，也就是说，把当前特征点和另一帧图像上的所有特征点的描述子距离都计算一遍。当然这种方法耗时耗力，因此人们常用<strong>快速近似最临近（FLANN）</strong>算法。 </p>
<h2 id="III-总结"><a href="#III-总结" class="headerlink" title="III. 总结"></a>III. 总结</h2><p>特征匹配是很重要的一步工作。特征点是由<strong>关键点</strong>和<strong>描述子</strong>来组成。在视觉SLAM中常用的是ORB特征，该特征考虑了尺度和旋转特性，因此更加稳定。ORB特征使用的是改进的FAST关键点，即某一像素点比其邻域的像素点的亮度都大或者特别小，则该像素点就是一个关键点。另外，还要考虑尺度和旋转的问题，ORB的关键点通过图像金字塔和计算关键点区域的图像灰度值中心来解决这两个问题。而对于描述子，ORB使用的是BRIEF描述子，该描述子通过随机抽取两个关键点邻域内的像素，并对其进行亮度值比较，来确定描述子的形式。该描述子由二进制位来描述。最后通过计算描述子的汉明距离来匹配特征点。</p>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM12】前端——根据匹配好的特征点计算相机位姿</title>
    <url>/2022/07/27/%E3%80%90%E8%A7%86%E8%A7%89SLAM12%E3%80%91%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E5%8C%B9%E9%85%8D%E5%A5%BD%E7%9A%84%E7%89%B9%E5%BE%81%E7%82%B9%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E4%BD%8D%E5%A7%BF/</url>
    <content><![CDATA[<p>在匹配好两张图像的特征点后，就可以用来求取相机的位姿了。根据相机的原理不同，可以分为三种情况：</p>
<ul>
<li><p><strong>2D—2D（对极几何问题）</strong>：当使用单目相机时，仅知道所匹配特征点的两组像素坐标。</p>
</li>
<li><p><strong>3D—2D（PnP问题）</strong>：知道所匹配特征点的一个相机坐标系下的坐标和一个像素坐标系下的坐标。</p>
</li>
<li><p><strong>3D—3D（ICP问题）</strong>：当使用的是RGB-D相机或双目相机时，即知道所匹配特征点的两组相机坐标系下的坐标。</p>
<span id="more"></span>
</li>
</ul>
<p>本节我们还要学另一个东东，就是已知相机的运动后，如何求路标点的空间位置，也叫作<strong>三角测量</strong>。</p>
<h2 id="I-2D-2D：对极几何"><a href="#I-2D-2D：对极几何" class="headerlink" title="I. 2D-2D：对极几何"></a>I. 2D-2D：对极几何</h2><p>我们先对匹配好的一对特征点建立关系：</p>
<h3 id="1-对极约束"><a href="#1-对极约束" class="headerlink" title="1. 对极约束"></a>1. 对极约束</h3><p>以下图为例，我们希望求取两帧图像 $I_{1}, I_{2}$ 之间的运动，<strong>设第一帧到第二帧的运动为</strong> $\boldsymbol{R}, \boldsymbol{t}$ 。 两个相机中心分别为 $O_{1}, O_{2}$ 。现在，考虑 $I_{1}$ 中有一个特征点 $p_{1}$ ，它在 $I_{2}$ 中对应着特征点 $p_{2}$ 。我们知道两者是通过特征匹配得到的。如果匹配正确，<strong>说明它们确实是同一个空间点在两个成像平面上的投影。</strong></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220727205714.png" alt="image-20220727205714351" style="zoom:67%;" /></p>
<p><strong>我们现在就是要建立这两个投影的像素坐标之间的关系。所建立的根据是</strong></p>
<script type="math/tex; mode=display">
\boldsymbol{O_2P}\cdot (\boldsymbol{O_1O_2}\times \boldsymbol{O_1P})=\boldsymbol{0}\tag{1}</script><p>而要想建立这个方程，就需要在同一坐标系下描述各个向量。</p>
<p>以相机1为基准建立相机坐标系，所以点 $P$ 的坐标为 $[X,Y,Z]^T$ ，根据相机模型，可以得到点 $P$ 在相机1和2的像素坐标系下的坐标为 $\boldsymbol{p_1,p_2}$ ，所以有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
s_1\boldsymbol{p_1}&=K\boldsymbol{P}\\
s_2\boldsymbol{p_2}&=K(R\boldsymbol{P}+\boldsymbol{t})
\end{aligned}\tag{2}</script><p>在已知像素坐标 $\boldsymbol{p_1,p_2}$ 时，我们无法直接求出 $\boldsymbol{P}$ 的具体坐标，但是我们是知道点 $P$ 在哪个射线上，所以我们就求点 $P$ 在相机1和2归一化平面上的投影点的坐标 $\boldsymbol{X_1,X_2}$ (分别在1和2相机系下的坐标)，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{X_1}&=K^{-1}\boldsymbol{p_1}\\
\boldsymbol{X_2}&=K^{-1}\boldsymbol{p_2}
\end{aligned}\tag{3}</script><p>因为投影点 $X_1和X_2$ 在射线 $O_1P和O_2P$ 上，所以向量 $\boldsymbol{O_1X_1,O_2X_2}$ 是这两条射线上的向量，接下来就可以用这两个向量来代替式（1）中的两个向量 $\boldsymbol{O_1P}和\boldsymbol{O_2P}$ 。</p>
<p>要想完成式（1）方程的建立，我们需要把所有向量都在同一坐标系下表示，我们在2系下表示：</p>
<ul>
<li>向量 $\boldsymbol{O_1X_1}$ 的坐标在1系下为 $\boldsymbol{X_1}$ ，所以在2系下需要进行坐标变换，即 $R\boldsymbol{X_1}$ 。</li>
<li>向量 $\boldsymbol{O_1O_2}$ 在2系下的坐标是 $-\boldsymbol{t}$ （$\boldsymbol{t}$ 表示由1到2的平移向量，所以是点 $O_1$ 在坐标系2下的坐标）。</li>
<li>向量 $\boldsymbol{O_2X_2}$ 在2系下的坐标为 $\boldsymbol{X_2}$ 。</li>
</ul>
<p>所以将三个向量的坐标带入（1）式中，有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{X_2}^T\cdot(-\boldsymbol{t}^{\wedge}\cdot R\boldsymbol{X_1})=0\\
\end{aligned}\tag{4}</script><p>整理有：</p>
<script type="math/tex; mode=display">
\boldsymbol{X_2}^T\boldsymbol{t}^{\wedge}R\boldsymbol{X_1}=0\tag{5}</script><p>重新带入 $\boldsymbol{p_1,p_2}$ ：</p>
<script type="math/tex; mode=display">
\boldsymbol{p_2}^TK^{-T}\boldsymbol{t}^{\wedge}RK^{-1}\boldsymbol{p_1}=0\tag{6}</script><p>式（5）和（6）就是对极约束，注意这两个式子中间包括了<strong>旋转矩阵</strong>和<strong>平移向量</strong>，现在我们令：</p>
<script type="math/tex; mode=display">
E=\boldsymbol{t}^{\wedge}R\tag{7}</script><p>或：</p>
<script type="math/tex; mode=display">
F=K^{-T}\boldsymbol{t}^{\wedge}RK^{-1}\tag{8}</script><p>则式（5）和式（6）还可以写为：</p>
<script type="math/tex; mode=display">
\boldsymbol{X}_{2}^{\mathrm{T}} \boldsymbol{E} \boldsymbol{X}_{1}=\boldsymbol{p}_{2}^{\mathrm{T}} \boldsymbol{F} \boldsymbol{p}_{1}=0\tag{9}</script><p>其中 $E$ 被称为<strong>本质矩阵</strong>，包含了相机的旋转和平移信息，主要用于已知相机内参时进行位姿求解。而 $F$ 称为<strong>基础矩阵</strong>，包括了相机的内参信息以及旋转平移信息。</p>
<h3 id="2-求解相机位姿（八点法）"><a href="#2-求解相机位姿（八点法）" class="headerlink" title="2. 求解相机位姿（八点法）"></a>2. 求解相机位姿（八点法）</h3><p><strong>当我们建立好了一组特征点的关系后，我们就可以通过已匹配的特征点来求相机的位姿了，根本上就是来求解本质矩阵 $E$ 或基础矩阵 $F$</strong> <strong>，然后由矩阵再求出旋转 $R$ 和平移 $\boldsymbol t$</strong> ，从本质上来讲，基础矩阵和本质矩阵并没有多大区别，一般相机的内参矩阵是已知的，所以我们主要讨论本质矩阵。</p>
<p>本质矩阵 $E=\boldsymbol{t}^{\wedge}R$ ，是一个 $3\times 3$ 的矩阵，有9个未知数，但这并不意味着任意一个 $3\times 3$ 的矩阵就是本质矩阵。本质矩阵有以下几点注意：</p>
<ul>
<li>由于本质矩阵是由对极约束来定义的，可以看到式（9）中乘以任意系数都成立，所以这表面本质矩阵 $E$ 在不同尺度下是等价的（可以在对极约束的图上想一下，当三角形 $O_1PO_2$ 任意放大缩小多少倍，投影的像素点位置都不变）。</li>
<li>本质矩阵有一个内在的性质，它的奇异值必定是 $[\sigma, \sigma, 0]^{\mathrm{T}}$ 的形式。</li>
<li>由于旋转和平移共有6个自由度，所以本质矩阵也有6个自由度，但由于尺度等价性，故 $E$ 实际上只能求5个自由度。</li>
</ul>
<p>求解本质矩阵 $E$ 最常用的方法就是<strong>八点法</strong>，考虑一对匹配点，它的归一化坐标为：$\boldsymbol{X}_{1}=\left[u_{1}, v_{1}, 1\right]^{\mathrm{T}}, \boldsymbol{X}_{2}=\left[u_{2}, v_{2}, 1\right]$ ，根据对极约束，有：</p>
<script type="math/tex; mode=display">
\left(u_{2}, v_{2}, 1\right)\left(\begin{array}{lll}
e_{1} & e_{2} & e_{3} \\
e_{4} & e_{5} & e_{6} \\
e_{7} & e_{8} & e_{9}
\end{array}\right)\left(\begin{array}{c}
u_{1} \\
v_{1} \\
1
\end{array}\right)=0\tag{10}</script><p>我们把矩阵 $E$ 展开写成向量的形式：</p>
<script type="math/tex; mode=display">
\boldsymbol{e}=\left[e_{1}, e_{2}, e_{3}, e_{4}, e_{5}, e_{6}, e_{7}, e_{8}, e_{9}\right]^{\mathrm{T}}\tag{11}</script><p> 式（10）还可以写成：</p>
<script type="math/tex; mode=display">
\left[u_{2} u_{1}, u_{2} v_{1}, u_{2}, v_{2} u_{1}, v_{2} v_{1}, v_{2}, u_{1}, v_{1}, 1\right] \cdot \boldsymbol{e}=0\tag{12}</script><p>同理，对于所有的8对点对也同样以该形式进行表示，并写到一个方程组中，则得到：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{ccccccccc}
u_{2}^{1} u_{1}^{1} & u_{2}^{1} v_{1}^{1} & u_{2}^{1} & v_{2}^{1} u_{1}^{1} & v_{2}^{1} v_{1}^{1} & v_{2}^{1} & u_{1}^{1} & v_{1}^{1} & 1 \\
u_{2}^{2} u_{1}^{2} & u_{2}^{2} v_{1}^{2} & u_{2}^{2} & v_{2}^{2} u_{1}^{2} & v_{2}^{2} v_{1}^{2} & v_{2}^{2} & u_{1}^{2} & v_{1}^{2} & 1 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \\
u_{2}^{8} u_{1}^{8} & u_{2}^{8} v_{1}^{8} & u_{2}^{8} & v_{2}^{8} u_{1}^{8} & v_{2}^{8} v_{1}^{8} & v_{2}^{8} & u_{1}^{8} & v_{1}^{8} & 1
\end{array}\right)\left(\begin{array}{l}
e_{1} \\
e_{2} \\
e_{3} \\
e_{4} \\
e_{5} \\
e_{6} \\
e_{7} \\
e_{8} \\
e_{9}
\end{array}\right)=0\tag{13}</script><p>这8个方程构成了一个线性方程组，它的系数矩阵由特征点位置构成，大小为 $8\times 9$，$\boldsymbol e$ 位于该矩阵的<strong>零空间中</strong>，如果系数矩阵是满秩的，那么它的零空间的维数为1，也就是 $\boldsymbol e$ 构成了一条线，这与 $\boldsymbol e$ 的尺度等价性是一致的。</p>
<p>在求得本质矩阵 $E$ 之后，我们便可以回复出相机的运动 $R$ 和 $\boldsymbol{t}$ 了，这个过程由奇异值分解得到，设本质矩阵 $E$ 的奇异值分解为：</p>
<script type="math/tex; mode=display">
\boldsymbol{E}=\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\mathrm{T}}\tag{14}</script><p>具体过程省略，我们可以得到4种情况：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\boldsymbol{t}_{1}^{\wedge}=\boldsymbol{U} \boldsymbol{R}_{Z}\left(\frac{\pi}{2}\right) \boldsymbol{\Sigma} \boldsymbol{U}^{\mathrm{T}}, \quad \boldsymbol{R}_{1}=\boldsymbol{U} \boldsymbol{R}_{Z}^{\mathrm{T}}\left(\frac{\pi}{2}\right) \boldsymbol{V}^{\mathrm{T}} \\
\boldsymbol{t}_{2}^{\wedge}=\boldsymbol{U} \boldsymbol{R}_{Z}\left(-\frac{\pi}{2}\right) \boldsymbol{\Sigma} \boldsymbol{U}^{\mathrm{T}}, \quad \boldsymbol{R}_{2}=\boldsymbol{U} \boldsymbol{R}_{Z}^{\mathrm{T}}\left(-\frac{\pi}{2}\right) \boldsymbol{V}^{\mathrm{T}}
\end{array}\tag{15}</script><p>虽然有四种情况，但是只有一种情况是 $P$ 在两个相机中都具有正深度，因此只要把任意一点代入4种解中，检测该点在两个相机下的深度，就可以确定哪个解是正确的了。如果我们求出的 $E$ 不满足奇异值为 $\sigma, \sigma, 0$ 的形式。这时, 我们会刻意地把 $\boldsymbol{\Sigma}$ 矩阵调整成上面的样子。通常的做法是，对八点法求得的 $E$ 进行 SVD，会得到奇异值矩阵 $\boldsymbol{\Sigma}=\operatorname{diag}\left(\sigma_{1}, \sigma_{2}, \sigma_{3}\right)$，不妨设 $\sigma_{1} \geqslant \sigma_{2} \geqslant \sigma_{3}$ 。取:</p>
<script type="math/tex; mode=display">
\boldsymbol{E}=\boldsymbol{U} \operatorname{diag}\left(\frac{\sigma_{1}+\sigma_{2}}{2}, \frac{\sigma_{1}+\sigma_{2}}{2}, 0\right) \boldsymbol{V}^{\mathrm{T}} \tag{16}</script><h3 id="3-单应矩阵"><a href="#3-单应矩阵" class="headerlink" title="3. 单应矩阵"></a>3. 单应矩阵</h3><p>当特征点在同一平面上时（这种情况在无人机携带相机俯视地面比较常见），可以借助该<strong>平面方程</strong>来进行推导特征点间的关系。这就说到了<strong>单应矩阵</strong>，它通常用来描述处于共同平面上的一些点在两张图像之间的变换关系。</p>
<p>当点 $P$ 位于某个平面 $\pi$ 上时，有平面方程：</p>
<script type="math/tex; mode=display">
\boldsymbol{n}^{T}\boldsymbol{P}+d=0\tag{17}</script><p>整理有：</p>
<script type="math/tex; mode=display">
-\frac{\boldsymbol{n}^{T}\boldsymbol{P}}{d}=1\tag{18}</script><p>把式（18）带入到式（2）中，得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
s_2\boldsymbol{p_{2}} & = K(R \boldsymbol P+\boldsymbol t) \\
& = K\left(R \boldsymbol P+\boldsymbol t \cdot\left(-\frac{\boldsymbol n^{\mathrm{T}} \boldsymbol{P}}{d}\right)\right) \\
& = K\left(R-\frac{\boldsymbol{t} \boldsymbol n^{\mathrm{T}}}{d}\right) \boldsymbol P \\
& = s_1 K\left(R-\frac{\boldsymbol{t} \boldsymbol n^{\mathrm{T}}}{d}\right) K^{-1} \boldsymbol {p_{1}} 
\end{aligned}\tag{19}</script><p>式（19）虽然是两面相等，但要注意的是由于像素坐标 $\boldsymbol{p_1,p_2}$ 都是由<strong>齐次坐标</strong>表示的，<strong>因此对其放大或缩小一定的倍率，并不影响结果。</strong>所以说式（19）可以写成：</p>
<script type="math/tex; mode=display">
\boldsymbol{p_2}\simeq K\left(\boldsymbol{R}-\frac{\boldsymbol{t} \boldsymbol{n}^{\mathrm{T}}}{d}\right) K^{-1} \boldsymbol{p}_{1}\tag{20}</script><p>这表示尺度一致性，现令中间部分：</p>
<script type="math/tex; mode=display">
H=K\left(\boldsymbol{R}-\frac{\boldsymbol{t} \boldsymbol{n}^{\mathrm{T}}}{d}\right) K^{-1}\tag{21}</script><p>则式（20）可写为：</p>
<script type="math/tex; mode=display">
\boldsymbol{p}_{2} \simeq H \boldsymbol{p}_1\tag{22}</script><p><strong>这里的 $H$ 放大或缩小任意倍数，原方程均成立。</strong> $H$ 的定义与<strong>旋转，平移和平面的参数</strong>有关，所以求解它的思路和求解本质矩阵一样，我们先将式（22）展开：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{c}
u_{2} \\
v_{2} \\
1
\end{array}\right) \simeq\left(\begin{array}{lll}
h_{1} & h_{2} & h_{3} \\
h_{4} & h_{5} & h_{6} \\
h_{7} & h_{8} & h_{9}
\end{array}\right)\left(\begin{array}{c}
u_{1} \\
v_{1} \\
1
\end{array}\right)\tag{23}</script><p>因为 $H$ 尺度不确定，我们在实际计算中令 $h_9=1$ （在它取非零值时），然后根据第3行，去掉这个非零因子，于是有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
u_{2} &=\frac{h_{1} u_{1}+h_{2} v_{1}+h_{3}}{h_{7} u_{1}+h_{8} v_{1}+h_{9}} \\
v_{2} &=\frac{h_{4} u_{1}+h_{5} v_{1}+h_{6}}{h_{7} u_{1}+h_{8} v_{1}+h_{9}}
\end{aligned}\tag{24}</script><p>整理得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&h_{1} u_{1}+h_{2} v_{1}+h_{3}-h_{7} u_{1} u_{2}-h_{8} v_{1} u_{2}=u_{2} \\
&h_{4} u_{1}+h_{5} v_{1}+h_{6}-h_{7} u_{1} v_{2}-h_{8} v_{1} v_{2}=v_{2}
\end{aligned}</script><p>这样一组匹配点可以<strong>构造出两个约束方程</strong>，于是自由度为8的单应矩阵可以通过4对匹配特征点算出（这些特征点不能有三点共线的情况），求解线性方程组：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{cccccccc}
u_{1}^{1} & v_{1}^{1} & 1 & 0 & 0 & 0 & -u_{1}^{1} u_{2}^{1} & -v_{1}^{1} u_{2}^{1} \\
0 & 0 & 0 & u_{1}^{1} & v_{1}^{1} & 1 & -u_{1}^{1} v_{2}^{1} & -v_{1}^{1} v_{2}^{1} \\
u_{1}^{2} & v_{1}^{2} & 1 & 0 & 0 & 0 & -u_{1}^{2} u_{2}^{2} & -v_{1}^{2} u_{2}^{2} \\
0 & 0 & 0 & u_{1}^{2} & v_{1}^{2} & 1 & -u_{1}^{2} v_{2}^{2} & -v_{1}^{2} v_{2}^{2} \\
u_{1}^{3} & v_{1}^{3} & 1 & 0 & 0 & 0 & -u_{1}^{3} u_{2}^{3} & -v_{1}^{3} u_{2}^{3} \\
0 & 0 & 0 & u_{1}^{3} & v_{1}^{3} & 1 & -u_{1}^{3} v_{2}^{3} & -v_{1}^{3} v_{2}^{3} \\
u_{1}^{4} & v_{1}^{4} & 1 & 0 & 0 & 0 & -u_{1}^{4} u_{2}^{4} & -v_{1}^{4} u_{2}^{4} \\
0 & 0 & 0 & u_{1}^{4} & v_{1}^{4} & 1 & -u_{1}^{4} v_{2}^{4} & -v_{1}^{4} v_{2}^{4}
\end{array}\right)\left(\begin{array}{l}
h_{1} \\
h_{2} \\
h_{3} \\
h_{4} \\
h_{5} \\
h_{6} \\
h_{7} \\
h_{8}
\end{array}\right)=\left(\begin{array}{l}
u_{2}^{1} \\
v_{2}^{1} \\
u_{2}^{2} \\
v_{2}^{2} \\
u_{2}^{3} \\
v_{2}^{3} \\
u_{2}^{4} \\
v_{2}^{4}
\end{array}\right)\tag{25}</script><p><strong>注意：</strong> 当  $h_9=0$ 时，式（25）右侧为0。</p>
<p>这种方法称为<strong>直接线性变换法（DLT）</strong>，求解后可以对 $H$ 矩阵进行分解，得到相应的旋转矩阵 $R$ 和 $\boldsymbol{t}$ 。它可以分解为四种情况，也可以根据深度信息，最后进行判断得到一组正确的解，具体不做介绍。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>对极几何问题中，我们可以根据匹配好的特征点计算出本质矩阵或基础矩阵。也可以根据同一平面上的特征点计算出单应矩阵。对上面的问题进行总结：</p>
<ul>
<li>本质矩阵 $E$ 是尺度不确定的，我们可以从它分解得到旋转矩阵$R$ 和平移向量 $\boldsymbol{t}$ ，但是我们知道旋转矩阵 $R\in SO(3)$ ，有自身的约束，所以我们认为 $\boldsymbol{t}$ 具有一个尺度，即任意非零常数乘以 $\boldsymbol{t}$ 都符合，所以我们通常把  $\boldsymbol{t}$  归一化，令其长度为1。</li>
<li>在单目视觉中，我们对两张图像的 $\boldsymbol{t}$ 归一化相当于固定了尺度。虽然我们不知道它的实际长度是多少，但我们以这时的 $\boldsymbol t$ 为单位 1 , 计算相机运动和特征点的 3D 位置。这被称为单目 SLAM 的初始化。在初始化之后, 就可以用 <strong>3D-2D</strong> 计算相机运动了。初始化之后的轨迹和地图的单位，就是初始化时固定的尺度。因此, 单目 SLAM 有一步不可避免的初始化。初始化的两张图像<strong>必须有一定程度的平移</strong>，而后的轨迹和地图都将以此步的平移为单位。</li>
<li>当相机做纯旋转运动时，此时  $\boldsymbol{t}$ 为0，所以本质矩阵也将为零，这将导致无法求解 $R$ ，此时我们可以靠求单应矩阵 $H$ 来求取旋转，但是仅有旋转，<strong>我们无法用三角测量</strong>估计特征点的空间位置。<strong>所以单目初始化不能只有纯旋转，必须有一定程度的平移。</strong></li>
</ul>
<h2 id="II-3D-2D-PnP"><a href="#II-3D-2D-PnP" class="headerlink" title="II. 3D-2D: PnP"></a>II. 3D-2D: PnP</h2><p>如果两张图片中的一张图片上的特征点的3D位置已知，那么最少只需三个点对就可以估计相机运动。这种方法在双目或RGB-D的视觉里程计中常用。<strong>在单目视觉里程计中，必须在初始化后，才能使用PnP进行求解</strong>（初始化后可以得到一些特征点的3D坐标，并确定当前尺度为单位，接下来用PnP方法来求解，这样之后的位姿估计都是建立在初始化尺度下的）。</p>
<p>求解PnP问题可以用以下的方法。</p>
<h3 id="1-直接线性变换"><a href="#1-直接线性变换" class="headerlink" title="1. 直接线性变换"></a>1. 直接线性变换</h3><p>考虑某个空间点 $P$ ，它的齐次坐标为 $\boldsymbol{P}=(X, Y, Z, 1)^{\mathrm{T}}$ 。在图像 $I_{1}$ 中，投影到特征点 $\boldsymbol{x}_{1}=$ $\left(u_{1}, v_{1}, 1\right)^{\mathrm{T}}$ (以齐次坐标表示 )。此时，相机的位姿 $R, \boldsymbol{t}$ 是末知的，<strong>假设内参矩阵 $K$ 已知</strong>。与单应矩阵的求解类似，我们定义增广矩阵 $K[R \mid \boldsymbol{t}]$ 为一个 $3 \times 4$ 的矩阵，包含了旋转与平移信息。我们将其展开形式列写如下：</p>
<script type="math/tex; mode=display">
s\left(\begin{array}{c}
u_{1} \\
v_{1} \\
1
\end{array}\right)=\left(\begin{array}{llll}
t_{1} & t_{2} & t_{3} & t_{4} \\
t_{5} & t_{6} & t_{7} & t_{8} \\
t_{9} & t_{10} & t_{11} & t_{12}
\end{array}\right)\left(\begin{array}{c}
X \\
Y \\
Z \\
1
\end{array}\right)\tag{26}</script><p>最后一行把 $s$ 消去，得到两个约束：</p>
<script type="math/tex; mode=display">
u_{1}=\frac{t_{1} X+t_{2} Y+t_{3} Z+t_{4}}{t_{9} X+t_{10} Y+t_{11} Z+t_{12}}, \quad v_{1}=\frac{t_{5} X+t_{6} Y+t_{7} Z+t_{8}}{t_{9} X+t_{10} Y+t_{11} Z+t_{12}}\tag{27}</script><p>为了简化表示，定义行向量：</p>
<script type="math/tex; mode=display">
\boldsymbol{t}_{1}=\left(t_{1}, t_{2}, t_{3}, t_{4}\right)^{\mathrm{T}}, \boldsymbol{t}_{2}=\left(t_{5}, t_{6}, t_{7}, t_{8}\right)^{\mathrm{T}}, \boldsymbol{t}_{3}=\left(t_{9}, t_{10}, t_{11}, t_{12}\right)^{\mathrm{T}}\tag{28}</script><p>于是式（27）可以简写为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\boldsymbol{t}_{1}^{\mathrm{T}} \boldsymbol{P}-\boldsymbol{t}_{3}^{\mathrm{T}} \boldsymbol{P} u_{1}=0 \\
&\boldsymbol{t}_{2}^{\mathrm{T}} \boldsymbol{P}-\boldsymbol{t}_{3}^{\mathrm{T}} \boldsymbol{P} v_{1}=0
\end{aligned}\tag{29}</script><p>这样，每个特征点可以建立两个约束方程，假设一共有 $N$ 个特征点，则可以列出线性方程组为：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{ccc}
\boldsymbol{P}_{1}^{\mathrm{T}} & 0 & -u_{1} \boldsymbol{P}_{1}^{\mathrm{T}} \\
0 & \boldsymbol{P}_{1}^{\mathrm{T}} & -v_{1} \boldsymbol{P}_{1}^{\mathrm{T}} \\
\vdots & \vdots & \vdots \\
\boldsymbol{P}_{N}^{\mathrm{T}} & 0 & -u_{N} \boldsymbol{P}_{N}^{\mathrm{T}} \\
0 & \boldsymbol{P}_{N}^{\mathrm{T}} & -v_{N} \boldsymbol{P}_{N}^{\mathrm{T}}
\end{array}\right)\left(\begin{array}{c}
\boldsymbol{t}_{1} \\
\boldsymbol{t}_{2} \\
\boldsymbol{t}_{3}
\end{array}\right)=0\tag{30}</script><p>一共有12个未知量，因此最少可以通过6对匹配点就可以实现矩阵的线性求解。如果大于6对匹配点，则可以通过最小二乘方法求解。在得到这个矩阵后，我们需要对其进行划分，来求旋转矩阵 $R$ 和 $\boldsymbol{t}$ 。</p>
<p>$\boldsymbol{t}$ 比较好办，它属于向量空间。而对于 $R$ ，要符合 $R\in SO(3)$ ，所以我们根据所求出来的矩阵左边 $3\times 3$ 的矩阵块，寻找一个最好的旋转矩阵对它进行近似。</p>
<h3 id="2-P3P方法"><a href="#2-P3P方法" class="headerlink" title="2. P3P方法"></a>2. P3P方法</h3><p>我们还可以用P3P方法来求解PnP问题。它仅需使用3对匹配点就可以求解。</p>
<p>P3P 需要利用给定的 3 个点的几何关系。它的输人数据为 3 对 3D-2D 匹配点。记 3D 点为 $A, B, C$ ； 2D点为 $a, b, c$ ，其中小写字母代表的点为对应大写字母代表的点在相机成像平面上的投影。此外，P3P 还需要使用一对验证点，以从可能的解中选出正确的那一个 (类似于对极几何情形 ）记验证点对为 $D-d$，相机光心为 $O$ 。请注意，我们知道的是 $A, B, C$ 在<strong>世界坐标系中的坐标</strong>（此处也可以认为是上一个相机坐标系下的坐标），但一定不是当前相机坐标系下的坐标。一旦 3D 点在相机坐标系下的坐标能够算出，我们就得到了 3D-3D 的对应点，把 PnP 问题转换为了 ICP 问题。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220728180736.png" alt="image-20220728180736043" style="zoom:50%;" /></p>
<p>根据三角形之间的对应关系，有：</p>
<script type="math/tex; mode=display">
\Delta O a b-\triangle O A B, \quad \triangle O b c-\triangle O B C, \quad \triangle O a c-\triangle O A C\tag{31}</script><p>利用余弦定理有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&O A^{2}+O B^{2}-2 O A \cdot O B \cdot \cos \langle a, b\rangle=A B^{2} \\
&O B^{2}+O C^{2}-2 O B \cdot O C \cdot \cos \langle b, c\rangle=B C^{2} \\
&O A^{2}+O C^{2}-2 O A \cdot O C \cdot \cos \langle a, c\rangle=A C^{2}
\end{aligned}\tag{32}</script><p>对式（32）除以 $OC^2$ ，并且记 $x=O A / O C, y=O B / O C $ ，得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x^{2}+y^{2}-2 x y \cos \langle a, b\rangle=A B^{2} / O C^{2} \\
&y^{2}+1^{2}-2 y \cos \langle b, c\rangle=B C^{2} / O C^{2} \\
&x^{2}+1^{2}-2 x \cos \langle a, c\rangle=A C^{2} / O C^{2} 
\end{aligned}\tag{33}</script><p>记 $v=A B^{2} / O C^{2}, u v=B C^{2} / O C^{2}, w v=A C^{2} / O C^{2}$， 有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x^{2}+y^{2}-2 x y \cos \langle a, b\rangle-v=0 \\
&y^{2}+1^{2}-2 y \cos \langle b, c\rangle-u v=0 \\
&x^{2}+1^{2}-2 x \cos \langle a, c\rangle-w v=0
\end{aligned}\tag{34}</script><p>我们可以把第一个式子中的 $v$ 放到等式一边，并代人其后两式，得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(1-u) y^{2}-u x^{2}-\cos \langle b, c\rangle y+2 u x y \cos \langle a, b\rangle+1=0 \\
&(1-w) x^{2}-w y^{2}-\cos \langle a, c\rangle x+2 w x y \cos \langle a, b\rangle+1=0
\end{aligned}\tag{35}</script><p>我们现在来看已知量：三个余弦角是知道的，我们可以通过投影点在归一化平面上的坐标来求得。同时，$u=B C^{2} / A B^{2}$ ， $w=A C^{2} / A B^{2} $ 可以通过 $A, B, C$ 在世界坐标系下的坐标算出来。</p>
<p>在式（35）中，只有 $x,y$ 是未知的，随着相机移动会发生变化。因此式（35）是关于 $x,y$ 的二元二次方程，该方程解析解的求解是一个复杂的过程，要用到<strong>吴消元法</strong>。解得后可以得到4个解，同样我们可以通过验证点来得到最可能的解，<strong>即得到点 $A,B,C$ 在当前相机系下的坐标，然后再通过3D-3D的点对，计算相机的位姿。</strong></p>
<h3 id="3-最小化重投影误差求解PnP"><a href="#3-最小化重投影误差求解PnP" class="headerlink" title="3. 最小化重投影误差求解PnP"></a>3. 最小化重投影误差求解PnP</h3><h4 id="1-最小化重投影误差"><a href="#1-最小化重投影误差" class="headerlink" title="(1) 最小化重投影误差"></a>(1) 最小化重投影误差</h4><p>之前求解的方法中，如<strong>对极几何约束</strong>和<strong>直接线性变换方法求PnP</strong>这些方法，我们都是先根据匹配的特征点，求出相机的位姿，再进行三角化来求特征点的空间位置。但是在非线性优化中，<strong>则是同时把相机位姿和特征点的空间位置看为优化变量，放在一起优化。</strong>这一类方法称为 <strong>Bundle Adjustment</strong>，简称<strong>BA</strong>。</p>
<p>下面我们来看如何用BA来求解PnP问题，我们现在仅考虑在<strong>两个视图下</strong>的基本形式。</p>
<p>考虑 $n$ 个三维空间点 $P$ 及其投影 $p$，我们希望计算相机的位姿 $R, \boldsymbol{t}$，它的李群表示为 $T$ 。假设某空间点坐标为 $\boldsymbol{P}_{i}=\left[X_{i}, Y_{i}, Z_{i}\right]^{\mathrm{T}}$，其投影的像素坐标为 $\boldsymbol{u}_{i}=\left[u_{i}, v_{i}\right]^{\mathrm{T}}$ 。由相机模型，像素位置与空间点位置的关系如下（其中自动包括一次齐次坐标转换为非齐次坐标）：</p>
<script type="math/tex; mode=display">
s_{i} \boldsymbol{u}_{i}=KT \boldsymbol{P}_{i}\tag{36}</script><p>由于相机的位姿 $T$ 未知，以及观测点噪声，该等式存在一个误差。现在将误差求和，构建最小二乘问题，寻求最佳的相机位姿，使误差和最小：</p>
<script type="math/tex; mode=display">
T^{*}=\arg \min _{T} \frac{1}{2} \sum_{i=1}^{n}\left\|\boldsymbol{u}_{i}-\frac{1}{s_{i}} KT\boldsymbol{P}_{i}\right\|_{2}^{2}\tag{37}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220728190253.png" alt="image-20220728190253089" style="zoom:50%;" /></p>
<p>该问题的误差项，是将 3D 点的投影位置与观测位置作差，所以称为<strong>重投影误差</strong>。如图所示，我们通过特征匹配知道了 $p_{1}$ 和 $p_{2}$ 是同一个空间点 $P$ 的投影，但是不知道相机的位姿。在初始值中，$P$ 的投影 $\hat{p}_{2}$ 与实际的 $p_{2}$ 之 间有一定的距离。于是我们调整相机的位姿，使得这个距离变小。不过，由于这个调整需要考虑很多个点， 所以最后的效果是整体误差的缩小，而每个点的误差通常都不会精确为零。</p>
<p>之前我们学习了如何进行非线性优化，只其中很<strong>重要的一点是求误差项关于优化变量的导数</strong>，也就是雅可比矩阵 $J^T$ ，我们可以使用数值导数来求解，但是如果能得到解析形式，当然更好了。现在我们的误差 $\boldsymbol{e}$ 是2维的，而优化的变量是相机的位姿有6维，所以 $J^T$ 将是一个 $2\times6$ 的矩阵。</p>
<h4 id="2-推导-J-T"><a href="#2-推导-J-T" class="headerlink" title="(2) 推导 $J^T$"></a>(2) 推导 $J^T$</h4><p>记变换到相机坐标系下的空间点坐标系为: </p>
<script type="math/tex; mode=display">
\boldsymbol{P'}=[X',Y',Z']^T=T\boldsymbol{P}\tag{38}</script><p>根据相机模型，由 $\boldsymbol{P’}$ 到像素点坐标为：</p>
<script type="math/tex; mode=display">
s \boldsymbol{u}=K \boldsymbol{P}^{\prime}\tag{39}</script><p>由齐次坐标变为非齐次坐标，可以得到：</p>
<script type="math/tex; mode=display">
u=f_{x} \frac{X^{\prime}}{Z^{\prime}}+c_{x}, \quad v=f_{y} \frac{Y^{\prime}}{Z^{\prime}}+c_{y} \tag{40}</script><p>所以误差 $\boldsymbol{e}$ 为：</p>
<script type="math/tex; mode=display">
\boldsymbol{e}=\left[\begin{array}{c}
u'-u\\
v'-v
\end{array}\right]=\left[\begin{array}{c}
u'-f_x\frac{X'}{Z'}-c_x\\
v'-f_y\frac{Y'}{Z'}-c_y
\end{array}\right]\tag{41}</script><p>现在求误差 $\boldsymbol{e}$ 对相机的位姿进行求导。我们在李代数那一节已经推出，李群的导数可以转化成其左乘扰动 $\delta \boldsymbol\xi$ 后对扰动量 $\delta \boldsymbol\xi$ 的导数。利用链式求导法则，有：</p>
<script type="math/tex; mode=display">
\frac{\partial \boldsymbol{e}}{\partial \delta \boldsymbol{\xi}}=\lim _{\delta \boldsymbol{\xi} \rightarrow 0} \frac{\boldsymbol{e}(\delta \boldsymbol{\xi} \oplus \boldsymbol{\xi})-\boldsymbol{e}(\boldsymbol{\xi})}{\delta \boldsymbol{\xi}}=\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^{\prime}} \frac{\partial \boldsymbol{P}^{\prime}}{\partial \delta \boldsymbol{\xi}}\tag{42}</script><p>这里的 $\oplus$ 表示李代数上的左乘扰动。第一项是误差关于投影点的导数，因为误差中的 $u’和 v’$ 都是观测量，因此导数为0，所以有：</p>
<script type="math/tex; mode=display">
\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^{\prime}}=-\left[\begin{array}{ccc}
\frac{\partial u}{\partial X^{\prime}} & \frac{\partial u}{\partial Y^{\prime}} & \frac{\partial u}{\partial Z^{\prime}} \\
\frac{\partial v}{\partial X^{\prime}} & \frac{\partial v}{\partial Y^{\prime}} & \frac{\partial v}{\partial Z^{\prime}}
\end{array}\right]=-\left[\begin{array}{ccc}
\frac{f_{x}}{Z^{\prime}} & 0 & -\frac{f_{x} X^{\prime}}{Z^{\prime 2}} \\
0 & \frac{f_{y}}{Z^{\prime}} & -\frac{f_{y} Y^{\prime}}{Z^{\prime 2}}
\end{array}\right]\tag{43}</script><p>再来看第二项的导数为：</p>
<script type="math/tex; mode=display">
\frac{\partial\boldsymbol{P'}}{\partial\delta\boldsymbol\xi}=\frac{\partial(T \boldsymbol{P})}{\partial \delta \boldsymbol\xi}=(T\boldsymbol{P})^{\odot}=\left[\begin{array}{cc}
I & -\boldsymbol{P}^{\prime \wedge} \\
\mathbf{0}^{\mathrm{T}} & \mathbf{0}^{\mathrm{T}}
\end{array}\right]\tag{44}</script><p>取前3维即：</p>
<script type="math/tex; mode=display">
\frac{\partial \boldsymbol{P}^{\prime}}{\partial \delta \boldsymbol{\xi}}=\left[I,-\boldsymbol{P}^{\prime \wedge}\right] \tag{45}</script><p>将这两项相乘, 就得到了 $2 \times 6$ 的雅可比矩阵:</p>
<script type="math/tex; mode=display">
\frac{\partial \boldsymbol{e}}{\partial \delta \xi}=-\left[\begin{array}{cccccc}
\frac{f_{x}}{Z^{\prime}} & 0 & -\frac{f_{x} X^{\prime}}{Z^{\prime 2}} & -\frac{f_{x} X^{\prime} Y^{\prime}}{Z^{\prime 2}} & f_{x}+\frac{f_{x} X^{\prime 2}}{Z^{\prime 2}} & -\frac{f_{x} Y^{\prime}}{Z^{\prime}} \\
0 & \frac{f_{y}}{Z^{\prime}} & -\frac{f_{y} Y^{\prime}}{Z^{\prime 2}} & -f_{y}-\frac{f_{y} Y^{\prime 2}}{Z^{\prime 2}} & \frac{f_{y} X^{\prime} Y^{\prime}}{Z^{\prime 2}} & \frac{f_{y} X^{\prime}}{Z^{\prime}}
\end{array}\right] \tag{46}</script><p>除了对相机位姿优化，我们说过BA还可以对路标点的位置进行优化，这就需要求对空间点坐标 $\boldsymbol{P}$ 的导数，利用链式求导法则：</p>
<script type="math/tex; mode=display">
\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}}=\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^{\prime}} \frac{\partial \boldsymbol{P}^{\prime}}{\partial \boldsymbol{P}}\tag{47}</script><p>因为我们知道：</p>
<script type="math/tex; mode=display">
\boldsymbol{P'}=R\boldsymbol{P}+\boldsymbol{t}\tag{48}</script><p>所以 $\frac{\partial \boldsymbol{P}^{\prime}}{\partial \boldsymbol{P}}=R$ ，带入式（47）为：</p>
<script type="math/tex; mode=display">
\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}}=-\left[\begin{array}{ccc}
\frac{f_{x}}{Z^{\prime}} & 0 & -\frac{f_{x} X^{\prime}}{Z^{\prime 2}} \\
0 & \frac{f_{y}}{Z^{\prime}} & -\frac{f_{y} Y^{\prime}}{Z^{\prime 2}}
\end{array}\right]\tag{49}</script><h2 id="III-3D-3D：ICP"><a href="#III-3D-3D：ICP" class="headerlink" title="III. 3D-3D：ICP"></a>III. 3D-3D：ICP</h2><p>当知道某一路标点在两相机坐标系下的坐标时，就可以通过ICP来求解这两相机间的相对位姿。</p>
<p>假设我们有一组匹配好的3D点，在各自相机系下的坐标分别为：</p>
<script type="math/tex; mode=display">
\boldsymbol{P}=\left\{\boldsymbol{p}_{1}, \cdots, \boldsymbol{p}_{n}\right\}, \quad \boldsymbol{P}^{\prime}=\left\{\boldsymbol{p}_{1}^{\prime}, \cdots, \boldsymbol{p}_{n}^{\prime}\right\}\tag{50}</script><p>现在，想要找一个欧氏变换 $R, \boldsymbol t$，使得 $\forall i$ 有：</p>
<script type="math/tex; mode=display">
\boldsymbol{p}_{i}=R \boldsymbol{p}_{i}^{\prime}+\boldsymbol{t}\tag{51}</script><p>在ICP中，并没有出现相机模型，也就是说当考虑两组3D点变换时，和相机并没有关系。在激光SLAM中也会碰到ICP（只不过激光的数据信息不丰富，我们无从知道两个点集之间的匹配关系，只能认为距离最近的两个点为同一个）。和PnP问题类似，解决ICP问题也可以通过线性代数的方法求解，也可以通过非线性优化的方法求解。</p>
<h3 id="1-代数方法—SVD"><a href="#1-代数方法—SVD" class="headerlink" title="1. 代数方法—SVD"></a>1. 代数方法—SVD</h3><p>首先来看以 SVD 为代表的代数方法。根据前面描述的 ICP 问题，我们先定义第 $i$ 对点的误差项:</p>
<script type="math/tex; mode=display">
\boldsymbol{e}_{i}=\boldsymbol{p}_{i}-\left(R\boldsymbol{p}_{i}^{\prime}+\boldsymbol{t}\right)\tag{52}</script><p>然后构建最小二乘问题，找到使误差平方和达到极小的 $R 和 \boldsymbol{t}$ ：</p>
<script type="math/tex; mode=display">
\min _{R, \boldsymbol{t}} \frac{1}{2} \sum_{i=1}^{n}\left\|\left(\boldsymbol{p}_{i}-\left(R \boldsymbol{p}_{i}{ }^{\prime}+\boldsymbol{t}\right)\right)\right\|_{2}^{2}\tag{53}</script><p>现在求解式（53），首先定义两组点的质心：</p>
<script type="math/tex; mode=display">
\boldsymbol{p}=\frac{1}{n} \sum_{i=1}^{n}\left(\boldsymbol{p}_{i}\right), \quad \boldsymbol{p}^{\prime}=\frac{1}{n} \sum_{i=1}^{n}\left(\boldsymbol{p}_{i}^{\prime}\right)\tag{54}</script><p>然后随后在误差函数中做如下处理：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{1}{2} \sum_{i=1}^{n}\left\|\boldsymbol{p}_{i}-\left(\boldsymbol{R} \boldsymbol{p}_{i}{ }^{\prime}+\boldsymbol{t}\right)\right\|^{2}=& \frac{1}{2} \sum_{i=1}^{n}\left\|\boldsymbol{p}_{i}-\boldsymbol{R} \boldsymbol{p}_{i}{ }^{\prime}-\boldsymbol{t}-\boldsymbol{p}+\boldsymbol{R} \boldsymbol{p}^{\prime}+\boldsymbol{p}-\boldsymbol{R} \boldsymbol{p}^{\prime}\right\|^{2} \\
=& \frac{1}{2} \sum_{i=1}^{n}\left\|\left(\boldsymbol{p}_{i}-\boldsymbol{p}-\boldsymbol{R}\left(\boldsymbol{p}_{i}{ }^{\prime}-\boldsymbol{p}^{\prime}\right)\right)+\left(\boldsymbol{p}-\boldsymbol{R} \boldsymbol{p}^{\prime}-\boldsymbol{t}\right)\right\|^{2} \\
=& \frac{1}{2} \sum_{i=1}^{n}\left(\left\|\boldsymbol{p}_{i}-\boldsymbol{p}-\boldsymbol{R}\left(\boldsymbol{p}_{i}{ }^{\prime}-\boldsymbol{p}^{\prime}\right)\right\|^{2}+\left\|\boldsymbol{p}-\boldsymbol{R} \boldsymbol{p}^{\prime}-\boldsymbol{t}\right\|^{2}+2\left(\boldsymbol{p}_{i}-\boldsymbol{p}-\boldsymbol{R}\left(\boldsymbol{p}_{i}{ }^{\prime}-\boldsymbol{p}^{\prime}\right)\right)^{\mathrm{T}}\left(\boldsymbol{p}-\boldsymbol{R} \boldsymbol{p}^{\prime}-\boldsymbol{t}\right)\right) 
\end{aligned}\tag{55}</script><p>在式（55）中，注意到交叉项部分中 $\left(\boldsymbol{p}_{i}-\boldsymbol{p}-\boldsymbol{R}\left(\boldsymbol{p}_{i}{ }^{\prime}-\boldsymbol{p}^{\prime}\right)\right)$ 在求和之后为零，因此优化目标函数可以简化为：</p>
<script type="math/tex; mode=display">
\min _{R, \boldsymbol{t}} J=\frac{1}{2} \sum_{i=1}^{n}\left[\left\|\boldsymbol{p}_{i}-\boldsymbol{p}-R\left(\boldsymbol{p}_{i}^{\prime}-\boldsymbol{p}^{\prime}\right)\right\|^{2}+\left\|\boldsymbol{p}-R \boldsymbol{p}^{\prime}-\boldsymbol{t}\right\|^{2}\right]\tag{56}</script><p>仔细观察式（56）左右两项，左边一项只和旋转矩阵 $R$ 相关，而右边既有 $\boldsymbol{t}$ 也有 $R$ ，但只和质心相关（质心是一个确定的值）。所以我们只要获得了 $R$ ，再令右边一项为零就能得到 $\boldsymbol{t}$ 。</p>
<p>我们先定义去掉质心坐标 $\boldsymbol{q_i}，\boldsymbol{q_i}^{\prime}$ :</p>
<script type="math/tex; mode=display">
\boldsymbol{q}_{i}=\boldsymbol{p}_{i}-\boldsymbol{p}, \quad \boldsymbol{q}_{i}^{\prime}=\boldsymbol{p}_{i}^{\prime}-\boldsymbol{p}^{\prime}\tag{57}</script><p>现在把式（57）也就是去质心的坐标带入到（56）中，并展开右边第一项有：</p>
<script type="math/tex; mode=display">
\frac{1}{2} \sum_{i=1}^{n}\left\|\boldsymbol{q}_{i}-R \boldsymbol{q}_{i}^{\prime}\right\|^{2}=\frac{1}{2} \sum_{i=1}^{n}\left(\boldsymbol{q}_{i}^{\mathrm{T}} \boldsymbol{q}_{i}+\boldsymbol{q}_{i}^{\prime \mathrm{T}} R^{\mathrm{T}} R \boldsymbol{q}_{i}^{\prime}-2 \boldsymbol{q}_{i}^{\mathrm{T}} R \boldsymbol{q}_{i}^{\prime}\right)\tag{58}</script><p>看式（58）可知，我们想要通过调整 $R$ 来使这个式子最小，发现（58）中的前两项和 $R$ 都无关，所以只剩下最后一项了：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}-\boldsymbol{q}_{i}^{\mathrm{T}} R \boldsymbol{q}_{i}^{\prime}=\sum_{i=1}^{n}-\operatorname{tr}\left(R \boldsymbol{q}_{i}^{\prime} \boldsymbol{q}_{i}^{\mathrm{T}}\right)=-\operatorname{tr}\left(R \sum_{i=1}^{n} \boldsymbol{q}_{i}^{\prime} \boldsymbol{q}_{i}^{\mathrm{T}}\right)\tag{59}</script><p><strong>可以通过SVD方法求解出最优的 $R$</strong> ，然后可以求出最佳的 $\boldsymbol{t}$：</p>
<script type="math/tex; mode=display">
\boldsymbol{t^{*}}=p-R\boldsymbol p^{\prime}\tag{60}</script><h3 id="2-非线性优化方法"><a href="#2-非线性优化方法" class="headerlink" title="2. 非线性优化方法"></a>2. 非线性优化方法</h3><p>我们通过李代数来表达位姿，代价函数可以写成：</p>
<script type="math/tex; mode=display">
\min _{\boldsymbol{\xi}}=\frac{1}{2} \sum_{i=1}^{n}\left\|\left(\boldsymbol{p}_{i}-\exp \left(\boldsymbol{\xi}^{\wedge}\right) \boldsymbol{p}_{i}^{\prime}\right)\right\|_{2}^{2}\tag{61}</script><p>这里说明一下，可以证明ICP 问题存在唯一解或无穷多解的情况。在唯一解的情况下，只要能找到极小值解，这个极小值就是全局最优值，这也意味着 ICP 求解可以任意选定初始值。 这是已匹配点时求解 ICP 的一大好处。需要说明的是，我们这里讲的 ICP 是指已由图像特征给定了匹配的情况下进行位姿估计的问题。<strong>在匹配已知的情况下，这个最小二乘问题实际上具有解析解</strong>，所以并没有必要进行迭代 优化。</p>
<p><strong>既然在已知匹配的情况下可以得到解析解，为什么要用优化的方法呢？</strong>这是因为，某些场合下，例如在 RGB-D SLAM 中，一个像素的深度数据可能有，也可能测量不到，所以我们可以混合着使用 PnP 和 ICP 优化: 对于深度已知的特征点，建模它们的 3D-3D 误差；对于深度末知的特征点，则建模 3D-2D 的重投影误差。于是，可以将所有的误差放在同一个问题中考虑，使得求解更加方便。</p>
<h2 id="IV-三角测量"><a href="#IV-三角测量" class="headerlink" title="IV. 三角测量"></a>IV. 三角测量</h2><p>当我们求得两帧图像间的相机运动，就可以求得特征点在3D空间的位置了。这也就是三角测量问题，三角测量就是通过两帧图像，来确定一个特征点的深度。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220728040641.png" alt="image-20220728040641018" style="zoom: 67%;" /></p>
<p>考虑图像 $I_{1}$ 和 $I_{2}$，以左图为参考， 右图的变换矩阵为 $\boldsymbol{T}$ 。相机光心为 $O_{1}$ 和 $O_{2}$ 。在 $I_{1}$ 中有特征点 $\boldsymbol p_{1}$， 对应 $I_{2}$ 中有特征点 $\boldsymbol p_{2}$ 。 理论上，直线 $O_{1} p_{1}$ 与 $O_{2} p_{2}$ 在场景中会相交于一点 $P$ ，该点即两个特征点所对应的地图点在三维场景中的位置。然而由于噪声的影响，这两条直线往往无法相交。因此，可以通过最小二乘法求解。按照对极几何中的定义, 设 $\boldsymbol{x}_{1}, \boldsymbol{x}_{2}$ 为两个特征点的归一化坐标, 那么它们满足:</p>
<script type="math/tex; mode=display">
s_{2} \boldsymbol{x}_{2}=s_{1} \boldsymbol{R} \boldsymbol{x}_{1}+\boldsymbol{t} \tag{}</script><p>现在已知 $R, \boldsymbol{t}$ ，我们想求解两个特征点的深度 $s_{1}, s_{2}$ 。从几何上看, 可以在射线 $O_{1} p_{1}$ 上寻找 3D 点，使其投影位置接近 $\boldsymbol{p}_{2}$ 。同理，也可以在 $O_{2} p_{2}$ 上找，或者在两条线的中间找。不同的策略对应着不同的计算方式，当然它们大同小异。例如，我们希望计算 $s_{1}$，那么先对上式两侧左乘一 个 $\boldsymbol{x}_{2}^{\wedge}$，得</p>
<script type="math/tex; mode=display">
s_{2} \boldsymbol{x}_{2}^{\wedge} \boldsymbol{x}_{2}=0=s_{1} \boldsymbol{x}_{2}^{\wedge} \boldsymbol{R} \boldsymbol{x}_{1}+\boldsymbol{x}_{2}^{\wedge} \boldsymbol{t}</script><p>该式左侧为零，右侧可看成 $s_{2}$ 的一个方程，可以根据它直接求得 $s_{2}$ 。有了 $s_{2}, s_{1}$ 也非常容易求出。于是，我们就得到了两帧下的点的深度，确定了它们的空间坐标。当然，由于噪声的存在，我们估得的 $R, \boldsymbol{t}$ 不一定精确使上式为零，所以更常见的做法是求<strong>最小二乘解</strong>而不是直接的解。</p>
<p>三角测量是由平移得到的，有平移才会有对极几何中的三角形，才谈得上三角测量。因此，<strong>纯旋转是无法使用三角测量的</strong>，因为在平移为零时，对极约束一直为零。当然，实际数据往往不会完全等于零。在平移存在的情况下, 我们还要关心三角测量的不确定性，这会引出一个三角测量的矛盾。<strong>这个矛盾是，平移小了，深度的不确定性变大，因为相较于大平移，深度稍微差一点，就差出很多。而另一方面，大平移时，这会导致图像外观发生明显变化，使特征提取和匹配变得困难。</strong></p>
<p>在单目视觉中，由于单目图像没有深度信息，我们要等待特征点被追踪几帧之后，产生了足够的视角，再用三角化来确定新增特征点的深度值。这有时也被称为<strong>延迟三角化</strong> 。但是，如果相机发生了原地旋转，导致视差很小，就不好估计新观测到的特征点的深度。</p>
<h2 id="V-总结"><a href="#V-总结" class="headerlink" title="V. 总结"></a>V. 总结</h2><ol>
<li>对极几何约束中，约束不到相机运动的尺度，即不知道具体的平移向量的尺度，仅知道其方向。因此单目相机需要进行初始化，令初始的平移向量为单位，后面根据PnP问题，进行求解得到相机的运动。这些运动都是建立在初始化得到的单位上的。</li>
<li>单目相机初始化时，一定要有平移，不能是纯旋转，因为纯旋转时，本质矩阵或基础矩阵是0，因此求解不出来。</li>
<li>当发生纯旋转时，我们可以用单应矩阵来求解。但是此时不能进行三角化，所以还是不能得到空间点的相机坐标系下的坐标，因此初始化还是会失败（因为后面PnP要用到这些点的3D位置）。</li>
<li>PnP中的P3P方法，在已知空间点的世界坐标（或上一个相机系下的坐标）后，可以通过几何关系<strong>求出该空间点在当前相机系下的坐标</strong>。然后再通过ICP来求解相机的位姿。（先求相机系下坐标，再用ICP求相机运动）</li>
<li>运用李代数左乘扰动模型，可以计算出重投影误差相对于相机位姿和路标点位置的导数，也就是可以知道雅可比矩阵。</li>
<li>BA就是让相机位姿和路标点位置共同作为优化变量，而代价函数可以是3D-3D的误差，也可以是3D-2D的误差，然后进行非线性优化。在两帧图像之间，我们可以用BA来求解相机的位姿变化，和求出路标点的位置，这是前端使用的BA。但是BA也可以用在后端，此时是在许多帧图像中进行优化。</li>
</ol>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM13】前端——直接法计算相机位姿</title>
    <url>/2022/07/29/%E3%80%90%E8%A7%86%E8%A7%89SLAM13%E3%80%91%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E4%BD%8D%E5%A7%BF/</url>
    <content><![CDATA[<p>直接法就是不需要进行特征点匹配。在特征点法中，关键点的提取和描述子的计算特别耗时。另外，如果只提取特征点，就意味着同时也丢弃了大部分可能有用的图像信息。而且有时图像上并没有明显的特征，例如一堵白墙，这类场景下特征点数量会明显的减少。</p>
<span id="more"></span>
<p>直接法广义上可以理解为不进行特征点匹配，所以广义上的直接法包括：</p>
<ul>
<li>光流法：提取关键点，但并不计算描述子（描述子主要用来匹配的），跟踪关键点的运动（这就节省了特征匹配的步骤），<strong>然后再通过对极几何，PnP或ICP来求解相机位姿。</strong></li>
<li>直接法：完全不提取什么关键点（随机任意一点都可以），是通过<strong>最小化光度误差</strong>来进行求解。只要图像中存在明暗变化，这种纯直接法就能工作，根据使用像素点的数量，直接法可以分为稀疏、稠密和半稠密三种。所以直接法还具有回复稠密或半稠密结构的能力。</li>
</ul>
<h2 id="I-光流"><a href="#I-光流" class="headerlink" title="I. 光流"></a>I. 光流</h2><p>直接法是从光流演变而来的，它们具有相同的假设条件，即灰度不变假设。所以我们先来介绍光流。跟踪部分像素运动的称为<strong>稀疏光流</strong>，跟踪所有像素的称为<strong>稠密光流</strong>。稀疏光流以LK光流为代表，稠密光流以Horn-Schunck光流为代表。</p>
<h3 id="1-LK光流"><a href="#1-LK光流" class="headerlink" title="1. LK光流"></a>1. LK光流</h3><p>我们认为某一像素点的灰度值是时间的函数，所以可以记为 $I(t)$ ，因而有任意时间 $t$ ，位于 $(x,y)$ 处的像素，它的灰度值为：</p>
<script type="math/tex; mode=display">
I(x, y, t)\tag{1}</script><p>现在着眼于这个像素点，当相机发生运动后，这个像素点的位置会发生变化，而我们假设这个像素点在运动后，其灰度值也是不变的。注意这是一个假设性很强的条件，事实上可能是不成立的。所以有：</p>
<script type="math/tex; mode=display">
I(x+\mathrm{d} x, y+\mathrm{d} y, t+\mathrm{d} t)=I(x, y, t)\tag{2}</script><p>我们对式（2）左边进行泰勒展开：</p>
<script type="math/tex; mode=display">
I(x+\mathrm{d} x, y+\mathrm{d} y, t+\mathrm{d} t) \approx I(x, y, t)+\frac{\partial I}{\partial x} \mathrm{~d} x+\frac{\partial I}{\partial y} \mathrm{~d} y+\frac{\partial I}{\partial t} \mathrm{~d} t\tag{3}</script><p>把（2）带入（3）中可化简为：</p>
<script type="math/tex; mode=display">
\frac{\partial I}{\partial x} \mathrm{~d} x+\frac{\partial I}{\partial y} \mathrm{~d} y+\frac{\partial I}{\partial t} \mathrm{~d} t=0 \tag{4}</script><p>两边除以 $\mathrm{d} t$ ，得</p>
<script type="math/tex; mode=display">
\frac{\partial I}{\partial x} \frac{\mathrm{d} x}{\mathrm{~d} t}+\frac{\partial I}{\partial y} \frac{\mathrm{d} y}{\mathrm{~d} t}=-\frac{\partial I}{\partial t} \tag{5}</script><p>这里的 $dx/dt$ 和 $dy/dt$ 分别为该像素在 $x,y$ 轴上的运动速度，把它们记为 $u,v$ 。同时 $\partial I/\partial x$ 和 $\partial I/\partial y$ 分别表示该像素点 $x,y$ 方向的的灰度梯度，我们记为 $I_x,I_y$ ，把该像素点的灰度值对时间的变化量记为 $I_t$，则写成矩阵的形式有：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
I_{x} & I_{y}
\end{array}\right]\left[\begin{array}{l}
u \\
v
\end{array}\right]=-I_{t}\tag{6}</script><p>式（6）有两个变量，所以我们不能直接解出速度 $u,v$ ，所以我们还要假设在某一个窗口内的像素具有相同的运动。考虑一个 $w\times w$ 的窗口，它含有 $w^2$ 数量的像素。该窗口内像素具有同样的运动，因此我们可以建立 $w^2$ 个方程：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
I_{x} & I_{y}
\end{array}\right]_{k}\left[\begin{array}{l}
u \\
v
\end{array}\right]=-I_{t k}, \quad k=1, \ldots, w^{2}\tag{7}</script><p>写成矩阵为：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
&A\left[\begin{array}{c}
u \\
v
\end{array}\right]=-\boldsymbol{b}\\
&A=\left[\begin{array}{c}
{\left[I_{x}, I_{y}\right]_{1}} \\
\vdots \\
{\left[I_{x}, I_{y}\right]_{k}}
\end{array}\right], \boldsymbol{b}=\left[\begin{array}{c}
I_{t 1} \\
\vdots \\
I_{t k}
\end{array}\right] \\
\end{aligned}
\right.\tag{8}</script><p>这是一个超定线性方程，传统解法是求最小二乘解，可以得到一个解析解为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
u\\
v
\end{array}\right]^{*}=-\left(A^{\mathrm{T}} A\right)^{-1} A^{\mathrm{T}} \boldsymbol{b}\tag{9}</script><h3 id="2-优化方法求解光流"><a href="#2-优化方法求解光流" class="headerlink" title="2. 优化方法求解光流"></a>2. 优化方法求解光流</h3><p>我们还可以用优化的方法来追踪关键点位置，假设要追踪 $(x,y)$ 处的关键点，我们可以确定这样一个代价函数：</p>
<script type="math/tex; mode=display">
\min _{\Delta x, \Delta y}\left\|I_{1}(x, y)-I_{2}(x+\Delta x, y+\Delta y)\right\|_{2}^{2}\tag{10}</script><p>这里的雅可比矩阵是第二个图像在 $x+\Delta x$ ，$y+\Delta y$ 处的梯度。此外这里的梯度也可以用第一个图像 $I_1(x,y)$ 来替代，这种替代方法称为反向光流。</p>
<h3 id="3-多层光流"><a href="#3-多层光流" class="headerlink" title="3. 多层光流"></a>3. 多层光流</h3><p>我们把光流写成了优化问题，就必须假设优化的初始值靠近最优值，才能在一定程度上保障算法的收敛。如果相机运动较快, 两张图像差异较明显，那么单层图像光流法容易达到一个局部极小值。这种情况可以通过引人图像金字塔来改善。</p>
<p>图像金字塔是指对同一个图像进行缩放，得到不同分辨率下的图像，以原始图像作为金字塔底层，每往上一层，就对下层图像进行一定倍率的缩放，就得到了一个金字塔。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220729033627.png" alt="image-20220729033627398" style="zoom:50%;" /></p>
<p>然后，在计算光流时，<strong>先从顶层的图像开始计算，然后把上一层的追踪结果，作为下一层光流的初始值。</strong>由于上层的图像相对粗糙， 所以这个过程也称为<strong>由粗至精</strong> ( Coarse-to-fine) 的光流，也是实用光流法的通常流程。由粗至精的好处在于，当原始图像的像素运动较大时，在金字塔顶层的图像看来，运动仍然在一个很小范围内。</p>
<p><strong>注意：</strong></p>
<p>光流的计算速度很快，但是也有着容易跟丢或跟错的情况，这就需要后续算法拥有一定的异常去除机制。</p>
<h2 id="II-直接法"><a href="#II-直接法" class="headerlink" title="II. 直接法"></a>II. 直接法</h2><h3 id="1-直接法推导"><a href="#1-直接法推导" class="headerlink" title="1.直接法推导"></a>1.直接法推导</h3><p>在光流法中，我们还需要提取特征点，然后进行追踪。而直接法则不需要再提取特征点，直接根据图像来求取相机的位姿变化。考虑到空间点 $P$ 和两个时刻的相机，$P$ 的世界坐标为 $[X,Y,Z]^T$ ，在两个相机上的成像的像素坐标为 $\boldsymbol{p_1},\boldsymbol{p_2}$ 。 </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/pic/master/img-mac/20220807181201.png" alt="image-20220807181155545" style="zoom: 67%;" /></p>
<p>因此我们可以得到$\boldsymbol{p_1},\boldsymbol{p_2}$ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{p}_{1} &=\left[\begin{array}{c}
u \\
v \\
1
\end{array}\right]_{1}=\frac{1}{Z_{1}} K \boldsymbol{P} \\
\boldsymbol{p}_{2} &=\left[\begin{array}{l}
u \\
v \\
1
\end{array}\right]_{2}=\frac{1}{Z_{2}}K(R \boldsymbol{P}+\boldsymbol{t})
\end{aligned}\tag{11}</script><p>在特征点法中，我们是知道 $\boldsymbol{p_1},\boldsymbol{p_2}$ 的对应关系，可以通过最小化重投影误差来求解旋转矩阵 $R$ 和平移向量 $\boldsymbol{t}$ 。而在直接法中，我们不知道 $\boldsymbol{p_1},\boldsymbol{p_2}$ 的具体对应关系，直接法的思路是根据 $\boldsymbol{p_1}$ 所对应的光度值 $I(\boldsymbol{p_1})$ ，通过调整相机的位姿，来寻找 $\boldsymbol{p_2}$ 的位置使 $I(\boldsymbol{p_2})$ 和 $I(\boldsymbol{p_1})$ 相等。但实际上相等是很难做到的，所以我们要让这个误差最小，即光度误差最小：</p>
<script type="math/tex; mode=display">
e=I_{1}\left(\boldsymbol{p}_{1}\right)-I_{2}\left(\boldsymbol{p}_{2}\right)\tag{12}</script><p>我们要让这个误差最小，即：</p>
<script type="math/tex; mode=display">
\min _{\boldsymbol{T}} J(\boldsymbol{T})=\sum_{i=1}^{N} e_{i}^{\mathrm{T}} e_{i}, \quad e_{i}=\boldsymbol{I}_{1}\left(\boldsymbol{p}_{1, i}\right)-\boldsymbol{I}_{2}\left(\boldsymbol{p}_{2, i}\right)\tag{13}</script><p><strong>直接法的基础也是灰度不变假设，即一个空间点在各个视角下的成像的灰度值是不变的。</strong>为了求解这个优化问题，我们要求得误差 $e$ 是如何根据相机位姿 $T$ 变化的，即它们的导数关系。</p>
<p>定义中间变量：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{q} &=T \boldsymbol{P} \\
\boldsymbol{u} &=\frac{1}{Z_{2}} K \boldsymbol{q}
\end{aligned}\tag{14}</script><p>这里的 $\boldsymbol{q}$ 为 $P$ 在第二个相机坐标系下的坐标，而 $\boldsymbol{u}$ 为它的像素坐标。显然 $\boldsymbol{q}$ 是 $T$ 的函数，$\boldsymbol{u}$ 是 $\boldsymbol{q}$ 的函数，从而也是 $T$ 的函数。</p>
<p>根据引入的中间变量和根据李代数的左扰动模型，可以求出一阶雅可比矩阵 $J$ ，$e$ 对 $T$ 的导数为：</p>
<script type="math/tex; mode=display">
\frac{\partial e}{\partial T}=\frac{\partial {I}_{2}}{\partial \boldsymbol{u}} \frac{\partial \boldsymbol{u}}{\partial \boldsymbol{q}} \frac{\partial \boldsymbol{q}}{\partial \delta \boldsymbol{\xi}}\tag{15}</script><p>根据链式法则，我们将这个导数分为了三个部分：</p>
<ul>
<li>$\partial {I}_{2} / \partial \boldsymbol{u}$ 为 $\boldsymbol{u}$ 处的像素梯度。</li>
<li>$\partial \boldsymbol{u} / \partial \boldsymbol{q}$ 为投影方程关于相机坐标系下的三维点的导数。记 $\boldsymbol{q}=[X, Y, Z]^{\mathrm{T}}$ ，导数为<script type="math/tex; mode=display">
\frac{\partial \boldsymbol{u}}{\partial \boldsymbol{q}}=\left[\begin{array}{lll}
\frac{\partial u}{\partial X} & \frac{\partial u}{\partial Y} & \frac{\partial u}{\partial Z} \\
\frac{\partial v}{\partial X} & \frac{\partial v}{\partial Y} & \frac{\partial v}{\partial Z}
\end{array}\right]=\left[\begin{array}{ccc}
\frac{f_{x}}{Z} & 0 & -\frac{f_{x} X}{Z^{2}} \\
0 & \frac{f_{y}}{Z} & -\frac{f_{y} Y}{Z^{2}}
\end{array}\right]</script></li>
<li>$\partial \boldsymbol{q} / \partial \delta \boldsymbol{\xi}$ 为变换后的三维点对变换的导数，这在李代数一讲介绍过：</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial \boldsymbol{q}}{\partial \delta \boldsymbol{\xi}}=\left[\boldsymbol{I},-\boldsymbol{q}^{\wedge}\right]</script><p>所以雅可比矩阵为：</p>
<script type="math/tex; mode=display">
J=-\frac{\partial {I}_{2}}{\partial \boldsymbol{u}} \frac{\partial \boldsymbol{u}}{\partial \delta \boldsymbol{\xi}}\tag{16}</script><h3 id="2-直接法讨论"><a href="#2-直接法讨论" class="headerlink" title="2. 直接法讨论"></a>2. 直接法讨论</h3><p>在直接法中，<strong>我们需要知道 $P$ 点的三维坐标，</strong>才能求出相机的位姿变换。这里要说明一下，关于 $P$ 的三维坐标，准确地说也就是知道 $P$ 点的深度，只要知道深度信息，那么三维坐标就可以根据相机模型直接求出来。</p>
<p>当 $P$ 点的深度已知，我们可以把直接法进行分类：</p>
<p>（1）当 $P$ 来自于稀疏关键点，我们称之为稀疏直接法。通常，我们使用数百个至上千个关键点，并且像 L-K 光流那样，<strong>假设它周围像素也是不变的</strong>。这种稀疏直接法不必计算描述子，并且只使用数百个像素，因此速度最快，但只能计算稀疏的重构。</p>
<p>（2）$P$ 来自部分像素。我们看到式（16）中，如果像素梯度为零，那么整项雅可比矩阵就为零，不会对计算运动增量有任何贡献。因此，可以考虑只使用带有梯度的像素点，舍弃像素梯度不明显的地方。这称为半稠密 ( Semi-Dense ) 的直接法，可以重构一个半稠密结构。</p>
<p>（3）$P$ 为所有像素，称为稠密直接法。稠密重构需要计算所有像素 (一般几十万至几百万个)，因此多数不能在现有的 CPU 上实时计算，需要 GPU 的加速。但是，如前面讨论的，像素梯度不明显的点，在运动估计中不会有太大贡献，在重构时也会难以估计位置。</p>
<p><strong>总结：</strong></p>
<ul>
<li>直接法相比于传统的特征点法和光流通常会快一些</li>
<li>直接法完全依靠于优化来求解相机位姿，在优化中像素梯度引导着优化增量变化的方向。然而图像通常是一个很强烈的非凸函数，只有当相机运动很小时，图中的梯度不会有很强的非凸性时，直接法才能成立。</li>
<li>实际中，单个像素点和周围的像素点的亮度都差不多，所以会使用小图像块和更复杂的差异度量。</li>
<li>直接法不需要提取特征点，在实际场景中，有些是无法提取出特征点或角点的，所以在这些场景中，直接法的优势很大。</li>
<li>直接法可以构建半稠密和稠密地图，这是特征点法无法做到的。</li>
<li>直接法的假设是灰度值不变，但如果相机是自动曝光的，会使图像整体变量或变暗。这时会导致直接法失效。</li>
</ul>
]]></content>
      <categories>
        <category>专业原理</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
</search>
