<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SLAM的数学描述</title>
    <url>/2021/10/18/SLAM%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<p>主要介绍如何使用数学语言来描述SLAM问题。<br><span id="more"></span><br>设 $\vec{x}$ 表示相机的位置，$\vec x_1\ , \ \vec x_2 \ …\ ,\vec x_k$表示不同时刻的位置信息，$\vec y_1 \ , \vec y_2 \ ,\ …\ \vec y_n$表示路标的位置，共有n个路标点</p>
<hr>
<p>我们的<strong>目标是：</strong>描述以下两件事情：</p>
<ol>
<li>什么是运动 ：k-1时刻到k时刻，$\vec x$是如何变化的</li>
<li>什么是观测：在k时刻，相机在 $\vec x_k$处探测到某一路标，$\vec y_j$​ </li>
</ol>
<hr>
<p>首先来说关于 <strong><u>运动</u></strong> 的数学描述：</p>
<script type="math/tex; mode=display">
\vec x_k = f(\vec x_{k-1}\ , \vec u_k\ ,\vec w_k)</script><p>$\vec u_k$表示k时刻运动的输入(可以是传感器读出来的速度或者是通过视觉里程计估算出来的速度)，$\vec w_k$表示噪声</p>
<p>接下来说关于 <strong><u>观测</u></strong> 的表述：</p>
<script type="math/tex; mode=display">
\vec z_{k,j}=h(\vec y_j\ ,\vec x_k \ ,\vec {v_{k,j}})</script><p>该式表示的是相机在位置 $\vec x_k$上看到某个路标点 $\vec y_j$时，产生了一个观测数据 $\vec z_{k,j}$ ，而 $\vec v_{k,j}$表示观测噪声</p>
<hr>
<p>以二维运动为例：</p>
<p>如图所示</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018023849.png" style="zoom:60%;" /></p>
<p>已知上一时刻k-1的相机位姿 $\vec x_{k-1}$ 和运动输入$\vec{u}_{k}$（在视觉SLAM中可以由视觉里程计得出或通过传感器得出）</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\vec{x}_{k}=\left[x_{1}, x_{2}, \theta\right]_{k}^{\top} \\
&\vec{u}_{k}=\left[\Delta x_{1}, \Delta x_{2}, \Delta \theta\right]_{k}^{\top}
\end{aligned}</script><p>运动方程为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{1} \\
x_{2} \\
\theta
\end{array}\right]_{k}=\left[\begin{array}{l}
x_{1} \\
x_{2} \\
\theta
\end{array}\right]_{k-1}+\left[\begin{array}{c}
\Delta x_{1} \\
\Delta x_{2} \\
\Delta \theta
\end{array}\right]_{k}+\vec{w}_{k}</script><p>对于观测方程，以二维激光传感器为例，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018023854.png" alt="img" style="zoom:60%;" /></p>
<p>路标点j与相机位置关系由距离r和夹角 $\varphi$表示，即观测数据 $z_{k,j}=[r_{j},\varphi_{j}]^T_k$（这是由传感器测出的值），这里的k表示k时刻下的观测数据</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
r_{j} \\
\varphi_{j}
\end{array}\right]_k=\left[\begin{array}{c}
\sqrt{\left(x_{1,k}-y_{1, j}\right)^{2}+\left(x_{2,k}, -y_{2, j}\right)^{2}} \\
\arctan \left(\frac{y_{2,j} -x_{2, k}}{y_{1, j}-x_{1, k}}\right)
\end{array}\right]+\vec{v}</script><p>$\vec{v}$是观测误差，现在就要求 $\vec x_k$和 $\vec y_j$</p>
<blockquote>
<p>注意：这里求 $\vec x_k$表示定位问题，即求出相机自己本身在世界坐标系下的坐标，而求出 $\vec y_j$表示建图问题，即求出周围环境中路标点在世界坐标系下的坐标</p>
</blockquote>
<p>如果求出了 $\vec x_k$和 $\vec y_j$，这样就可以确定相机位置与路标点的位置，也就完成了定位和建图，而反看上面的运动方程和观测方程，假如没有噪声的存在，那么直接解方程就是了，就可以准确的求出相机和路标点在世界坐标系下的位置，然而现实并不是这样，由于噪声的存在，<strong>解方程的问题就变成了一个状态估计问题</strong>，这也是SLAM的最基本问题。</p>
<p>按照运动和观测方程是否为线性和噪声是否服从高斯分布，可以分为以下几类以及解决其状态估计的办法：</p>
<p>线性高斯分布（LG）$\longrightarrow$ 卡尔曼滤波（KF）</p>
<p>非线性非高斯分布（NLNG）$\longrightarrow$扩展卡尔曼滤波（EKF）或非线性优化</p>
]]></content>
      <categories>
        <category>SLAM学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode编译环境配置</title>
    <url>/2021/10/18/VScode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在linux或mac中编译C++,首先要配置好编译环境。<br><span id="more"></span></p>
<h1 id="1-首先编写CMakeLists-txt文件"><a href="#1-首先编写CMakeLists-txt文件" class="headerlink" title="1.首先编写CMakeLists.txt文件"></a>1.首先编写CMakeLists.txt文件</h1><p>注意：在<code>c_cpp_properties.json</code>中设置了头文件路径，在编译的过程中就会有头文件内容的提示，但仍需要在<code>CMakeLists.txt</code>中写好包含的头文件路径，否则编译器只会在<code>usr/include文件夹下</code>和<code>CMakeLists.txt</code>所在文件夹下寻找头文件</p>
<p>如果不在<code>c_cpp_properties.json</code>中设置头文件路径，在写代码的时候可能会没有提示，而且头文件名字下会有红波浪线，但可以正常编译</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(文件名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ VAR) <span class="comment">#把当前路径下的所有源文件打包程VAR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(添加头文件路径)<span class="comment">#如果在vscode中已经添加了头文件路径了，就不需要再添加了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(搜索库)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;添加库的头文件&#125;</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)<span class="comment">#如果想调试，加上这一句，生成可调试文件</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS<span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;</span>)<span class="comment">#生成错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(可执行文件名 <span class="variable">$&#123;VAR&#125;</span>)<span class="comment">#生成可执行文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件 库名) <span class="comment">#链接库</span></span><br></pre></td></tr></table></figure>
<h1 id="2-文件根目录中建立一个build文件夹"><a href="#2-文件根目录中建立一个build文件夹" class="headerlink" title="2.文件根目录中建立一个build文件夹"></a>2.文件根目录中建立一个build文件夹</h1><p>编译过程中生成的中间文件和可执行文件全在该文件夹下，可执行文件的位置可在CMakeLists.txt中改变路径</p>
<h1 id="3-建立-json文件夹，编写launch-json文件"><a href="#3-建立-json文件夹，编写launch-json文件" class="headerlink" title="3.建立.json文件夹，编写launch.json文件"></a>3.建立.json文件夹，编写launch.json文件</h1><p>新建launch.json文件，该文件是在VSCODE中按F5后所执行的命令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/可执行文件名&quot;</span>,**<span class="comment">//执行文件的路径加上可执行文件，$&#123;workspaceFolder&#125;为根目录**</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,<span class="comment">//打开外部终端</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">             <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;Build&quot;</span>,<span class="comment">//该命令表示执行launch.json的命令之前的预执行任务，要在tasks.json中设置</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-编写tasks-json文件"><a href="#4-编写tasks-json文件" class="headerlink" title="4.编写tasks.json文件"></a>4.编写tasks.json文件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>:<span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOrder&quot;</span>: <span class="string">&quot;sequence&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span>:[<span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;make&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件实践</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>编程</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建课程笔记</title>
    <url>/2021/10/18/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习北邮鲁鹏老师《机器视觉》笔记。<br>三维重建的目标就是从单张或多张场景图片中重构出三维场景的结构信息。<br><span id="more"></span></p>
<h2 id="一、摄像机几何"><a href="#一、摄像机几何" class="headerlink" title="一、摄像机几何"></a>一、摄像机几何</h2><h3 id="A-针孔摄像机模型"><a href="#A-针孔摄像机模型" class="headerlink" title="A.针孔摄像机模型"></a>A.针孔摄像机模型</h3><p>首先，我们要知道三维世界中的点是如何映射到像素平面的，完成这个映射过程就是摄像机。</p>
<p>如果直接让胶片放置在物体的前方，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040014.png" alt="image-20210818224820393"></p>
<p>那么此时胶片上的一个点会记录真实世界多个点的信息。这样是不行的，于是我们采用针孔模型：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040016.png" alt="image-20210818224930850"></p>
<p>通过一个带有小孔的屏障，我们便可以使像素平面上的点与真实世界上的点形成一一对应的关系，这就是针孔相机模型。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040022.png" alt="image-20210818225105759"></p>
<p>下面具体描述一下<strong>针孔摄像机模型：</strong></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040034.png" alt="image-20210818230044519"></p>
<blockquote>
<p>要注意三个坐标系：</p>
<p>1.相机坐标系：以针孔为原点，建立的三维坐标系，其坐标轴单位是米</p>
<p>2.像平面坐标系：以像平面中心为原点的三维坐标系，坐标轴单位是米</p>
<p>3.像素坐标系：与像平面重合的二维坐标系，其坐标轴单位是像素</p>
</blockquote>
<p>根据三角形相似法则，最终可以得到相机坐标系下的P点到像平面坐标系的P‘点的映射关系：</p>
<script type="math/tex; mode=display">
P=\left[\begin{array}{l}
x \\
y \\
z
\end{array}\right] \rightarrow P^{\prime}=\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]\tag{1.1}</script><script type="math/tex; mode=display">
\quad\left\{\begin{array}{l}
x^{\prime}=f \frac{x}{z} \\
y^{\prime}=f \frac{y}{z}
\end{array}\right.\tag{1.2}</script><h3 id="B-摄像机和透镜"><a href="#B-摄像机和透镜" class="headerlink" title="B.摄像机和透镜"></a>B.摄像机和透镜</h3><p>光圈就是针孔模型中的小孔，小孔的大小决定了像的清晰程度和亮度</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040040.png" alt="image-20210818231502207"></p>
<p>如果光圈太大，像中的一个点会对应真实世界中的多个点，此时图像会模糊，但是光圈太小，又会使透过的光变少，像变暗。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040044.png" alt="image-20210818231844139"></p>
<p>那么如何才能使像既清晰又明亮呢？</p>
<p>增加透镜！！！</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040047.png" alt="image-20210818232135974"></p>
<p>透镜的特点：</p>
<p>1.所有平行于光轴的光线都会会聚到焦点，焦点到透镜中心的距离称为焦距</p>
<p>2.穿过中心的光线的方向不发生改变</p>
<h4 id="1-加上透镜后的针孔模型"><a href="#1-加上透镜后的针孔模型" class="headerlink" title="1.加上透镜后的针孔模型"></a>1.加上透镜后的针孔模型</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040053.png" alt="image-20210818232418455"></p>
<p>该模型与之前的针孔模型区别不大，只是针孔模型中的 $f$ 变为 $z’$ </p>
<script type="math/tex; mode=display">
z^{\prime}=f+z_{0} \quad\left\{\begin{array}{l}
x^{\prime}=z^{\prime} \frac{x}{z} \\
y^{\prime}=z^{\prime} \frac{y}{z}
\end{array}\right.\tag{1.3}</script><p>此处的 $f$ 是透镜的焦距，其与透镜的自身性质有关。</p>
<h4 id="2-透镜引起的问题"><a href="#2-透镜引起的问题" class="headerlink" title="2.透镜引起的问题"></a>2.透镜引起的问题</h4><h5 id="a-失焦"><a href="#a-失焦" class="headerlink" title="a.失焦"></a>a.失焦</h5><p>可以看到加上了透镜好处多多，但是也会引起一个问题，在一定的范围内，光线会会聚到像平面上，但是当超过了这个范围，光线就不会会聚到像平面上，此时便发生失焦。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040100.png" alt="image-20210818233432270"></p>
<h5 id="b-径向畸变"><a href="#b-径向畸变" class="headerlink" title="b.径向畸变"></a>b.径向畸变</h5><p>图像像素点以畸变中心为中心点，沿着径向产生位置偏差，从而导致图像中所成的像发生形变</p>
<p>枕形畸变：畸变像点相对于理想像点沿径向向外偏移，远离中心</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040104.png" alt="image-20210818233754147"></p>
<p>桶形畸变：畸变像点相对于理想像点沿径向向内偏移，向中心靠拢</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040106.png" alt="image-20210818233846093"></p>
<h3 id="C-摄像机几何"><a href="#C-摄像机几何" class="headerlink" title="C.摄像机几何"></a>C.摄像机几何</h3><p>在我们分析图像时，是在像素坐标系下分析的，像素坐标系和像平面坐标系的区别是，像素坐标系</p>
<p>是二维的，其坐标轴单位是像素，且其坐标原点一般不是在最中心，这就会发生一个坐标的偏移。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040108.png" alt="image-20210818234715959" style="zoom: 67%;" /></p>
<p>因此，需要根据像平面坐标系中点的坐标，求出该点在像素坐标系下的坐标：</p>
<script type="math/tex; mode=display">
P=(x, y, z) \rightarrow P^{\prime}=\left(u,v\right)\\
\left\{\begin{array}{l}
u=\alpha \frac{x}{z}+c_{x}\\
v=\beta \frac{y}{z}+c_{y}
\end{array}\right.\tag{1.4}</script><p>可是此时，空间点 $P$ 到 像素点 $P’$ 的坐标变换并不是一个线性变换，如果想变成一个线性变换，需要引入齐次坐标来表达。</p>
<h4 id="1-齐次坐标"><a href="#1-齐次坐标" class="headerlink" title="1.齐次坐标"></a>1.齐次坐标</h4><p>我们之前所使用的都是欧式坐标，例如三维空间中的一点，可以用 $(x,y,z)$ 来表示，此时在原有维数的基础上再添一维，就变成了齐次坐标。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040113.png" alt="image-20211004222903357" style="zoom:50%;" /></p>
<p>对于齐次坐标 $(1,1,1)$ 和 $(2,2,2)$ ，其所对应的欧式坐标都是 $(1,1)$ ，所以，对于齐次坐标 P 和 Q，如果P=kQ，那么 P 和 Q 对应同一个欧式坐标。</p>
<h4 id="2-齐次坐标的投影变换"><a href="#2-齐次坐标的投影变换" class="headerlink" title="2.齐次坐标的投影变换"></a>2.齐次坐标的投影变换</h4><p>引入齐次坐标后，空间点的齐次坐标与所对应的像素点的齐次坐标可以用一个线性变换来表达：</p>
<script type="math/tex; mode=display">
P_{h}^{\prime}=\left[\begin{array}{c}
\alpha x+c_{x} z \\
\beta y+c_{y} z \\
z
\end{array}\right]=\left[\begin{array}{cccc}
\alpha & 0 & c_{x} & 0 \\
0 & \beta & c_{y} & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
z \\
1
\end{array}\right]=MP_h\tag{1.5}</script><script type="math/tex; mode=display">
\overbrace{P_{h}^{\prime}}^{\text {齐次坐标 }} \rightarrow \overbrace{P^{\prime}=\left(\alpha \frac{x}{z}+c_{x}, \beta \frac{y}{z}+c_{y}\right)}^{\text {欧式坐标}}\tag{1.6}</script><p>M矩阵是摄像机的投影矩阵。</p>
<h4 id="3-摄像机偏斜"><a href="#3-摄像机偏斜" class="headerlink" title="3.摄像机偏斜"></a>3.摄像机偏斜</h4><p>有的时候，像素坐标系的两个坐标轴不是垂直的</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040121.png" alt="image-20210819004057419"></p>
<p>此时投影矩阵M为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{cccc}
\alpha & -\alpha \cot \theta & c_{x} & 0 \\
0 & \frac{\beta}{\sin \theta} & c_{y} & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\tag{1.7}</script><h4 id="4-摄像机内参数矩阵"><a href="#4-摄像机内参数矩阵" class="headerlink" title="4.摄像机内参数矩阵"></a>4.摄像机内参数矩阵</h4><p>上文提到的M前三列所构成的3*3矩阵称为摄像机的内参数矩阵K，它由摄像机的制作工艺决定。</p>
<script type="math/tex; mode=display">
M=K[I\ 0]\tag{1.8}</script><p>摄像机的内参数决定了空间点到图像点的映射。</p>
<p>摄像机的内参数矩阵共有5个自由度。</p>
<p>当K矩阵为单位阵时，此时的相机称为规范化相机，其变换叫做规范化投影变换。</p>
<blockquote>
<p>小结：当已知空间点坐标和相机内参时，一定可以求出像素点坐标。而仅知道像素点坐标和内参时，反求不出空间点坐标。因为像素点的欧式坐标对应无数个齐次坐标（尺度不确定问题）</p>
</blockquote>
<h4 id="5-世界坐标系的点到像素坐标系"><a href="#5-世界坐标系的点到像素坐标系" class="headerlink" title="5.世界坐标系的点到像素坐标系"></a>5.世界坐标系的点到像素坐标系</h4><p>在世界坐标系下，同一个点在不同相机的坐标系下坐标不同。</p>
<p>世界坐标系的坐标到相机坐标系的坐标可由下面式子来描述：</p>
<script type="math/tex; mode=display">
P=\left[\begin{array}{ll}
R & T \\
0 & 1
\end{array}\right] P_{w}=\left[\begin{array}{ll}
R & T \\
0 & 1
\end{array}\right] \left[\begin{array}{c}
x_{w} \\
y_{w} \\
z_{w} \\
1
\end{array}\right]\tag{1.9}</script><p>已知世界坐标系一点坐标，映射到像素坐标系中为：</p>
<script type="math/tex; mode=display">
P^{\prime}=K\left[\begin{array}{ll}
I & 0
\end{array}\right] P=K\left[\begin{array}{ll}
I & 0
\end{array}\right]\left[\begin{array}{cc}
R & T \\
0 & 1
\end{array}\right] P_{w}=\overbrace{K}^{内部参数}
\overbrace{[R \quad T]}^{外部参数}
P_{w}=M P_{w}\tag{1.10}</script><p>此时的投影矩阵M，既包含相机的内参信息，又包含了相机的运动信息（外部参数），M共有11个自由度。</p>
<h4 id="6-透视投影相机"><a href="#6-透视投影相机" class="headerlink" title="6.透视投影相机"></a>6.透视投影相机</h4><p>之前所得到的M矩阵叫做投影矩阵，它代表着透视投影模型，也就是三维真实空间到图像上的投影过程。符合该模型的相机称为透视投影相机，我们生活中的大多数相机都是透视投影相机，人类的眼睛也符合该模型。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040127.jpg" alt="img"></p>
<p>透视投影有以下几个特点：</p>
<ol>
<li>点投影为点</li>
<li>线投影为线</li>
<li>近大远小</li>
<li>角度不再保持</li>
<li>平行线相交</li>
</ol>
<h4 id="7-Faugeras定理"><a href="#7-Faugeras定理" class="headerlink" title="7.Faugeras定理"></a>7.Faugeras定理</h4><p>我们知道投影矩阵M是3 <em> 4的矩阵，当已知任意3 </em> 4的矩阵时，是否是投影矩阵呢？可以用Faugeras定理来进行判断。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040132.png" alt="image-20210819012316783"></p>
<h3 id="D-其他摄像机模型"><a href="#D-其他摄像机模型" class="headerlink" title="D.其他摄像机模型"></a>D.其他摄像机模型</h3><h4 id="1-弱透视投影摄像机"><a href="#1-弱透视投影摄像机" class="headerlink" title="1.弱透视投影摄像机"></a>1.弱透视投影摄像机</h4><p>当空间点的深度相差不多时，即相对场景深度小于其与相机的距离。可以简化为在同一深度。此时便是弱透视投影相机模型。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040138.png" alt="image-20210819101236994" style="zoom: 67%;" /></p>
<p>这里与透视投影相机的不同是其各点的深度是一个定值，且相同</p>
<script type="math/tex; mode=display">
\left\{\begin{array} { l } 
{ x ^ { \prime } = \frac { f ^ { \prime } } { z } x } \\
{ y ^ { \prime } = \frac { f ^ { \prime } } { z } y }
\end{array} \rightarrow \left\{\begin{array}{l}
x^{\prime}=\frac{f^{\prime}}{z_{0}} x \\
y^{\prime}=\frac{f^{\prime}}{z_{0}} y
\end{array}\right.\right.\tag{1.11}</script><p>通过这个简化后，投影矩阵的第三行变成了 $[0,0,0,1]$ </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040144.png" alt="image-20210819103539119" style="zoom:67%;" /></p>
<p>当物体较小且较远时准确，常用于图像识别任务。</p>
<h4 id="2-正交投影摄像机"><a href="#2-正交投影摄像机" class="headerlink" title="2.正交投影摄像机"></a>2.正交投影摄像机</h4><p>摄像机中心到像平面的距离无限远时</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040149.png" alt="image-20210819104040178" style="zoom: 50%;" /></p>
<p>此时像平面上投影点的x，y方向的坐标等于实际空间点的坐标。</p>
<p>该模型常用于CAD制图时使用。</p>
<h2 id="二、摄像机标定"><a href="#二、摄像机标定" class="headerlink" title="二、摄像机标定"></a>二、摄像机标定</h2><p>摄像机标定就是求解摄像机的内外参数，更为准确的说，一般的相机内参数是不变的，而外参代表着相机的运动，是时刻改变的，所以一般的相机标定是对相机的内参的计算。</p>
<h3 id="A-标定方法-PnP的直接线性变换解法"><a href="#A-标定方法-PnP的直接线性变换解法" class="headerlink" title="A.标定方法(PnP的直接线性变换解法)"></a>A.标定方法(PnP的直接线性变换解法)</h3><h4 id="1-标定设备"><a href="#1-标定设备" class="headerlink" title="1.标定设备"></a>1.标定设备</h4><p> 如下图所示，有一个标定板，上面的每个点的坐标都已知。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040155.png" alt="image-20210820145956320"></p>
<p>然后对该标定板拍照，得到图像，可以得到空间点的坐标 $P_i$ 和其对应点的像素坐标 $p_i$ 。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040200.png" alt="image-20210820150231966"></p>
<h4 id="2-建立线性方程组"><a href="#2-建立线性方程组" class="headerlink" title="2.建立线性方程组"></a>2.建立线性方程组</h4><p>由上文提到，投影矩阵M是一个3*4的矩阵，可以表示为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{l}
m_1\\
m_2\\
m_3\\
\end{array}\right]\tag{2.1}</script><p>其中 $m_i$ 是一个4阶的行向量。</p>
<p>根据前面的透视投影关系，可以得到像素坐标和世界坐标的关系：</p>
<script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=\left[\begin{array}{l}
\frac{m_{1} P_{i}}{m_{3} P_{i}} \\
\frac{m_{2} P_{i}}{m_{3} P_{i}}
\end{array}\right]\tag{2.2}</script><p>知道一对对应点（ $P_i$ 和 $p_i$ 为已知），就可以得到两个方程，而M矩阵共有11个自由度，理论上用6对点便可以求解。但实际中会选6对以上的点来计算，这样可以提高结果的鲁棒性。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&u_{i}=\frac{m_{1} P_{i}}{m_{3} P_{i}} \rightarrow u_{i}\left(m_{3} P_{i}\right)=m_{1} P_{i} \rightarrow u_{i}\left(m_{3} P_{i}\right)-m_{1} P_{i}=0 \\
&v_{i}=\frac{m_{2} P_{i}}{m_{3} P_{i}} \rightarrow v_{i}\left(m_{3} P_{i}\right)=m_{2} P_{i} \rightarrow v_{i}\left(m_{3} P_{i}\right)-m_{2} P_{i}=0
\end{aligned}\tag{2.3}</script><p>可以将每个点的方程整理成(2.3)的形式，便可以得到一个线性方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
u_{1}\left(m_{3} P_{1}\right)-m_{1} P_{1}=0 \\
v_{1}\left(m_{3} P_{1}\right)-m_{2} P_{1}=0 \\
\vdots \\
u_{i}\left(m_{3} P_{i}\right)-m_{1} P_{i}=0 \\
v_{i}\left(m_{3} P_{i}\right)-m_{2} P_{i}=0 \\
\vdots \\
u_{n}\left(m_{3} P_{n}\right)-m_{1} P_{n}=0 \\
v_{n}\left(m_{3} P_{n}\right)-m_{2} P_{n}=0
\end{array}\right.\tag{2.4}</script><p>然后将上式写成矩阵的形式：</p>
<script type="math/tex; mode=display">
Pm=0\tag{2.5}\\
\begin{aligned}
P \stackrel{\text { def }}{=}\left(\begin{array}{ccc}
P_{1}^{T} & 0^{T} & -u_{1} P_{1}^{T} \\
0^{T} & P_{1}^{T} & -v_{1} P_{1}^{T} \\
& \vdots & \\
P_{n}{ }^{T} & 0^{T} & -u_{n} P_{n}{ }^{T} \\
0^{T} & P_{n}^{T} & -v_{n} P_{n}{ }^{T}
\end{array}\right)_{2 n \times 12}m \stackrel{\text { def }}{=}\left(\begin{array}{c}
{m_{1}^{T}} \\
{m_{2}^{T}} \\
m_{3}^{T}
\end{array}\right)_{12 \times 1}
\end{aligned}</script><blockquote>
<p>注意这里的 $P_i$ 是空间点的齐次坐标</p>
</blockquote>
<h4 id="3-求解方程组"><a href="#3-求解方程组" class="headerlink" title="3.求解方程组"></a>3.求解方程组</h4><p>P矩阵中所有的元素是已知的，下面求解该线性方程：P的行数有2n个，列数有12个。</p>
<p>当P的秩小于12时，该方程组有非零解。</p>
<p>当P的秩大于等于12时，此时为超定方程，该方程组只有0解。</p>
<p>通常情况下，P矩阵的秩都大于12，这样就解不了该方程。</p>
<p><strong>现在该怎么办呢？答案是采用优化的思想，找到合适的m， 让其$||m||$为1 ，使 $||Pm||$ 最小。</strong></p>
<p>对于该优化问题的解，先对P矩阵进行奇异值分解，可以得到：</p>
<script type="math/tex; mode=display">
P=U_{2n\times12}D_{12\times12}V_{12\times12}^T\tag{2.6}</script><p>m为P矩阵最小奇异值的右奇异向量，且 $||m||=1$ ，求得m后，便可以得到投影矩阵M。</p>
<script type="math/tex; mode=display">
\boldsymbol{m} \stackrel{\text { def }}{=}\left(\begin{array}{c}
m_{1}^{T} \\
m_{2}^{T} \\
m_{3}^{T}
\end{array}\right) \rightarrow M=\left[\begin{array}{c}
m_{1} \\
m_{2} \\
m_{3}
\end{array}\right]=[A\ b]\tag{2.7}</script><h4 id="4-提取摄像机参数"><a href="#4-提取摄像机参数" class="headerlink" title="4.提取摄像机参数"></a>4.提取摄像机参数</h4><p>我们知道，投影矩阵M包括相机的内参和外参信息，当得到M后，需要提取出内参和外参的信息。</p>
<p>先来看看已知R，T，K后，如何得到M</p>
<script type="math/tex; mode=display">
M=K[R\ \ T]_{3\times4}\tag{2.8}</script><script type="math/tex; mode=display">
K=\left[\begin{array}{ccc}
\alpha & -\alpha \cot \theta & u_{0} \\
0 & \frac{\beta}{\sin \theta} & v_{0} \\
0 & 0 & 1
\end{array}\right] \quad R=\left[\begin{array}{c}
r_{1}^{T} \\
r_{2}^T \\
r_{3} ^T
\end{array}\right] \quad T=\left[\begin{array}{c}
t_{x} \\
t_{y} \\
t_{z}
\end{array}\right]\tag{2.9}</script><p>所以：</p>
<script type="math/tex; mode=display">
M=K[R\ \ T]=\left(\begin{array}{cc}
\alpha r_{1}^{T}-\alpha \cot \theta r_{2}^{T}+u_{0} r_{3}^{T} & \alpha t_{x}-\alpha \cot \theta t_{y}+u_{0} t_{z} \\
\frac{\beta}{\sin \theta} r_{2}^{T}+v_{0} r_{3}^{T} & \frac{\beta}{\sin \theta} t_{y}+v_{0} t_{z} \\
r_{3}^{T} & t_{z}
\end{array}\right)_{3 \times 4}\tag{2.10}</script><p>因为我们之前规定了m向量的模长为1，所以我们求出的M和真实的M相差一个系数 $\rho$ </p>
<script type="math/tex; mode=display">
\rho M=\rho[A\ \ b]=K[R\ \ T]\tag{2.11}</script><p>令：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{l}
a_{1}{ }^{T} \\
a_{2}{ }^{T} \\
a_{3}{ }^{T}
\end{array}\right] \quad \mathbf{b}=\left[\begin{array}{l}
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right]\tag{2.12}</script><p>则：</p>
<script type="math/tex; mode=display">
\rho A=\rho\left(\begin{array}{c}
a_{1}^{T} \\
a_{2}{ }^{T} \\
a_{3}{ }^{T}
\end{array}\right)=\left(\begin{array}{c}
\alpha r_{1}^{T}-\alpha \cot \theta r_{2}^{T}+u_{0} r_{3}^{T} \\
\frac{\beta}{\sin \theta} r_{2}^{T}+v_{0} r_{3}^{T} \\
r_{3}{ }^{T}
\end{array}\right)=K R\tag{2.13}</script><h5 id="a-提取内参数"><a href="#a-提取内参数" class="headerlink" title="a.提取内参数"></a>a.提取内参数</h5><p>从(2.13)最后一行可以看出：</p>
<script type="math/tex; mode=display">
\rho a_3=r_3\\\tag{2.14}</script><p>因为 $r_3$ 是旋转矩阵的列向量，其模长为1，因此可以得到：</p>
<script type="math/tex; mode=display">
\rho=\frac{\pm 1}{\left|a_{3}\right|}\tag{2.15}</script><p>然后分别将(2.13)左右两侧第3行的向量和第1行的向量点乘，第3行的向量和第2行的向量点乘，因为旋转矩阵的列向量互相正交，所以可以得到：</p>
<script type="math/tex; mode=display">
\quad \begin{aligned}
&u_{0}=\rho^{2}\left(a_{1} \cdot a_{3}\right) \\
&v_{0}=\rho^{2}\left(a_{2} \cdot a_{3}\right)
\end{aligned}\tag{2.16}</script><p>同理再将(2.13)的行向量进行叉乘，可以得到下面的式子：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{ l } 
{ \rho ^ { 2 } ( a _ { 1 } \times a _ { 3 } ) = \alpha r _ { 2 } - \alpha \operatorname { cot\theta} r _ { 1 } } \\
{ \rho ^ { 2 } ( a _ { 2 } \times a _ { 3 } ) = \frac { \beta } { \operatorname { sin } \theta } r _ { 1 } }
\end{array} 
\right.\tag{2.17}</script><p>在将(2.17)上下两行进行点乘，可以得到</p>
<script type="math/tex; mode=display">
\rho^4(a_1 \times a_3)(a_2 \times a_3)=- \frac{\alpha \beta \cos{\theta}}{\sin\theta^2} \tag{2.18}</script><p>然后对(2.17)的向量两边取模：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\rho^{2}\left|a_{1} \times a_{3}\right|=\frac{|\alpha|}{\sin \theta} \\
\rho^{2}\left|a_{2} \times a_{3}\right|=\frac{|\beta|}{\sin \theta}
\end{array}\right.\tag{2.19}</script><p>最后可以得到内参矩阵中的所有参数：</p>
<script type="math/tex; mode=display">
\cos \theta=-\frac{\left(a_{1} \times a_{3}\right) \cdot\left(a_{2} \times a_{3}\right)}{\left|a_{1} \times a_{3}\right| \cdot\left|a_{2} \times a_{3}\right|}\\
\begin{array}{l}
\alpha=\rho^{2}\left|a_{1} \times a_{3}\right| \sin \theta \\
\beta=\rho^{2}\left|a_{2} \times a_{3}\right| \sin \theta
\end{array}\tag{2.20}</script><p>到此，摄像机的内参数全部求出。</p>
<h5 id="b-提取外参数"><a href="#b-提取外参数" class="headerlink" title="b.提取外参数"></a>b.提取外参数</h5><p>根据(2.14)和(2.17)可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&r_{1}=\frac{\left(a_{2} \times a_{3}\right)}{\left|a_{2} \times a_{3}\right|}\\
&r_{3}=\frac{\pm a_{3}}{\left|a_{3}\right|} \\
&r_{2}=r_{3} \times r_{1}\end{aligned}\tag{2.21}</script><p>下面再计算T，根据：</p>
<script type="math/tex; mode=display">
\rho b=KT\tag{2.22}</script><p>可以得到：</p>
<script type="math/tex; mode=display">
T=\rho K^{-1}b\tag{2.23}</script><blockquote>
<p>注意：选取的点不能在同一平面</p>
</blockquote>
<h3 id="B-径向畸变标定"><a href="#B-径向畸变标定" class="headerlink" title="B.径向畸变标定"></a>B.径向畸变标定</h3><h4 id="1-径向畸变的描述"><a href="#1-径向畸变的描述" class="headerlink" title="1.径向畸变的描述"></a>1.径向畸变的描述</h4><p>在原有的透视投影矩阵M基础上，加上一个缩放矩阵 $S_\lambda$ ，如下：</p>
<script type="math/tex; mode=display">
{\left[\begin{array}{ccc}
\frac{1}{\lambda} & 0 & 0 \\
0 & \frac{1}{\lambda} & 0 \\
0 & 0 & 1
\end{array}\right]}
M P_{i} \rightarrow\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=p_{i}\quad 其中
\lambda=1 \pm \sum_{p=1}^{3} k_pd^{2p} \quad (d^2=u^{2}+v^{2})\tag{2.24}</script><p>当 $\lambda=1$ 时，真实的像和理想的像重叠，此时无畸变</p>
<p>当 $\lambda&lt;1$时，真实的像比理想的像的位置靠外，枕形畸变</p>
<p>当$\lambda&gt;1$ 时，真实的像比理想的像的位置靠里，桶形畸变</p>
<h4 id="2-径向畸变的标定"><a href="#2-径向畸变的标定" class="headerlink" title="2.径向畸变的标定"></a>2.径向畸变的标定</h4><p>令</p>
<script type="math/tex; mode=display">
S_\lambda M=Q=
\left[\begin{array}{}
q_1\\
q_2\\
q_3
\end{array}{}\right]_{3\times 4}\tag{2.25}</script><script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{l}
u_{i} \\
v_{i}
\end{array}\right]=\left[\begin{array}{l}
\frac{q_{1} p_{i}}{q_{3} p_{i}} \\
\frac{q_{2} p_{i}}{q_{3} p_{i}}
\end{array}\right] \quad \longrightarrow \quad\left\{\begin{array}{l}
u_{i} q_{3} P_{i}=q_{1} P_{i} \\
v_{i} q_{3} P_{i}=q_{2} P_{i}
\end{array}\right.\tag{2.26}</script><p>(2.26)右边的方程组并不是线性方程组，因为 $q_i$ 是变化的，如果想要求解该方程，需要采用非线性优化方法，使观测值和理论值的误差最小，可以采用牛顿法或LM方法。</p>
<p>但是可以求解出系统的线性部分以找到近似解，然后使用该解作为整个系统的初始条件，再使用数值方法进行求解。</p>
<p>根据(2.23)和(2.25)，Q矩阵的前两行等于 $\frac{1}\lambda M$ 的前两行，于是可以将 $\lambda$ 约去</p>
<script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=\frac{1}{\lambda}\left[\begin{array}{l}
\frac{m_{1} p_{i}}{m_{3} p_{i}} \\
\frac{m_{2} p_{i}}{m_{3} p_{i}}
\end{array}\right] \quad \longrightarrow \quad \frac{u_{i}}{v_{i}}=\frac{\frac{1}{\lambda} \frac{\left(m_{1} P_{i}\right)}{\left(m_{3} p_{i}\right)}}{\frac{1}{\lambda} \frac{\left(m_{2} p_{i}\right)}{\left(m_{3} p_{i}\right)}}=\frac{m_{1} p_{i}}{m_{2} p_{i}}\tag{2.27}</script><p>建立如下的线性方程组</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
v_{1}\left(m_{1} P_{1}\right)-u_{1}\left(m_{2} P_{1}\right)=0  \\
v_{i}\left(m_{1} P_{i}\right)-u_{i}\left(m_{2} P_{i}\right)=0 
\\
\vdots \\
v_{n}\left(m_{1} P_{n}\right)-u_{n}\left(m_{2} P_{n}\right)=0
\end{array} \longrightarrow\quad 
\\ L \boldsymbol{n}=0 \\

\right. \\\tag{2.28}</script><p>其中</p>
<script type="math/tex; mode=display">
L \stackrel{\operatorname{dec}}{=}\left(\begin{array}{cc}
v_{1} p_{1}^{T} & -u_{1} p_{1}^{T} \\
v_{2} p_{2}^{T} & -u_{2} p_{2}^{T} \\
\vdots & \vdots \\
v_{n} p_{n}^{T} & -u_{n} p_{n}^{T}
\end{array}\right)\tag{2.29}\\\\
n=\left[\begin{array}{c}
m_{1}{ }^{T} \\
m_{2}{ }^{T}
\end{array}\right]</script><p>和(2.6)的方法类似，可以通过奇异值分解求出 $m_1$和 $m_2$ 。然后再通过非线性优化的方法求出 $k_p$ 和 $m_3$。</p>
<h2 id="三、单视图几何"><a href="#三、单视图几何" class="headerlink" title="三、单视图几何"></a>三、单视图几何</h2><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040215.png" alt="image-20210820213946776"></p>
<p>已知摄像机的内参和外部参数，是否可以根据单个图片的测量值p去估计空间点P呢？</p>
<p>ans：是不能的，只能确定P点位于c和p的连线上的任意位置。原因是单目相机无法获得深度信息，在这条线上的任意点的投影都位于该像素点上，当对空间有一些先验的信息时，是可以获得空间点P的位置信息的。</p>
<h3 id="A-2D变换"><a href="#A-2D变换" class="headerlink" title="A.2D变换"></a>A.2D变换</h3><h4 id="1-等距变换"><a href="#1-等距变换" class="headerlink" title="1.等距变换"></a>1.等距变换</h4><p>等距变换也叫做欧式变换，是将平面上的点经过旋转平移，不改变图形的形状，面积。仅仅改变图形的位置和朝向。</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{l}
R & \boldsymbol{t} \\
0 & 1\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1\end{array}\right]=H_{e}\left[\begin{array}{l}
x \\
y \\
1\end{array}\right]\tag{3.1}</script><p>有3个自由度(1个旋转角度+2个平移量)</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040219.png" alt="image-20210823171132345"></p>
<h4 id="2-相似变换"><a href="#2-相似变换" class="headerlink" title="2.相似变换"></a>2.相似变换</h4><p>在等距变换的基础上，如式(3.1)所示，增加了一个S矩阵(对角阵)，对原图形进行缩放。</p>
<p>它不改变图形长度的比值，还有线段间的角度。</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
S R & \boldsymbol{t} \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=H_{S}\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right] \quad S=\left[\begin{array}{ll}
s & 0 \\
0 & s
\end{array}\right]\tag{3.2}</script><p>有4个自由度(1个缩放系数+1个旋转角度+2个平移量)</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040226.png" alt="image-20210823171619104"></p>
<h4 id="3-仿射变换"><a href="#3-仿射变换" class="headerlink" title="3.仿射变换"></a>3.仿射变换</h4><p>（直观意义后续再学习，现在先搞懂数学表达）</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
A & \boldsymbol{t} \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]=H_{a}\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]\tag{3.3}</script><p>注意这里的矩阵与(3.1)和(3.2)不同，A矩阵是任意的一个2阶方阵，有4个自由度。整个矩阵共有6个自由度(4个自由度+2个平移量)</p>
<p><strong>特点</strong>：它不改变图形中的平行线关系，还有面积比值。但不能保持线段之间的夹角关系。</p>
<h4 id="4-透视变换-射影变换"><a href="#4-透视变换-射影变换" class="headerlink" title="4.透视变换(射影变换)"></a>4.透视变换(射影变换)</h4><p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
A & \boldsymbol{t} \\
v & 1
\end{array}\right]\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]=H_{p}\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]\tag{3.4}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040232.png" alt="image-20210823233103207"></p>
<p><strong>特点</strong>：</p>
<p>共线性，原来在一条直线上的点变换后还在一条直线上。</p>
<p>四共线点的交比</p>
<p>交比的定义为：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018041052.png" alt="image-20210823225125021" style="zoom:50%;" /></p>
<script type="math/tex; mode=display">
\frac{|| P_{3}-P_{1}||\left\|P_{4}-P_{2}\right\|}{|| P_{3}-P_{2}||\left\|P_{4}-P_{1}\right\|} \quad P_{i}=\left[\begin{array}{c}
X_{i} \\
Y_{i} \\
Z_{i} \\
1
\end{array}\right]\tag{3.5}</script><h3 id="B-二维空间点和直线的投影变换"><a href="#B-二维空间点和直线的投影变换" class="headerlink" title="B.二维空间点和直线的投影变换"></a>B.二维空间点和直线的投影变换</h3><p>我们的目的是用单张图像来重建三维场景，就要建立图像上几何元素和三维空间中的几何元素的对应关系。</p>
<p>我们先通过<strong><u>二维空间中</u></strong>的点和线来学习。</p>
<h4 id="1-平面上的线"><a href="#1-平面上的线" class="headerlink" title="1.平面上的线"></a>1.平面上的线</h4><p>我们可以用ax+by+c=0来表示一条平面上的线。我们可以用向量的形式来表达这个式子：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
x \\
y \\
1
\end{array}\right]^{T}\left[\begin{array}{l}
a \\
b \\
c
\end{array}\right]=0\tag{3.6}</script><p>(3.6)左边第一项是直线上点的齐次坐标，右边是直线的参数，所以直线可以表示成向量的形式：</p>
<script type="math/tex; mode=display">
l=\left[\begin{array}{l}
a\\
b\\
c
\end{array}\right]\tag{3.7}</script><h4 id="2-两条直线的交点"><a href="#2-两条直线的交点" class="headerlink" title="2.两条直线的交点"></a>2.两条直线的交点</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018041032.png" alt="image-20210823231412876"></p>
<p>两条直线的交点可以用式(3.7)的叉积来表示：</p>
<script type="math/tex; mode=display">
x=l\times l'\tag{3.8}</script><p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&l \times l^{\prime} \perp l \rightarrow\left(l \times l^{\prime}\right) \cdot l=0 \rightarrow x \in l \\
&l \times l^{\prime} \perp l' \rightarrow\left(l \times l^{\prime}\right) \cdot l'=0 \rightarrow x \in l^{\prime}
\end{aligned}\tag{3.9}</script><p>(3.9)中，两个表示直线的向量叉乘，与这两个直线向量的点乘为0，这说明了如果叉乘表示一个点，那么这个点在这两条直线上，所以该点为交点。</p>
<h4 id="3-无穷远点"><a href="#3-无穷远点" class="headerlink" title="3.无穷远点"></a>3.无穷远点</h4><p>首先定义无穷远点：平面上一个点的齐次坐标的第三维为0，该点为无穷远点。</p>
<p>因为转化成欧式坐标后，前两维都除以第三维0，为无穷大，所以是无穷远点。</p>
<script type="math/tex; mode=display">
x_\infty =\left[\begin{array}{}
x_1\\
x_2\\
0
\end{array}\right]\tag{3.10}</script><p>两条平行线的交点就是无穷远点。 </p>
<h4 id="4-无穷远直线"><a href="#4-无穷远直线" class="headerlink" title="4.无穷远直线"></a>4.无穷远直线</h4><p>无穷远点集位于无穷远线上。</p>
<p>无穷远线的向量表示为：</p>
<script type="math/tex; mode=display">
l_\infty =\left[\begin{array}{}
0\\
0\\
1
\end{array}\right]\tag{3.11}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040245.png" alt="image-20210823233249621" style="zoom: 67%;" /></p>
<h4 id="5-无穷远点的透视变换"><a href="#5-无穷远点的透视变换" class="headerlink" title="5.无穷远点的透视变换"></a>5.无穷远点的透视变换</h4><p>透视变换矩阵：</p>
<script type="math/tex; mode=display">
H=\left[ \begin{array}{l}
A & t \\
v & b
\end{array}\right] \tag{3.12}</script><p>无穷远点的<strong>透视变换</strong>：</p>
<script type="math/tex; mode=display">
p^{\prime}=Hp_\infty=\left[\begin{array}{l}
A & t \\
v & b
\end{array}\right]\left[\begin{array}{l}
1 \\
1 \\
0
\end{array}\right]=\left[\begin{array}{c}
p_{x}^{\prime} \\
p_{y}^{\prime} \\
p_{z}^{\prime}
\end{array}\right]\longrightarrow
\left[\begin{array}{}
\frac{p_x'}{p_z'}\\
\frac{p_y'}{p_z'}
\end{array}\right]\tag{3.13}</script><p>无穷远点的透视变换后，就不再是一个无穷远点了。</p>
<p>而无穷远点的<strong>仿射变换</strong>：</p>
<script type="math/tex; mode=display">
H_{A} p_{\infty}=\left[\begin{array}{cc}
A & t \\
0 & b
\end{array}\right]\left[\begin{array}{l}
1 \\
1 \\
0
\end{array}\right]=\left[\begin{array}{c}
p_{x}^{\prime} \\
p_{y} \\
0
\end{array}\right]\tag{3.14}</script><p>仍然是无穷远点。</p>
<h4 id="6-无穷远线的透视变换"><a href="#6-无穷远线的透视变换" class="headerlink" title="6.无穷远线的透视变换"></a>6.无穷远线的透视变换</h4><p>线的变换和点的变换不同，不能直接对直线向量进行变换。</p>
<p>我们知道对线的变换，等价于对线上所有的点的变换。</p>
<p>变换前的直线方程为：</p>
<script type="math/tex; mode=display">
x^Tl=0\tag{3.15}</script><p>对直线上的点的变换为：</p>
<script type="math/tex; mode=display">
Hx\tag{3.16}</script><p>则变换后的直线方程为：</p>
<script type="math/tex; mode=display">
(Hx)^Tl'=0\longrightarrow x^TH^Tl'=0\tag{3.17}</script><p>如果让(3.17)成立，则：</p>
<script type="math/tex; mode=display">
l'=H^{-T}l\tag{3.18}</script><p>所以直线的变换如式(3.18)所示。</p>
<p>无穷远线经过<strong>透视变换</strong>为：</p>
<script type="math/tex; mode=display">
H^{-T} l_{\infty}=\left[\begin{array}{ll}
A & t \\
v & b
\end{array}\right]^{-T}\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{c}
t_{x} \\
t_{y} \\
b
\end{array}\right]\tag{3.19}</script><p>显然变换后不再是无穷远线了。</p>
<p>无穷远线在<strong>仿射变换</strong>后：</p>
<script type="math/tex; mode=display">
{H}^{-T} l_{\infty}=\left[\begin{array}{cc}
A & t \\
0 & b
\end{array}\right]^{-T}\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{cc}
A^{-T} & 0 \\
-t^{T} A^{-T} & 1
\end{array}\right]\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]\tag{3.20}</script><p>仍是无穷远线。</p>
<h3 id="C-三维空间中的变换"><a href="#C-三维空间中的变换" class="headerlink" title="C.三维空间中的变换"></a>C.三维空间中的变换</h3><p>学完了二维空间中的点和线以及变换关系，接下来学习三维空间的点和线以及变换关系。</p>
<h4 id="1-空间中的点和面"><a href="#1-空间中的点和面" class="headerlink" title="1.空间中的点和面"></a>1.空间中的点和面</h4><p>与二维空间不同的是，三维空间是点和面可以用方程来表示。而直线用两个平面的交线来表示。</p>
<p>和二维空间中的直线的表示类似，三维空间中的平面表示为：</p>
<script type="math/tex; mode=display">
ax+by+cz+d=0\tag{3.21}</script><p>用向量的形式表示为：</p>
<script type="math/tex; mode=display">
x^T\Pi=0\quad\Pi=\left[\begin{array}{}
a\\
b\\
c\\d
\end{array}\right]\tag{3.22}</script><h4 id="2-空间中的线"><a href="#2-空间中的线" class="headerlink" title="2.空间中的线"></a>2.空间中的线</h4><p>如上所说，空间中的线不容易直接用方程来表示，但可以用向量表示出直线的方向。</p>
<script type="math/tex; mode=display">
d=\left[\begin{array}{}
a\\
b\\
c
\end{array}\right]\tag{3.23}</script><h4 id="3-影消点"><a href="#3-影消点" class="headerlink" title="3.影消点"></a>3.影消点</h4><p>影消点是三维空间中的无穷远点在二维平面上的投影点。</p>
<p>前面的二维空间中的无穷远点，经过投影变换后，变为一个有限点。那么三维空间中的无穷远点，经过投影变换后，在二维平面上，也为有限点。 </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040306.png" alt="image-20210824001710255" style="zoom:67%;" /></p>
<h4 id="4-影消点和直线方向的关系"><a href="#4-影消点和直线方向的关系" class="headerlink" title="4.影消点和直线方向的关系"></a>4.影消点和直线方向的关系</h4><p>影消点的齐次坐标为v，影消点和直线方向有如下关系</p>
<script type="math/tex; mode=display">
v=Kd\tag{3.24}</script><p>该式成立的条件是，相机坐标系和世界坐标系重合，否则和直线方向向量相差一个旋转平移的关系。</p>
<p>证明：</p>
<p>无穷远点坐标为：</p>
<script type="math/tex; mode=display">
X_\infty=\left[\begin{array}{}
a\\
b\\
c\\
0
\end{array}\right]\tag{3.25}</script><p>经过摄像机投影变换后</p>
<script type="math/tex; mode=display">
v=MX_\infty=K[I\ \ 0]\left[\begin{array}{}
a\\
b\\
c\\
0
\end{array}\right]=K\left[\begin{array}{}
a\\
b\\
c\\

\end{array}\right]\tag{3.26}</script><p>所以知道直线的方向就可以知道影消点，反过来知道影消点也可以知道直线的方向。</p>
<h4 id="5-影消线（视平线）"><a href="#5-影消线（视平线）" class="headerlink" title="5.影消线（视平线）"></a>5.影消线（视平线）</h4><p>三维空间中的无穷远线在二维空间中的投影。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040312.png" alt="image-20210824003405552"></p>
<h4 id="6-影消线和平面法向量"><a href="#6-影消线和平面法向量" class="headerlink" title="6.影消线和平面法向量"></a>6.影消线和平面法向量</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040317.png" alt="image-20210824003743383"></p>
<p>这个平面是指影消线所对应的平行线所在的平面。</p>
<p>平面法向量为n，影消线和平面法向量的关系为：</p>
<script type="math/tex; mode=display">
n=K^Tl_{horiz}\tag{3.27}</script><p>证明：</p>
<p>这里还是仅考虑相机坐标系和世界坐标系重合的情况。</p>
<p>设某一平面有一无穷远点x，其所在平面的方程为：</p>
<script type="math/tex; mode=display">
x^T\Pi=0\tag{3.28}</script><p>该点经过投影变换后，在影消线上，影消线方程为：</p>
<script type="math/tex; mode=display">
(Mx)^Tl_{horiz}=0\\
x^TM^Tl_{horiz}=0\tag{3.29}</script><p>比较(3.28)和(3.29)可知：</p>
<script type="math/tex; mode=display">
\Pi=M^Tl_{horiz}\tag{3.30}\\
因为M=K[I\ \ 0],\Pi\ 就是平面的法向量，所以有：
n=K^Tl_{horiz}</script><h4 id="7-无穷远平面"><a href="#7-无穷远平面" class="headerlink" title="7.无穷远平面"></a>7.无穷远平面</h4><p>影消线所在的平面。</p>
<p>表示向量的形式为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}
0\\
0\\
0\\
1
\end{array}\right]\tag{3.31}</script><h4 id="8-两组平行线的夹角和影消点的关系"><a href="#8-两组平行线的夹角和影消点的关系" class="headerlink" title="8.两组平行线的夹角和影消点的关系"></a>8.两组平行线的夹角和影消点的关系</h4><p>两平行线夹角：</p>
<script type="math/tex; mode=display">
co s\theta=\frac{d_1d_2}{|d_1||d_2|}\tag{3.32}</script><p>由式(3.24)可知，知道影消点坐标和相机内参矩阵后，可以反求出平行线方向向量d。</p>
<p>将 $d_1和d_2$ 代入(3.32)，可得：</p>
<script type="math/tex; mode=display">
co s\theta=\frac{d_1d_2}{|d_1||d_2|}=\frac{(K^{-1}v_1)^T(K^{-1}v_2)}{\sqrt{(K^{-1}v_1)^T(K^{-1}v_1)}\sqrt{(K^{-1}v_2)^T(K^{-1}v_2)}}\\
=\frac{v_{1}^{T} \omega v_{2}}{\sqrt{v_{1}^{T} \omega v_{1}} \sqrt{v_{2}^{T} \omega v_{2}}}\quad \omega= (KK^T)^{-1}\tag{3.33}</script><script type="math/tex; mode=display">
当\theta=90^{\circ} \rightarrow v_{1}^{T} \omega v_{2}=0\tag{3.34}</script><p>$\omega$ 的性质：</p>
<script type="math/tex; mode=display">
\omega=\left[\begin{array}{lll}
\omega_{1} & \omega_{2} & \omega_{4} \\
\omega_{2} & \omega_{3} & \omega_{5} \\
\omega_{4} & \omega_{5} & \omega_{6}
\end{array}\right]\tag{3.35}</script><p>对称阵</p>
<p>有5个自由度</p>
<p>$\omega _2=0$ ，无倾斜</p>
<p>$\omega_2=0,\omega_1=\omega_3$ ，方形像素</p>
<h3 id="D-单视图重构"><a href="#D-单视图重构" class="headerlink" title="D.单视图重构"></a>D.单视图重构</h3><h4 id="1-标定内参数"><a href="#1-标定内参数" class="headerlink" title="1.标定内参数"></a>1.标定内参数</h4><p>首先根据图像上的信息，可以标定出相机的内参数矩阵</p>
<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040956.png" alt="image-20210824015723059"></p>
<p>找到图像上两组垂直的平行线，可以找到两个影消点，根据影消点的坐标，以及式(3.34)可以得到一组方程。因为 $\omega $ 有5个自由度，所以还需要增加限制方程来求解。</p>
<p>我们找到三组平行线，可以得到三个方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
v_{1}^{T} \omega v_{2}=0 \\
v_{1}^{T} \omega v_{3}=0 \\
v_{2}^{T} \omega v_{3}=0
\end{array}\right.\tag{3.36}</script><p>我们可以再添加上两个限制方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\omega _{2}=0 \\
 \omega_1=\omega_3
\end{array}\right.\tag{3.37}</script><p>便可以求解出 $\omega$ 矩阵。</p>
<h4 id="2-恢复面的信息"><a href="#2-恢复面的信息" class="headerlink" title="2.恢复面的信息"></a>2.恢复面的信息</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040950.png" alt="image-20210824020434618"></p>
<p>然后连接两个影消点，可以得到影消线，从而得到影消线的方程。然后由式(3.27)可知，该平面的空间方程。这样就可以求得三个平面的方程。</p>
<blockquote>
<p>单视图恢复的场景，是无法知道场景尺寸的。而且必须要有场景的先验信息。</p>
</blockquote>
<h2 id="四、三维重建基础和极几何"><a href="#四、三维重建基础和极几何" class="headerlink" title="四、三维重建基础和极几何"></a>四、三维重建基础和极几何</h2><h3 id="A-三维重建基础"><a href="#A-三维重建基础" class="headerlink" title="A.三维重建基础"></a>A.三维重建基础</h3><h4 id="1-三角化"><a href="#1-三角化" class="headerlink" title="1.三角化"></a>1.三角化</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040326.png" alt="image-20210824021622264"></p>
<p>三角化的适用条件：用两个摄像机来感受外部空间。</p>
<p>如图所示，现在有两个摄像机，分别在 $O_1和O_2$ 点，空间点p在两个相机的成像平面上投影分别为 $p和p’$ 。</p>
<p>通常情况下，P点的坐标通过l和l’的叉乘来求得。</p>
<p>但是由于噪声的存在，$l和l’$ 一般是不相交的。现在想求P点的三维坐标。</p>
<p>ques：已知 $p和p’$ ，$K和K’$ ，以及R，T，求解P点的三维坐标。</p>
<p>非线性解法：建模成最小化问题。我们要找到一个点 $P^*$ ，使其投影到两个成像平面上的点和观测点的距离最小。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040344.png" alt="image-20210824022452348"></p>
<p>解法：寻找 $P^{\star}$ ，最小化 $d\left(p, M P^{\star}\right)+d\left(p^{\prime}, M^{\prime} P^{\star}\right)$ 。</p>
<h4 id="2-多视图几何的关键问题"><a href="#2-多视图几何的关键问题" class="headerlink" title="2.多视图几何的关键问题"></a>2.多视图几何的关键问题</h4><ol>
<li>摄像机几何：从一张或者多张图片中求解摄像机的内外参数</li>
<li>场景几何：从二至多幅图中找到场景的三维坐标</li>
<li>对应关系：已知一个图像的p点，如何在另一张图中找到p‘点</li>
</ol>
<h3 id="B-极几何—解决对应关系问题"><a href="#B-极几何—解决对应关系问题" class="headerlink" title="B.极几何—解决对应关系问题"></a>B.极几何—解决对应关系问题</h3><h4 id="1-极几何"><a href="#1-极几何" class="headerlink" title="1.极几何"></a>1.极几何</h4><p>极几何描述了同一场景或者物体在两个视点的几何关系。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040350.png" alt="image-20210824024244259"></p>
<p>极线：极平面与成像平面的交线</p>
<p>极点：极线与成像平面的交点</p>
<h5 id="a-极几何的特点："><a href="#a-极几何的特点：" class="headerlink" title="a.极几何的特点："></a>a.极几何的特点：</h5><ol>
<li>极平面相交于基线</li>
<li>极线相交于极点</li>
<li>$p$ 的对应点在极线 $l’$ 上</li>
<li>$p’$ 的对应点在极线 $l$ 上</li>
</ol>
<h5 id="b-极几何的两个特例："><a href="#b-极几何的两个特例：" class="headerlink" title="b.极几何的两个特例："></a>b.极几何的两个特例：</h5><h6 id="1-平行视图"><a href="#1-平行视图" class="headerlink" title="(1)平行视图"></a><strong>(1)平行视图</strong></h6><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040353.png" alt="image-20210824024726436"></p>
<p>特点：</p>
<ol>
<li>两个图像平面平行；</li>
<li>基线平行于成像平面，极点在无穷远处；</li>
<li>基线平行于像素坐标系u轴</li>
</ol>
<h6 id="2-前向平移（无旋转）"><a href="#2-前向平移（无旋转）" class="headerlink" title="(2)前向平移（无旋转）"></a><strong>(2)前向平移（无旋转）</strong></h6><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040356.png" alt="image-20210824024950629"></p>
<p>两个图像的极点有着相同的像素坐标</p>
<h4 id="2-本质矩阵"><a href="#2-本质矩阵" class="headerlink" title="2.本质矩阵"></a>2.本质矩阵</h4><p>本质矩阵：对规范化摄像机拍摄的两个视点图像间的极几何关系进行代数描述。</p>
<h5 id="a-规范化摄像机"><a href="#a-规范化摄像机" class="headerlink" title="a.规范化摄像机"></a>a.规范化摄像机</h5><p>摄像机的内参数K是单位矩阵</p>
<script type="math/tex; mode=display">
P^{\prime}=\left[\begin{array}{l}x \\ y \\ z\end{array}\right]=\left[\begin{array}{llll}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0\end{array}\right]\left[\begin{array}{l}x \\ y \\ z \\ 1\end{array}\right]\tag{4.1}</script><p>三维点的欧式坐标=像素点的齐次坐标</p>
<h5 id="b-极几何关系推导—对应点关系推导"><a href="#b-极几何关系推导—对应点关系推导" class="headerlink" title="b.极几何关系推导—对应点关系推导"></a>b.极几何关系推导—对应点关系推导</h5><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040401.png" alt="image-20210824025523590"></p>
<p>我们现在已经知道，K=K‘，且为规范化相机，p和p’的像素坐标。</p>
<p>由规范化相机还可以知道，空间点 $p$ 在 $O_1$ 坐标系下的欧式坐标为 $(u,v,1)$ ，以及 $p’$ 在 $O_2$ 坐标系下的欧式坐标 $(u’,v’,1)$</p>
<blockquote>
<p>因为是规范化相机，空间点的欧式坐标等于像素点的齐次坐标。已知p的空间坐标为(x,y,1)，p的像素齐次坐标为(u,v,1)，可以知道x=u,y=v。</p>
</blockquote>
<p>现在我们来求p和p‘的代数关系。</p>
<p>先把.$O_2$ 和 p‘的坐标转化到 $O_1$ 坐标系中为 $p’_{o_1}$：</p>
<p>因为</p>
<script type="math/tex; mode=display">
p'=Rp'_{o_1}+T\tag{4.2}</script><p>所以</p>
<script type="math/tex; mode=display">
p'_{o_1}=R^T(p'-T)\tag{4.3}</script><p>同理可得 $O_2$ 在 $O_1$ 坐标系下的坐标为：</p>
<script type="math/tex; mode=display">
O_2'=-R^TT\tag{4.4}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040405.png" alt="image-20210824031818767"></p>
<p>现在如上图找到几何关系： $O_1p’ 和 O_1O_2$向量的叉积与 $O_1p$ 向量垂直，则有如下方程：</p>
<script type="math/tex; mode=display">
[R^T(p'-T)\times R^TT]\cdot p=0\tag{4.5}</script><p>最终可得到两个对应点的约束关系：</p>
<script type="math/tex; mode=display">
p^{\prime T}[T \times R] p=0\tag{4.6}</script><p>我们将中间的矩阵记作E，E就是本质矩阵。</p>
<script type="math/tex; mode=display">
p^{\prime T} E p=0\tag{4.7}</script><p>上面p‘和p都是三维坐标，它与像素坐标的齐次形式相同。</p>
<blockquote>
<blockquote>
<p> 补充：两个向量的叉乘可以写成矩阵的表示形式</p>
</blockquote>
<script type="math/tex; mode=display">
a \times b=\left[\begin{array}{ccc}
0 & -a_{z} & a_{y} \\
a_{z} & 0 & -a_{x} \\
-a_{y} & a_{x} & 0
\end{array}\right]\left[\begin{array}{l}
b_{x} \\
b_{y} \\
b_{z}
\end{array}\right]=\left[a_{\times}\right] b\tag{4.8}</script><blockquote>
<p> 这里的 $\left[a_{\times}\right]$ 的秩为2。</p>
</blockquote>
</blockquote>
<h5 id="c-本质矩阵的特点"><a href="#c-本质矩阵的特点" class="headerlink" title="c.本质矩阵的特点"></a>c.本质矩阵的特点</h5><ol>
<li>p对应的极线是 $l’$ （$l’=Ep$）这里的 $l’$ 是二维空间中的直线向量，表示直线方程</li>
<li>p’对应的极线是 $l$ （$l=E^Tp’$）</li>
<li>$Ee=0$ 与 $E^Te’=0$</li>
<li>E 的秩为2</li>
<li>E有5个自由度（三个旋转+三个平移，det(E)=0去掉了一个自由度）</li>
</ol>
<h4 id="3-基础矩阵"><a href="#3-基础矩阵" class="headerlink" title="3.基础矩阵"></a>3.基础矩阵</h4><p>对一般透视相机在两个视点的图像间的极几何关系的代数描述</p>
<p>此时相机不再是规范化相机。</p>
<h5 id="a-基础矩阵推导"><a href="#a-基础矩阵推导" class="headerlink" title="a.基础矩阵推导"></a>a.基础矩阵推导</h5><p>思路：把相机转化为规范化相机</p>
<script type="math/tex; mode=display">
p=K[I\ \ 0]P\tag{4.9}</script><script type="math/tex; mode=display">
p_c=K^{-1} p=K^{-1} K[I\ \  0] P=\left[\begin{array}{llll}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0
\end{array}\right] P\tag{4.10}</script><p>同理</p>
<script type="math/tex; mode=display">
p'_c=K'^{-1}p'\tag{4.11}</script><p>于是有：</p>
<script type="math/tex; mode=display">
p_{c}^{\prime T} E p_{c}=p_{c}^{\prime T}\left[T_{\times}\right] R p_{c}=\left(K^{\prime-1} p^{\prime}\right)^{T} \cdot\left[T_{\times}\right] R K^{-1} p=p^{\prime T} K^{\prime-T}\left[T_{x}\right] R K^{-1} p=0\tag{4.12}</script><p>令中间的部分为F，F即为基础矩阵</p>
<script type="math/tex; mode=display">
p^{\prime T} F p=0\tag{4.13}</script><script type="math/tex; mode=display">
F=K^{\prime-T}\left[T_{x}\right] R K^{-1}\tag{4.14}</script><h5 id="b-基础矩阵性质"><a href="#b-基础矩阵性质" class="headerlink" title="b.基础矩阵性质"></a>b.基础矩阵性质</h5><ol>
<li>p对应的极线是 $l’$ （$l’=Fp$）这里的 $l’$ 是二维空间中的直线向量，表示直线方程</li>
<li>p’对应的极线是 $l$ （$l=F^Tp’$）</li>
<li>$Fe=0$ 与 $F^Te’=0$</li>
<li>F 的秩为2</li>
<li>F 有7个自由度（尺度无法确定，det(F)=0去掉了一个自由度）</li>
</ol>
<h4 id="4-基础矩阵的估计"><a href="#4-基础矩阵的估计" class="headerlink" title="4.基础矩阵的估计"></a>4.基础矩阵的估计</h4><p>已知对应点的像素坐标，来求解F矩阵。</p>
<h5 id="a-八点算法"><a href="#a-八点算法" class="headerlink" title="a.八点算法"></a>a.八点算法</h5><p>首先，对应点间有以下关系</p>
<script type="math/tex; mode=display">
p^{\prime T} F p=0 \quad p=\left[\begin{array}{l}
u \\
v \\
1
\end{array}\right] \quad p^{\prime}=\left[\begin{array}{l}
u^{\prime} \\
v^{\prime} \\
1
\end{array}\right]\tag{4.15}</script><script type="math/tex; mode=display">
\\

\left(u^{\prime}, v^{\prime}, 1\right)\left(\begin{array}{lll}
F_{11} & F_{12} & F_{13} \\
F_{21} & F_{22} & F_{23} \\
F_{31} & F_{32} & F_{33}
\end{array}\right)\left(\begin{array}{l}
u \\
v \\
1
\end{array}\right)=0 \\\tag{4.16}</script><p>将(4.16)写成另外一种形式，如下式：</p>
<script type="math/tex; mode=display">
\left(u u^{\prime}, v u^{\prime}, u^{\prime}, u v^{\prime}, v v^{\prime}, v^{\prime}, u, v, 1\right)\left(\begin{array}{l}
F_{11} \\
F_{12} \\
F_{13} \\
F_{21} \\
F_{22} \\
F_{23} \\
F_{31} \\
F_{32} \\
F_{33}
\end{array}\right)=0\tag{4.17}</script><p>我们要求的就是后面的列向量，前面是对应点的坐标构成的一个行向量，一对对应点可列得一个(4.17)方程。</p>
<p>现在来看式(4.17)，这是一个齐次线性方程，虽然有9个未知数，当确定8个未知数后，第9个便可以确定。因此，仅需要8对点即可求解出基础矩阵F。</p>
<p>选取8对对应点后，可得到下式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}
u_{1} u_{1}^{\prime} & v_{1} u_{1}^{\prime} & u_{1}^{\prime} & u_{1} v_{1}^{\prime} & v_{1} v_{1}^{\prime} & v_{1}^{\prime} & u_{1} & v_{1} & 1 \\
u_{2} u_{2}^{\prime} & v_{2} u_{2}^{\prime} & u_{2}^{\prime} & u_{2} v_{2}^{\prime} & v_{2} v_{2}^{\prime} & v_{2}^{\prime} & u_{2} & v_{2} & 1 \\
u_{3} u_{3}^{\prime} & v_{3} u_{3}^{\prime} & u_{3}^{\prime} & u_{3} v_{3}^{\prime} & v_{3} v_{3}^{\prime} & v_{3}^{\prime} & u_{3} & v_{3} & 1 \\
u_{4} u_{4}^{\prime} & v_{4} u_{4}^{\prime} & u_{4}^{\prime} & u_{4} v_{4}^{\prime} & v_{4} v_{4}^{\prime} & v_{4}^{\prime} & u_{4} & v_{4} & 1 \\
u_{5} u_{5}^{\prime} & v_{5} u_{5}^{\prime} & u_{5}^{\prime} & u_{5} v_{5}^{\prime} & v_{5} v_{5}^{\prime} & v_{5}^{\prime} & u_{5} & v_{5} & 1 \\
u_{6} u_{6}^{\prime} & v_{6} u_{6}^{\prime} & u_{6}^{\prime} & u_{6} v_{6}^{\prime} & v_{6} v_{6}^{\prime} & v_{6}^{\prime} & u_{6} & v_{6} & 1 \\
u_{7} u_{7}^{\prime} & v_{7} u_{7}^{\prime} & u_{7}^{\prime} & u_{7} v_{7}^{\prime} & v_{7} v_{7}^{\prime} & v_{7}^{\prime} & u_{7} & v_{7} & 1 \\
u_{8} u_{8}^{\prime} & v_{8} u_{8}^{\prime} & u_{8}^{\prime} & u_{8} v_{8}^{\prime} & v_{8} v_{8}^{\prime} & v_{8}^{\prime} & u_{8} & v_{8} & 1
\end{array}\right]\left[\begin{array}{c}
F_{11} \\
F_{12} \\
F_{13} \\
F_{21} \\
F_{22} \\
F_{23} \\
F_{31} \\
F_{32} \\
F_{33}
\end{array}\right]=0\tag{4.18}</script><p>(4.18)还可以写成：</p>
<script type="math/tex; mode=display">
Wf=0\tag{4.19}</script><p>当W的秩为8时，存在唯一非零解。</p>
<p>而实际中，我们会选取超过8对点，来估计F矩阵，以防止个别点出现偏差时影响F的估计。</p>
<p>当选取超过8个点的时候，会变成一个超定方程组，超定方程组只有0解。此时我们需要用非线性优化的方法来求解。</p>
<script type="math/tex; mode=display">
\begin{gathered}
\min _{\boldsymbol{f}}\|\boldsymbol{W} \boldsymbol{f}\| \\
\text { s. } t .\|\boldsymbol{f}\|=1
\end{gathered}\longrightarrow \hat{F}\tag{4.20}</script><p>当f的模为1时(因为这是一个齐次线性方程组，f的模可以是任意的，在这里我们取1)，使Wf最小。具体的过程就是奇异值分解，和式(2.7)求法相同。</p>
<p>这里 $\hat{F}$ 并不是我们要求的基础矩阵，因为基础矩阵的秩为2，此处的 $\hat{F}$ 的秩为3 。</p>
<p>继续用最优化思想来求解。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\text { 寻找F最小化 }\|F-\widehat{F}\|_{\mathrm{F}}\\
&\text { s.t. } \operatorname{det}(F)=0
\end{aligned}</script><p>具体过程也很简单，就是对 $\hat{F}$ 进行奇异值分解。</p>
<script type="math/tex; mode=display">
S V D(\hat{F})=U\left[\begin{array}{ccc}
s_{1} & 0 & 0 \\
0 & s_{2} & 0 \\
0 & 0 & s_{3}
\end{array}\right] V^{T} \Rightarrow F=U\left[\begin{array}{ccc}
s_{1} & 0 & 0 \\
0 & s_{2} & 0 \\
0 & 0 & 0
\end{array}\right] V^{T}\tag{4.21}</script><h5 id="b-八点算法的问题"><a href="#b-八点算法的问题" class="headerlink" title="b.八点算法的问题"></a>b.八点算法的问题</h5><p>精度低！！！</p>
<p>因为W矩阵中的各个元素的数值差异过大</p>
<h5 id="c-归一化八点法"><a href="#c-归一化八点法" class="headerlink" title="c.归一化八点法"></a>c.归一化八点法</h5><p>对每幅图施加变换T(平移与缩放)，让其满足以下条件：</p>
<ol>
<li>新原点=图像上点的重心</li>
<li>每个像点到坐标原点的均方根距离为 $\sqrt {2}$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040412.png" alt="image-20210825010953797"></p>
<p>归一化八点算法的步骤：</p>
<ol>
<li>先计算左图和右图的T和T‘</li>
<li>坐标归一化$q_{i}=T p_{i} \quad q^{\prime}{ }_{i}=T^{\prime} p_{i}{ }^{\prime}$</li>
<li>通过八点算法计算 $F_q$</li>
<li>逆归一化$F=T^{\prime T} F_{q} T$</li>
</ol>
<h2 id="五、双目立体视觉系统"><a href="#五、双目立体视觉系统" class="headerlink" title="五、双目立体视觉系统"></a>五、双目立体视觉系统</h2><h3 id="A-平行视图下的极几何"><a href="#A-平行视图下的极几何" class="headerlink" title="A.平行视图下的极几何"></a>A.平行视图下的极几何</h3><p>利用两个视点来观察物体，和人的眼睛一样。</p>
<p>可以让对应点搜索和深度求解更加简单。</p>
<h4 id="0-补充："><a href="#0-补充：" class="headerlink" title="0.补充："></a>0.补充：</h4><h5 id="a-极点坐标"><a href="#a-极点坐标" class="headerlink" title="a.极点坐标"></a>a.极点坐标</h5><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040415.png" alt="image-20210825160039966" style="zoom:50%;" /></p>
<p>我们前面说过，极点是基线和成像平面的交点。从另外一个角度来看，极点还可以是相机中心在成像平面上的投影点。那么如上图所示，极点 $e$ 是点 $O_2$ 在成像平面的投影。极点 $e’$ 是 $O_1$ 在成像平面的投影。</p>
<p>那么点 $O_1$ 在坐标系 $O_1$ 中的齐次坐标为 $[0\ 0\ 0\ 1]^T$ ，其在坐标系 $O_2$ 中的欧式坐标为：</p>
<script type="math/tex; mode=display">
[R\ T]\left[\begin{array}{}0\\0\\0\\1\end{array}\right]\tag{5.1}</script><p>所以 $e’$ 的齐次坐标就为：</p>
<script type="math/tex; mode=display">
e'=K'[R\ T]\left[\begin{array}{}0\\0\\0\\1\end{array}\right]=K'T\tag{5.2}</script><h5 id="b-叉乘性质"><a href="#b-叉乘性质" class="headerlink" title="b.叉乘性质"></a>b.叉乘性质</h5><p>对于任意向量t，如果M可逆，相差一个尺度的情况下，有如下关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&{\left[t_{\times}\right] M=M^{-T}\left[\left(M^{-1} t\right)_{\times}\right]} \\

\end{aligned}\tag{5.3}</script><p>然后我们令$ t=T, M=K^{\prime-1}$ ，代入到式(5.3)中</p>
<script type="math/tex; mode=display">
{\left[T_{\times}\right] K^{\prime-1}=K^{\prime T}\left[\left(K^{\prime} T\right)_{x}\right]} \\\tag{5.4}</script><p>便可以得到：</p>
<script type="math/tex; mode=display">
\left[T_{\times}\right]=K^{\prime T}\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime}\tag{5.5}</script><p>然后将式(5.5)代入基础矩阵(4.14)中：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F&=K^{\prime-T}\left[T_{x}\right] R K^{-1}\\
&=K^{\prime-T} K^{\prime T}\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime} R K^{-1}\\
&=\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime} R K^{-1}\\
&=\left[e_{x}^{\prime}\right] K^{\prime} R K^{-1}
\end{aligned}\tag{5.6}</script><h4 id="1-平行视图的基础矩阵"><a href="#1-平行视图的基础矩阵" class="headerlink" title="1.平行视图的基础矩阵"></a>1.平行视图的基础矩阵</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040420.png" alt="image-20210825164325338" style="zoom:50%;" /></p>
<p>两个成像平面平行</p>
<p>基线平行于成像平面，极点 $e$ 和 $e’$ 位于无穷远处</p>
<p>我们假定两个摄像机的内参是一样的，$K=K’$。旋转矩阵 $R=I$ 。平移向量$T=[T\ 0\ 0]^T$ 和极点坐标 $e’=[1\ 0\ 0]^T$ 。</p>
<p>将上面的表达式代入到(5.6)中：</p>
<script type="math/tex; mode=display">
F=\left[e_{x}^{\prime}\right] K^{\prime} R K^{-1}=\left[e^{\prime}{ }_{x}\right]=\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & -1 \\
0 & 1 & 0
\end{array}\right]\tag{5.7}</script><p>这就是平行视图的基础矩阵。</p>
<h4 id="2-平行视图下的极线"><a href="#2-平行视图下的极线" class="headerlink" title="2.平行视图下的极线"></a>2.平行视图下的极线</h4><p>一对对应点p和p‘，像素坐标为：$\left(p_{u}, p_{v}\right) 和<br>\left(p_{u}^{\prime}, p_{v}^{\prime}\right)$</p>
<p>极线的方程为：</p>
<script type="math/tex; mode=display">
l=F^{T} p^{\prime}=\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & 1 \\
0 & -1 & 0
\end{array}\right]\left[\begin{array}{c}
p_{u}^{\prime} \\
p_{v}^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{c}
0 \\
1 \\
-p_{v}^{\prime}
\end{array}\right]\tag{5.8}</script><p>可以看出，该极线是平行于u轴的。</p>
<h4 id="3-对应点关系"><a href="#3-对应点关系" class="headerlink" title="3.对应点关系"></a>3.对应点关系</h4><script type="math/tex; mode=display">
p'^TFp=0\tag{5.9}</script><p>即：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{lll}
p_{u}^{\prime} & p_{v}^{\prime} & 1
\end{array}\right)\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & -1 \\
0 & 1 & 0
\end{array}\right]\left[\begin{array}{l}
p_u \\
p_v \\
1
\end{array}\right]=0\tag{5.10}</script><p>最后得到：</p>
<script type="math/tex; mode=display">
p_v=p_v'\tag{5.11}</script><p>这说明对应点的v坐标是一样的。寻找对应点时，直接在扫描线上找即可。</p>
<h4 id="4-平行视图的三角测量"><a href="#4-平行视图的三角测量" class="headerlink" title="4.平行视图的三角测量"></a>4.平行视图的三角测量</h4><p>因为对应点的v坐标相同，所以可以很方便的测量P点的深度值。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040425.png" alt="image-20210825171253726" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
p_{u}-p_{u}^{\prime}=\frac{B \cdot f}{z}\tag{5.12}</script><p>知道视差和基线长度后，便可以计算出深度。</p>
<h3 id="B-图像校正"><a href="#B-图像校正" class="headerlink" title="B.图像校正"></a>B.图像校正</h3><p>平行视图让我们寻找对应点和三角化更加简单，但通常情况下我们构建的双目立体视觉系统是很难得到平行视图的。我们可以将非平行视图转化到平行视图，这就是图像校正。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040427.png" alt="image-20210825175411272" style="zoom: 33%;" /></p>
<p>完成校正这一目标需要构建两个矩阵H和H‘，我们可以通过以下5个步骤来求得这两个矩阵。</p>
<ol>
<li><p>找8个以上的匹配点对。</p>
</li>
<li><p>计算基础矩阵F，然后来求解两幅图像中的极点。具体可以通过上一步的匹配点通过八点算法求出基础矩阵F，然后可以通过基础矩阵的性质求得极线方程。再根据所有极线都经过极点这一性质，求得极点的齐次坐标。</p>
</li>
<li><p>选择透视变换 $H’$ 将 $e’$ 映射到无穷远点 $(f,0,0)$。其中 $H’=T^{-1}GRT$ 。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040431.png" alt="image-20210825180734367" style="zoom:50%;" /></p>
</li>
<li><p>寻找透视变换矩阵H，使得 $\sum_{i} d\left(H p_{i}, H^{\prime} p_{i}^{\prime}\right)$ 最小。</p>
</li>
<li><p>分别用H和H‘对左右两幅图进行重采样。</p>
</li>
</ol>
<p><strong>图像校正例子：</strong></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040434.png" alt="image-20210825181026118" style="zoom: 33%;" /></p>
<h3 id="C-对应点搜索"><a href="#C-对应点搜索" class="headerlink" title="C.对应点搜索"></a>C.对应点搜索</h3><p>给定一个空间点P，在左右图像中找到相应的观测值，也称为双目融合问题。 </p>
<p>图像经过校正后，对应点在扫描线上搜索即可。</p>
<h4 id="1-相关法"><a href="#1-相关法" class="headerlink" title="1.相关法"></a>1.相关法</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018051704.png" style="zoom:50%;" /></p>
<p>首先建立一个窗口</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018052138.png" alt="image-20210825193829734" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018052251.png" alt="image-20211009194933364" style="zoom: 33%;" /></p>
<h4 id="2-归一化相关法"><a href="#2-归一化相关法" class="headerlink" title="2.归一化相关法"></a>2.归一化相关法</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040443.png" alt="image-20210825194834081" style="zoom:50%;" /></p>
<p>当两幅图在光照不同的情况下，会使其像素点的灰度值发生剧烈变化。</p>
<p>此时只需要将窗口内的像素点的灰度值进行去均值即可。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040449.png" alt="image-20210825195133785" style="zoom:150%;" /></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040454.png" alt="image-20210825195236089"></p>
<p>窗口大小的影响：上面我们选取的是 $3\times 3$ 窗口，当选取其他大小窗口的时候会有什么样的变化呢？</p>
<p>ans：较小的窗口，细节丰富，但噪声较大。较大的窗口，视差图更为平滑，但是细节丢失。</p>
<p>例如下图所示，右边两幅图为视差图：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040500.png" alt="image-20210825195947480"></p>
<h4 id="3-相关法存在的问题"><a href="#3-相关法存在的问题" class="headerlink" title="3.相关法存在的问题"></a>3.相关法存在的问题</h4><h5 id="a-透视缩短"><a href="#a-透视缩短" class="headerlink" title="a.透视缩短"></a>a.透视缩短</h5><p>一个物体的长度在一个成像平面上是正常的，但可能在另一成像平面上非常的短。此时在相同范围邻域的内容有很大的不同。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040506.png" alt="image-20210825235305290" style="zoom:50%;" /></p>
<h5 id="b-遮挡"><a href="#b-遮挡" class="headerlink" title="b.遮挡"></a>b.遮挡</h5><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040511.png" alt="image-20210825235332461" style="zoom:50%;" /></p>
<p>以上两种问题的解决办法：</p>
<p>合理的选择基线与深度的比值。</p>
<script type="math/tex; mode=display">
\frac{B}{z}\tag{5.13}</script><p>减小B/z时，可以有效的避免透视缩短和遮挡的问题。用我们最直观的感受就是离物体远点，就看的更全了。</p>
<p>但缩小B/z，也会造成一个问题，就是当匹配点有很小的误差时，就会造成深度估算的大误差。</p>
<p>如下面两幅图所示，红色的点就是根据对应点估算空间点的位置。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040517.png" alt="image-20210825235821706" style="zoom: 25%;" /></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040522.png" alt="image-20210825235841876" style="zoom: 50%;" /></p>
<p>可以看到，当B/z较小时，所估算的深度误差和真实的相差很大。</p>
<h5 id="c-同质区域"><a href="#c-同质区域" class="headerlink" title="c.同质区域"></a>c.同质区域</h5><p>有多个地方与要匹配的点相似。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040527.png" alt="image-20210826000100677" style="zoom:50%;" /></p>
<h5 id="d-重复模式"><a href="#d-重复模式" class="headerlink" title="d.重复模式"></a>d.重复模式</h5><p>和上面的问题类似。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040533.png" alt="image-20210826000215422" style="zoom:50%;" /></p>
<p>容易产生误匹配。所以对应点匹配问题是一个很难的问题。</p>
<p>要解决这些问题，我们需要增加约束来解决对应点匹配问题。</p>
<h4 id="4-其他约束"><a href="#4-其他约束" class="headerlink" title="4.其他约束"></a>4.其他约束</h4><ol>
<li>唯一性约束：一张图像中的任何点，在另一张图像中最多只有一个匹配点。</li>
<li>顺序约束/单调性约束：左右视图中对应点的次序一致</li>
<li>平滑性约束：视差函数通常是平滑的（除了边界遮挡）</li>
</ol>
<p>这些方法可以参考：《计算机视觉：一种现代方法》</p>
<h2 id="六、多视图几何"><a href="#六、多视图几何" class="headerlink" title="六、多视图几何"></a>六、多视图几何</h2><h3 id="A-运动恢复结构问题"><a href="#A-运动恢复结构问题" class="headerlink" title="A.运动恢复结构问题"></a>A.运动恢复结构问题</h3><p>通过三维场景的多张图像，恢复出该场景的三维结构信息以及每张图片所对应的摄像机参数。这也就是SLAM，恢复机构等价于建图，求对应的摄像机参数等价于定位，因为摄像机参数包括内参和外参，外参数就是摄像机的运动信息。</p>
<h4 id="1-问题的具体描述"><a href="#1-问题的具体描述" class="headerlink" title="1.问题的具体描述"></a>1.问题的具体描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$ </p>
<p>且 $x_{ij}=M_iX_j$ ，其中 $M_i$ 为第 $i$ 张图片对应的摄像机投影矩阵</p>
<p><strong>求解</strong>：$m$ 个摄像机的投影矩阵 $M_i$ ；<strong>运动</strong></p>
<p>​            $n$ 个三维点 $X_j$ 的坐标；<strong>三维结构</strong></p>
<p>该类问题也称作运动恢复结构问题。</p>
<h4 id="2-三种典型的运动恢复结构任务"><a href="#2-三种典型的运动恢复结构任务" class="headerlink" title="2.三种典型的运动恢复结构任务"></a>2.三种典型的运动恢复结构任务</h4><h5 id="a-欧式结构恢复"><a href="#a-欧式结构恢复" class="headerlink" title="a.欧式结构恢复"></a>a.欧式结构恢复</h5><p>摄像机内参已知，外参未知。</p>
<p>应用场景：扫地机器人，无人驾驶汽车</p>
<h5 id="b-仿射结构恢复"><a href="#b-仿射结构恢复" class="headerlink" title="b.仿射结构恢复"></a>b.仿射结构恢复</h5><p>摄像机为仿射相机，内、外参数均未知。</p>
<p>应用场景：待重构场景离摄像机较远，而且场景的深度变化不大。</p>
<h5 id="c-透视结构恢复"><a href="#c-透视结构恢复" class="headerlink" title="c.透视结构恢复"></a>c.透视结构恢复</h5><p>摄像机为透视相机，内、外参数均未知。</p>
<p>应用场景：只知道图片，还不能忽略深度变化。</p>
<h3 id="B-欧式结构恢复"><a href="#B-欧式结构恢复" class="headerlink" title="B.欧式结构恢复"></a>B.欧式结构恢复</h3><h4 id="0-问题描述"><a href="#0-问题描述" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>$m$ 张图片对应的摄像机内参数矩阵 $K_i\ (i=1,…m)$</p>
<p>有$x_{ij}=M_iX_j=K_i[R_i\ T_i]X_j$ </p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的外参数 $R_i$ 和 $T_i$ 。</p>
<p>先来看两视图情况，令 $O_1$ 坐标系与世界坐标系固定。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040543.png" alt="image-20210826014140627" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
\begin{aligned}
&x_{1j}=M_{1} X_{j}=K_{1}\left[\begin{array}{ll}
I & 0
\end{array}\right] X_{j} \\
&x_{2 j}=M_{2} X_{j}=K_{2}\left[\begin{array}{ll}
R \ \ \ T
\end{array}\right] X_{j}
\end{aligned}\tag{6.1}</script><h4 id="1-基本求法"><a href="#1-基本求法" class="headerlink" title="1.基本求法"></a>1.基本求法</h4><p>可以分为四步：</p>
<ol>
<li>求解基础矩阵F，归一化八点法</li>
<li>利用F与摄像机内参数求解本质矩阵E，$E=K_{2}^{T} F K_{1}$</li>
<li>分解本质矩阵获得R和T</li>
<li>三角化求解三维点 $X_j$ 的坐标。$X_{j}^{*}=\underset{X_{j}}{\operatorname{argmin}}\left(d\left(x_{1 j}, M_{1} X_{j}\right)+d\left(x_{2 j}, M_{2} X_{j}\right)\right)$</li>
</ol>
<p>这里要说明一下步骤1，2之前都已经学过，而最重要的本质矩阵分解将在下面介绍。</p>
<h4 id="2-本质矩阵分解"><a href="#2-本质矩阵分解" class="headerlink" title="2.本质矩阵分解"></a>2.本质矩阵分解</h4><h5 id="a-本质矩阵推导"><a href="#a-本质矩阵推导" class="headerlink" title="a.本质矩阵推导"></a>a.本质矩阵推导</h5><blockquote>
<p>重要说明：在我们使用八点法求解基础矩阵F时，是无法确定F的符号和尺度的。求解F的方程为 $x_2^TFx_1=0$ ，而-F和kF都满足这个方程，所以说解出来的F可能不是真正的F。同理由F得到的E也是无法确定符号和尺度的。</p>
</blockquote>
<p>先定义两个矩阵：</p>
<script type="math/tex; mode=display">
W=\left[\begin{array}{ccc}
0 & -1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1
\end{array}\right] \quad Z=\left[\begin{array}{ccc}
0 & 1 & 0 \\
-1 & 0 & 0 \\
0 & 0 & 0
\end{array}\right]\tag{6.2}</script><p>这两个矩阵有一个重要的性质：</p>
<script type="math/tex; mode=display">
Z=-diag(1,1,0)W=diag(1,1,0)W^T\tag{6.3}</script><p>本质矩阵E中的 $[T_{\times}]$ 可以写成：</p>
<script type="math/tex; mode=display">
\left[T_{\times}\right]=k U Z U^{T}\tag{6.4}</script><p>其中U是单位正交阵。(6.4)中的Z用W来表示：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}

\left[T_{\times}\right]&=k U Z U^{T}\\
&=-kUdiag(1,1,0)WU^T\\
&=kUdiag(1,1,0)W^TU^T
\end{aligned}\tag{6.5}</script><p>当忽略尺度和符号的情况下，可以认为(6.5)为：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}

\left[T_{\times}\right]&=k U Z U^{T}\\
&=Udiag(1,1,0)WU^T\\
&=Udiag(1,1,0)W^TU^T
\end{aligned}\tag{6.6}</script><p>所以本质矩阵为：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}
E&=[T_{\times}]R\\
&=Udiag(1,1,0)(WU^TR)\\
&=Udiag(1,1,0)(W^TU^TR)
\end{aligned}\tag{6.7}</script><h5 id="b-本质矩阵分解"><a href="#b-本质矩阵分解" class="headerlink" title="b.本质矩阵分解"></a>b.本质矩阵分解</h5><p>现在我们有通过八点法计算出来的本质矩阵E，我们对其进行奇异值分解：</p>
<script type="math/tex; mode=display">
E=Udiag(1,1,0)V^T\tag{6.8}</script><p>(6.8)和(6.7)进行比较，可以得到：</p>
<script type="math/tex; mode=display">
\quad V^T=WU^TR\\
or\quad V^T=W^TU^TR\tag{6.9}</script><p>因为W矩阵和U矩阵都是可逆矩阵，所以可以求得R为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R&=(WU^T)^{-1}V^T\\
&=-UWV^T
\\
or\quad R&=(W^TU^T)^{-1}V^T\\
&=-UW^TV^T
\end{aligned}\tag{6.10}</script><blockquote>
<p>这里：$W^{-1}=-W\ and \ W^{-T}=W^T$</p>
</blockquote>
<p>忽略正负号，最终可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R&=UWV^T
\\
or\quad R
&=UW^TV^T
\end{aligned}\tag{6.11}</script><p>(6.11)中R有两个值，分别对应着在E推导的过程中，使用 $W\ and \ W^T$ 的两种情况。</p>
<p>然后我们再来求解平移向量T。首先根据叉乘性质：</p>
<script type="math/tex; mode=display">
T\times T=[T_{\times}]T=UZU^TT=0\tag{6.12}</script><p>因为U是单位正交阵，将U矩阵写出：</p>
<script type="math/tex; mode=display">
U=[u_1\ u_2 \ u_3]\quad note:u_i\ 是单位列向量\tag{6.13}</script><p>(6.12)展开可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
UZU^TT&=[u_1\ u_2 \ u_3]diag(1,1,0)W
\left[\begin{array}{l}
u_1^T\\
u_2^T\\
u_3^T
\end{array}\right]T
\\
&=(u_2u_1^T-u_1u_2^T)T=0
\end{aligned}\tag{6.14}</script><p>因为 $u_i$  间两两正交，所以当 $T=\pm ku_3$ 时，式(6.14)成立。</p>
<p>现在R和T对应着两个结果，而两两组合就会出现四种情况。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left\{\begin{array}{lc}
R= U W V^{T} &T=u_{3} \\
R= U W V^{T} &T=-u_{3} \\
R=U W^{T} V^{T} &T=u_{3} \\
R=U W^{T} V^{T} &T=-u_{3}
\end{array}\right.
\end{aligned}\tag{6.15}</script><p>分别对应着下面的四种情况：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040555.png" alt="image-20210828023242724" style="zoom:50%;" /></p>
<p>选择一个或多个点，分别用不同的R和T进行三角化计算，只有深度值都为正的R和T才为最终所求。</p>
<h4 id="3-欧式结构恢复存在的问题"><a href="#3-欧式结构恢复存在的问题" class="headerlink" title="3.欧式结构恢复存在的问题"></a>3.欧式结构恢复存在的问题</h4><p>正如我们在2.a中的推导，是忽略了尺度上差异和正负号差异的基础上建立的，通过求目标点的深度我们可以去除掉正负号的影响，但是尺度上的差异是去除不掉的。对于单目相机来说，凭借序列图是无法重构出正确尺度下的三维场景。</p>
<p>例如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040600.png" alt="image-20210828030716063"></p>
<p>从上图可以看出，两个空间点在两成像平面的像素坐标都是相同的，但两个空间点的深度不同，两个视点间的变换也不同，右边的平移矩阵T与左边的T相差一个系数k。另外，在真实空间中P1和P2的朝向也是不同的，这通过欧式重构也是求解不出来的。</p>
<p>我们可以这样认为，恢复出来的欧式结构和真实场景相差一个相似变换(旋转+平移+缩放)。这个相似变换的重构被称为度量重构。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040604.png" alt="image-20210828031302492" style="zoom:50%;" /></p>
<p>所以在没有先验知识的情况下，仅凭单目相机是不能恢复出三维空间结构的。</p>
<h3 id="C-仿射结构恢复"><a href="#C-仿射结构恢复" class="headerlink" title="C.仿射结构恢复"></a>C.仿射结构恢复</h3><p>由(3.3)知道，仿射变换矩阵为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{l}
m_{1} \\
m_{2} \\
m_{3}
\end{array}\right]=\left[\begin{array}{cc}
A_{2 \times 3} & b_{2 \times 1} \\
0_{1 \times 3} & 1
\end{array}\right]=\left[\begin{array}{ccc}
&m_{1} \\
&m_{2} \\
0&0&0&1
\end{array}\right]\tag{6.16}</script><p>则空间中的三维点经过仿射变换到像素坐标系中：</p>
<script type="math/tex; mode=display">
x=\left[\begin{array}{l}u\\
v\\
1\end{array}\right]=MX=M\left[\begin{array}{l}x\\
y\\
z\\
1\end{array}\right]=AX^E+b\quad(X^E为空间点的欧式坐标)\tag{6.17}</script><h4 id="0-问题描述-1"><a href="#0-问题描述-1" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>有$x_{ij}=A_iX_j+b_i$ </p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的投影矩阵 $A_i\ and\ b_i$ 。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040608.png" alt="image-20210829191114401"></p>
<h4 id="1-因式分解法"><a href="#1-因式分解法" class="headerlink" title="1.因式分解法"></a>1.因式分解法</h4><h5 id="a-数据中心化"><a href="#a-数据中心化" class="headerlink" title="a.数据中心化"></a>a.数据中心化</h5><p>中心化就是减去图像点的质心。</p>
<script type="math/tex; mode=display">
\hat{x}_{i j}=x_{i j}-\bar{x}_{i} \\ 其中：\begin{aligned}\bar{x}_{i}=\frac{1}{n} \sum_{k=1}^{n} x_{i k} \\ 
x_{\mathrm{ij}}=A_{i} X_{j}+b_{i}\end{aligned}\tag{6.18}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040613.png" alt="image-20210829191737903"></p>
<p>然后可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{x}_{i j}=x_{i j}-\frac{1}{n} \sum_{k=1}^{n} x_{i k} &=A_{i} X_{j}+b_{i}-\frac{1}{n} \sum_{k=1}^{n} A_{i} X_{k}-\frac{1}{n} \sum_{k=1}^{n} b_{i} \\
&=A_{i}\left(X_{j}-\frac{1}{n} \sum_{k=1}^{n} X_{k}\right)\\&=A_{i}\left(X_{j}-\bar{X}\right)\\&=A_{i} \hat{X}_{j}
\end{aligned}\tag{6.19}</script><p>如果令三维空间点的质心=世界坐标系的远点。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040618.png" alt="image-20210829191948530"></p>
<p>那么：</p>
<script type="math/tex; mode=display">
\hat{x}_{i j}=A_{i} \hat{X}_{j}=A_{i} X_{j}\tag{6.20}</script><h5 id="b-因式分解"><a href="#b-因式分解" class="headerlink" title="b.因式分解"></a>b.因式分解</h5><p>现在我们把去均值以后的 $m\times n$ 个测量值写成矩阵的形式：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{cccc}
\hat{x}_{11} & \hat{x}_{12} & \cdots & \hat{x}_{1 n} \\
\hat{x}_{21} & \hat{x}_{22} & \cdots & \hat{x}_{2 n} \\
& & \ddots & \\
\hat{x}_{m 1} & \hat{x}_{m 2} & \cdots & \hat{x}_{m n}
\end{array}\right]\tag{6.21}</script><p>其中每个 $\hat{x}_{ij}$ 是一个 $2\times1$ 的向量，它是图像点的像素坐标。</p>
<p>根据式(6.20)，可以推导出D的由来：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{llll}
\hat{x}_{11} & \hat{x}_{12} & \cdots & \hat{x}_{1 n} \\
\hat{x}_{21} & \hat{x}_{22} & \cdots & \hat{x}_{2 n} \\
& & \ddots & \\
\hat{x}_{m 1} & \hat{x}_{m 2} & \cdots & \hat{x}_{m n}
\end{array}\right]=\left[\begin{array}{c}
A_{1} \\
A_{2} \\
\vdots \\
A_{m}
\end{array}\right]
\left[\begin{array}{c} X_{1} & X_{2} & \cdots & X_{n}
\end{array}\right]=MS\tag{6.22}</script><p>下面对D进行奇异值分解：</p>
<script type="math/tex; mode=display">
D=UWV^T\tag{6.23}</script><p>(6.22)中，M矩阵的最大秩为3，S矩阵的最大秩也为3。所以D的最大秩为3</p>
<p>那么我们就可以选择前三个最大的奇异值来进行分解，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040622.png" style="zoom: 67%;" /></p>
<p>所以：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040625.png" alt="image-20210829193956389" style="zoom:67%;" /></p>
<script type="math/tex; mode=display">
D=U_3W_3V_3^T=U_3(W_3V_3^T)=M^\star S^\star \tag{6.24}</script><p>(6.24)中，我们用后面 $W_3V_3^T$ 来重构S矩阵，当然也可以用 $V_3^T$ 来重构S。</p>
<p>这就引出了一个问题，对于同一结构，为什么可以有不同种恢复机构呢？</p>
<p>这个问题就是仿射结构的恢复歧义。</p>
<h5 id="c-因式分解法的问题"><a href="#c-因式分解法的问题" class="headerlink" title="c.因式分解法的问题"></a>c.因式分解法的问题</h5><p>当我们构建D矩阵时，是假设所有的三维点在图像上都能找得到，但当三维点被遮挡后，图像上找不到它的投影点，此时D矩阵中的元素就会空缺。这就会造成求解失败。</p>
<h4 id="2-仿射结构恢复歧义"><a href="#2-仿射结构恢复歧义" class="headerlink" title="2.仿射结构恢复歧义"></a>2.仿射结构恢复歧义</h4><p>先来看看D矩阵的推导过程，可用下图来表示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040717.png" alt="image-20210829194730339"></p>
<p>当我们在M矩阵和S矩阵间乘上一个可逆矩阵H和它的逆后：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040635.png" alt="image-20210829194843158"></p>
<p>最后的结果还是D矩阵，但是M和S矩阵却不相同了。其中H矩阵可以是任意的可逆的 $3\times3$ 的矩阵</p>
<p>所以必须利用其他的约束条件来解决歧义的问题。</p>
<p>仿射歧义的可视化如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040638.png" alt="image-20210829195044317"></p>
<p>真实的三维结构和恢复的三维结构之间相差了一个任意的 $3\times 3$ 的可逆矩阵H。</p>
<h3 id="D-透视结构恢复"><a href="#D-透视结构恢复" class="headerlink" title="D.透视结构恢复"></a>D.透视结构恢复</h3><h4 id="0-问题描述-2"><a href="#0-问题描述-2" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>有$x_{ij}=M_iX_j$ </p>
<p>$M_i$ 是第i张图片对应的摄像机投影矩阵</p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的投影矩阵 $M_i$ 。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040643.png" alt="image-20210829195526866"></p>
<h4 id="1-透视结构恢复歧义"><a href="#1-透视结构恢复歧义" class="headerlink" title="1.透视结构恢复歧义"></a>1.透视结构恢复歧义</h4><p>根据透视相机投影规律，当不知道相机的内参和外参时，可用M矩阵来表示透视投影关系，M是一个 $3\times4$ 矩阵，透视关系如下：</p>
<script type="math/tex; mode=display">
x_{ij}=M_iX_j\tag{6.25}</script><p>当 $M_i$ 和 $X_j$ 之间，可以加上任意一个 $4\times 4$ 的可逆矩阵H和其逆矩阵的乘积。</p>
<script type="math/tex; mode=display">
x_{ij}=M_iHH^{-1}X_j\tag{6.26}</script><p>这样，在恢复结构的时候，所恢复出的 $M_i$ 和真实的 $M_i$ 可能会相差一个H投影变换矩阵。这就是透视结构恢复歧义。</p>
<p>所以我们恢复透视结构时，是在相差一个 $4\times4$ 的可逆变换的情况下，恢复摄像机运动和场景结构的。</p>
<h4 id="2-代数方法（通过基础矩阵）"><a href="#2-代数方法（通过基础矩阵）" class="headerlink" title="2.代数方法（通过基础矩阵）"></a>2.代数方法（通过基础矩阵）</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040648.png" alt="image-20210829202031145"></p>
<p>代数方法主要用于两视图情况，尽管我们要使用的是一个图像序列，但是我们可以将其分成多个两视图情况来进行求解。</p>
<p>具体求解有三个步骤：</p>
<p>(1) 八点算法来求得基础矩阵F</p>
<p>(2)由基础矩阵F求得摄像机的投影矩阵。</p>
<p>(3)用三角化计算三维点的坐标。</p>
<h5 id="a-基础矩阵和投影矩阵的关系"><a href="#a-基础矩阵和投影矩阵的关系" class="headerlink" title="a.基础矩阵和投影矩阵的关系"></a>a.基础矩阵和投影矩阵的关系</h5><p>在这里，第(2)步中，<strong>如何通过F矩阵来求投影矩阵M我们之前没有说过</strong>。下面介绍该步骤的解法。</p>
<p>由于透视歧义的存在，我们总是可以找到一个可逆矩阵H，使得：</p>
<script type="math/tex; mode=display">
M_{1} H^{-1}=[I \mid 0] \quad M_{2} H^{-1}=[A \mid b]\tag{6.27}</script><p>用X表示三维点，$x\ and \ x’$ 分别称为摄像机1和2的对应观测值。</p>
<p>令：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\widetilde{M}_{1}=M_{1} H^{-1}=\left[\begin{array}{ll}
I & 0
\end{array}\right] \\
\widetilde{M}_{2}=M_{2} H^{-1}=\left[\begin{array}{ll}
A & b
\end{array}\right] \\
\widetilde{X}=H X
\end{array}\right.\tag{6.28}</script><p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x=M_{1} X=M_{1} H^{-1} H X=[I \mid 0] \tilde{X} \\
&x^{\prime}=M_{2} X=M_{2} H^{-1} H X=[A \mid b] \tilde{X}
\end{aligned}\tag{6.29}</script><p>对于摄像机1和2的观测值 $x\ and \ x’$ 有如下关系：</p>
<script type="math/tex; mode=display">
x^{\prime}=[A \mid b] \widetilde{X}=[A \mid b]\left[\begin{array}{c}
\widetilde{X}_{1} \\
\widetilde{X}_{2} \\
\widetilde{X}_{3} \\
1
\end{array}\right]=A[I \mid 0]\left[\begin{array}{c}
\widetilde{X}_{1} \\
\widetilde{X}_{2} \\
\widetilde{X}_{3} \\
1
\end{array}\right]+b=A[I \mid 0] \widetilde{X}+b=A x+b\tag{6.30}</script><p>然后我们将(6.30)中的  $x’$ 叉乘b：</p>
<script type="math/tex; mode=display">
x'\times b=(Ax+b)\times b=Ax\times b\tag{6.31}</script><p>再用 $x’$ 点乘 $x’\times b$ ，它的结果为0，所以：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x'^T \cdot(x'\times b)&=x'^T\cdot(Ax\times b)\\
&=-x'^T\cdot(b\times Ax)\\
&=-x'^T[b_{\times}]Ax=0
\end{aligned}\tag{6.32}</script><p>由极几何关系，可以知道两个视图的对应点的像素坐标的关系是：</p>
<script type="math/tex; mode=display">
x'^TFx=0\tag{6.33}</script><p>所以比较(6.32)和(6.33)，有：</p>
<script type="math/tex; mode=display">
F=[b_{\times}]A\tag{6.34}</script><p><strong>有了这个关系，我们现在就可以用八点法得到的基础矩阵F来分解出A矩阵和b</strong></p>
<h5 id="b-计算投影矩阵中的b"><a href="#b-计算投影矩阵中的b" class="headerlink" title="b.计算投影矩阵中的b"></a>b.计算投影矩阵中的b</h5><p>考虑：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F^Tb&=([b_{\times}]A)^Tb\\
&=A^T[b_{\times}]^Tb\\
&=-A^T[b_{\times}]b\\
&=0
\end{aligned}\tag{6.35}</script><p>所以可通过(6.35)的线性方程组来求解出b</p>
<p>b为 $F^T$ 矩阵的最小奇异值的右奇异向量，且 $||b||=1$ 。</p>
<h5 id="c-计算A矩阵"><a href="#c-计算A矩阵" class="headerlink" title="c.计算A矩阵"></a>c.计算A矩阵</h5><p>直接定义：</p>
<script type="math/tex; mode=display">
A'=-[b_{\times}]F\tag{6.36}</script><p>下面来验证 $[b_{\times}]A’$ 是否等于 $F$ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\ [b_{\times}]A'&=-[b_\times][b_\times]F\\
&=-(bb^T-|b|^2I)F\\
&=-bb^TF+|b|^2F\\
&=-b(F^Tb)^T+|b|^2F\\
&=1\cdot F\\
&=F
\end{aligned}\tag{6.37}</script><p>所以可以得到：</p>
<script type="math/tex; mode=display">
A=A'=-[b_\times]F\tag{6.38}</script><p>最后我们就可以计算出两个投影矩阵了：</p>
<script type="math/tex; mode=display">
\widetilde{M}_{1}=\left[\begin{array}{ll}
I & 0
\end{array}\right] \quad \widetilde{M}_{2}=\left[-\left[b_{\times}\right] F \quad b\right]</script><blockquote>
<p>这里的b是有具体的几何含义的，在第四章3小节b中，基础矩阵的性质可知，$F^Te=0$ ，而这里的 $F^Tb=0$ ，所以b是一个极点。</p>
</blockquote>
<h5 id="d-代数法的问题"><a href="#d-代数法的问题" class="headerlink" title="d.代数法的问题"></a>d.代数法的问题</h5><p>在实际的应用中，我们拥有的是一个图像序列，我们需要在两两视图间进行求解，然后再将得到的结果累加，例如求得了 $M_1$ 和 $M_2$ ，然后再求 $M_2 \ and \ M_3$ 之间的关系，最后再进行累加得到 $M_1\ and \ M_3$ 的关系，这样一点一点累积，但凡每步都有一点点小误差，但当不断积累后，就会变成一个较大的误差。</p>
<h4 id="3-捆绑调整"><a href="#3-捆绑调整" class="headerlink" title="3.捆绑调整"></a>3.捆绑调整</h4><p>考虑到因式分解法和代数法的缺点，我们又提出了一种新的方法，捆绑法。</p>
<p>捆绑法主要采用非线性优化方法，通过最小化重投影误差，来优化得到 $X_j\ and\ M_i$ </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040657.png" alt="image-20210829232507094"></p>
<p>最小化重投影误差：</p>
<script type="math/tex; mode=display">
E(M, X)=\sum_{i=1}^{m} \sum_{j=1}^{n} D\left(x_{i j}, M_{i} X_{j}\right)^{2}\tag{6.39}</script><p>我们可以使用牛顿法或列文伯格-马夸尔特方法来进行非线性优化。</p>
<p>该方法的优势是可以同时处理大量视图，处理丢失的数据。</p>
<p>但该方法的弊端也十分致命，就是需要优化的参数过多，所以需要良好的初始条件。</p>
<p>因此在实际的应用中，常用作结构恢复SFM(structure from motion)的最后一步，通过因式分解法或代数法来求的优化问题的初始解，然后在通过捆绑法进行优化。</p>
]]></content>
      <categories>
        <category>SLAM学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
</search>
