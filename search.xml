<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SLAM的数学描述</title>
    <url>/2021/10/18/SLAM%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<p>主要介绍如何使用数学语言来描述SLAM问题。<br><span id="more"></span><br>设 $\vec{x}$ 表示相机的位置，$\vec x_1\ , \ \vec x_2 \ …\ ,\vec x_k$表示不同时刻的位置信息，$\vec y_1 \ , \vec y_2 \ ,\ …\ \vec y_n$表示路标的位置，共有n个路标点</p>
<hr>
<p>我们的<strong>目标是：</strong>描述以下两件事情：</p>
<ol>
<li>什么是运动 ：k-1时刻到k时刻，$\vec x$是如何变化的</li>
<li>什么是观测：在k时刻，相机在 $\vec x_k$处探测到某一路标，$\vec y_j$​ </li>
</ol>
<hr>
<p>首先来说关于 <strong><u>运动</u></strong> 的数学描述：</p>
<script type="math/tex; mode=display">
\vec x_k = f(\vec x_{k-1}\ , \vec u_k\ ,\vec w_k)</script><p>$\vec u_k$表示k时刻运动的输入(可以是传感器读出来的速度或者是通过视觉里程计估算出来的速度)，$\vec w_k$表示噪声</p>
<p>接下来说关于 <strong><u>观测</u></strong> 的表述：</p>
<script type="math/tex; mode=display">
\vec z_{k,j}=h(\vec y_j\ ,\vec x_k \ ,\vec {v_{k,j}})</script><p>该式表示的是相机在位置 $\vec x_k$上看到某个路标点 $\vec y_j$时，产生了一个观测数据 $\vec z_{k,j}$ ，而 $\vec v_{k,j}$表示观测噪声</p>
<hr>
<p>以二维运动为例：</p>
<p>如图所示</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018023849.png" style="zoom:60%;" /></p>
<p>已知上一时刻k-1的相机位姿 $\vec x_{k-1}$ 和运动输入$\vec{u}_{k}$（在视觉SLAM中可以由视觉里程计得出或通过传感器得出）</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\vec{x}_{k}=\left[x_{1}, x_{2}, \theta\right]_{k}^{\top} \\
&\vec{u}_{k}=\left[\Delta x_{1}, \Delta x_{2}, \Delta \theta\right]_{k}^{\top}
\end{aligned}</script><p>运动方程为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{1} \\
x_{2} \\
\theta
\end{array}\right]_{k}=\left[\begin{array}{l}
x_{1} \\
x_{2} \\
\theta
\end{array}\right]_{k-1}+\left[\begin{array}{c}
\Delta x_{1} \\
\Delta x_{2} \\
\Delta \theta
\end{array}\right]_{k}+\vec{w}_{k}</script><p>对于观测方程，以二维激光传感器为例，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018023854.png" alt="img" style="zoom:60%;" /></p>
<p>路标点j与相机位置关系由距离r和夹角 $\varphi$表示，即观测数据 $z_{k,j}=[r_{j},\varphi_{j}]^T_k$（这是由传感器测出的值），这里的k表示k时刻下的观测数据</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
r_{j} \\
\varphi_{j}
\end{array}\right]_k=\left[\begin{array}{c}
\sqrt{\left(x_{1,k}-y_{1, j}\right)^{2}+\left(x_{2,k}, -y_{2, j}\right)^{2}} \\
\arctan \left(\frac{y_{2,j} -x_{2, k}}{y_{1, j}-x_{1, k}}\right)
\end{array}\right]+\vec{v}</script><p>$\vec{v}$是观测误差，现在就要求 $\vec x_k$和 $\vec y_j$</p>
<blockquote>
<p>注意：这里求 $\vec x_k$表示定位问题，即求出相机自己本身在世界坐标系下的坐标，而求出 $\vec y_j$表示建图问题，即求出周围环境中路标点在世界坐标系下的坐标</p>
</blockquote>
<p>如果求出了 $\vec x_k$和 $\vec y_j$，这样就可以确定相机位置与路标点的位置，也就完成了定位和建图，而反看上面的运动方程和观测方程，假如没有噪声的存在，那么直接解方程就是了，就可以准确的求出相机和路标点在世界坐标系下的位置，然而现实并不是这样，由于噪声的存在，<strong>解方程的问题就变成了一个状态估计问题</strong>，这也是SLAM的最基本问题。</p>
<p>按照运动和观测方程是否为线性和噪声是否服从高斯分布，可以分为以下几类以及解决其状态估计的办法：</p>
<p>线性高斯分布（LG）$\longrightarrow$ 卡尔曼滤波（KF）</p>
<p>非线性非高斯分布（NLNG）$\longrightarrow$扩展卡尔曼滤波（EKF）或非线性优化</p>
]]></content>
      <categories>
        <category>SLAM学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode编译环境配置</title>
    <url>/2021/10/18/VScode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在linux或mac中编译C++,首先要配置好编译环境。<br><span id="more"></span></p>
<h1 id="1-首先编写CMakeLists-txt文件"><a href="#1-首先编写CMakeLists-txt文件" class="headerlink" title="1.首先编写CMakeLists.txt文件"></a>1.首先编写CMakeLists.txt文件</h1><p>注意：在<code>c_cpp_properties.json</code>中设置了头文件路径，在编译的过程中就会有头文件内容的提示，但仍需要在<code>CMakeLists.txt</code>中写好包含的头文件路径，否则编译器只会在<code>usr/include文件夹下</code>和<code>CMakeLists.txt</code>所在文件夹下寻找头文件</p>
<p>如果不在<code>c_cpp_properties.json</code>中设置头文件路径，在写代码的时候可能会没有提示，而且头文件名字下会有红波浪线，但可以正常编译</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(文件名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ VAR) <span class="comment">#把当前路径下的所有源文件打包程VAR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(添加头文件路径)<span class="comment">#如果在vscode中已经添加了头文件路径了，就不需要再添加了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(搜索库)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;添加库的头文件&#125;</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)<span class="comment">#如果想调试，加上这一句，生成可调试文件</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS<span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;</span>)<span class="comment">#生成错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(可执行文件名 <span class="variable">$&#123;VAR&#125;</span>)<span class="comment">#生成可执行文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件 库名) <span class="comment">#链接库</span></span><br></pre></td></tr></table></figure>
<h1 id="2-文件根目录中建立一个build文件夹"><a href="#2-文件根目录中建立一个build文件夹" class="headerlink" title="2.文件根目录中建立一个build文件夹"></a>2.文件根目录中建立一个build文件夹</h1><p>编译过程中生成的中间文件和可执行文件全在该文件夹下，可执行文件的位置可在CMakeLists.txt中改变路径</p>
<h1 id="3-建立-json文件夹，编写launch-json文件"><a href="#3-建立-json文件夹，编写launch-json文件" class="headerlink" title="3.建立.json文件夹，编写launch.json文件"></a>3.建立.json文件夹，编写launch.json文件</h1><p>新建launch.json文件，该文件是在VSCODE中按F5后所执行的命令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/可执行文件名&quot;</span>,**<span class="comment">//执行文件的路径加上可执行文件，$&#123;workspaceFolder&#125;为根目录**</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,<span class="comment">//打开外部终端</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">             <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;Build&quot;</span>,<span class="comment">//该命令表示执行launch.json的命令之前的预执行任务，要在tasks.json中设置</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-编写tasks-json文件"><a href="#4-编写tasks-json文件" class="headerlink" title="4.编写tasks.json文件"></a>4.编写tasks.json文件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>:<span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOrder&quot;</span>: <span class="string">&quot;sequence&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span>:[<span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;make&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件实践</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>编程</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建课程笔记</title>
    <url>/2021/10/18/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习北邮鲁鹏老师《机器视觉》笔记。<br>三维重建的目标就是从单张或多张场景图片中重构出三维场景的结构信息。<br><span id="more"></span></p>
<h2 id="一、摄像机几何"><a href="#一、摄像机几何" class="headerlink" title="一、摄像机几何"></a>一、摄像机几何</h2><h3 id="A-针孔摄像机模型"><a href="#A-针孔摄像机模型" class="headerlink" title="A.针孔摄像机模型"></a>A.针孔摄像机模型</h3><p>首先，我们要知道三维世界中的点是如何映射到像素平面的，完成这个映射过程就是摄像机。</p>
<p>如果直接让胶片放置在物体的前方，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040014.png" alt="image-20210818224820393"></p>
<p>那么此时胶片上的一个点会记录真实世界多个点的信息。这样是不行的，于是我们采用针孔模型：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040016.png" alt="image-20210818224930850"></p>
<p>通过一个带有小孔的屏障，我们便可以使像素平面上的点与真实世界上的点形成一一对应的关系，这就是针孔相机模型。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040022.png" alt="image-20210818225105759"></p>
<p>下面具体描述一下<strong>针孔摄像机模型：</strong></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040034.png" alt="image-20210818230044519"></p>
<blockquote>
<p>要注意三个坐标系：</p>
<p>1.相机坐标系：以针孔为原点，建立的三维坐标系，其坐标轴单位是米</p>
<p>2.像平面坐标系：以像平面中心为原点的三维坐标系，坐标轴单位是米</p>
<p>3.像素坐标系：与像平面重合的二维坐标系，其坐标轴单位是像素</p>
</blockquote>
<p>根据三角形相似法则，最终可以得到相机坐标系下的P点到像平面坐标系的P‘点的映射关系：</p>
<script type="math/tex; mode=display">
P=\left[\begin{array}{l}
x \\
y \\
z
\end{array}\right] \rightarrow P^{\prime}=\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]\tag{1.1}</script><script type="math/tex; mode=display">
\quad\left\{\begin{array}{l}
x^{\prime}=f \frac{x}{z} \\
y^{\prime}=f \frac{y}{z}
\end{array}\right.\tag{1.2}</script><h3 id="B-摄像机和透镜"><a href="#B-摄像机和透镜" class="headerlink" title="B.摄像机和透镜"></a>B.摄像机和透镜</h3><p>光圈就是针孔模型中的小孔，小孔的大小决定了像的清晰程度和亮度</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040040.png" alt="image-20210818231502207"></p>
<p>如果光圈太大，像中的一个点会对应真实世界中的多个点，此时图像会模糊，但是光圈太小，又会使透过的光变少，像变暗。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040044.png" alt="image-20210818231844139"></p>
<p>那么如何才能使像既清晰又明亮呢？</p>
<p>增加透镜！！！</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040047.png" alt="image-20210818232135974"></p>
<p>透镜的特点：</p>
<p>1.所有平行于光轴的光线都会会聚到焦点，焦点到透镜中心的距离称为焦距</p>
<p>2.穿过中心的光线的方向不发生改变</p>
<h4 id="1-加上透镜后的针孔模型"><a href="#1-加上透镜后的针孔模型" class="headerlink" title="1.加上透镜后的针孔模型"></a>1.加上透镜后的针孔模型</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040053.png" alt="image-20210818232418455"></p>
<p>该模型与之前的针孔模型区别不大，只是针孔模型中的 $f$ 变为 $z’$ </p>
<script type="math/tex; mode=display">
z^{\prime}=f+z_{0} \quad\left\{\begin{array}{l}
x^{\prime}=z^{\prime} \frac{x}{z} \\
y^{\prime}=z^{\prime} \frac{y}{z}
\end{array}\right.\tag{1.3}</script><p>此处的 $f$ 是透镜的焦距，其与透镜的自身性质有关。</p>
<h4 id="2-透镜引起的问题"><a href="#2-透镜引起的问题" class="headerlink" title="2.透镜引起的问题"></a>2.透镜引起的问题</h4><h5 id="a-失焦"><a href="#a-失焦" class="headerlink" title="a.失焦"></a>a.失焦</h5><p>可以看到加上了透镜好处多多，但是也会引起一个问题，在一定的范围内，光线会会聚到像平面上，但是当超过了这个范围，光线就不会会聚到像平面上，此时便发生失焦。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040100.png" alt="image-20210818233432270"></p>
<h5 id="b-径向畸变"><a href="#b-径向畸变" class="headerlink" title="b.径向畸变"></a>b.径向畸变</h5><p>图像像素点以畸变中心为中心点，沿着径向产生位置偏差，从而导致图像中所成的像发生形变</p>
<p>枕形畸变：畸变像点相对于理想像点沿径向向外偏移，远离中心</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040104.png" alt="image-20210818233754147"></p>
<p>桶形畸变：畸变像点相对于理想像点沿径向向内偏移，向中心靠拢</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040106.png" alt="image-20210818233846093"></p>
<h3 id="C-摄像机几何"><a href="#C-摄像机几何" class="headerlink" title="C.摄像机几何"></a>C.摄像机几何</h3><p>在我们分析图像时，是在像素坐标系下分析的，像素坐标系和像平面坐标系的区别是，像素坐标系</p>
<p>是二维的，其坐标轴单位是像素，且其坐标原点一般不是在最中心，这就会发生一个坐标的偏移。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040108.png" alt="image-20210818234715959" style="zoom: 67%;" /></p>
<p>因此，需要根据像平面坐标系中点的坐标，求出该点在像素坐标系下的坐标：</p>
<script type="math/tex; mode=display">
P=(x, y, z) \rightarrow P^{\prime}=\left(u,v\right)\\
\left\{\begin{array}{l}
u=\alpha \frac{x}{z}+c_{x}\\
v=\beta \frac{y}{z}+c_{y}
\end{array}\right.\tag{1.4}</script><p>可是此时，空间点 $P$ 到 像素点 $P’$ 的坐标变换并不是一个线性变换，如果想变成一个线性变换，需要引入齐次坐标来表达。</p>
<h4 id="1-齐次坐标"><a href="#1-齐次坐标" class="headerlink" title="1.齐次坐标"></a>1.齐次坐标</h4><p>我们之前所使用的都是欧式坐标，例如三维空间中的一点，可以用 $(x,y,z)$ 来表示，此时在原有维数的基础上再添一维，就变成了齐次坐标。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040113.png" alt="image-20211004222903357" style="zoom:50%;" /></p>
<p>对于齐次坐标 $(1,1,1)$ 和 $(2,2,2)$ ，其所对应的欧式坐标都是 $(1,1)$ ，所以，对于齐次坐标 P 和 Q，如果P=kQ，那么 P 和 Q 对应同一个欧式坐标。</p>
<h4 id="2-齐次坐标的投影变换"><a href="#2-齐次坐标的投影变换" class="headerlink" title="2.齐次坐标的投影变换"></a>2.齐次坐标的投影变换</h4><p>引入齐次坐标后，空间点的齐次坐标与所对应的像素点的齐次坐标可以用一个线性变换来表达：</p>
<script type="math/tex; mode=display">
P_{h}^{\prime}=\left[\begin{array}{c}
\alpha x+c_{x} z \\
\beta y+c_{y} z \\
z
\end{array}\right]=\left[\begin{array}{cccc}
\alpha & 0 & c_{x} & 0 \\
0 & \beta & c_{y} & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
z \\
1
\end{array}\right]=MP_h\tag{1.5}</script><script type="math/tex; mode=display">
\overbrace{P_{h}^{\prime}}^{\text {齐次坐标 }} \rightarrow \overbrace{P^{\prime}=\left(\alpha \frac{x}{z}+c_{x}, \beta \frac{y}{z}+c_{y}\right)}^{\text {欧式坐标}}\tag{1.6}</script><p>M矩阵是摄像机的投影矩阵。</p>
<h4 id="3-摄像机偏斜"><a href="#3-摄像机偏斜" class="headerlink" title="3.摄像机偏斜"></a>3.摄像机偏斜</h4><p>有的时候，像素坐标系的两个坐标轴不是垂直的</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040121.png" alt="image-20210819004057419"></p>
<p>此时投影矩阵M为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{cccc}
\alpha & -\alpha \cot \theta & c_{x} & 0 \\
0 & \frac{\beta}{\sin \theta} & c_{y} & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\tag{1.7}</script><h4 id="4-摄像机内参数矩阵"><a href="#4-摄像机内参数矩阵" class="headerlink" title="4.摄像机内参数矩阵"></a>4.摄像机内参数矩阵</h4><p>上文提到的M前三列所构成的3*3矩阵称为摄像机的内参数矩阵K，它由摄像机的制作工艺决定。</p>
<script type="math/tex; mode=display">
M=K[I\ 0]\tag{1.8}</script><p>摄像机的内参数决定了空间点到图像点的映射。</p>
<p>摄像机的内参数矩阵共有5个自由度。</p>
<p>当K矩阵为单位阵时，此时的相机称为规范化相机，其变换叫做规范化投影变换。</p>
<blockquote>
<p>小结：当已知空间点坐标和相机内参时，一定可以求出像素点坐标。而仅知道像素点坐标和内参时，反求不出空间点坐标。因为像素点的欧式坐标对应无数个齐次坐标（尺度不确定问题）</p>
</blockquote>
<h4 id="5-世界坐标系的点到像素坐标系"><a href="#5-世界坐标系的点到像素坐标系" class="headerlink" title="5.世界坐标系的点到像素坐标系"></a>5.世界坐标系的点到像素坐标系</h4><p>在世界坐标系下，同一个点在不同相机的坐标系下坐标不同。</p>
<p>世界坐标系的坐标到相机坐标系的坐标可由下面式子来描述：</p>
<script type="math/tex; mode=display">
P=\left[\begin{array}{ll}
R & T \\
0 & 1
\end{array}\right] P_{w}=\left[\begin{array}{ll}
R & T \\
0 & 1
\end{array}\right] \left[\begin{array}{c}
x_{w} \\
y_{w} \\
z_{w} \\
1
\end{array}\right]\tag{1.9}</script><p>已知世界坐标系一点坐标，映射到像素坐标系中为：</p>
<script type="math/tex; mode=display">
P^{\prime}=K\left[\begin{array}{ll}
I & 0
\end{array}\right] P=K\left[\begin{array}{ll}
I & 0
\end{array}\right]\left[\begin{array}{cc}
R & T \\
0 & 1
\end{array}\right] P_{w}=\overbrace{K}^{内部参数}
\overbrace{[R \quad T]}^{外部参数}
P_{w}=M P_{w}\tag{1.10}</script><p>此时的投影矩阵M，既包含相机的内参信息，又包含了相机的运动信息（外部参数），M共有11个自由度。</p>
<h4 id="6-透视投影相机"><a href="#6-透视投影相机" class="headerlink" title="6.透视投影相机"></a>6.透视投影相机</h4><p>之前所得到的M矩阵叫做投影矩阵，它代表着透视投影模型，也就是三维真实空间到图像上的投影过程。符合该模型的相机称为透视投影相机，我们生活中的大多数相机都是透视投影相机，人类的眼睛也符合该模型。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040127.jpg" alt="img"></p>
<p>透视投影有以下几个特点：</p>
<ol>
<li>点投影为点</li>
<li>线投影为线</li>
<li>近大远小</li>
<li>角度不再保持</li>
<li>平行线相交</li>
</ol>
<h4 id="7-Faugeras定理"><a href="#7-Faugeras定理" class="headerlink" title="7.Faugeras定理"></a>7.Faugeras定理</h4><p>我们知道投影矩阵M是3 <em> 4的矩阵，当已知任意3 </em> 4的矩阵时，是否是投影矩阵呢？可以用Faugeras定理来进行判断。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040132.png" alt="image-20210819012316783"></p>
<h3 id="D-其他摄像机模型"><a href="#D-其他摄像机模型" class="headerlink" title="D.其他摄像机模型"></a>D.其他摄像机模型</h3><h4 id="1-弱透视投影摄像机"><a href="#1-弱透视投影摄像机" class="headerlink" title="1.弱透视投影摄像机"></a>1.弱透视投影摄像机</h4><p>当空间点的深度相差不多时，即相对场景深度小于其与相机的距离。可以简化为在同一深度。此时便是弱透视投影相机模型。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040138.png" alt="image-20210819101236994" style="zoom: 67%;" /></p>
<p>这里与透视投影相机的不同是其各点的深度是一个定值，且相同</p>
<script type="math/tex; mode=display">
\left\{\begin{array} { l } 
{ x ^ { \prime } = \frac { f ^ { \prime } } { z } x } \\
{ y ^ { \prime } = \frac { f ^ { \prime } } { z } y }
\end{array} \rightarrow \left\{\begin{array}{l}
x^{\prime}=\frac{f^{\prime}}{z_{0}} x \\
y^{\prime}=\frac{f^{\prime}}{z_{0}} y
\end{array}\right.\right.\tag{1.11}</script><p>通过这个简化后，投影矩阵的第三行变成了 $[0,0,0,1]$ </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040144.png" alt="image-20210819103539119" style="zoom:67%;" /></p>
<p>当物体较小且较远时准确，常用于图像识别任务。</p>
<h4 id="2-正交投影摄像机"><a href="#2-正交投影摄像机" class="headerlink" title="2.正交投影摄像机"></a>2.正交投影摄像机</h4><p>摄像机中心到像平面的距离无限远时</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040149.png" alt="image-20210819104040178" style="zoom: 50%;" /></p>
<p>此时像平面上投影点的x，y方向的坐标等于实际空间点的坐标。</p>
<p>该模型常用于CAD制图时使用。</p>
<h2 id="二、摄像机标定"><a href="#二、摄像机标定" class="headerlink" title="二、摄像机标定"></a>二、摄像机标定</h2><p>摄像机标定就是求解摄像机的内外参数，更为准确的说，一般的相机内参数是不变的，而外参代表着相机的运动，是时刻改变的，所以一般的相机标定是对相机的内参的计算。</p>
<h3 id="A-标定方法-PnP的直接线性变换解法"><a href="#A-标定方法-PnP的直接线性变换解法" class="headerlink" title="A.标定方法(PnP的直接线性变换解法)"></a>A.标定方法(PnP的直接线性变换解法)</h3><h4 id="1-标定设备"><a href="#1-标定设备" class="headerlink" title="1.标定设备"></a>1.标定设备</h4><p> 如下图所示，有一个标定板，上面的每个点的坐标都已知。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040155.png" alt="image-20210820145956320"></p>
<p>然后对该标定板拍照，得到图像，可以得到空间点的坐标 $P_i$ 和其对应点的像素坐标 $p_i$ 。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040200.png" alt="image-20210820150231966"></p>
<h4 id="2-建立线性方程组"><a href="#2-建立线性方程组" class="headerlink" title="2.建立线性方程组"></a>2.建立线性方程组</h4><p>由上文提到，投影矩阵M是一个3*4的矩阵，可以表示为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{l}
m_1\\
m_2\\
m_3\\
\end{array}\right]\tag{2.1}</script><p>其中 $m_i$ 是一个4阶的行向量。</p>
<p>根据前面的透视投影关系，可以得到像素坐标和世界坐标的关系：</p>
<script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=\left[\begin{array}{l}
\frac{m_{1} P_{i}}{m_{3} P_{i}} \\
\frac{m_{2} P_{i}}{m_{3} P_{i}}
\end{array}\right]\tag{2.2}</script><p>知道一对对应点（ $P_i$ 和 $p_i$ 为已知），就可以得到两个方程，而M矩阵共有11个自由度，理论上用6对点便可以求解。但实际中会选6对以上的点来计算，这样可以提高结果的鲁棒性。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&u_{i}=\frac{m_{1} P_{i}}{m_{3} P_{i}} \rightarrow u_{i}\left(m_{3} P_{i}\right)=m_{1} P_{i} \rightarrow u_{i}\left(m_{3} P_{i}\right)-m_{1} P_{i}=0 \\
&v_{i}=\frac{m_{2} P_{i}}{m_{3} P_{i}} \rightarrow v_{i}\left(m_{3} P_{i}\right)=m_{2} P_{i} \rightarrow v_{i}\left(m_{3} P_{i}\right)-m_{2} P_{i}=0
\end{aligned}\tag{2.3}</script><p>可以将每个点的方程整理成(2.3)的形式，便可以得到一个线性方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
u_{1}\left(m_{3} P_{1}\right)-m_{1} P_{1}=0 \\
v_{1}\left(m_{3} P_{1}\right)-m_{2} P_{1}=0 \\
\vdots \\
u_{i}\left(m_{3} P_{i}\right)-m_{1} P_{i}=0 \\
v_{i}\left(m_{3} P_{i}\right)-m_{2} P_{i}=0 \\
\vdots \\
u_{n}\left(m_{3} P_{n}\right)-m_{1} P_{n}=0 \\
v_{n}\left(m_{3} P_{n}\right)-m_{2} P_{n}=0
\end{array}\right.\tag{2.4}</script><p>然后将上式写成矩阵的形式：</p>
<script type="math/tex; mode=display">
Pm=0\tag{2.5}\\
\begin{aligned}
P \stackrel{\text { def }}{=}\left(\begin{array}{ccc}
P_{1}^{T} & 0^{T} & -u_{1} P_{1}^{T} \\
0^{T} & P_{1}^{T} & -v_{1} P_{1}^{T} \\
& \vdots & \\
P_{n}{ }^{T} & 0^{T} & -u_{n} P_{n}{ }^{T} \\
0^{T} & P_{n}^{T} & -v_{n} P_{n}{ }^{T}
\end{array}\right)_{2 n \times 12}m \stackrel{\text { def }}{=}\left(\begin{array}{c}
{m_{1}^{T}} \\
{m_{2}^{T}} \\
m_{3}^{T}
\end{array}\right)_{12 \times 1}
\end{aligned}</script><blockquote>
<p>注意这里的 $P_i$ 是空间点的齐次坐标</p>
</blockquote>
<h4 id="3-求解方程组"><a href="#3-求解方程组" class="headerlink" title="3.求解方程组"></a>3.求解方程组</h4><p>P矩阵中所有的元素是已知的，下面求解该线性方程：P的行数有2n个，列数有12个。</p>
<p>当P的秩小于12时，该方程组有非零解。</p>
<p>当P的秩大于等于12时，此时为超定方程，该方程组只有0解。</p>
<p>通常情况下，P矩阵的秩都大于12，这样就解不了该方程。</p>
<p><strong>现在该怎么办呢？答案是采用优化的思想，找到合适的m， 让其$||m||$为1 ，使 $||Pm||$ 最小。</strong></p>
<p>对于该优化问题的解，先对P矩阵进行奇异值分解，可以得到：</p>
<script type="math/tex; mode=display">
P=U_{2n\times12}D_{12\times12}V_{12\times12}^T\tag{2.6}</script><p>m为P矩阵最小奇异值的右奇异向量，且 $||m||=1$ ，求得m后，便可以得到投影矩阵M。</p>
<script type="math/tex; mode=display">
\boldsymbol{m} \stackrel{\text { def }}{=}\left(\begin{array}{c}
m_{1}^{T} \\
m_{2}^{T} \\
m_{3}^{T}
\end{array}\right) \rightarrow M=\left[\begin{array}{c}
m_{1} \\
m_{2} \\
m_{3}
\end{array}\right]=[A\ b]\tag{2.7}</script><h4 id="4-提取摄像机参数"><a href="#4-提取摄像机参数" class="headerlink" title="4.提取摄像机参数"></a>4.提取摄像机参数</h4><p>我们知道，投影矩阵M包括相机的内参和外参信息，当得到M后，需要提取出内参和外参的信息。</p>
<p>先来看看已知R，T，K后，如何得到M</p>
<script type="math/tex; mode=display">
M=K[R\ \ T]_{3\times4}\tag{2.8}</script><script type="math/tex; mode=display">
K=\left[\begin{array}{ccc}
\alpha & -\alpha \cot \theta & u_{0} \\
0 & \frac{\beta}{\sin \theta} & v_{0} \\
0 & 0 & 1
\end{array}\right] \quad R=\left[\begin{array}{c}
r_{1}^{T} \\
r_{2}^T \\
r_{3} ^T
\end{array}\right] \quad T=\left[\begin{array}{c}
t_{x} \\
t_{y} \\
t_{z}
\end{array}\right]\tag{2.9}</script><p>所以：</p>
<script type="math/tex; mode=display">
M=K[R\ \ T]=\left(\begin{array}{cc}
\alpha r_{1}^{T}-\alpha \cot \theta r_{2}^{T}+u_{0} r_{3}^{T} & \alpha t_{x}-\alpha \cot \theta t_{y}+u_{0} t_{z} \\
\frac{\beta}{\sin \theta} r_{2}^{T}+v_{0} r_{3}^{T} & \frac{\beta}{\sin \theta} t_{y}+v_{0} t_{z} \\
r_{3}^{T} & t_{z}
\end{array}\right)_{3 \times 4}\tag{2.10}</script><p>因为我们之前规定了m向量的模长为1，所以我们求出的M和真实的M相差一个系数 $\rho$ </p>
<script type="math/tex; mode=display">
\rho M=\rho[A\ \ b]=K[R\ \ T]\tag{2.11}</script><p>令：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{l}
a_{1}{ }^{T} \\
a_{2}{ }^{T} \\
a_{3}{ }^{T}
\end{array}\right] \quad \mathbf{b}=\left[\begin{array}{l}
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right]\tag{2.12}</script><p>则：</p>
<script type="math/tex; mode=display">
\rho A=\rho\left(\begin{array}{c}
a_{1}^{T} \\
a_{2}{ }^{T} \\
a_{3}{ }^{T}
\end{array}\right)=\left(\begin{array}{c}
\alpha r_{1}^{T}-\alpha \cot \theta r_{2}^{T}+u_{0} r_{3}^{T} \\
\frac{\beta}{\sin \theta} r_{2}^{T}+v_{0} r_{3}^{T} \\
r_{3}{ }^{T}
\end{array}\right)=K R\tag{2.13}</script><h5 id="a-提取内参数"><a href="#a-提取内参数" class="headerlink" title="a.提取内参数"></a>a.提取内参数</h5><p>从(2.13)最后一行可以看出：</p>
<script type="math/tex; mode=display">
\rho a_3=r_3\\\tag{2.14}</script><p>因为 $r_3$ 是旋转矩阵的列向量，其模长为1，因此可以得到：</p>
<script type="math/tex; mode=display">
\rho=\frac{\pm 1}{\left|a_{3}\right|}\tag{2.15}</script><p>然后分别将(2.13)左右两侧第3行的向量和第1行的向量点乘，第3行的向量和第2行的向量点乘，因为旋转矩阵的列向量互相正交，所以可以得到：</p>
<script type="math/tex; mode=display">
\quad \begin{aligned}
&u_{0}=\rho^{2}\left(a_{1} \cdot a_{3}\right) \\
&v_{0}=\rho^{2}\left(a_{2} \cdot a_{3}\right)
\end{aligned}\tag{2.16}</script><p>同理再将(2.13)的行向量进行叉乘，可以得到下面的式子：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{ l } 
{ \rho ^ { 2 } ( a _ { 1 } \times a _ { 3 } ) = \alpha r _ { 2 } - \alpha \operatorname { cot\theta} r _ { 1 } } \\
{ \rho ^ { 2 } ( a _ { 2 } \times a _ { 3 } ) = \frac { \beta } { \operatorname { sin } \theta } r _ { 1 } }
\end{array} 
\right.\tag{2.17}</script><p>在将(2.17)上下两行进行点乘，可以得到</p>
<script type="math/tex; mode=display">
\rho^4(a_1 \times a_3)(a_2 \times a_3)=- \frac{\alpha \beta \cos{\theta}}{\sin\theta^2} \tag{2.18}</script><p>然后对(2.17)的向量两边取模：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\rho^{2}\left|a_{1} \times a_{3}\right|=\frac{|\alpha|}{\sin \theta} \\
\rho^{2}\left|a_{2} \times a_{3}\right|=\frac{|\beta|}{\sin \theta}
\end{array}\right.\tag{2.19}</script><p>最后可以得到内参矩阵中的所有参数：</p>
<script type="math/tex; mode=display">
\cos \theta=-\frac{\left(a_{1} \times a_{3}\right) \cdot\left(a_{2} \times a_{3}\right)}{\left|a_{1} \times a_{3}\right| \cdot\left|a_{2} \times a_{3}\right|}\\
\begin{array}{l}
\alpha=\rho^{2}\left|a_{1} \times a_{3}\right| \sin \theta \\
\beta=\rho^{2}\left|a_{2} \times a_{3}\right| \sin \theta
\end{array}\tag{2.20}</script><p>到此，摄像机的内参数全部求出。</p>
<h5 id="b-提取外参数"><a href="#b-提取外参数" class="headerlink" title="b.提取外参数"></a>b.提取外参数</h5><p>根据(2.14)和(2.17)可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&r_{1}=\frac{\left(a_{2} \times a_{3}\right)}{\left|a_{2} \times a_{3}\right|}\\
&r_{3}=\frac{\pm a_{3}}{\left|a_{3}\right|} \\
&r_{2}=r_{3} \times r_{1}\end{aligned}\tag{2.21}</script><p>下面再计算T，根据：</p>
<script type="math/tex; mode=display">
\rho b=KT\tag{2.22}</script><p>可以得到：</p>
<script type="math/tex; mode=display">
T=\rho K^{-1}b\tag{2.23}</script><blockquote>
<p>注意：选取的点不能在同一平面</p>
</blockquote>
<h3 id="B-径向畸变标定"><a href="#B-径向畸变标定" class="headerlink" title="B.径向畸变标定"></a>B.径向畸变标定</h3><h4 id="1-径向畸变的描述"><a href="#1-径向畸变的描述" class="headerlink" title="1.径向畸变的描述"></a>1.径向畸变的描述</h4><p>在原有的透视投影矩阵M基础上，加上一个缩放矩阵 $S_\lambda$ ，如下：</p>
<script type="math/tex; mode=display">
{\left[\begin{array}{ccc}
\frac{1}{\lambda} & 0 & 0 \\
0 & \frac{1}{\lambda} & 0 \\
0 & 0 & 1
\end{array}\right]}
M P_{i} \rightarrow\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=p_{i}\quad 其中
\lambda=1 \pm \sum_{p=1}^{3} k_pd^{2p} \quad (d^2=u^{2}+v^{2})\tag{2.24}</script><p>当 $\lambda=1$ 时，真实的像和理想的像重叠，此时无畸变</p>
<p>当 $\lambda&lt;1$时，真实的像比理想的像的位置靠外，枕形畸变</p>
<p>当$\lambda&gt;1$ 时，真实的像比理想的像的位置靠里，桶形畸变</p>
<h4 id="2-径向畸变的标定"><a href="#2-径向畸变的标定" class="headerlink" title="2.径向畸变的标定"></a>2.径向畸变的标定</h4><p>令</p>
<script type="math/tex; mode=display">
S_\lambda M=Q=
\left[\begin{array}{}
q_1\\
q_2\\
q_3
\end{array}{}\right]_{3\times 4}\tag{2.25}</script><script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{l}
u_{i} \\
v_{i}
\end{array}\right]=\left[\begin{array}{l}
\frac{q_{1} p_{i}}{q_{3} p_{i}} \\
\frac{q_{2} p_{i}}{q_{3} p_{i}}
\end{array}\right] \quad \longrightarrow \quad\left\{\begin{array}{l}
u_{i} q_{3} P_{i}=q_{1} P_{i} \\
v_{i} q_{3} P_{i}=q_{2} P_{i}
\end{array}\right.\tag{2.26}</script><p>(2.26)右边的方程组并不是线性方程组，因为 $q_i$ 是变化的，如果想要求解该方程，需要采用非线性优化方法，使观测值和理论值的误差最小，可以采用牛顿法或LM方法。</p>
<p>但是可以求解出系统的线性部分以找到近似解，然后使用该解作为整个系统的初始条件，再使用数值方法进行求解。</p>
<p>根据(2.23)和(2.25)，Q矩阵的前两行等于 $\frac{1}\lambda M$ 的前两行，于是可以将 $\lambda$ 约去</p>
<script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=\frac{1}{\lambda}\left[\begin{array}{l}
\frac{m_{1} p_{i}}{m_{3} p_{i}} \\
\frac{m_{2} p_{i}}{m_{3} p_{i}}
\end{array}\right] \quad \longrightarrow \quad \frac{u_{i}}{v_{i}}=\frac{\frac{1}{\lambda} \frac{\left(m_{1} P_{i}\right)}{\left(m_{3} p_{i}\right)}}{\frac{1}{\lambda} \frac{\left(m_{2} p_{i}\right)}{\left(m_{3} p_{i}\right)}}=\frac{m_{1} p_{i}}{m_{2} p_{i}}\tag{2.27}</script><p>建立如下的线性方程组</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
v_{1}\left(m_{1} P_{1}\right)-u_{1}\left(m_{2} P_{1}\right)=0  \\
v_{i}\left(m_{1} P_{i}\right)-u_{i}\left(m_{2} P_{i}\right)=0 
\\
\vdots \\
v_{n}\left(m_{1} P_{n}\right)-u_{n}\left(m_{2} P_{n}\right)=0
\end{array} \longrightarrow\quad 
\\ L \boldsymbol{n}=0 \\

\right. \\\tag{2.28}</script><p>其中</p>
<script type="math/tex; mode=display">
L \stackrel{\operatorname{dec}}{=}\left(\begin{array}{cc}
v_{1} p_{1}^{T} & -u_{1} p_{1}^{T} \\
v_{2} p_{2}^{T} & -u_{2} p_{2}^{T} \\
\vdots & \vdots \\
v_{n} p_{n}^{T} & -u_{n} p_{n}^{T}
\end{array}\right)\tag{2.29}\\\\
n=\left[\begin{array}{c}
m_{1}{ }^{T} \\
m_{2}{ }^{T}
\end{array}\right]</script><p>和(2.6)的方法类似，可以通过奇异值分解求出 $m_1$和 $m_2$ 。然后再通过非线性优化的方法求出 $k_p$ 和 $m_3$。</p>
<h2 id="三、单视图几何"><a href="#三、单视图几何" class="headerlink" title="三、单视图几何"></a>三、单视图几何</h2><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040215.png" alt="image-20210820213946776"></p>
<p>已知摄像机的内参和外部参数，是否可以根据单个图片的测量值p去估计空间点P呢？</p>
<p>ans：是不能的，只能确定P点位于c和p的连线上的任意位置。原因是单目相机无法获得深度信息，在这条线上的任意点的投影都位于该像素点上，当对空间有一些先验的信息时，是可以获得空间点P的位置信息的。</p>
<h3 id="A-2D变换"><a href="#A-2D变换" class="headerlink" title="A.2D变换"></a>A.2D变换</h3><h4 id="1-等距变换"><a href="#1-等距变换" class="headerlink" title="1.等距变换"></a>1.等距变换</h4><p>等距变换也叫做欧式变换，是将平面上的点经过旋转平移，不改变图形的形状，面积。仅仅改变图形的位置和朝向。</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{l}
R & \boldsymbol{t} \\
0 & 1\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1\end{array}\right]=H_{e}\left[\begin{array}{l}
x \\
y \\
1\end{array}\right]\tag{3.1}</script><p>有3个自由度(1个旋转角度+2个平移量)</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040219.png" alt="image-20210823171132345"></p>
<h4 id="2-相似变换"><a href="#2-相似变换" class="headerlink" title="2.相似变换"></a>2.相似变换</h4><p>在等距变换的基础上，如式(3.1)所示，增加了一个S矩阵(对角阵)，对原图形进行缩放。</p>
<p>它不改变图形长度的比值，还有线段间的角度。</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
S R & \boldsymbol{t} \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=H_{S}\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right] \quad S=\left[\begin{array}{ll}
s & 0 \\
0 & s
\end{array}\right]\tag{3.2}</script><p>有4个自由度(1个缩放系数+1个旋转角度+2个平移量)</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040226.png" alt="image-20210823171619104"></p>
<h4 id="3-仿射变换"><a href="#3-仿射变换" class="headerlink" title="3.仿射变换"></a>3.仿射变换</h4><p>（直观意义后续再学习，现在先搞懂数学表达）</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
A & \boldsymbol{t} \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]=H_{a}\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]\tag{3.3}</script><p>注意这里的矩阵与(3.1)和(3.2)不同，A矩阵是任意的一个2阶方阵，有4个自由度。整个矩阵共有6个自由度(4个自由度+2个平移量)</p>
<p><strong>特点</strong>：它不改变图形中的平行线关系，还有面积比值。但不能保持线段之间的夹角关系。</p>
<h4 id="4-透视变换-射影变换"><a href="#4-透视变换-射影变换" class="headerlink" title="4.透视变换(射影变换)"></a>4.透视变换(射影变换)</h4><p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
A & \boldsymbol{t} \\
v & 1
\end{array}\right]\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]=H_{p}\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]\tag{3.4}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040232.png" alt="image-20210823233103207"></p>
<p><strong>特点</strong>：</p>
<p>共线性，原来在一条直线上的点变换后还在一条直线上。</p>
<p>四共线点的交比</p>
<p>交比的定义为：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018041052.png" alt="image-20210823225125021" style="zoom:50%;" /></p>
<script type="math/tex; mode=display">
\frac{|| P_{3}-P_{1}||\left\|P_{4}-P_{2}\right\|}{|| P_{3}-P_{2}||\left\|P_{4}-P_{1}\right\|} \quad P_{i}=\left[\begin{array}{c}
X_{i} \\
Y_{i} \\
Z_{i} \\
1
\end{array}\right]\tag{3.5}</script><h3 id="B-二维空间点和直线的投影变换"><a href="#B-二维空间点和直线的投影变换" class="headerlink" title="B.二维空间点和直线的投影变换"></a>B.二维空间点和直线的投影变换</h3><p>我们的目的是用单张图像来重建三维场景，就要建立图像上几何元素和三维空间中的几何元素的对应关系。</p>
<p>我们先通过<strong><u>二维空间中</u></strong>的点和线来学习。</p>
<h4 id="1-平面上的线"><a href="#1-平面上的线" class="headerlink" title="1.平面上的线"></a>1.平面上的线</h4><p>我们可以用ax+by+c=0来表示一条平面上的线。我们可以用向量的形式来表达这个式子：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
x \\
y \\
1
\end{array}\right]^{T}\left[\begin{array}{l}
a \\
b \\
c
\end{array}\right]=0\tag{3.6}</script><p>(3.6)左边第一项是直线上点的齐次坐标，右边是直线的参数，所以直线可以表示成向量的形式：</p>
<script type="math/tex; mode=display">
l=\left[\begin{array}{l}
a\\
b\\
c
\end{array}\right]\tag{3.7}</script><h4 id="2-两条直线的交点"><a href="#2-两条直线的交点" class="headerlink" title="2.两条直线的交点"></a>2.两条直线的交点</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018041032.png" alt="image-20210823231412876"></p>
<p>两条直线的交点可以用式(3.7)的叉积来表示：</p>
<script type="math/tex; mode=display">
x=l\times l'\tag{3.8}</script><p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&l \times l^{\prime} \perp l \rightarrow\left(l \times l^{\prime}\right) \cdot l=0 \rightarrow x \in l \\
&l \times l^{\prime} \perp l' \rightarrow\left(l \times l^{\prime}\right) \cdot l'=0 \rightarrow x \in l^{\prime}
\end{aligned}\tag{3.9}</script><p>(3.9)中，两个表示直线的向量叉乘，与这两个直线向量的点乘为0，这说明了如果叉乘表示一个点，那么这个点在这两条直线上，所以该点为交点。</p>
<h4 id="3-无穷远点"><a href="#3-无穷远点" class="headerlink" title="3.无穷远点"></a>3.无穷远点</h4><p>首先定义无穷远点：平面上一个点的齐次坐标的第三维为0，该点为无穷远点。</p>
<p>因为转化成欧式坐标后，前两维都除以第三维0，为无穷大，所以是无穷远点。</p>
<script type="math/tex; mode=display">
x_\infty =\left[\begin{array}{}
x_1\\
x_2\\
0
\end{array}\right]\tag{3.10}</script><p>两条平行线的交点就是无穷远点。 </p>
<h4 id="4-无穷远直线"><a href="#4-无穷远直线" class="headerlink" title="4.无穷远直线"></a>4.无穷远直线</h4><p>无穷远点集位于无穷远线上。</p>
<p>无穷远线的向量表示为：</p>
<script type="math/tex; mode=display">
l_\infty =\left[\begin{array}{}
0\\
0\\
1
\end{array}\right]\tag{3.11}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040245.png" alt="image-20210823233249621" style="zoom: 67%;" /></p>
<h4 id="5-无穷远点的透视变换"><a href="#5-无穷远点的透视变换" class="headerlink" title="5.无穷远点的透视变换"></a>5.无穷远点的透视变换</h4><p>透视变换矩阵：</p>
<script type="math/tex; mode=display">
H=\left[ \begin{array}{l}
A & t \\
v & b
\end{array}\right] \tag{3.12}</script><p>无穷远点的<strong>透视变换</strong>：</p>
<script type="math/tex; mode=display">
p^{\prime}=Hp_\infty=\left[\begin{array}{l}
A & t \\
v & b
\end{array}\right]\left[\begin{array}{l}
1 \\
1 \\
0
\end{array}\right]=\left[\begin{array}{c}
p_{x}^{\prime} \\
p_{y}^{\prime} \\
p_{z}^{\prime}
\end{array}\right]\longrightarrow
\left[\begin{array}{}
\frac{p_x'}{p_z'}\\
\frac{p_y'}{p_z'}
\end{array}\right]\tag{3.13}</script><p>无穷远点的透视变换后，就不再是一个无穷远点了。</p>
<p>而无穷远点的<strong>仿射变换</strong>：</p>
<script type="math/tex; mode=display">
H_{A} p_{\infty}=\left[\begin{array}{cc}
A & t \\
0 & b
\end{array}\right]\left[\begin{array}{l}
1 \\
1 \\
0
\end{array}\right]=\left[\begin{array}{c}
p_{x}^{\prime} \\
p_{y} \\
0
\end{array}\right]\tag{3.14}</script><p>仍然是无穷远点。</p>
<h4 id="6-无穷远线的透视变换"><a href="#6-无穷远线的透视变换" class="headerlink" title="6.无穷远线的透视变换"></a>6.无穷远线的透视变换</h4><p>线的变换和点的变换不同，不能直接对直线向量进行变换。</p>
<p>我们知道对线的变换，等价于对线上所有的点的变换。</p>
<p>变换前的直线方程为：</p>
<script type="math/tex; mode=display">
x^Tl=0\tag{3.15}</script><p>对直线上的点的变换为：</p>
<script type="math/tex; mode=display">
Hx\tag{3.16}</script><p>则变换后的直线方程为：</p>
<script type="math/tex; mode=display">
(Hx)^Tl'=0\longrightarrow x^TH^Tl'=0\tag{3.17}</script><p>如果让(3.17)成立，则：</p>
<script type="math/tex; mode=display">
l'=H^{-T}l\tag{3.18}</script><p>所以直线的变换如式(3.18)所示。</p>
<p>无穷远线经过<strong>透视变换</strong>为：</p>
<script type="math/tex; mode=display">
H^{-T} l_{\infty}=\left[\begin{array}{ll}
A & t \\
v & b
\end{array}\right]^{-T}\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{c}
t_{x} \\
t_{y} \\
b
\end{array}\right]\tag{3.19}</script><p>显然变换后不再是无穷远线了。</p>
<p>无穷远线在<strong>仿射变换</strong>后：</p>
<script type="math/tex; mode=display">
{H}^{-T} l_{\infty}=\left[\begin{array}{cc}
A & t \\
0 & b
\end{array}\right]^{-T}\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{cc}
A^{-T} & 0 \\
-t^{T} A^{-T} & 1
\end{array}\right]\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]\tag{3.20}</script><p>仍是无穷远线。</p>
<h3 id="C-三维空间中的变换"><a href="#C-三维空间中的变换" class="headerlink" title="C.三维空间中的变换"></a>C.三维空间中的变换</h3><p>学完了二维空间中的点和线以及变换关系，接下来学习三维空间的点和线以及变换关系。</p>
<h4 id="1-空间中的点和面"><a href="#1-空间中的点和面" class="headerlink" title="1.空间中的点和面"></a>1.空间中的点和面</h4><p>与二维空间不同的是，三维空间是点和面可以用方程来表示。而直线用两个平面的交线来表示。</p>
<p>和二维空间中的直线的表示类似，三维空间中的平面表示为：</p>
<script type="math/tex; mode=display">
ax+by+cz+d=0\tag{3.21}</script><p>用向量的形式表示为：</p>
<script type="math/tex; mode=display">
x^T\Pi=0\quad\Pi=\left[\begin{array}{}
a\\
b\\
c\\d
\end{array}\right]\tag{3.22}</script><h4 id="2-空间中的线"><a href="#2-空间中的线" class="headerlink" title="2.空间中的线"></a>2.空间中的线</h4><p>如上所说，空间中的线不容易直接用方程来表示，但可以用向量表示出直线的方向。</p>
<script type="math/tex; mode=display">
d=\left[\begin{array}{}
a\\
b\\
c
\end{array}\right]\tag{3.23}</script><h4 id="3-影消点"><a href="#3-影消点" class="headerlink" title="3.影消点"></a>3.影消点</h4><p>影消点是三维空间中的无穷远点在二维平面上的投影点。</p>
<p>前面的二维空间中的无穷远点，经过投影变换后，变为一个有限点。那么三维空间中的无穷远点，经过投影变换后，在二维平面上，也为有限点。 </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040306.png" alt="image-20210824001710255" style="zoom:67%;" /></p>
<h4 id="4-影消点和直线方向的关系"><a href="#4-影消点和直线方向的关系" class="headerlink" title="4.影消点和直线方向的关系"></a>4.影消点和直线方向的关系</h4><p>影消点的齐次坐标为v，影消点和直线方向有如下关系</p>
<script type="math/tex; mode=display">
v=Kd\tag{3.24}</script><p>该式成立的条件是，相机坐标系和世界坐标系重合，否则和直线方向向量相差一个旋转平移的关系。</p>
<p>证明：</p>
<p>无穷远点坐标为：</p>
<script type="math/tex; mode=display">
X_\infty=\left[\begin{array}{}
a\\
b\\
c\\
0
\end{array}\right]\tag{3.25}</script><p>经过摄像机投影变换后</p>
<script type="math/tex; mode=display">
v=MX_\infty=K[I\ \ 0]\left[\begin{array}{}
a\\
b\\
c\\
0
\end{array}\right]=K\left[\begin{array}{}
a\\
b\\
c\\

\end{array}\right]\tag{3.26}</script><p>所以知道直线的方向就可以知道影消点，反过来知道影消点也可以知道直线的方向。</p>
<h4 id="5-影消线（视平线）"><a href="#5-影消线（视平线）" class="headerlink" title="5.影消线（视平线）"></a>5.影消线（视平线）</h4><p>三维空间中的无穷远线在二维空间中的投影。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040312.png" alt="image-20210824003405552"></p>
<h4 id="6-影消线和平面法向量"><a href="#6-影消线和平面法向量" class="headerlink" title="6.影消线和平面法向量"></a>6.影消线和平面法向量</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040317.png" alt="image-20210824003743383"></p>
<p>这个平面是指影消线所对应的平行线所在的平面。</p>
<p>平面法向量为n，影消线和平面法向量的关系为：</p>
<script type="math/tex; mode=display">
n=K^Tl_{horiz}\tag{3.27}</script><p>证明：</p>
<p>这里还是仅考虑相机坐标系和世界坐标系重合的情况。</p>
<p>设某一平面有一无穷远点x，其所在平面的方程为：</p>
<script type="math/tex; mode=display">
x^T\Pi=0\tag{3.28}</script><p>该点经过投影变换后，在影消线上，影消线方程为：</p>
<script type="math/tex; mode=display">
(Mx)^Tl_{horiz}=0\\
x^TM^Tl_{horiz}=0\tag{3.29}</script><p>比较(3.28)和(3.29)可知：</p>
<script type="math/tex; mode=display">
\Pi=M^Tl_{horiz}\tag{3.30}\\
因为M=K[I\ \ 0],\Pi\ 就是平面的法向量，所以有：
n=K^Tl_{horiz}</script><h4 id="7-无穷远平面"><a href="#7-无穷远平面" class="headerlink" title="7.无穷远平面"></a>7.无穷远平面</h4><p>影消线所在的平面。</p>
<p>表示向量的形式为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}
0\\
0\\
0\\
1
\end{array}\right]\tag{3.31}</script><h4 id="8-两组平行线的夹角和影消点的关系"><a href="#8-两组平行线的夹角和影消点的关系" class="headerlink" title="8.两组平行线的夹角和影消点的关系"></a>8.两组平行线的夹角和影消点的关系</h4><p>两平行线夹角：</p>
<script type="math/tex; mode=display">
co s\theta=\frac{d_1d_2}{|d_1||d_2|}\tag{3.32}</script><p>由式(3.24)可知，知道影消点坐标和相机内参矩阵后，可以反求出平行线方向向量d。</p>
<p>将 $d_1和d_2$ 代入(3.32)，可得：</p>
<script type="math/tex; mode=display">
co s\theta=\frac{d_1d_2}{|d_1||d_2|}=\frac{(K^{-1}v_1)^T(K^{-1}v_2)}{\sqrt{(K^{-1}v_1)^T(K^{-1}v_1)}\sqrt{(K^{-1}v_2)^T(K^{-1}v_2)}}\\
=\frac{v_{1}^{T} \omega v_{2}}{\sqrt{v_{1}^{T} \omega v_{1}} \sqrt{v_{2}^{T} \omega v_{2}}}\quad \omega= (KK^T)^{-1}\tag{3.33}</script><script type="math/tex; mode=display">
当\theta=90^{\circ} \rightarrow v_{1}^{T} \omega v_{2}=0\tag{3.34}</script><p>$\omega$ 的性质：</p>
<script type="math/tex; mode=display">
\omega=\left[\begin{array}{lll}
\omega_{1} & \omega_{2} & \omega_{4} \\
\omega_{2} & \omega_{3} & \omega_{5} \\
\omega_{4} & \omega_{5} & \omega_{6}
\end{array}\right]\tag{3.35}</script><p>对称阵</p>
<p>有5个自由度</p>
<p>$\omega _2=0$ ，无倾斜</p>
<p>$\omega_2=0,\omega_1=\omega_3$ ，方形像素</p>
<h3 id="D-单视图重构"><a href="#D-单视图重构" class="headerlink" title="D.单视图重构"></a>D.单视图重构</h3><h4 id="1-标定内参数"><a href="#1-标定内参数" class="headerlink" title="1.标定内参数"></a>1.标定内参数</h4><p>首先根据图像上的信息，可以标定出相机的内参数矩阵</p>
<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040956.png" alt="image-20210824015723059"></p>
<p>找到图像上两组垂直的平行线，可以找到两个影消点，根据影消点的坐标，以及式(3.34)可以得到一组方程。因为 $\omega $ 有5个自由度，所以还需要增加限制方程来求解。</p>
<p>我们找到三组平行线，可以得到三个方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
v_{1}^{T} \omega v_{2}=0 \\
v_{1}^{T} \omega v_{3}=0 \\
v_{2}^{T} \omega v_{3}=0
\end{array}\right.\tag{3.36}</script><p>我们可以再添加上两个限制方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\omega _{2}=0 \\
 \omega_1=\omega_3
\end{array}\right.\tag{3.37}</script><p>便可以求解出 $\omega$ 矩阵。</p>
<h4 id="2-恢复面的信息"><a href="#2-恢复面的信息" class="headerlink" title="2.恢复面的信息"></a>2.恢复面的信息</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040950.png" alt="image-20210824020434618"></p>
<p>然后连接两个影消点，可以得到影消线，从而得到影消线的方程。然后由式(3.27)可知，该平面的空间方程。这样就可以求得三个平面的方程。</p>
<blockquote>
<p>单视图恢复的场景，是无法知道场景尺寸的。而且必须要有场景的先验信息。</p>
</blockquote>
<h2 id="四、三维重建基础和极几何"><a href="#四、三维重建基础和极几何" class="headerlink" title="四、三维重建基础和极几何"></a>四、三维重建基础和极几何</h2><h3 id="A-三维重建基础"><a href="#A-三维重建基础" class="headerlink" title="A.三维重建基础"></a>A.三维重建基础</h3><h4 id="1-三角化"><a href="#1-三角化" class="headerlink" title="1.三角化"></a>1.三角化</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040326.png" alt="image-20210824021622264"></p>
<p>三角化的适用条件：用两个摄像机来感受外部空间。</p>
<p>如图所示，现在有两个摄像机，分别在 $O_1和O_2$ 点，空间点p在两个相机的成像平面上投影分别为 $p和p’$ 。</p>
<p>通常情况下，P点的坐标通过l和l’的叉乘来求得。</p>
<p>但是由于噪声的存在，$l和l’$ 一般是不相交的。现在想求P点的三维坐标。</p>
<p>ques：已知 $p和p’$ ，$K和K’$ ，以及R，T，求解P点的三维坐标。</p>
<p>非线性解法：建模成最小化问题。我们要找到一个点 $P^*$ ，使其投影到两个成像平面上的点和观测点的距离最小。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040344.png" alt="image-20210824022452348"></p>
<p>解法：寻找 $P^{\star}$ ，最小化 $d\left(p, M P^{\star}\right)+d\left(p^{\prime}, M^{\prime} P^{\star}\right)$ 。</p>
<h4 id="2-多视图几何的关键问题"><a href="#2-多视图几何的关键问题" class="headerlink" title="2.多视图几何的关键问题"></a>2.多视图几何的关键问题</h4><ol>
<li>摄像机几何：从一张或者多张图片中求解摄像机的内外参数</li>
<li>场景几何：从二至多幅图中找到场景的三维坐标</li>
<li>对应关系：已知一个图像的p点，如何在另一张图中找到p‘点</li>
</ol>
<h3 id="B-极几何—解决对应关系问题"><a href="#B-极几何—解决对应关系问题" class="headerlink" title="B.极几何—解决对应关系问题"></a>B.极几何—解决对应关系问题</h3><h4 id="1-极几何"><a href="#1-极几何" class="headerlink" title="1.极几何"></a>1.极几何</h4><p>极几何描述了同一场景或者物体在两个视点的几何关系。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040350.png" alt="image-20210824024244259"></p>
<p>极线：极平面与成像平面的交线</p>
<p>极点：极线与成像平面的交点</p>
<h5 id="a-极几何的特点："><a href="#a-极几何的特点：" class="headerlink" title="a.极几何的特点："></a>a.极几何的特点：</h5><ol>
<li>极平面相交于基线</li>
<li>极线相交于极点</li>
<li>$p$ 的对应点在极线 $l’$ 上</li>
<li>$p’$ 的对应点在极线 $l$ 上</li>
</ol>
<h5 id="b-极几何的两个特例："><a href="#b-极几何的两个特例：" class="headerlink" title="b.极几何的两个特例："></a>b.极几何的两个特例：</h5><h6 id="1-平行视图"><a href="#1-平行视图" class="headerlink" title="(1)平行视图"></a><strong>(1)平行视图</strong></h6><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040353.png" alt="image-20210824024726436"></p>
<p>特点：</p>
<ol>
<li>两个图像平面平行；</li>
<li>基线平行于成像平面，极点在无穷远处；</li>
<li>基线平行于像素坐标系u轴</li>
</ol>
<h6 id="2-前向平移（无旋转）"><a href="#2-前向平移（无旋转）" class="headerlink" title="(2)前向平移（无旋转）"></a><strong>(2)前向平移（无旋转）</strong></h6><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040356.png" alt="image-20210824024950629"></p>
<p>两个图像的极点有着相同的像素坐标</p>
<h4 id="2-本质矩阵"><a href="#2-本质矩阵" class="headerlink" title="2.本质矩阵"></a>2.本质矩阵</h4><p>本质矩阵：对规范化摄像机拍摄的两个视点图像间的极几何关系进行代数描述。</p>
<h5 id="a-规范化摄像机"><a href="#a-规范化摄像机" class="headerlink" title="a.规范化摄像机"></a>a.规范化摄像机</h5><p>摄像机的内参数K是单位矩阵</p>
<script type="math/tex; mode=display">
P^{\prime}=\left[\begin{array}{l}x \\ y \\ z\end{array}\right]=\left[\begin{array}{llll}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0\end{array}\right]\left[\begin{array}{l}x \\ y \\ z \\ 1\end{array}\right]\tag{4.1}</script><p>三维点的欧式坐标=像素点的齐次坐标</p>
<h5 id="b-极几何关系推导—对应点关系推导"><a href="#b-极几何关系推导—对应点关系推导" class="headerlink" title="b.极几何关系推导—对应点关系推导"></a>b.极几何关系推导—对应点关系推导</h5><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040401.png" alt="image-20210824025523590"></p>
<p>我们现在已经知道，K=K‘，且为规范化相机，p和p’的像素坐标。</p>
<p>由规范化相机还可以知道，空间点 $p$ 在 $O_1$ 坐标系下的欧式坐标为 $(u,v,1)$ ，以及 $p’$ 在 $O_2$ 坐标系下的欧式坐标 $(u’,v’,1)$</p>
<blockquote>
<p>因为是规范化相机，空间点的欧式坐标等于像素点的齐次坐标。已知p的空间坐标为(x,y,1)，p的像素齐次坐标为(u,v,1)，可以知道x=u,y=v。</p>
</blockquote>
<p>现在我们来求p和p‘的代数关系。</p>
<p>先把.$O_2$ 和 p‘的坐标转化到 $O_1$ 坐标系中为 $p’_{o_1}$：</p>
<p>因为</p>
<script type="math/tex; mode=display">
p'=Rp'_{o_1}+T\tag{4.2}</script><p>所以</p>
<script type="math/tex; mode=display">
p'_{o_1}=R^T(p'-T)\tag{4.3}</script><p>同理可得 $O_2$ 在 $O_1$ 坐标系下的坐标为：</p>
<script type="math/tex; mode=display">
O_2'=-R^TT\tag{4.4}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040405.png" alt="image-20210824031818767"></p>
<p>现在如上图找到几何关系： $O_1p’ 和 O_1O_2$向量的叉积与 $O_1p$ 向量垂直，则有如下方程：</p>
<script type="math/tex; mode=display">
[R^T(p'-T)\times R^TT]\cdot p=0\tag{4.5}</script><p>最终可得到两个对应点的约束关系：</p>
<script type="math/tex; mode=display">
p^{\prime T}[T \times R] p=0\tag{4.6}</script><p>我们将中间的矩阵记作E，E就是本质矩阵。</p>
<script type="math/tex; mode=display">
p^{\prime T} E p=0\tag{4.7}</script><p>上面p‘和p都是三维坐标，它与像素坐标的齐次形式相同。</p>
<blockquote>
<blockquote>
<p> 补充：两个向量的叉乘可以写成矩阵的表示形式</p>
</blockquote>
<script type="math/tex; mode=display">
a \times b=\left[\begin{array}{ccc}
0 & -a_{z} & a_{y} \\
a_{z} & 0 & -a_{x} \\
-a_{y} & a_{x} & 0
\end{array}\right]\left[\begin{array}{l}
b_{x} \\
b_{y} \\
b_{z}
\end{array}\right]=\left[a_{\times}\right] b\tag{4.8}</script><blockquote>
<p> 这里的 $\left[a_{\times}\right]$ 的秩为2。</p>
</blockquote>
</blockquote>
<h5 id="c-本质矩阵的特点"><a href="#c-本质矩阵的特点" class="headerlink" title="c.本质矩阵的特点"></a>c.本质矩阵的特点</h5><ol>
<li>p对应的极线是 $l’$ （$l’=Ep$）这里的 $l’$ 是二维空间中的直线向量，表示直线方程</li>
<li>p’对应的极线是 $l$ （$l=E^Tp’$）</li>
<li>$Ee=0$ 与 $E^Te’=0$</li>
<li>E 的秩为2</li>
<li>E有5个自由度（三个旋转+三个平移，det(E)=0去掉了一个自由度）</li>
</ol>
<h4 id="3-基础矩阵"><a href="#3-基础矩阵" class="headerlink" title="3.基础矩阵"></a>3.基础矩阵</h4><p>对一般透视相机在两个视点的图像间的极几何关系的代数描述</p>
<p>此时相机不再是规范化相机。</p>
<h5 id="a-基础矩阵推导"><a href="#a-基础矩阵推导" class="headerlink" title="a.基础矩阵推导"></a>a.基础矩阵推导</h5><p>思路：把相机转化为规范化相机</p>
<script type="math/tex; mode=display">
p=K[I\ \ 0]P\tag{4.9}</script><script type="math/tex; mode=display">
p_c=K^{-1} p=K^{-1} K[I\ \  0] P=\left[\begin{array}{llll}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0
\end{array}\right] P\tag{4.10}</script><p>同理</p>
<script type="math/tex; mode=display">
p'_c=K'^{-1}p'\tag{4.11}</script><p>于是有：</p>
<script type="math/tex; mode=display">
p_{c}^{\prime T} E p_{c}=p_{c}^{\prime T}\left[T_{\times}\right] R p_{c}=\left(K^{\prime-1} p^{\prime}\right)^{T} \cdot\left[T_{\times}\right] R K^{-1} p=p^{\prime T} K^{\prime-T}\left[T_{x}\right] R K^{-1} p=0\tag{4.12}</script><p>令中间的部分为F，F即为基础矩阵</p>
<script type="math/tex; mode=display">
p^{\prime T} F p=0\tag{4.13}</script><script type="math/tex; mode=display">
F=K^{\prime-T}\left[T_{x}\right] R K^{-1}\tag{4.14}</script><h5 id="b-基础矩阵性质"><a href="#b-基础矩阵性质" class="headerlink" title="b.基础矩阵性质"></a>b.基础矩阵性质</h5><ol>
<li>p对应的极线是 $l’$ （$l’=Fp$）这里的 $l’$ 是二维空间中的直线向量，表示直线方程</li>
<li>p’对应的极线是 $l$ （$l=F^Tp’$）</li>
<li>$Fe=0$ 与 $F^Te’=0$</li>
<li>F 的秩为2</li>
<li>F 有7个自由度（尺度无法确定，det(F)=0去掉了一个自由度）</li>
</ol>
<h4 id="4-基础矩阵的估计"><a href="#4-基础矩阵的估计" class="headerlink" title="4.基础矩阵的估计"></a>4.基础矩阵的估计</h4><p>已知对应点的像素坐标，来求解F矩阵。</p>
<h5 id="a-八点算法"><a href="#a-八点算法" class="headerlink" title="a.八点算法"></a>a.八点算法</h5><p>首先，对应点间有以下关系</p>
<script type="math/tex; mode=display">
p^{\prime T} F p=0 \quad p=\left[\begin{array}{l}
u \\
v \\
1
\end{array}\right] \quad p^{\prime}=\left[\begin{array}{l}
u^{\prime} \\
v^{\prime} \\
1
\end{array}\right]\tag{4.15}</script><script type="math/tex; mode=display">
\\

\left(u^{\prime}, v^{\prime}, 1\right)\left(\begin{array}{lll}
F_{11} & F_{12} & F_{13} \\
F_{21} & F_{22} & F_{23} \\
F_{31} & F_{32} & F_{33}
\end{array}\right)\left(\begin{array}{l}
u \\
v \\
1
\end{array}\right)=0 \\\tag{4.16}</script><p>将(4.16)写成另外一种形式，如下式：</p>
<script type="math/tex; mode=display">
\left(u u^{\prime}, v u^{\prime}, u^{\prime}, u v^{\prime}, v v^{\prime}, v^{\prime}, u, v, 1\right)\left(\begin{array}{l}
F_{11} \\
F_{12} \\
F_{13} \\
F_{21} \\
F_{22} \\
F_{23} \\
F_{31} \\
F_{32} \\
F_{33}
\end{array}\right)=0\tag{4.17}</script><p>我们要求的就是后面的列向量，前面是对应点的坐标构成的一个行向量，一对对应点可列得一个(4.17)方程。</p>
<p>现在来看式(4.17)，这是一个齐次线性方程，虽然有9个未知数，当确定8个未知数后，第9个便可以确定。因此，仅需要8对点即可求解出基础矩阵F。</p>
<p>选取8对对应点后，可得到下式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}
u_{1} u_{1}^{\prime} & v_{1} u_{1}^{\prime} & u_{1}^{\prime} & u_{1} v_{1}^{\prime} & v_{1} v_{1}^{\prime} & v_{1}^{\prime} & u_{1} & v_{1} & 1 \\
u_{2} u_{2}^{\prime} & v_{2} u_{2}^{\prime} & u_{2}^{\prime} & u_{2} v_{2}^{\prime} & v_{2} v_{2}^{\prime} & v_{2}^{\prime} & u_{2} & v_{2} & 1 \\
u_{3} u_{3}^{\prime} & v_{3} u_{3}^{\prime} & u_{3}^{\prime} & u_{3} v_{3}^{\prime} & v_{3} v_{3}^{\prime} & v_{3}^{\prime} & u_{3} & v_{3} & 1 \\
u_{4} u_{4}^{\prime} & v_{4} u_{4}^{\prime} & u_{4}^{\prime} & u_{4} v_{4}^{\prime} & v_{4} v_{4}^{\prime} & v_{4}^{\prime} & u_{4} & v_{4} & 1 \\
u_{5} u_{5}^{\prime} & v_{5} u_{5}^{\prime} & u_{5}^{\prime} & u_{5} v_{5}^{\prime} & v_{5} v_{5}^{\prime} & v_{5}^{\prime} & u_{5} & v_{5} & 1 \\
u_{6} u_{6}^{\prime} & v_{6} u_{6}^{\prime} & u_{6}^{\prime} & u_{6} v_{6}^{\prime} & v_{6} v_{6}^{\prime} & v_{6}^{\prime} & u_{6} & v_{6} & 1 \\
u_{7} u_{7}^{\prime} & v_{7} u_{7}^{\prime} & u_{7}^{\prime} & u_{7} v_{7}^{\prime} & v_{7} v_{7}^{\prime} & v_{7}^{\prime} & u_{7} & v_{7} & 1 \\
u_{8} u_{8}^{\prime} & v_{8} u_{8}^{\prime} & u_{8}^{\prime} & u_{8} v_{8}^{\prime} & v_{8} v_{8}^{\prime} & v_{8}^{\prime} & u_{8} & v_{8} & 1
\end{array}\right]\left[\begin{array}{c}
F_{11} \\
F_{12} \\
F_{13} \\
F_{21} \\
F_{22} \\
F_{23} \\
F_{31} \\
F_{32} \\
F_{33}
\end{array}\right]=0\tag{4.18}</script><p>(4.18)还可以写成：</p>
<script type="math/tex; mode=display">
Wf=0\tag{4.19}</script><p>当W的秩为8时，存在唯一非零解。</p>
<p>而实际中，我们会选取超过8对点，来估计F矩阵，以防止个别点出现偏差时影响F的估计。</p>
<p>当选取超过8个点的时候，会变成一个超定方程组，超定方程组只有0解。此时我们需要用非线性优化的方法来求解。</p>
<script type="math/tex; mode=display">
\begin{gathered}
\min _{\boldsymbol{f}}\|\boldsymbol{W} \boldsymbol{f}\| \\
\text { s. } t .\|\boldsymbol{f}\|=1
\end{gathered}\longrightarrow \hat{F}\tag{4.20}</script><p>当f的模为1时(因为这是一个齐次线性方程组，f的模可以是任意的，在这里我们取1)，使Wf最小。具体的过程就是奇异值分解，和式(2.7)求法相同。</p>
<p>这里 $\hat{F}$ 并不是我们要求的基础矩阵，因为基础矩阵的秩为2，此处的 $\hat{F}$ 的秩为3 。</p>
<p>继续用最优化思想来求解。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\text { 寻找F最小化 }\|F-\widehat{F}\|_{\mathrm{F}}\\
&\text { s.t. } \operatorname{det}(F)=0
\end{aligned}</script><p>具体过程也很简单，就是对 $\hat{F}$ 进行奇异值分解。</p>
<script type="math/tex; mode=display">
S V D(\hat{F})=U\left[\begin{array}{ccc}
s_{1} & 0 & 0 \\
0 & s_{2} & 0 \\
0 & 0 & s_{3}
\end{array}\right] V^{T} \Rightarrow F=U\left[\begin{array}{ccc}
s_{1} & 0 & 0 \\
0 & s_{2} & 0 \\
0 & 0 & 0
\end{array}\right] V^{T}\tag{4.21}</script><h5 id="b-八点算法的问题"><a href="#b-八点算法的问题" class="headerlink" title="b.八点算法的问题"></a>b.八点算法的问题</h5><p>精度低！！！</p>
<p>因为W矩阵中的各个元素的数值差异过大</p>
<h5 id="c-归一化八点法"><a href="#c-归一化八点法" class="headerlink" title="c.归一化八点法"></a>c.归一化八点法</h5><p>对每幅图施加变换T(平移与缩放)，让其满足以下条件：</p>
<ol>
<li>新原点=图像上点的重心</li>
<li>每个像点到坐标原点的均方根距离为 $\sqrt {2}$</li>
</ol>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040412.png" alt="image-20210825010953797"></p>
<p>归一化八点算法的步骤：</p>
<ol>
<li>先计算左图和右图的T和T‘</li>
<li>坐标归一化$q_{i}=T p_{i} \quad q^{\prime}{ }_{i}=T^{\prime} p_{i}{ }^{\prime}$</li>
<li>通过八点算法计算 $F_q$</li>
<li>逆归一化$F=T^{\prime T} F_{q} T$</li>
</ol>
<h2 id="五、双目立体视觉系统"><a href="#五、双目立体视觉系统" class="headerlink" title="五、双目立体视觉系统"></a>五、双目立体视觉系统</h2><h3 id="A-平行视图下的极几何"><a href="#A-平行视图下的极几何" class="headerlink" title="A.平行视图下的极几何"></a>A.平行视图下的极几何</h3><p>利用两个视点来观察物体，和人的眼睛一样。</p>
<p>可以让对应点搜索和深度求解更加简单。</p>
<h4 id="0-补充："><a href="#0-补充：" class="headerlink" title="0.补充："></a>0.补充：</h4><h5 id="a-极点坐标"><a href="#a-极点坐标" class="headerlink" title="a.极点坐标"></a>a.极点坐标</h5><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040415.png" alt="image-20210825160039966" style="zoom:50%;" /></p>
<p>我们前面说过，极点是基线和成像平面的交点。从另外一个角度来看，极点还可以是相机中心在成像平面上的投影点。那么如上图所示，极点 $e$ 是点 $O_2$ 在成像平面的投影。极点 $e’$ 是 $O_1$ 在成像平面的投影。</p>
<p>那么点 $O_1$ 在坐标系 $O_1$ 中的齐次坐标为 $[0\ 0\ 0\ 1]^T$ ，其在坐标系 $O_2$ 中的欧式坐标为：</p>
<script type="math/tex; mode=display">
[R\ T]\left[\begin{array}{}0\\0\\0\\1\end{array}\right]\tag{5.1}</script><p>所以 $e’$ 的齐次坐标就为：</p>
<script type="math/tex; mode=display">
e'=K'[R\ T]\left[\begin{array}{}0\\0\\0\\1\end{array}\right]=K'T\tag{5.2}</script><h5 id="b-叉乘性质"><a href="#b-叉乘性质" class="headerlink" title="b.叉乘性质"></a>b.叉乘性质</h5><p>对于任意向量t，如果M可逆，相差一个尺度的情况下，有如下关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&{\left[t_{\times}\right] M=M^{-T}\left[\left(M^{-1} t\right)_{\times}\right]} \\

\end{aligned}\tag{5.3}</script><p>然后我们令$ t=T, M=K^{\prime-1}$ ，代入到式(5.3)中</p>
<script type="math/tex; mode=display">
{\left[T_{\times}\right] K^{\prime-1}=K^{\prime T}\left[\left(K^{\prime} T\right)_{x}\right]} \\\tag{5.4}</script><p>便可以得到：</p>
<script type="math/tex; mode=display">
\left[T_{\times}\right]=K^{\prime T}\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime}\tag{5.5}</script><p>然后将式(5.5)代入基础矩阵(4.14)中：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F&=K^{\prime-T}\left[T_{x}\right] R K^{-1}\\
&=K^{\prime-T} K^{\prime T}\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime} R K^{-1}\\
&=\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime} R K^{-1}\\
&=\left[e_{x}^{\prime}\right] K^{\prime} R K^{-1}
\end{aligned}\tag{5.6}</script><h4 id="1-平行视图的基础矩阵"><a href="#1-平行视图的基础矩阵" class="headerlink" title="1.平行视图的基础矩阵"></a>1.平行视图的基础矩阵</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040420.png" alt="image-20210825164325338" style="zoom:50%;" /></p>
<p>两个成像平面平行</p>
<p>基线平行于成像平面，极点 $e$ 和 $e’$ 位于无穷远处</p>
<p>我们假定两个摄像机的内参是一样的，$K=K’$。旋转矩阵 $R=I$ 。平移向量$T=[T\ 0\ 0]^T$ 和极点坐标 $e’=[1\ 0\ 0]^T$ 。</p>
<p>将上面的表达式代入到(5.6)中：</p>
<script type="math/tex; mode=display">
F=\left[e_{x}^{\prime}\right] K^{\prime} R K^{-1}=\left[e^{\prime}{ }_{x}\right]=\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & -1 \\
0 & 1 & 0
\end{array}\right]\tag{5.7}</script><p>这就是平行视图的基础矩阵。</p>
<h4 id="2-平行视图下的极线"><a href="#2-平行视图下的极线" class="headerlink" title="2.平行视图下的极线"></a>2.平行视图下的极线</h4><p>一对对应点p和p‘，像素坐标为：$\left(p_{u}, p_{v}\right) 和<br>\left(p_{u}^{\prime}, p_{v}^{\prime}\right)$</p>
<p>极线的方程为：</p>
<script type="math/tex; mode=display">
l=F^{T} p^{\prime}=\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & 1 \\
0 & -1 & 0
\end{array}\right]\left[\begin{array}{c}
p_{u}^{\prime} \\
p_{v}^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{c}
0 \\
1 \\
-p_{v}^{\prime}
\end{array}\right]\tag{5.8}</script><p>可以看出，该极线是平行于u轴的。</p>
<h4 id="3-对应点关系"><a href="#3-对应点关系" class="headerlink" title="3.对应点关系"></a>3.对应点关系</h4><script type="math/tex; mode=display">
p'^TFp=0\tag{5.9}</script><p>即：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{lll}
p_{u}^{\prime} & p_{v}^{\prime} & 1
\end{array}\right)\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & -1 \\
0 & 1 & 0
\end{array}\right]\left[\begin{array}{l}
p_u \\
p_v \\
1
\end{array}\right]=0\tag{5.10}</script><p>最后得到：</p>
<script type="math/tex; mode=display">
p_v=p_v'\tag{5.11}</script><p>这说明对应点的v坐标是一样的。寻找对应点时，直接在扫描线上找即可。</p>
<h4 id="4-平行视图的三角测量"><a href="#4-平行视图的三角测量" class="headerlink" title="4.平行视图的三角测量"></a>4.平行视图的三角测量</h4><p>因为对应点的v坐标相同，所以可以很方便的测量P点的深度值。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040425.png" alt="image-20210825171253726" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
p_{u}-p_{u}^{\prime}=\frac{B \cdot f}{z}\tag{5.12}</script><p>知道视差和基线长度后，便可以计算出深度。</p>
<h3 id="B-图像校正"><a href="#B-图像校正" class="headerlink" title="B.图像校正"></a>B.图像校正</h3><p>平行视图让我们寻找对应点和三角化更加简单，但通常情况下我们构建的双目立体视觉系统是很难得到平行视图的。我们可以将非平行视图转化到平行视图，这就是图像校正。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040427.png" alt="image-20210825175411272" style="zoom: 33%;" /></p>
<p>完成校正这一目标需要构建两个矩阵H和H‘，我们可以通过以下5个步骤来求得这两个矩阵。</p>
<ol>
<li><p>找8个以上的匹配点对。</p>
</li>
<li><p>计算基础矩阵F，然后来求解两幅图像中的极点。具体可以通过上一步的匹配点通过八点算法求出基础矩阵F，然后可以通过基础矩阵的性质求得极线方程。再根据所有极线都经过极点这一性质，求得极点的齐次坐标。</p>
</li>
<li><p>选择透视变换 $H’$ 将 $e’$ 映射到无穷远点 $(f,0,0)$。其中 $H’=T^{-1}GRT$ 。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040431.png" alt="image-20210825180734367" style="zoom:50%;" /></p>
</li>
<li><p>寻找透视变换矩阵H，使得 $\sum_{i} d\left(H p_{i}, H^{\prime} p_{i}^{\prime}\right)$ 最小。</p>
</li>
<li><p>分别用H和H‘对左右两幅图进行重采样。</p>
</li>
</ol>
<p><strong>图像校正例子：</strong></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040434.png" alt="image-20210825181026118" style="zoom: 33%;" /></p>
<h3 id="C-对应点搜索"><a href="#C-对应点搜索" class="headerlink" title="C.对应点搜索"></a>C.对应点搜索</h3><p>给定一个空间点P，在左右图像中找到相应的观测值，也称为双目融合问题。 </p>
<p>图像经过校正后，对应点在扫描线上搜索即可。</p>
<h4 id="1-相关法"><a href="#1-相关法" class="headerlink" title="1.相关法"></a>1.相关法</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018051704.png" style="zoom:50%;" /></p>
<p>首先建立一个窗口</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018052138.png" alt="image-20210825193829734" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018052251.png" alt="image-20211009194933364" style="zoom: 33%;" /></p>
<h4 id="2-归一化相关法"><a href="#2-归一化相关法" class="headerlink" title="2.归一化相关法"></a>2.归一化相关法</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040443.png" alt="image-20210825194834081" style="zoom:50%;" /></p>
<p>当两幅图在光照不同的情况下，会使其像素点的灰度值发生剧烈变化。</p>
<p>此时只需要将窗口内的像素点的灰度值进行去均值即可。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040449.png" alt="image-20210825195133785" style="zoom:150%;" /></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040454.png" alt="image-20210825195236089"></p>
<p>窗口大小的影响：上面我们选取的是 $3\times 3$ 窗口，当选取其他大小窗口的时候会有什么样的变化呢？</p>
<p>ans：较小的窗口，细节丰富，但噪声较大。较大的窗口，视差图更为平滑，但是细节丢失。</p>
<p>例如下图所示，右边两幅图为视差图：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040500.png" alt="image-20210825195947480"></p>
<h4 id="3-相关法存在的问题"><a href="#3-相关法存在的问题" class="headerlink" title="3.相关法存在的问题"></a>3.相关法存在的问题</h4><h5 id="a-透视缩短"><a href="#a-透视缩短" class="headerlink" title="a.透视缩短"></a>a.透视缩短</h5><p>一个物体的长度在一个成像平面上是正常的，但可能在另一成像平面上非常的短。此时在相同范围邻域的内容有很大的不同。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040506.png" alt="image-20210825235305290" style="zoom:50%;" /></p>
<h5 id="b-遮挡"><a href="#b-遮挡" class="headerlink" title="b.遮挡"></a>b.遮挡</h5><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040511.png" alt="image-20210825235332461" style="zoom:50%;" /></p>
<p>以上两种问题的解决办法：</p>
<p>合理的选择基线与深度的比值。</p>
<script type="math/tex; mode=display">
\frac{B}{z}\tag{5.13}</script><p>减小B/z时，可以有效的避免透视缩短和遮挡的问题。用我们最直观的感受就是离物体远点，就看的更全了。</p>
<p>但缩小B/z，也会造成一个问题，就是当匹配点有很小的误差时，就会造成深度估算的大误差。</p>
<p>如下面两幅图所示，红色的点就是根据对应点估算空间点的位置。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040517.png" alt="image-20210825235821706" style="zoom: 25%;" /></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040522.png" alt="image-20210825235841876" style="zoom: 50%;" /></p>
<p>可以看到，当B/z较小时，所估算的深度误差和真实的相差很大。</p>
<h5 id="c-同质区域"><a href="#c-同质区域" class="headerlink" title="c.同质区域"></a>c.同质区域</h5><p>有多个地方与要匹配的点相似。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040527.png" alt="image-20210826000100677" style="zoom:50%;" /></p>
<h5 id="d-重复模式"><a href="#d-重复模式" class="headerlink" title="d.重复模式"></a>d.重复模式</h5><p>和上面的问题类似。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040533.png" alt="image-20210826000215422" style="zoom:50%;" /></p>
<p>容易产生误匹配。所以对应点匹配问题是一个很难的问题。</p>
<p>要解决这些问题，我们需要增加约束来解决对应点匹配问题。</p>
<h4 id="4-其他约束"><a href="#4-其他约束" class="headerlink" title="4.其他约束"></a>4.其他约束</h4><ol>
<li>唯一性约束：一张图像中的任何点，在另一张图像中最多只有一个匹配点。</li>
<li>顺序约束/单调性约束：左右视图中对应点的次序一致</li>
<li>平滑性约束：视差函数通常是平滑的（除了边界遮挡）</li>
</ol>
<p>这些方法可以参考：《计算机视觉：一种现代方法》</p>
<h2 id="六、多视图几何"><a href="#六、多视图几何" class="headerlink" title="六、多视图几何"></a>六、多视图几何</h2><h3 id="A-运动恢复结构问题"><a href="#A-运动恢复结构问题" class="headerlink" title="A.运动恢复结构问题"></a>A.运动恢复结构问题</h3><p>通过三维场景的多张图像，恢复出该场景的三维结构信息以及每张图片所对应的摄像机参数。这也就是SLAM，恢复机构等价于建图，求对应的摄像机参数等价于定位，因为摄像机参数包括内参和外参，外参数就是摄像机的运动信息。</p>
<h4 id="1-问题的具体描述"><a href="#1-问题的具体描述" class="headerlink" title="1.问题的具体描述"></a>1.问题的具体描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$ </p>
<p>且 $x_{ij}=M_iX_j$ ，其中 $M_i$ 为第 $i$ 张图片对应的摄像机投影矩阵</p>
<p><strong>求解</strong>：$m$ 个摄像机的投影矩阵 $M_i$ ；<strong>运动</strong></p>
<p>​            $n$ 个三维点 $X_j$ 的坐标；<strong>三维结构</strong></p>
<p>该类问题也称作运动恢复结构问题。</p>
<h4 id="2-三种典型的运动恢复结构任务"><a href="#2-三种典型的运动恢复结构任务" class="headerlink" title="2.三种典型的运动恢复结构任务"></a>2.三种典型的运动恢复结构任务</h4><h5 id="a-欧式结构恢复"><a href="#a-欧式结构恢复" class="headerlink" title="a.欧式结构恢复"></a>a.欧式结构恢复</h5><p>摄像机内参已知，外参未知。</p>
<p>应用场景：扫地机器人，无人驾驶汽车</p>
<h5 id="b-仿射结构恢复"><a href="#b-仿射结构恢复" class="headerlink" title="b.仿射结构恢复"></a>b.仿射结构恢复</h5><p>摄像机为仿射相机，内、外参数均未知。</p>
<p>应用场景：待重构场景离摄像机较远，而且场景的深度变化不大。</p>
<h5 id="c-透视结构恢复"><a href="#c-透视结构恢复" class="headerlink" title="c.透视结构恢复"></a>c.透视结构恢复</h5><p>摄像机为透视相机，内、外参数均未知。</p>
<p>应用场景：只知道图片，还不能忽略深度变化。</p>
<h3 id="B-欧式结构恢复"><a href="#B-欧式结构恢复" class="headerlink" title="B.欧式结构恢复"></a>B.欧式结构恢复</h3><h4 id="0-问题描述"><a href="#0-问题描述" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>$m$ 张图片对应的摄像机内参数矩阵 $K_i\ (i=1,…m)$</p>
<p>有$x_{ij}=M_iX_j=K_i[R_i\ T_i]X_j$ </p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的外参数 $R_i$ 和 $T_i$ 。</p>
<p>先来看两视图情况，令 $O_1$ 坐标系与世界坐标系固定。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040543.png" alt="image-20210826014140627" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
\begin{aligned}
&x_{1j}=M_{1} X_{j}=K_{1}\left[\begin{array}{ll}
I & 0
\end{array}\right] X_{j} \\
&x_{2 j}=M_{2} X_{j}=K_{2}\left[\begin{array}{ll}
R \ \ \ T
\end{array}\right] X_{j}
\end{aligned}\tag{6.1}</script><h4 id="1-基本求法"><a href="#1-基本求法" class="headerlink" title="1.基本求法"></a>1.基本求法</h4><p>可以分为四步：</p>
<ol>
<li>求解基础矩阵F，归一化八点法</li>
<li>利用F与摄像机内参数求解本质矩阵E，$E=K_{2}^{T} F K_{1}$</li>
<li>分解本质矩阵获得R和T</li>
<li>三角化求解三维点 $X_j$ 的坐标。$X_{j}^{*}=\underset{X_{j}}{\operatorname{argmin}}\left(d\left(x_{1 j}, M_{1} X_{j}\right)+d\left(x_{2 j}, M_{2} X_{j}\right)\right)$</li>
</ol>
<p>这里要说明一下步骤1，2之前都已经学过，而最重要的本质矩阵分解将在下面介绍。</p>
<h4 id="2-本质矩阵分解"><a href="#2-本质矩阵分解" class="headerlink" title="2.本质矩阵分解"></a>2.本质矩阵分解</h4><h5 id="a-本质矩阵推导"><a href="#a-本质矩阵推导" class="headerlink" title="a.本质矩阵推导"></a>a.本质矩阵推导</h5><blockquote>
<p>重要说明：在我们使用八点法求解基础矩阵F时，是无法确定F的符号和尺度的。求解F的方程为 $x_2^TFx_1=0$ ，而-F和kF都满足这个方程，所以说解出来的F可能不是真正的F。同理由F得到的E也是无法确定符号和尺度的。</p>
</blockquote>
<p>先定义两个矩阵：</p>
<script type="math/tex; mode=display">
W=\left[\begin{array}{ccc}
0 & -1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1
\end{array}\right] \quad Z=\left[\begin{array}{ccc}
0 & 1 & 0 \\
-1 & 0 & 0 \\
0 & 0 & 0
\end{array}\right]\tag{6.2}</script><p>这两个矩阵有一个重要的性质：</p>
<script type="math/tex; mode=display">
Z=-diag(1,1,0)W=diag(1,1,0)W^T\tag{6.3}</script><p>本质矩阵E中的 $[T_{\times}]$ 可以写成：</p>
<script type="math/tex; mode=display">
\left[T_{\times}\right]=k U Z U^{T}\tag{6.4}</script><p>其中U是单位正交阵。(6.4)中的Z用W来表示：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}

\left[T_{\times}\right]&=k U Z U^{T}\\
&=-kUdiag(1,1,0)WU^T\\
&=kUdiag(1,1,0)W^TU^T
\end{aligned}\tag{6.5}</script><p>当忽略尺度和符号的情况下，可以认为(6.5)为：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}

\left[T_{\times}\right]&=k U Z U^{T}\\
&=Udiag(1,1,0)WU^T\\
&=Udiag(1,1,0)W^TU^T
\end{aligned}\tag{6.6}</script><p>所以本质矩阵为：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}
E&=[T_{\times}]R\\
&=Udiag(1,1,0)(WU^TR)\\
&=Udiag(1,1,0)(W^TU^TR)
\end{aligned}\tag{6.7}</script><h5 id="b-本质矩阵分解"><a href="#b-本质矩阵分解" class="headerlink" title="b.本质矩阵分解"></a>b.本质矩阵分解</h5><p>现在我们有通过八点法计算出来的本质矩阵E，我们对其进行奇异值分解：</p>
<script type="math/tex; mode=display">
E=Udiag(1,1,0)V^T\tag{6.8}</script><p>(6.8)和(6.7)进行比较，可以得到：</p>
<script type="math/tex; mode=display">
\quad V^T=WU^TR\\
or\quad V^T=W^TU^TR\tag{6.9}</script><p>因为W矩阵和U矩阵都是可逆矩阵，所以可以求得R为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R&=(WU^T)^{-1}V^T\\
&=-UWV^T
\\
or\quad R&=(W^TU^T)^{-1}V^T\\
&=-UW^TV^T
\end{aligned}\tag{6.10}</script><blockquote>
<p>这里：$W^{-1}=-W\ and \ W^{-T}=W^T$</p>
</blockquote>
<p>忽略正负号，最终可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R&=UWV^T
\\
or\quad R
&=UW^TV^T
\end{aligned}\tag{6.11}</script><p>(6.11)中R有两个值，分别对应着在E推导的过程中，使用 $W\ and \ W^T$ 的两种情况。</p>
<p>然后我们再来求解平移向量T。首先根据叉乘性质：</p>
<script type="math/tex; mode=display">
T\times T=[T_{\times}]T=UZU^TT=0\tag{6.12}</script><p>因为U是单位正交阵，将U矩阵写出：</p>
<script type="math/tex; mode=display">
U=[u_1\ u_2 \ u_3]\quad note:u_i\ 是单位列向量\tag{6.13}</script><p>(6.12)展开可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
UZU^TT&=[u_1\ u_2 \ u_3]diag(1,1,0)W
\left[\begin{array}{l}
u_1^T\\
u_2^T\\
u_3^T
\end{array}\right]T
\\
&=(u_2u_1^T-u_1u_2^T)T=0
\end{aligned}\tag{6.14}</script><p>因为 $u_i$  间两两正交，所以当 $T=\pm ku_3$ 时，式(6.14)成立。</p>
<p>现在R和T对应着两个结果，而两两组合就会出现四种情况。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left\{\begin{array}{lc}
R= U W V^{T} &T=u_{3} \\
R= U W V^{T} &T=-u_{3} \\
R=U W^{T} V^{T} &T=u_{3} \\
R=U W^{T} V^{T} &T=-u_{3}
\end{array}\right.
\end{aligned}\tag{6.15}</script><p>分别对应着下面的四种情况：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040555.png" alt="image-20210828023242724" style="zoom:50%;" /></p>
<p>选择一个或多个点，分别用不同的R和T进行三角化计算，只有深度值都为正的R和T才为最终所求。</p>
<h4 id="3-欧式结构恢复存在的问题"><a href="#3-欧式结构恢复存在的问题" class="headerlink" title="3.欧式结构恢复存在的问题"></a>3.欧式结构恢复存在的问题</h4><p>正如我们在2.a中的推导，是忽略了尺度上差异和正负号差异的基础上建立的，通过求目标点的深度我们可以去除掉正负号的影响，但是尺度上的差异是去除不掉的。对于单目相机来说，凭借序列图是无法重构出正确尺度下的三维场景。</p>
<p>例如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040600.png" alt="image-20210828030716063"></p>
<p>从上图可以看出，两个空间点在两成像平面的像素坐标都是相同的，但两个空间点的深度不同，两个视点间的变换也不同，右边的平移矩阵T与左边的T相差一个系数k。另外，在真实空间中P1和P2的朝向也是不同的，这通过欧式重构也是求解不出来的。</p>
<p>我们可以这样认为，恢复出来的欧式结构和真实场景相差一个相似变换(旋转+平移+缩放)。这个相似变换的重构被称为度量重构。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040604.png" alt="image-20210828031302492" style="zoom:50%;" /></p>
<p>所以在没有先验知识的情况下，仅凭单目相机是不能恢复出三维空间结构的。</p>
<h3 id="C-仿射结构恢复"><a href="#C-仿射结构恢复" class="headerlink" title="C.仿射结构恢复"></a>C.仿射结构恢复</h3><p>由(3.3)知道，仿射变换矩阵为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{l}
m_{1} \\
m_{2} \\
m_{3}
\end{array}\right]=\left[\begin{array}{cc}
A_{2 \times 3} & b_{2 \times 1} \\
0_{1 \times 3} & 1
\end{array}\right]=\left[\begin{array}{ccc}
&m_{1} \\
&m_{2} \\
0&0&0&1
\end{array}\right]\tag{6.16}</script><p>则空间中的三维点经过仿射变换到像素坐标系中：</p>
<script type="math/tex; mode=display">
x=\left[\begin{array}{l}u\\
v\\
1\end{array}\right]=MX=M\left[\begin{array}{l}x\\
y\\
z\\
1\end{array}\right]=AX^E+b\quad(X^E为空间点的欧式坐标)\tag{6.17}</script><h4 id="0-问题描述-1"><a href="#0-问题描述-1" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>有$x_{ij}=A_iX_j+b_i$ </p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的投影矩阵 $A_i\ and\ b_i$ 。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040608.png" alt="image-20210829191114401"></p>
<h4 id="1-因式分解法"><a href="#1-因式分解法" class="headerlink" title="1.因式分解法"></a>1.因式分解法</h4><h5 id="a-数据中心化"><a href="#a-数据中心化" class="headerlink" title="a.数据中心化"></a>a.数据中心化</h5><p>中心化就是减去图像点的质心。</p>
<script type="math/tex; mode=display">
\hat{x}_{i j}=x_{i j}-\bar{x}_{i} \\ 其中：\begin{aligned}\bar{x}_{i}=\frac{1}{n} \sum_{k=1}^{n} x_{i k} \\ 
x_{\mathrm{ij}}=A_{i} X_{j}+b_{i}\end{aligned}\tag{6.18}</script><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040613.png" alt="image-20210829191737903"></p>
<p>然后可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{x}_{i j}=x_{i j}-\frac{1}{n} \sum_{k=1}^{n} x_{i k} &=A_{i} X_{j}+b_{i}-\frac{1}{n} \sum_{k=1}^{n} A_{i} X_{k}-\frac{1}{n} \sum_{k=1}^{n} b_{i} \\
&=A_{i}\left(X_{j}-\frac{1}{n} \sum_{k=1}^{n} X_{k}\right)\\&=A_{i}\left(X_{j}-\bar{X}\right)\\&=A_{i} \hat{X}_{j}
\end{aligned}\tag{6.19}</script><p>如果令三维空间点的质心=世界坐标系的远点。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040618.png" alt="image-20210829191948530"></p>
<p>那么：</p>
<script type="math/tex; mode=display">
\hat{x}_{i j}=A_{i} \hat{X}_{j}=A_{i} X_{j}\tag{6.20}</script><h5 id="b-因式分解"><a href="#b-因式分解" class="headerlink" title="b.因式分解"></a>b.因式分解</h5><p>现在我们把去均值以后的 $m\times n$ 个测量值写成矩阵的形式：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{cccc}
\hat{x}_{11} & \hat{x}_{12} & \cdots & \hat{x}_{1 n} \\
\hat{x}_{21} & \hat{x}_{22} & \cdots & \hat{x}_{2 n} \\
& & \ddots & \\
\hat{x}_{m 1} & \hat{x}_{m 2} & \cdots & \hat{x}_{m n}
\end{array}\right]\tag{6.21}</script><p>其中每个 $\hat{x}_{ij}$ 是一个 $2\times1$ 的向量，它是图像点的像素坐标。</p>
<p>根据式(6.20)，可以推导出D的由来：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{llll}
\hat{x}_{11} & \hat{x}_{12} & \cdots & \hat{x}_{1 n} \\
\hat{x}_{21} & \hat{x}_{22} & \cdots & \hat{x}_{2 n} \\
& & \ddots & \\
\hat{x}_{m 1} & \hat{x}_{m 2} & \cdots & \hat{x}_{m n}
\end{array}\right]=\left[\begin{array}{c}
A_{1} \\
A_{2} \\
\vdots \\
A_{m}
\end{array}\right]
\left[\begin{array}{c} X_{1} & X_{2} & \cdots & X_{n}
\end{array}\right]=MS\tag{6.22}</script><p>下面对D进行奇异值分解：</p>
<script type="math/tex; mode=display">
D=UWV^T\tag{6.23}</script><p>(6.22)中，M矩阵的最大秩为3，S矩阵的最大秩也为3。所以D的最大秩为3</p>
<p>那么我们就可以选择前三个最大的奇异值来进行分解，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040622.png" style="zoom: 67%;" /></p>
<p>所以：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040625.png" alt="image-20210829193956389" style="zoom:67%;" /></p>
<script type="math/tex; mode=display">
D=U_3W_3V_3^T=U_3(W_3V_3^T)=M^\star S^\star \tag{6.24}</script><p>(6.24)中，我们用后面 $W_3V_3^T$ 来重构S矩阵，当然也可以用 $V_3^T$ 来重构S。</p>
<p>这就引出了一个问题，对于同一结构，为什么可以有不同种恢复机构呢？</p>
<p>这个问题就是仿射结构的恢复歧义。</p>
<h5 id="c-因式分解法的问题"><a href="#c-因式分解法的问题" class="headerlink" title="c.因式分解法的问题"></a>c.因式分解法的问题</h5><p>当我们构建D矩阵时，是假设所有的三维点在图像上都能找得到，但当三维点被遮挡后，图像上找不到它的投影点，此时D矩阵中的元素就会空缺。这就会造成求解失败。</p>
<h4 id="2-仿射结构恢复歧义"><a href="#2-仿射结构恢复歧义" class="headerlink" title="2.仿射结构恢复歧义"></a>2.仿射结构恢复歧义</h4><p>先来看看D矩阵的推导过程，可用下图来表示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040717.png" alt="image-20210829194730339"></p>
<p>当我们在M矩阵和S矩阵间乘上一个可逆矩阵H和它的逆后：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040635.png" alt="image-20210829194843158"></p>
<p>最后的结果还是D矩阵，但是M和S矩阵却不相同了。其中H矩阵可以是任意的可逆的 $3\times3$ 的矩阵</p>
<p>所以必须利用其他的约束条件来解决歧义的问题。</p>
<p>仿射歧义的可视化如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040638.png" alt="image-20210829195044317"></p>
<p>真实的三维结构和恢复的三维结构之间相差了一个任意的 $3\times 3$ 的可逆矩阵H。</p>
<h3 id="D-透视结构恢复"><a href="#D-透视结构恢复" class="headerlink" title="D.透视结构恢复"></a>D.透视结构恢复</h3><h4 id="0-问题描述-2"><a href="#0-问题描述-2" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>有$x_{ij}=M_iX_j$ </p>
<p>$M_i$ 是第i张图片对应的摄像机投影矩阵</p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的投影矩阵 $M_i$ 。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040643.png" alt="image-20210829195526866"></p>
<h4 id="1-透视结构恢复歧义"><a href="#1-透视结构恢复歧义" class="headerlink" title="1.透视结构恢复歧义"></a>1.透视结构恢复歧义</h4><p>根据透视相机投影规律，当不知道相机的内参和外参时，可用M矩阵来表示透视投影关系，M是一个 $3\times4$ 矩阵，透视关系如下：</p>
<script type="math/tex; mode=display">
x_{ij}=M_iX_j\tag{6.25}</script><p>当 $M_i$ 和 $X_j$ 之间，可以加上任意一个 $4\times 4$ 的可逆矩阵H和其逆矩阵的乘积。</p>
<script type="math/tex; mode=display">
x_{ij}=M_iHH^{-1}X_j\tag{6.26}</script><p>这样，在恢复结构的时候，所恢复出的 $M_i$ 和真实的 $M_i$ 可能会相差一个H投影变换矩阵。这就是透视结构恢复歧义。</p>
<p>所以我们恢复透视结构时，是在相差一个 $4\times4$ 的可逆变换的情况下，恢复摄像机运动和场景结构的。</p>
<h4 id="2-代数方法（通过基础矩阵）"><a href="#2-代数方法（通过基础矩阵）" class="headerlink" title="2.代数方法（通过基础矩阵）"></a>2.代数方法（通过基础矩阵）</h4><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040648.png" alt="image-20210829202031145"></p>
<p>代数方法主要用于两视图情况，尽管我们要使用的是一个图像序列，但是我们可以将其分成多个两视图情况来进行求解。</p>
<p>具体求解有三个步骤：</p>
<p>(1) 八点算法来求得基础矩阵F</p>
<p>(2)由基础矩阵F求得摄像机的投影矩阵。</p>
<p>(3)用三角化计算三维点的坐标。</p>
<h5 id="a-基础矩阵和投影矩阵的关系"><a href="#a-基础矩阵和投影矩阵的关系" class="headerlink" title="a.基础矩阵和投影矩阵的关系"></a>a.基础矩阵和投影矩阵的关系</h5><p>在这里，第(2)步中，<strong>如何通过F矩阵来求投影矩阵M我们之前没有说过</strong>。下面介绍该步骤的解法。</p>
<p>由于透视歧义的存在，我们总是可以找到一个可逆矩阵H，使得：</p>
<script type="math/tex; mode=display">
M_{1} H^{-1}=[I \mid 0] \quad M_{2} H^{-1}=[A \mid b]\tag{6.27}</script><p>用X表示三维点，$x\ and \ x’$ 分别称为摄像机1和2的对应观测值。</p>
<p>令：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\widetilde{M}_{1}=M_{1} H^{-1}=\left[\begin{array}{ll}
I & 0
\end{array}\right] \\
\widetilde{M}_{2}=M_{2} H^{-1}=\left[\begin{array}{ll}
A & b
\end{array}\right] \\
\widetilde{X}=H X
\end{array}\right.\tag{6.28}</script><p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x=M_{1} X=M_{1} H^{-1} H X=[I \mid 0] \tilde{X} \\
&x^{\prime}=M_{2} X=M_{2} H^{-1} H X=[A \mid b] \tilde{X}
\end{aligned}\tag{6.29}</script><p>对于摄像机1和2的观测值 $x\ and \ x’$ 有如下关系：</p>
<script type="math/tex; mode=display">
x^{\prime}=[A \mid b] \widetilde{X}=[A \mid b]\left[\begin{array}{c}
\widetilde{X}_{1} \\
\widetilde{X}_{2} \\
\widetilde{X}_{3} \\
1
\end{array}\right]=A[I \mid 0]\left[\begin{array}{c}
\widetilde{X}_{1} \\
\widetilde{X}_{2} \\
\widetilde{X}_{3} \\
1
\end{array}\right]+b=A[I \mid 0] \widetilde{X}+b=A x+b\tag{6.30}</script><p>然后我们将(6.30)中的  $x’$ 叉乘b：</p>
<script type="math/tex; mode=display">
x'\times b=(Ax+b)\times b=Ax\times b\tag{6.31}</script><p>再用 $x’$ 点乘 $x’\times b$ ，它的结果为0，所以：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x'^T \cdot(x'\times b)&=x'^T\cdot(Ax\times b)\\
&=-x'^T\cdot(b\times Ax)\\
&=-x'^T[b_{\times}]Ax=0
\end{aligned}\tag{6.32}</script><p>由极几何关系，可以知道两个视图的对应点的像素坐标的关系是：</p>
<script type="math/tex; mode=display">
x'^TFx=0\tag{6.33}</script><p>所以比较(6.32)和(6.33)，有：</p>
<script type="math/tex; mode=display">
F=[b_{\times}]A\tag{6.34}</script><p><strong>有了这个关系，我们现在就可以用八点法得到的基础矩阵F来分解出A矩阵和b</strong></p>
<h5 id="b-计算投影矩阵中的b"><a href="#b-计算投影矩阵中的b" class="headerlink" title="b.计算投影矩阵中的b"></a>b.计算投影矩阵中的b</h5><p>考虑：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F^Tb&=([b_{\times}]A)^Tb\\
&=A^T[b_{\times}]^Tb\\
&=-A^T[b_{\times}]b\\
&=0
\end{aligned}\tag{6.35}</script><p>所以可通过(6.35)的线性方程组来求解出b</p>
<p>b为 $F^T$ 矩阵的最小奇异值的右奇异向量，且 $||b||=1$ 。</p>
<h5 id="c-计算A矩阵"><a href="#c-计算A矩阵" class="headerlink" title="c.计算A矩阵"></a>c.计算A矩阵</h5><p>直接定义：</p>
<script type="math/tex; mode=display">
A'=-[b_{\times}]F\tag{6.36}</script><p>下面来验证 $[b_{\times}]A’$ 是否等于 $F$ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\ [b_{\times}]A'&=-[b_\times][b_\times]F\\
&=-(bb^T-|b|^2I)F\\
&=-bb^TF+|b|^2F\\
&=-b(F^Tb)^T+|b|^2F\\
&=1\cdot F\\
&=F
\end{aligned}\tag{6.37}</script><p>所以可以得到：</p>
<script type="math/tex; mode=display">
A=A'=-[b_\times]F\tag{6.38}</script><p>最后我们就可以计算出两个投影矩阵了：</p>
<script type="math/tex; mode=display">
\widetilde{M}_{1}=\left[\begin{array}{ll}
I & 0
\end{array}\right] \quad \widetilde{M}_{2}=\left[-\left[b_{\times}\right] F \quad b\right]</script><blockquote>
<p>这里的b是有具体的几何含义的，在第四章3小节b中，基础矩阵的性质可知，$F^Te=0$ ，而这里的 $F^Tb=0$ ，所以b是一个极点。</p>
</blockquote>
<h5 id="d-代数法的问题"><a href="#d-代数法的问题" class="headerlink" title="d.代数法的问题"></a>d.代数法的问题</h5><p>在实际的应用中，我们拥有的是一个图像序列，我们需要在两两视图间进行求解，然后再将得到的结果累加，例如求得了 $M_1$ 和 $M_2$ ，然后再求 $M_2 \ and \ M_3$ 之间的关系，最后再进行累加得到 $M_1\ and \ M_3$ 的关系，这样一点一点累积，但凡每步都有一点点小误差，但当不断积累后，就会变成一个较大的误差。</p>
<h4 id="3-捆绑调整"><a href="#3-捆绑调整" class="headerlink" title="3.捆绑调整"></a>3.捆绑调整</h4><p>考虑到因式分解法和代数法的缺点，我们又提出了一种新的方法，捆绑法。</p>
<p>捆绑法主要采用非线性优化方法，通过最小化重投影误差，来优化得到 $X_j\ and\ M_i$ </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018040657.png" alt="image-20210829232507094"></p>
<p>最小化重投影误差：</p>
<script type="math/tex; mode=display">
E(M, X)=\sum_{i=1}^{m} \sum_{j=1}^{n} D\left(x_{i j}, M_{i} X_{j}\right)^{2}\tag{6.39}</script><p>我们可以使用牛顿法或列文伯格-马夸尔特方法来进行非线性优化。</p>
<p>该方法的优势是可以同时处理大量视图，处理丢失的数据。</p>
<p>但该方法的弊端也十分致命，就是需要优化的参数过多，所以需要良好的初始条件。</p>
<p>因此在实际的应用中，常用作结构恢复SFM(structure from motion)的最后一步，通过因式分解法或代数法来求的优化问题的初始解，然后在通过捆绑法进行优化。</p>
]]></content>
      <categories>
        <category>SLAM学习</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu的使用手册</title>
    <url>/2021/10/18/Ubuntu%E7%9A%84%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>Unbuntu中常用的命令和使用规则。<br><span id="more"></span></p>
<h2 id="一、软件的安装"><a href="#一、软件的安装" class="headerlink" title="一、软件的安装"></a>一、软件的安装</h2><h3 id="1-软件源"><a href="#1-软件源" class="headerlink" title="1.软件源"></a>1.软件源</h3><p>软件源就是所下载的软件来源，软件源会决定软件的下载速度。</p>
<p>在<code>软件和更新</code>中可以更换软件源。</p>
<h3 id="2-安装软件中的一些基本操作"><a href="#2-安装软件中的一些基本操作" class="headerlink" title="2.安装软件中的一些基本操作"></a>2.安装软件中的一些基本操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  	重新载入软件源，将软件列表更新。</span><br></pre></td></tr></table></figure>
<h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h2><p>Ubuntu操作系统中，通常是通过命令行来操作的，命令行应用的扩展性和灵活性较好，在早期的Windows系统中也是用命令行来操作电脑的。</p>
<p>命令行在终端中输入，用 <code>Ctrl</code>+<code>Alt</code>+<code>T</code> 快捷键可以打开终端窗口。</p>
<h3 id="1-pwd"><a href="#1-pwd" class="headerlink" title="1.pwd"></a>1.pwd</h3><p>查看当前的路径。</p>
<h3 id="2-cd"><a href="#2-cd" class="headerlink" title="2.cd"></a>2.cd</h3><p>切换当前路径。后面可以接相对路径，也可接绝对路径。</p>
<h3 id="3-mkdir"><a href="#3-mkdir" class="headerlink" title="3.mkdir"></a>3.mkdir</h3><p>创建文件夹。</p>
<h3 id="4-ls"><a href="#4-ls" class="headerlink" title="4.ls"></a>4.ls</h3><p>查看当前路径下的文件和文件夹。</p>
<h3 id="5-touch"><a href="#5-touch" class="headerlink" title="5.touch"></a>5.touch</h3><p>创建文件。</p>
<h3 id="6-mv"><a href="#6-mv" class="headerlink" title="6.mv"></a>6.mv</h3><p>将一个文件或文件夹移动到另外一个路径，相当于剪切的作用。</p>
<p>具体用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv file new_path</span><br></pre></td></tr></table></figure>
<p>将一个文件或文件夹拷贝到另一个路径，相当于复制粘贴。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv file new_path</span><br></pre></td></tr></table></figure>
<h3 id="8-rm"><a href="#8-rm" class="headerlink" title="8.rm"></a>8.rm</h3><p>删除文件或文件夹。</p>
<p>具体用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm file</span><br><span class="line">rm -r folder</span><br></pre></td></tr></table></figure>
<h3 id="9-sudo"><a href="#9-sudo" class="headerlink" title="9.sudo"></a>9.sudo</h3><p>sudo 的作用是提升当前用户的权限。比如安装软件时，必须要使用sudo命令。</p>
<h2 id="三、更改文件权限"><a href="#三、更改文件权限" class="headerlink" title="三、更改文件权限"></a>三、更改文件权限</h2><h3 id="1-Linux-文件基本属性"><a href="#1-Linux-文件基本属性" class="headerlink" title="1.Linux 文件基本属性"></a>1.Linux 文件基本属性</h3><p><a href="https://www.runoob.com/linux/linux-file-attr-permission.html">参考</a></p>
<p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>
<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>
<ul>
<li>chown (change ownerp) ： 修改所属用户与组。</li>
<li>chmod (change mode) ： 修改用户的权限。</li>
</ul>
<p>下图中通过 chown 来授权用户，通过 chmod 为用户设置可以开门的权限。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018054806.png" alt="img"></p>
<p>在 Linux 中我们可以使用 <strong>ll</strong> 或者 <strong>ls –l</strong> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www /]<span class="comment"># ls -l</span></span><br><span class="line">total 64</span><br><span class="line">dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</span><br><span class="line">dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>实例中，<strong>bin</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul>
<li>当为 <strong>d</strong> 则是目录</li>
<li>当为 <strong>-</strong> 则是文件；</li>
<li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li>
<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018054821.jpg" alt="img"></p>
<p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018054825.png" alt="363003_1227493859FdXT"></p>
<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>
<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p>
<p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p>
<p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>
<hr>
<h3 id="2-Linux文件属主和属组"><a href="#2-Linux文件属主和属组" class="headerlink" title="2.Linux文件属主和属组"></a>2.Linux文件属主和属组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www /]# ls -l</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron</span><br><span class="line">drwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p>
<p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p>
<hr>
<h3 id="3-更改文件属性"><a href="#3-更改文件属性" class="headerlink" title="3.更改文件属性"></a>3.更改文件属性</h3><h4 id="1-chgrp：更改文件属组"><a href="#1-chgrp：更改文件属组" class="headerlink" title="(1)chgrp：更改文件属组"></a>(1)chgrp：更改文件属组</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>
<p>参数选项</p>
<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<h4 id="2-chown：更改文件属主，也可以同时更改文件属组"><a href="#2-chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="(2)chown：更改文件属主，也可以同时更改文件属组"></a>(2)chown：更改文件属主，也可以同时更改文件属组</h4><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>
<p>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~] <span class="built_in">cd</span> ~</span><br><span class="line">[root@www ~]<span class="comment"># chown bin install.log</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</span><br></pre></td></tr></table></figure>
<p>将install.log的拥有者与群组改回为root：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># chown root:root install.log</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</span><br></pre></td></tr></table></figure>
<h4 id="3-chmod：更改文件9个属性"><a href="#3-chmod：更改文件9个属性" class="headerlink" title="(3)chmod：更改文件9个属性"></a>(3)chmod：更改文件9个属性</h4><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux 文件的基本权限就有九个，分别是 <strong>owner/group/others(拥有者/组/其他)</strong> 三种身份各有自己的 <strong>read/write/execute</strong> 权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为： <strong>-rwxrwxrwx</strong> ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： <strong>-rwxrwx—-</strong> 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= —- = 0+0+0 = 0</li>
</ul>
<p>所以等一下我们设定权限的变更时，该文件的权限数字就是 <strong>770</strong>。变更权限的指令 chmod 的语法是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<p>举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc</span><br><span class="line">[root@www ~]<span class="comment"># chmod 777 .bashrc</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</span><br></pre></td></tr></table></figure>
<p>那如果要将权限变成 <em>-rwxr-xr—</em> 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。</p>
<h4 id="4-符号类型改变文件权限"><a href="#4-符号类型改变文件权限" class="headerlink" title="(4)符号类型改变文件权限"></a>(4)符号类型改变文件权限</h4><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p>
<ul>
<li>user：用户</li>
<li>group：组</li>
<li>others：其他</li>
</ul>
<p>那么我们就可以使用 <strong>u, g, o</strong> 来代表三种身份的权限。</p>
<p>此外， <strong>a</strong> 则代表 <strong>all</strong>，即全部的身份。读写的权限可以写成 <strong>r, w, x</strong>，也就是可以使用下表的方式来看：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>chmod</th>
<th>u g o a</th>
<th>+(加入) -(除去) =(设定)</th>
<th>r w x</th>
<th>文件或目录</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>如果我们需要将文件权限设置为 <strong>-rwxr-xr—</strong> ，可以使用 <strong>chmod u=rwx,g=rx,o=r 文件名</strong> 来设定:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  touch test1    // 创建 test1 文件</span></span><br><span class="line"><span class="comment"># ls -al test1    // 查看 test1 默认权限</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br><span class="line"><span class="comment"># chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限</span></span><br><span class="line"><span class="comment"># ls -al test1</span></span><br><span class="line">-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</span><br></pre></td></tr></table></figure>
<p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  chmod  a-x test1</span></span><br><span class="line"><span class="comment"># ls -al test1</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件实践</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>古月ROS21讲学习笔记</title>
    <url>/2021/10/18/%E5%8F%A4%E6%9C%88ROS21%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习《古月ROS入门21讲》的学习笔记<br><span id="more"></span><br>课程总览：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055135.png" alt="image-20211007012207647"></p>
<h1 id="一、ROS是什么"><a href="#一、ROS是什么" class="headerlink" title="一、ROS是什么"></a>一、ROS是什么</h1><p>ROS1.0发布于2010年，其发布的根本目的就是在机器人开发过程中，提高代码的复用率。就是在开发一个机器人时，可以通过ROS提供的各种功能，驱动机器人移动，感知外部环境，做出决策等。这就极大的节省了机器人开发的时间。</p>
<p>ROS(Robot operation system)全名为机器人操作系统，具体的它包括四大部分，分别为<strong>通信机制，开发工具，应用功能和生态系统</strong>。</p>
<h2 id="1-通信机制"><a href="#1-通信机制" class="headerlink" title="1.通信机制"></a>1.通信机制</h2><p>ROS提供了一种松耦合分布式通信机制，机器人的内部各个模块可以依靠这种通信机制完成信息的传递。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055137.png" alt="image-20211005000749206" style="zoom:67%;" /></p>
<h2 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2.开发工具"></a>2.开发工具</h2><p>ROS提供了一系列的开发工具，可以为机器人开发提供很大的帮助。</p>
<p>常用的开发工具有TF坐标变换，QT工具箱，Rviz，Gazebo。会在后面进行具体的使用介绍。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055141.png" alt="image-20211005000718567"></p>
<h2 id="3-应用功能"><a href="#3-应用功能" class="headerlink" title="3.应用功能"></a>3.应用功能</h2><p>ROS中包含各种功能包，可供机器人开发中使用。例如有可以驱动相机的功能包，有进行图像处理的功能包，有控制机器人运动的功能包，还有SLAM功能包。这些功能包的存在可以大大简化机器人的开发过程。</p>
<h2 id="4-生态环境"><a href="#4-生态环境" class="headerlink" title="4.生态环境"></a>4.生态环境</h2><p>ROS的生态环境具体指的是依据ROS系统，建立起来的一个ROS社区，在这个社区中，包含着我们需要的各种东西。主要有以下几部分组成：</p>
<ul>
<li>发行版：ROS发行版包括一系列带有版本号，可以直接安装的功能包。</li>
<li>软件源：ROS依赖于共享网络上的开源代码，不同组织机构可以开发或共享自己的机器人软件。</li>
<li>ROS wiki：记录ROS信息文档的论坛。</li>
<li>ROs Answer：咨询ROS相关的网站。</li>
</ul>
<h1 id="二、ROS中的核心概念"><a href="#二、ROS中的核心概念" class="headerlink" title="二、ROS中的核心概念"></a>二、ROS中的核心概念</h1><p>从上一章所知，ROS主要有四部分组成，包括通信机制，开发工具，应用功能和生态环境。抛开生态环境不说，因为整个ROS生态环境是当我们遇到困难或有什么特殊需求的时候，寻求帮助的地方。在我们实际的开发中，我们需要非常了解前三个部分。</p>
<p>下面我们来细细的说明一下ROS中的核心概念。</p>
<h2 id="1-组成ROS的基本单元"><a href="#1-组成ROS的基本单元" class="headerlink" title="1.组成ROS的基本单元"></a>1.组成ROS的基本单元</h2><p>当我们要了解ROS的通信机制时，就要知道是什么和什么在进行通信，也就是通信的主体是什么。在ROS中，通信的主体有节点和节点管理器两部分组成。</p>
<h3 id="1-节点-Node-—工人"><a href="#1-节点-Node-—工人" class="headerlink" title="(1)节点(Node)—工人"></a>(1)节点(Node)—工人</h3><p>节点是ROS系统中最基本的执行单元，有如下特点：</p>
<ul>
<li>节点要执行具体的任务进程，是一个可独立运行的可执行文件。</li>
<li>不同的节点可以使用不同的编程语言，可分布式运行在不同的主机。</li>
<li>节点在系统中的名称必须是唯一的。</li>
</ul>
<h3 id="2-节点管理器-Ros-Master-—管理员"><a href="#2-节点管理器-Ros-Master-—管理员" class="headerlink" title="(2)节点管理器(Ros Master)—管理员"></a>(2)节点管理器(Ros Master)—管理员</h3><p>对于节点的管理工作，需要节点管理器来完成，它主要有如下作用：</p>
<ul>
<li>为节点提供命名和注册服务。</li>
<li>跟踪和记录话题/服务通信（后面会说），辅助节点相互查找、建立连接。</li>
<li>提供参数服务器，节点使用此服务器存储和检索运行时的参数。</li>
</ul>
<p>下面我们用工人和管理员对以上的功能进行类比。对于每一个节点，我们可以把它看成是一个工人。工人就需要做好自己特定的工作（执行具体的任务进程），比如这个工人负责搬砖，另一个工人负责盖楼。不管这个工人来自哪里（使用不同的编程语言），或者在哪个工地（可运行在不同主机），只要能干活就可以。另外，工人不能重名（节点的名称唯一），这样不方便管理员管理。</p>
<p>而对于管理员，首先就是要为工人注册信息，分配工号（为节点提供命名和注册服务），然后给每个工人分配一个工作内容，并记录下工人所汇报的工作情况，方便其他工人了解完成情况（跟踪记录通信，辅助节点查找，建立连接）。另外，管理员还要记录下工程的水泥灰号，垒砖高度等工程参数，以方便工人在工作时可以随时查询（提供参数服务器）。</p>
<h2 id="2-通信机制"><a href="#2-通信机制" class="headerlink" title="2.通信机制"></a>2.通信机制</h2><p>通信机制主要有两种，一种是异步通信机制，叫做话题（Topic），另一种是同步通信机制，叫做服务（Service）。</p>
<h3 id="1-异步通信机制"><a href="#1-异步通信机制" class="headerlink" title="(1)异步通信机制"></a>(1)异步通信机制</h3><p>在该通信机制下，节点间传输的数据不是实时的。我们要知道两个概念：</p>
<h4 id="a-话题-Topic"><a href="#a-话题-Topic" class="headerlink" title="a.话题(Topic)"></a>a.话题(Topic)</h4><ul>
<li>节点间用来传输数据的总线。</li>
<li>使用发布/订阅模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以不唯一。</li>
</ul>
<h4 id="b-消息-Message"><a href="#b-消息-Message" class="headerlink" title="b.消息(Message)"></a>b.消息(Message)</h4><ul>
<li>消息是话题的数据。</li>
<li>具有一定的数据类型和数据结构，包括ROS提供的标准类型和用户自定义类型。</li>
<li>使用与编程语言无关的.msg文件定义，编译过程中生成对应的代码文件。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055153.png" alt="image-20211005005705788"></p>
<p>好了，说完这么抽象的概念，我们还是用一个生活的例子来类比一下。在我们生活中，异步通信机制一个很明显的例子就是Youtube视频。例如有一个篮球话题（Topic），有一群订阅者（subsciber）和一群发布者（publisher）。当某一个发布者发布了一条视频（message）时，订阅者并不会马上知道，而是等他想看的时候，才会查看该话题下的内容，这就是异步通信机制。对于发布的视频的内容结构，可以是先热身，后打球，也可以是先打球，后洗澡，虽然结构可以变，但是有一定结构的。另外，无论视频内容如何，都必须是.avi格式的（.msg）。</p>
<p>所以说话题（Topic）是一个传输数据的总线，也可以理解成一个频道，一个管道，我们订阅了这个频道后，其内容会保持一定的结构，但是会变化。</p>
<p>在ROS中，话题的一个例子如下：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055200.png" alt="image-20211005010719866"></p>
<h3 id="2-同步通信机制"><a href="#2-同步通信机制" class="headerlink" title="(2)同步通信机制"></a>(2)同步通信机制</h3><p>同步通信机制，也叫做服务。它可以保证数据的传递是实时的。它有如下特点：</p>
<ul>
<li>使用客户端/服务器模型，客户端发送请求，服务器完成处理后返回应答数据。</li>
<li>使用与编程语言无关的.srv文件定义请求和应答数据结构，编译过程中生成对应的代码文件。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055205.png" alt="image-20211005011052269" style="zoom: 67%;" /></p>
<p>这就好比一个服务员和一个顾客，顾客首先需要说出一个需求，然后服务员要做出回应。比如，顾客说帮我订一张机票（request），服务员立即定了一张机票然后回复订完了（reponse）。</p>
<p>ROS中服务的一个例子：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055209.png" alt="image-20211005011405078"></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055214.png" alt="image-20211005011450237" style="zoom:67%;" /></p>
<h2 id="3-参数—全局共享字典"><a href="#3-参数—全局共享字典" class="headerlink" title="3.参数—全局共享字典"></a>3.参数—全局共享字典</h2><p>前面讲了工人和管理员的关系，管理员要记录一些所有工人都要用的信息，例如水泥的灰号。ROS中的参数的功能也是这样。参数由节点管理器提供服务器存储。特点如下：</p>
<ul>
<li>可通过网络访问的共享、多变量字典。</li>
<li>节点可以使用此服务器（也就是字典）来存储和检索运行时的参数。</li>
<li>适合存储静态、非二进制的配置参数，不适合存储动态配置的数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055219.png" alt="image-20211005012244569"></p>
<h2 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4.文件系统"></a>4.文件系统</h2><p>前面所讲的节点等所有的东西都需要存储在文件中，也就是真实存在的形式。ROS的文件系统由三部分组成。</p>
<h3 id="1-功能包-Package"><a href="#1-功能包-Package" class="headerlink" title="(1)功能包(Package)"></a>(1)功能包(Package)</h3><p>ROS软件中的基本单元，包含节点源码、配置文件、数据定义等。</p>
<h3 id="2-功能包清单-Package-Manifest"><a href="#2-功能包清单-Package-Manifest" class="headerlink" title="(2)功能包清单(Package Manifest)"></a>(2)功能包清单(Package Manifest)</h3><p>记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。</p>
<h3 id="3-元功能包-Meta-Package"><a href="#3-元功能包-Meta-Package" class="headerlink" title="(3)元功能包(Meta Package)"></a>(3)元功能包(Meta Package)</h3><p>多个用于同一目的的功能包构成一个元功能包。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055223.png" alt="image-20211005012811067"></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055230.png" alt="image-20211005012906244"></p>
<h1 id="三、ROS命令行工具"><a href="#三、ROS命令行工具" class="headerlink" title="三、ROS命令行工具"></a>三、ROS命令行工具</h1><p>ROS中提供了命令行工具帮助我们实现各种功能。</p>
<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h2><p><code>roscore</code>     启动Ros Master（必须启动）。</p>
<p><code>rosrun    功能包名    节点</code>     运行节点，要加功能包名，然后要运行的节点名。</p>
<h2 id="2-节点命令"><a href="#2-节点命令" class="headerlink" title="2.节点命令"></a>2.节点命令</h2><p>以<code>rosnode</code> 开头的命令，是处理节点的命令。</p>
<h3 id="1-rosnode-list"><a href="#1-rosnode-list" class="headerlink" title="(1)rosnode list"></a>(1)<code>rosnode list</code></h3><p>列出当前系统的所有节点。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055236.png" alt="image-20211005015249575"></p>
<p>在这里有一个rosout节点，是默认打开的，该节点主要是接受各个节点的信息形成一个日志信息。</p>
<h3 id="2-rosnode-info-节点名"><a href="#2-rosnode-info-节点名" class="headerlink" title="(2)rosnode info 节点名"></a>(2)<code>rosnode info 节点名</code></h3><p>查看某个节点信息。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055240.png" alt="image-20211005015739389"></p>
<p>在这里显示出的发布或订阅的内容中，前面部分为话题名，后面的是消息名。</p>
<h2 id="3-话题命令"><a href="#3-话题命令" class="headerlink" title="3.话题命令"></a>3.话题命令</h2><p>以<code>rostopic</code> 开头的命令，是处理话题的命令。</p>
<h3 id="1-rostopic-list"><a href="#1-rostopic-list" class="headerlink" title="(1)rostopic list"></a>(1)<code>rostopic list</code></h3><p>查看当前系统的所有话题。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055247.png" alt="image-20211005020128092"></p>
<h3 id="2-rostopic-pub"><a href="#2-rostopic-pub" class="headerlink" title="(2)rostopic pub"></a>(2)<code>rostopic pub</code></h3><p>向话题发布消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic	 pub 	话题名 	消息名 	内容</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rostopic 	pub 	/turtle1/cmd_vel 	geometry_msgs/Twist 	<span class="string">&quot;消息内容(在这里ROS定义的结构)&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这里，/turtle1/cmd_vel是话题名，geometry_msgs/Twist 是消息内容，后面双引号内是具体的消息内容，消息内容会有特定的结构。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055316.png" alt="image-20211005020805272"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic 	pub 	-r 		10 		话题名		消息名		内容</span><br></pre></td></tr></table></figure>
<p>-r表示发布循环发布，这里表示发布频率为10Hz。</p>
<p>按<code>Ctrl+C</code>可以停止发布。</p>
<h2 id="4-话题消息命令"><a href="#4-话题消息命令" class="headerlink" title="4.话题消息命令"></a>4.话题消息命令</h2><p>以<code>rosmsg</code> 开头的命令，是处理话题消息的命令。</p>
<h3 id="1-rosmsg-show"><a href="#1-rosmsg-show" class="headerlink" title="(1)rosmsg show"></a>(1)<code>rosmsg show</code></h3><p>查看某个消息的数据结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosmsg 		show	消息名</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055335.png" alt="image-20211005022203709"></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="5-服务命令"><a href="#5-服务命令" class="headerlink" title="5.服务命令"></a>5.服务命令</h2><p>以<code>rosservice</code> 开头的命令，是处理服务的命令。</p>
<h3 id="1-rosservice-list"><a href="#1-rosservice-list" class="headerlink" title="(1)rosservice list"></a>(1)<code>rosservice list</code></h3><p>查看服务端的服务。也就是查看可提供的服务。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055339.png" alt="image-20211005022505249"></p>
<h3 id="2-rosservice-call"><a href="#2-rosservice-call" class="headerlink" title="(2)rosservice call"></a>(2)<code>rosservice call</code></h3><p>对某个服务发送请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice		call		可提供服务名		<span class="string">&quot;请求内容&quot;</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">rosservice 		call 		/spawn 		<span class="string">&quot;x: 0.0</span></span><br><span class="line"><span class="string">y: 0.0</span></span><br><span class="line"><span class="string">theta: 0.0</span></span><br><span class="line"><span class="string">name:&#x27;	 &#x27; &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，服务名为/spawn，双引号内为请求的内容，具有系统定义的数据结构。</p>
<h2 id="6-服务消息命令"><a href="#6-服务消息命令" class="headerlink" title="6.服务消息命令"></a>6.服务消息命令</h2><p>以<code>rossrv</code>开头的命令，是处理服务消息的命令。</p>
<h3 id="1-rossrv-show"><a href="#1-rossrv-show" class="headerlink" title="(1)rossrv show"></a>(1)<code>rossrv show</code></h3><p>查看服务消息数据的内容结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rossrv 		show		服务消息名</span><br></pre></td></tr></table></figure>
<p>在标准的服务消息数据中，有—-分隔，在其上面的是request的内容，下面是response的内容。request可以是空的，如果是空的，直接call服务就可以。response能不能是空的还不知道。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055352.png" alt="image-20211006001820657"></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055356.png" alt="image-20211006001952198"></p>
<h2 id="7-话题记录和复现"><a href="#7-话题记录和复现" class="headerlink" title="7.话题记录和复现"></a>7.话题记录和复现</h2><p>记录当前系统中所有话题的数据并保存下来，然后可以再用的时候复现出来。</p>
<h3 id="1-rosbag-record"><a href="#1-rosbag-record" class="headerlink" title="(1)rosbag record"></a>(1)<code>rosbag record</code></h3><p>记录想要保存的话题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosbag		record		-a		-O		储存的文件名</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rosbag 		record 		-a		-O		cmd_record</span><br></pre></td></tr></table></figure>
<p>在这里-a表示记录所有话题数据。-O表示保存数据为一个压缩包。</p>
<p>文件会被储存到终端当前的工作目录。</p>
<h3 id="2-rosbag-play"><a href="#2-rosbag-play" class="headerlink" title="(2)rosbag play"></a>(2)<code>rosbag play</code></h3><p>复现保存的话题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosbag 		play		储存的文件名</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rosbag 		play		cmd_record</span><br></pre></td></tr></table></figure>
<h2 id="8-参数命令"><a href="#8-参数命令" class="headerlink" title="8.参数命令"></a>8.参数命令</h2><p>以<code>rosparam</code> 开头的命令，都是处理参数的命令。</p>
<h3 id="1-rosparam-list"><a href="#1-rosparam-list" class="headerlink" title="(1)rosparam list"></a>(1)<code>rosparam list</code></h3><p>查看当前的全局参数。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055411.png" alt="image-20211006013652641"></p>
<h3 id="2-rosparam-get"><a href="#2-rosparam-get" class="headerlink" title="(2)rosparam get"></a>(2)<code>rosparam get</code></h3><p>获取某个参数的具体值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	get 	参数名</span><br><span class="line">rosparam 	get 	/run_id</span><br></pre></td></tr></table></figure>
<h3 id="3-rosparam-set"><a href="#3-rosparam-set" class="headerlink" title="(3)rosparam set"></a>(3)<code>rosparam set</code></h3><p>修改某个参数的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	<span class="built_in">set</span>		参数名		参数值</span><br><span class="line">rosparam 	<span class="built_in">set</span> 	/turtlesim/background_b		255</span><br></pre></td></tr></table></figure>
<h3 id="4-rosparam-dump"><a href="#4-rosparam-dump" class="headerlink" title="(4)rosparam dump"></a>(4)<code>rosparam dump</code></h3><p>把现在系统中的全局参数保存到一个文件，文件的类型为.yaml，文件存储到终端的当前路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	dump 	文件名.yaml</span><br></pre></td></tr></table></figure>
<h3 id="5-rosparam-load"><a href="#5-rosparam-load" class="headerlink" title="(5)rosparam load"></a>(5)<code>rosparam load</code></h3><p>从文件中加载参数，我们可以在文件中修改参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	load 	文件名.yaml</span><br></pre></td></tr></table></figure>
<h3 id="6-rosparam-delete"><a href="#6-rosparam-delete" class="headerlink" title="(6)rosparam delete"></a>(6)<code>rosparam delete</code></h3><p>删除某个参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	delete 	参数名</span><br></pre></td></tr></table></figure>
<h1 id="四、创建工作空间与功能包"><a href="#四、创建工作空间与功能包" class="headerlink" title="四、创建工作空间与功能包"></a>四、创建工作空间与功能包</h1><p>工作空间是用来存储ROS工程开发相关文件的文件夹。就像我们在使用IDE写代码的时候，首先要建立一个工程文件。</p>
<p>工作空间主要有四个文件夹：</p>
<ul>
<li>src：代码空间，用来放置功能包，所有功能包的代码，配置文件，launch文件存储在该处。</li>
<li>build：编译空间，放置编译过程中产生的中间文件。（一般不用管）</li>
<li>devel：开发空间，放置一些生成的可执行文件，库或脚本。</li>
<li>install：安装空间，安装位置。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055437.png" alt="image-20211005030701463"></p>
<h2 id="1-创建工作空间"><a href="#1-创建工作空间" class="headerlink" title="1.创建工作空间"></a>1.创建工作空间</h2><p>(1)建立工作空间的文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir	-p	~/catkin_Name/src</span><br><span class="line"><span class="built_in">cd</span>		~/catkin_Name/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<p>(2)编译工作空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>(3)设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>		devel/setup.bash		</span><br></pre></td></tr></table></figure>
<p>(4)检查环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 	<span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>
<h2 id="2-创建功能包"><a href="#2-创建功能包" class="headerlink" title="2.创建功能包"></a>2.创建功能包</h2><p>如果要写代码，必须要创建功能包，因为功能包是ROS里放置源码的最小单元。</p>
<p>创建功能包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name/src</span><br><span class="line">catkin_create_pkg	功能包名	依赖1		依赖2		……</span><br></pre></td></tr></table></figure>
<p>编译功能包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span>		~/catkin_Name/devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>注意：同一个工作空间下，不允许存在同名的功能包。</p>
<h1 id="五、话题中各部分的编程实现"><a href="#五、话题中各部分的编程实现" class="headerlink" title="五、话题中各部分的编程实现"></a>五、话题中各部分的编程实现</h1><h2 id="1-发布者编程实现"><a href="#1-发布者编程实现" class="headerlink" title="1.发布者编程实现"></a>1.发布者编程实现</h2><p>之前我们控制的海龟是用键盘控制或者命令行控制，现在我们想通过编写一个程序来控制海龟的运动。这就需要写一个发布者的程序。</p>
<p>我们要清楚的是，发布者应该由节点充当。但是一个节点还可以对很多话题发布数据，所以我们在节点中，定义publisher来代表向一个话题的发布。它们之间的关系如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055505.png" alt="image-20211005164112040"></p>
<p>但容易混淆的是，发布消息的节点本身也可以叫做publisher。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055509.png" alt="image-20211005140716108"></p>
<h3 id="1-编写程序之前"><a href="#1-编写程序之前" class="headerlink" title="(1)编写程序之前"></a>(1)编写程序之前</h3><p>写具体的代码之前，我们要创建好工作空间，这里就不多说了。</p>
<p>然后要创建一个功能包。因为ROS的可执行文件都放在功能包中存储。如第四章第2节所述。功能包在工作空间的src文件夹下。</p>
<p>然后进入功能包，在功能包下的src文件夹中编写代码。</p>
<h3 id="2-代码实现过程"><a href="#2-代码实现过程" class="headerlink" title="(2)代码实现过程"></a>(2)代码实现过程</h3><ul>
<li>初始化ROS节点：在这一步要设置节点的名字。（在这里要注意节点名和可执行文件名的区别，节点可以理解为一个可执行文件，但这个可执行文件有一个名字，这个文件运行后会产生节点，节点也会有一个名字，这两个名字可能会有些不同。例如：在海龟仿真器中，功能包名字为turtlesim，生成节点的可执行文件名为turtlesim_node，运行后产生的节点名字为turtlesim）这里设置的就是运行后的节点名。</li>
<li>创建publisher，</li>
<li>向ROS Master注册节点信息，包括发布的话题名和话题中的消息类型。</li>
<li>创建消息数据。</li>
<li>按照一定频率循环发布的消息。</li>
</ul>
<p>如海龟速度发布程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ROS节点初始化</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建节点句柄，配置节点资源。</span></span><br><span class="line">	ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建一个Publisher，设置要往哪个话题发布什么样的消息内容。</span></span><br><span class="line"><span class="comment">	一个节点，可以发布不同的内容，用publisher来代表节点中不同的发布内容。</span></span><br><span class="line"><span class="comment"> 	在这里：发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，</span></span><br><span class="line"><span class="comment"> 	队列长度10，不能及时发布的数据就被存在队列中。*/</span></span><br><span class="line">	ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置循环的频率</span></span><br><span class="line">	<span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">// 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">		geometry_msgs::Twist vel_msg;<span class="comment">//数据类型是一个类，创建一个对象</span></span><br><span class="line">		vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">		vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 发布消息</span></span><br><span class="line">		turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">		<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, </span><br><span class="line">				vel_msg.linear.x, vel_msg.angular.z);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 按照循环频率延时</span></span><br><span class="line">	    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-编译代码"><a href="#3-编译代码" class="headerlink" title="(3)编译代码"></a>(3)编译代码</h3><p>编译代码，需要修改该程序包中的CMakeLists文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行文件名 	src/源码名)<span class="comment">#注意这里的可执行文件名就是一会要rosrun 功能包  可执行文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件名	<span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#这里直接用变量代替依赖的库路径，因为前面会自己找到依赖库的路径。</span></span><br></pre></td></tr></table></figure>
<p>然后回到工作空间根目录，用<code>catkin_make</code> 命令完成编译。</p>
<p>生成的可执行文件会在工作空间根目录下的devel/lib中找到。</p>
<h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="(4)配置环境变量"></a>(4)配置环境变量</h3><p>一定要设置环境变量，要不然系统是找不到这个可执行文件的。设置环境变量的文件是工作空间根目录下的devel中的setup.bash文件。</p>
<p>用下面的命令完成设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> 		devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>如果想避免重复的设置环境变量，也可以在终端的隐藏文件中设置。</p>
<p>首先打开主文件夹，然后按Ctrl+H快捷键显示隐藏文件，然后打开.bashrc，在最后面写上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> 		/home/pigpighero/工作空间/devel/setup.bash</span><br></pre></td></tr></table></figure>
<h3 id="5-运行"><a href="#5-运行" class="headerlink" title="(5)运行"></a>(5)运行</h3><p>接下来就可以在终端中运行这个发布者节点了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun  	功能包		可执行文件名</span><br></pre></td></tr></table></figure>
<h2 id="2-订阅者编程实现"><a href="#2-订阅者编程实现" class="headerlink" title="2.订阅者编程实现"></a>2.订阅者编程实现</h2><p>现在编程实现一个订阅者节点，和发布者是一样的，我们同样在功能包的src文件中编写代码。</p>
<p>代码的实现过程：</p>
<ul>
<li>初始化ROS节点</li>
<li>订阅需要的话题</li>
<li>循环等待话题消息，接收到消息后进入回调函数</li>
<li>在回调函数中完成消息处理</li>
</ul>
<p>在这里要注意一下回调函数，这和单片机开发中的中断函数类似，在收到消息后，可以立即跳入到回调函数中，完成消息的处理。</p>
<p>以订阅海龟的位置消息为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::Pose::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span></span><br><span class="line">    ros::Subscriber pose_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/turtle1/pose&quot;</span>, <span class="number">10</span>, poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后同样要注意编写CMakeLists文件和设置环境变量，这里都和前面一样。</p>
<h2 id="3-自定义话题消息结构"><a href="#3-自定义话题消息结构" class="headerlink" title="3.自定义话题消息结构"></a>3.自定义话题消息结构</h2><p>我们之前发布和订阅的话题的消息结构都是定义好的，我们现在自己来完成消息结构的定义。</p>
<p>下面我们用一个实际的例子，按照以下步骤来完成自定义的消息结构：</p>
<h3 id="1-定义msg文件"><a href="#1-定义msg文件" class="headerlink" title="(1)定义msg文件"></a>(1)定义msg文件</h3><p>消息的结构载体为.msg文件，这就是简单的纯文本文件，每一行由字段类型和字段名称组成。</p>
<p>我们首先在功能包中创建一个新的msg文件夹，用来存储所有的消息结构。</p>
<p>我们定义一个人的消息结构在Person.msg文件中：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">string 	name</span><br><span class="line">uint8 	sex</span><br><span class="line">uint8 	age</span><br></pre></td></tr></table></figure>
<h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="(2)编辑配置文件"></a>(2)编辑配置文件</h3><p><strong>首先要在package.xml中添加功能包依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055909.png" alt="image-20211005185240266"></p>
<p><strong>然后在CMakeLists添加相关配置</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation <span class="comment">#这个是后加的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055903.png" alt="image-20211005185707368"></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_message_files(FILES 	Person.msg)<span class="comment">#配置msg源文件</span></span><br><span class="line">generate_messages(DEPENDENCIES		std_msgs)<span class="comment">#生成消息时依赖于std_msgs</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行时依赖</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES learning_topic</span></span><br><span class="line">  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="(3)使用"></a>(3)使用</h3><p>最后就是编译了，在工作空间目录下使用<code>catkin_make</code> 命令完成。生成的文件在devel/include中。</p>
<p>在ROS中，消息的结构需要在发布和订阅消息的时候使用，我们先用一个.msg纯文本文件把消息结构写好，然后通过编译，生成头文件结构，这里面是包含该消息结构的类，我们在编写程序的时候可以直接引用头文件并使用。</p>
<p><strong>person_publisher.cpp:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_topic/Person.h&quot;</span><span class="comment">//这里引用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span></span><br><span class="line">    ros::Publisher person_info_pub = n.advertise&lt;learning_topic::Person&gt;(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置循环的频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化learning_topic::Person类型的消息</span></span><br><span class="line">    	learning_topic::Person person_msg;</span><br><span class="line">		person_msg.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">		person_msg.age  = <span class="number">18</span>;</span><br><span class="line">		person_msg.sex  = learning_topic::Person::male;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">		person_info_pub.<span class="built_in">publish</span>(person_msg);</span><br><span class="line"></span><br><span class="line">       	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">				  person_msg.name.<span class="built_in">c_str</span>(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照循环频率延时</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>person_subscriber.cpp:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">personInfoCallback</span><span class="params">(<span class="keyword">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">			 msg-&gt;name.<span class="built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span></span><br><span class="line">    ros::Subscriber person_info_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，在CMakeLists中加入：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(person_publisher src/person_publisher.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_publisher <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(person_subscriber src/person_subscriber.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_subscriber <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055601.png" alt="image-20211005193520292"></p>
<p>注意：在话题通信中，话题的建立是通过建立发布者或订阅者的。比如说上面的Person_publisher.cpp程序中，在建立publisher时，要注明发送的话题，此时便建立了话题。</p>
<h1 id="六、服务中各部分的编程实现"><a href="#六、服务中各部分的编程实现" class="headerlink" title="六、服务中各部分的编程实现"></a>六、服务中各部分的编程实现</h1><h2 id="1-客户端编程实现"><a href="#1-客户端编程实现" class="headerlink" title="1.客户端编程实现"></a>1.客户端编程实现</h2><p>前面我们使用命令行对海龟仿真节点发送了一个请求，又生成了一只海龟，现在我们通过程序来发送请求。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055606.png" alt="image-20211005230349178"></p>
<p>和编写发布者的过程类似，先创建一个新的功能包。在代码实现过程，也是在创建节点的基础上编写请求数据。具体的程序内容主要包括以下部分：</p>
<ul>
<li>初始化ROS节点。</li>
<li>创建一个Client实例。</li>
<li>发布服务请求数据。</li>
<li>等待Server处理之后的应答结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);<span class="comment">//查询当前系统中是否有spanw服务，如果没有一直等待</span></span><br><span class="line">	ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">	turtlesim::Spawn srv;</span><br><span class="line">	srv.request.x = <span class="number">2.0</span>;</span><br><span class="line">	srv.request.y = <span class="number">2.0</span>;</span><br><span class="line">	srv.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, </span><br><span class="line">			 srv.request.x, srv.request.y, srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示服务调用结果</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spwan turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-服务端编程实现"><a href="#2-服务端编程实现" class="headerlink" title="2.服务端编程实现"></a>2.服务端编程实现</h2><p>在这一节，我们实现这样一个功能，就是客户端向服务端发送一个请求，让服务端来控制海龟。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055617.png" alt="image-20211005235128008"></p>
<p>这里面，这个服务叫做/turtle_command，发送的request数据类型为std_srvs::Trigger。</p>
<p>服务端的程序主要有以下几部分组成：</p>
<ul>
<li>初始化ROS节点</li>
<li>创建Server实例</li>
<li>循环等待服务请求，进入回调函数</li>
<li>在回调函数中完成服务功能的处理，并反馈应答数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_srvs/Trigger.h&gt;</span><span class="comment">//服务数据类型的头文件</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher turtle_vel_pub;</span><br><span class="line"><span class="keyword">bool</span> pubCommand = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">commandCallback</span><span class="params">(std_srvs::Trigger::Request  &amp;req,<span class="comment">//客户端发送的请求</span></span></span></span><br><span class="line"><span class="params"><span class="function">         			std_srvs::Trigger::Response &amp;res)</span><span class="comment">//服务端的回应</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pubCommand = !pubCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="literal">true</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置反馈数据</span></span><br><span class="line">	res.success = <span class="literal">true</span>;</span><br><span class="line">	res.message = <span class="string">&quot;Change turtle command state!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_command_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span></span><br><span class="line">    ros::ServiceServer command_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/turtle_command&quot;</span>, commandCallback);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">	turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to receive turtle command.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置循环的频率</span></span><br><span class="line">	<span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 查看一次回调函数队列</span></span><br><span class="line">    	ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果标志为true，则发布速度指令</span></span><br><span class="line">		<span class="keyword">if</span>(pubCommand)</span><br><span class="line">		&#123;</span><br><span class="line">			geometry_msgs::Twist vel_msg;</span><br><span class="line">			vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">			vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line">			turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//按照循环频率延时</span></span><br><span class="line">	    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序运行的过程是这样的，先是创建好Server和Publisher，然后等待请求，当有请求指令时，立即跳入到回调函数。回调函数中设置了输入数据的类型为std_srvs::Trigger::Request，当有这种类型的数据输入时，才跳入回调函数（在本例中，Request是空的，所以可以不用输入内容）。进入到回调函数后，pubCommand变为真，这在主函数的循环中，if语句开始执行，将发送话题数据twist，控制海龟移动。</p>
<p>呼叫服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice 		call 		/turtle_command </span><br></pre></td></tr></table></figure>
<h2 id="3-服务数据的定义与使用"><a href="#3-服务数据的定义与使用" class="headerlink" title="3.服务数据的定义与使用"></a>3.服务数据的定义与使用</h2><p>上一节我们用的服务数据为Trigger，这是ROS定义好的，我们现在来自己定义一个服务的数据。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055634.png" alt="image-20211006003654128"></p>
<p>我们要实现的功能如上所示，我们自己定义一个服务消息数据为Person，客户端可以发送请求，获得show_person服务，服务端发出一个回应。</p>
<h3 id="1-定义数据"><a href="#1-定义数据" class="headerlink" title="(1)定义数据"></a>(1)定义数据</h3><p>请求数据和回应数据中间用<code>---</code>来隔开，和话题消息数据定义一样，我们用写在一个纯文本文件中，文件格式为.srv。</p>
<p>先在功能包目录下建立一个文件夹srv。然后创建.srv文件。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055638.png" alt="image-20211006004641504"></p>
<h3 id="2-编辑配置文件-1"><a href="#2-编辑配置文件-1" class="headerlink" title="(2)编辑配置文件"></a>(2)编辑配置文件</h3><p>与话题消息几乎一样，只不过在CMakeLists中，话题消息的配置使用的是add_message_files(FILES Person.msg)，而在服务数据的配置使用的是add_service_files(FILES Person.srv)。</p>
<p><strong>首先要在package.xml中添加功能包依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055644.png" alt="image-20211005185240266"></p>
<p><strong>然后在CMakeLists添加相关配置</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation <span class="comment">#这个是后加的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055649.png" alt="image-20211005185707368"></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_service_files(FILES 	Person.srv)<span class="comment">#配置msg源文件</span></span><br><span class="line">generate_messages(DEPENDENCIES		std_msgs)<span class="comment">#生成消息时依赖于std_msgs</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行时依赖</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES learning_topic</span></span><br><span class="line">  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-1"><a href="#3-使用-1" class="headerlink" title="(3)使用"></a>(3)使用</h3><p>最后就是编译了，在工作空间目录下使用<code>catkin_make</code> 命令完成。生成的文件在devel/include中。</p>
<p><strong>客户端：person_client.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line">	ros::ServiceClient person_client = node.serviceClient&lt;learning_service::Person&gt;(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化learning_service::Person的请求数据</span></span><br><span class="line">	learning_service::Person srv;</span><br><span class="line">	srv.request.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">	srv.request.age  = <span class="number">20</span>;</span><br><span class="line">	srv.request.sex  = learning_service::Person::Request::male;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, </span><br><span class="line">			 srv.request.name.<span class="built_in">c_str</span>(), srv.request.age, srv.request.sex);</span><br><span class="line"></span><br><span class="line">	person_client.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示服务调用结果</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>服务端：person_server.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">personCallback</span><span class="params">(learning_service::Person::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         			learning_service::Person::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="built_in">c_str</span>(), req.age, req.sex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置反馈数据</span></span><br><span class="line">	res.result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span></span><br><span class="line">    ros::ServiceServer person_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/show_person&quot;</span>, personCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to show person informtion.&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，在CMakeLists中加入：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(person_client src/person_client.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_client <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_client <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(person_server src/person_server.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_server <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_server <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="七、参数的使用与编程方法"><a href="#七、参数的使用与编程方法" class="headerlink" title="七、参数的使用与编程方法"></a>七、参数的使用与编程方法</h1><p>ROS Master中有一个参数服务器，它可以存储全局参数，各个节点都可以访问（不同的主机也可访问）。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055707.png" alt="image-20211006011750764"></p>
<p>还是创建一个节点来实现用程序使用全局参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程设置/读取海龟例程中的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_srvs/Empty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;parameter_config&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用服务，刷新背景颜色</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">	ros::ServiceClient clear_background = node.serviceClient&lt;std_srvs::Empty&gt;(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">	std_srvs::Empty srv;</span><br><span class="line">	clear_background.<span class="built_in">call</span>(srv);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、ROS中的常用组件"><a href="#八、ROS中的常用组件" class="headerlink" title="八、ROS中的常用组件"></a>八、ROS中的常用组件</h1><h2 id="1-坐标变换管理系统-TF功能包"><a href="#1-坐标变换管理系统-TF功能包" class="headerlink" title="1.坐标变换管理系统-TF功能包"></a>1.坐标变换管理系统-TF功能包</h2><p>TF功能包能管理机器人中的各个坐标系之间的变换关系。</p>
<p>TF可以在分布式系统中进行操作，也就是说，一个机器人系统中所有的坐标变换关系，对于所有的节点组件都是可用的，所有订阅TF消息的节点都会缓冲一份所有坐标系的变换关系数据，所以这种结构不需要中心服务器来存储任何数据。</p>
<p>想要使用TF功能包，需要一下两个步骤：</p>
<ul>
<li>广播TF变换：向系统中广播坐标系之间的变换关系。就是通过节点，根据自身的位置和对方的位置，计算出变换关系。</li>
<li>监听TF变换：接收并缓存系统中发布的所有坐标变换数据，并从中查询所需要的坐标变换关系。</li>
</ul>
<p>在ROS中，使用树结构来进行管理。</p>
<p>例如一个小车，小车的中心点为base_link坐标系原点，上面有一个激光雷达，激光雷达中心为base_laser坐标系原点。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055714.png" alt="image-20211006021136321"></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055717.png" alt="image-20211006021150776"></p>
<h3 id="1-一个例程"><a href="#1-一个例程" class="headerlink" title="(1)一个例程"></a>(1)一个例程</h3><p>在ROS中有一个例程，海龟跟踪，这个就是通过TF坐标来实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo 	apt-get		install		ros-melodic-turtle-tf  //下载例程文件</span><br><span class="line">roslaunch  	turtle_tf	turtle_tf_demo.launch //roslaunch命令是启动.launch文件，这个文件中包括了很多个节点</span><br><span class="line">rosrun 		turtlesim		turtle_teleop_key //启动键盘控制</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun 		tf		view_frames  //运行tf的一个可视化工具，会在当前路径下生成pdf文件，来表示当前坐标系关系</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055724.png" alt="image-20211006023541876"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tf		tf_echo		turtle1		turtle2  //显示两个坐标系间的关系</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055729.png" alt="image-20211006023636826"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun 	rviz	 rviz 	-d 		&#x27;rospack find turtle_tf&#x27;/rviz/turtle_rviz.rviz		//运行rviz可视化工具，可以查看坐标关系</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055732.png" alt="image-20211006023829401" style="zoom:50%;" /></p>
<h3 id="2-创建TF广播器"><a href="#2-创建TF广播器" class="headerlink" title="(2)创建TF广播器"></a>(2)创建TF广播器</h3><p>首先，我们需要创建一个发布乌龟坐标系和世界坐标系之间TF变换的节点。然后这个节点可以把坐标变换关系发送到TF树中。</p>
<ul>
<li>定义TF广播器</li>
<li>创建坐标变换值</li>
<li>发布坐标变换</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程产生tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建tf的广播器</span></span><br><span class="line">	<span class="keyword">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化tf数据</span></span><br><span class="line">	tf::Transform transform;<span class="comment">//坐标变换矩阵4*4</span></span><br><span class="line">	transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );<span class="comment">//设置平移</span></span><br><span class="line">	tf::Quaternion q;</span><br><span class="line">	q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);<span class="comment">//设置四元数</span></span><br><span class="line">	transform.<span class="built_in">setRotation</span>(q);<span class="comment">//设置旋转</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 广播world与海龟坐标系之间的tf数据</span></span><br><span class="line">	br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));<span class="comment">//将坐标变换关系发送到坐标树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输入参数作为海龟的名字</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 订阅海龟的位姿话题</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line">	ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">	ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-创建TF监听器"><a href="#3-创建TF监听器" class="headerlink" title="(3)创建TF监听器"></a>(3)创建TF监听器</h3><p>监听器的作用就是从TF树中获取坐标变换关系。</p>
<ul>
<li>定义TF监听器</li>
<li>查找坐标变换</li>
</ul>
<p>现在我们从TF树中获取turtle2相对于turtle1的坐标变换，从而控制turtle2的移动。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求产生turtle2</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	turtlesim::Spawn srv;</span><br><span class="line">	add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建发布turtle2速度控制指令的发布者</span></span><br><span class="line">	ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建tf的监听器</span></span><br><span class="line">	tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line">	<span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">		tf::StampedTransform transform;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));<span class="comment">//等待TF数据，看系统中是否有这个数据。</span></span><br><span class="line">			listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);<span class="comment">//查询数据，结果保存到transform里</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span> (tf::TransformException &amp;ex) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">			ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span></span><br><span class="line">		geometry_msgs::Twist vel_msg;</span><br><span class="line">		vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">				                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">		vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">				                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">		turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">		rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-Launch文件"><a href="#2-Launch文件" class="headerlink" title="2.Launch文件"></a>2.Launch文件</h2><p>前面我们每启动一个节点，都需要在终端中输入一个命令，这十分麻烦，我们可以用启动文件来进行运行，这样一次就可以启动多个节点，还可以自动启动ROS Master节点管理器，并实现每个节点的各种配置。</p>
<p>Launch文件是一个.XML文件。它可以自动启动ROS Master。</p>
<h3 id="1-根元素"><a href="#1-根元素" class="headerlink" title="(1)根元素"></a>(1)根元素</h3><p>XML文件中必须包含一个根元素，采用<code>&lt;launch&gt;</code>标签定义，文件中其他的内容都必须在这个标签内。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">其他内容</span><br><span class="line">&lt;\launch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-节点元素"><a href="#2-节点元素" class="headerlink" title="(2)节点元素"></a>(2)节点元素</h3><p>采用节点标签定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span>	<span class="attr">pkg</span>=<span class="string">&quot;功能包名字&quot;</span>   <span class="attr">type</span>=<span class="string">&quot;可执行文件名字&quot;</span>	<span class="attr">name</span>=<span class="string">&quot;节点名字&quot;</span>		/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这三个属性是最基本的属性，后面节点的名字是定义运行该可执行文件产生的节点名字，会覆盖节点中init()赋予的节点名字。</p>
<p>在节点元素中，我们还可以增加其他属性。</p>
<p><code>output=&quot;screen&quot;</code> ：讲节点的标准输出打印到终端屏幕，默认输出为日志文档。</p>
<p><code>respawn=&quot;true&quot;</code>：复位属性，该节点停止时，会自动重启，默认为false。</p>
<p><code>required=&quot;true&quot;</code> ：必要节点，该节点终止时，launch文件中的其他节点也被终止。</p>
<p><code>ns=&quot;namespace&quot;</code> ：命名空间，为节点内的相对名称添加命名空间前缀。</p>
<p><code>args=&quot;arguments&quot;</code> ：节点需要的输入参数。</p>
<h3 id="3-参数元素"><a href="#3-参数元素" class="headerlink" title="(3)参数元素"></a>(3)参数元素</h3><p>为了方便全局参数的修改和设置，我们使用参数设置标签<code>&lt;param&gt;</code> 或 <code>&lt;rosparam&gt;</code> 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> 		<span class="attr">name</span>=<span class="string">&quot;参数名字&quot;</span>		<span class="attr">value</span>=<span class="string">&quot;设置参数值&quot;</span>   /&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是还是觉得一条一条的打很麻烦，我们还可以用加载参数文件的方式。</p>
<p><code>&lt;rosparam&gt;</code> 可以帮助我们将一个YAML格式文件中的参数全部加载到ROS参数服务器中，需要设置command属性为”load”，还可以设置命名空间”ns”。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span>  	<span class="attr">file</span>=<span class="string">&quot;文件名.YAML&quot;</span>		<span class="attr">command</span>=<span class="string">&quot;load&quot;</span>		<span class="attr">ns</span>=<span class="string">&quot;命名空间&quot;</span>		/&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有一个参数，就是launch文件中的参数，类似于文件内部的局部变量，仅限于在launch文件中使用，与ROS的参数无关。我们可以用<code>&lt;arg&gt;</code> 来设置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> 	<span class="attr">name</span>=<span class="string">&quot;参数名&quot;</span>		<span class="attr">default</span>=<span class="string">&quot;参数值&quot;</span>	/&gt;</span>   //设置参数</span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> 		<span class="attr">name</span>=<span class="string">&quot;foo&quot;</span>		<span class="attr">value</span>=<span class="string">&quot;$&#123;arg		设置的参数名&#125;&quot;</span>	/&gt;</span>		//使用这个参数</span><br></pre></td></tr></table></figure>
<h3 id="4-重映射机制"><a href="#4-重映射机制" class="headerlink" title="(4)重映射机制"></a>(4)重映射机制</h3><p>在别人的功能包的接口和自己要用的不一样的时候，我们可以将这个功能包改一个名字。例如，turtlebot的键盘控制节点发布的速度指令话题为/turtlebot/cmd_vel，但是我们的机器人订阅的速度控制话题是/cmd_vel，这是使用<code>&lt;remap&gt;</code> 就可以进行重映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span>	<span class="attr">from</span>=<span class="string">&quot;/turtlebot/cmd_vel&quot;</span>	<span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span>	/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-嵌套复用"><a href="#5-嵌套复用" class="headerlink" title="(5)嵌套复用"></a>(5)嵌套复用</h3><p>在复杂系统中，launch文件往往有很多，这些launch文件之间也可能会存在依赖关系，如果要直接服用一个已有launch文件中的内容，可以使用<code>&lt;include&gt;</code> 标签包含其他launch文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>	<span class="attr">file</span>=<span class="string">&quot;$&#123;dirname&#125;/other.launch&quot;</span>	/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-使用"><a href="#6-使用" class="headerlink" title="(6)使用"></a>(6)使用</h3><p>写好launch文件后，将其放在名为launch的文件夹中，然后在工作空间目录打开终端，使用<code>catkin_make</code> 进行编译，然后使用<code>roslaunch</code>直接运行launch文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch	功能包		launch文件</span><br></pre></td></tr></table></figure>
<h2 id="3-QT工具箱"><a href="#3-QT工具箱" class="headerlink" title="3.QT工具箱"></a>3.QT工具箱</h2><p>为了方便可视化调试和显示，ROS提供了QT工具箱。</p>
<p>以<code>rqt</code> 开头的命令即为QT工具的命令。</p>
<p><code>rqt_graph</code>     显示系统的计算图，通过这张图可以了解整个系统的全貌。</p>
<p><code>rqt_console</code>     显示工作日志信息。</p>
<p><code>rqt_plot</code>     数据绘图工具。</p>
<p><code>rosrun     rqt_reconfigure    rqt_reconfigure</code>    参数动态配置，可以在不重启系统时，动态配置ROS系统中的参数。</p>
<p><code>rqt_imag</code>     有摄像头时，显示图像。</p>
<p><code>rqt</code>    所有工具的集合窗口，在界面中选择工具。</p>
<h2 id="4-rviz三维可视化平台"><a href="#4-rviz三维可视化平台" class="headerlink" title="4.rviz三维可视化平台"></a>4.rviz三维可视化平台</h2><p>启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun	rviz	rviz</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055751.png" alt="image-20211007011943519"></p>
<h2 id="5-Gazebo"><a href="#5-Gazebo" class="headerlink" title="5.Gazebo"></a>5.Gazebo</h2><p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055810.png" alt="image-20211007012012849"></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018055801.png" alt="image-20211007012025774"></p>
]]></content>
      <categories>
        <category>软件实践</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown常用语法</title>
    <url>/2021/10/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown常用语法，方便使用时查阅。<br><span id="more"></span><br>[toc]</p>
<h2 id="锚点和目录"><a href="#锚点和目录" class="headerlink" title="锚点和目录"></a>锚点和目录</h2><p>目录在前面用 <code>[toc]</code> 即可。</p>
<p>锚点: <code>[说明文字](#jump)</code>，然后在要跳跃的位置处写 <code>&lt;span id=&quot;jump&quot;&gt;跳转位置的名字&lt;/span&gt;</code></p>
<p>例如：<a href="#希腊字母">希腊字母</a> </p>
<p>超链接：<code>[网页名字](地址)</code>，如<a href="https://github.com/">github</a></p>
<h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol>
<li>行内公式：将公式插入到本行内，符号：<script type="math/tex">公式内容</script>，如：$xyz$</li>
<li>独行公式：将公式插入到新的一行内，并且居中，符号：<script type="math/tex">$公式内容$$$，如：</script>xyz$$</li>
</ol>
<h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol>
<li>上标符号，符号：<code>^</code>，如：$x^4$</li>
<li>下标符号，符号：<code>_</code>，如：$x_1$</li>
<li>组合符号，符号：<code>&#123;&#125;</code>，如：${16}_{8}O{2+}_{2}$</li>
</ol>
<h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol>
<li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：$V_{\mbox{初始}}$</li>
<li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li>
<li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li>
<li>标签，符号<code>\tag&#123;数字&#125;</code>，如：$\tag{11}$</li>
<li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li>
<li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li>
<li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li>
</ol>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol>
<li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li>
<li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li>
<li>大空格，符号<code>\</code>，如：$x \  y$ </li>
<li>中空格，符号<code>\:</code>，如：$x \: y$</li>
<li>小空格，符号<code>\,</code>，如：$x \, y$</li>
<li>没有空格，符号``，如：$xy$</li>
<li>紧贴，符号<code>\!</code>，如：$x ! y$</li>
</ol>
<h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol>
<li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li>
<li>中括号，符号：<code>[]</code>，如：$[x+y]$</li>
<li>大括号，符号：<code>\&#123; \&#125;</code>，如: $\{\}$</li>
<li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li>
<li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li>
<li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</li>
</ol>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol>
<li>加法运算，符号：<code>+</code>，如：$x+y=z$</li>
<li>减法运算，符号：<code>-</code>，如：$x-y=z$</li>
<li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li>
<li>减加运算，符号：<code>\mp</code>，如：$x \mp y=z$</li>
<li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li>
<li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li>
<li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li>
<li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li>
<li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li>
<li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：$\frac{x+y}{y+z}$</li>
<li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：${x+y} \over {y+z}$</li>
<li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li>
</ol>
<h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol>
<li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：$\overline{xyz}$</li>
<li>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li>
<li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：$\sqrt[3]{x+y}$</li>
<li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li>
<li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li>
<li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li>
<li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li>
<li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;5 &amp;6 &amp;\cdots &amp;8\\\vdots &amp;\vdots &amp;\ddots &amp;\vdots&amp; \vdots&amp;\cdots &amp;16\end{matrix} \right]$</li>
</ol>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol>
<li>等于运算，符号：<code>=</code>，如：$x+y=z$</li>
<li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li>
<li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li>
<li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li>
<li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li>
<li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li>
<li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li>
<li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li>
<li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li>
<li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li>
<li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li>
<li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li>
</ol>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol>
<li>属于运算，符号：<code>\in</code>，如：$x \in y$</li>
<li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li>
<li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li>
<li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li>
<li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li>
<li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li>
<li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li>
<li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li>
<li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li>
<li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li>
<li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li>
<li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li>
<li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li>
<li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li>
<li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li>
<li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li>
<li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li>
<li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li>
<li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li>
</ol>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol>
<li>无穷，符号：<code>\infty</code>，如：$\infty$</li>
<li>虚数，符号：<code>\imath</code>，如：$\imath$</li>
<li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li>
<li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</li>
<li>数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</li>
<li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</li>
<li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</li>
<li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</li>
<li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</li>
<li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</li>
<li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</li>
<li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</li>
<li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</li>
<li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</li>
<li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li>
<li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li>
<li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li>
<li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li>
<li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li>
<li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li>
<li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li>
<li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li>
<li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li>
<li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li>
<li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li>
<li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li>
</ol>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a><span id="希腊字母">希腊字母</span></h2><p>|      |<br>| —— |</p>
]]></content>
      <categories>
        <category>软件实践</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数可视化学习笔记</title>
    <url>/2021/10/18/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>3Blue1Brown 线代课程学习笔记，受益匪浅。<br><span id="more"></span></p>
<h1 id="线性代数可视化"><a href="#线性代数可视化" class="headerlink" title="线性代数可视化"></a>线性代数可视化</h1><p><a href="https://www.bilibili.com/video/BV1ib411t7YR?p=1">参考</a></p>
<h2 id="1-向量是什么"><a href="#1-向量是什么" class="headerlink" title="1.向量是什么"></a>1.向量是什么</h2><p>对于向量的理解，可以分为三个层面：</p>
<ul>
<li><p><strong>物理学家眼中</strong>：向量是一个空间中箭头，它只包括长度和方向两个信息，而与其所在的空间位置无关</p>
</li>
<li><p><strong>计算机专业眼中</strong>：向量是一个有序数组，这个有序数组可以表示物理学家眼中的向量在空间中的坐标，而且这个向量通常是以坐标系原点为起点的。为了区分于点的坐标，向量通常竖着写</p>
</li>
<li><p><strong>数学家眼中</strong>：向量可以是任何东西，只要能保证两个向量相加和数与向量相乘满足一定的条件即可</p>
</li>
</ul>
<p>通过建立坐标系，可以使一个向量与有序的数组相联系，每一个数组对应一个向量，每一个向量也可以用数组来表示，这就为物理学家在描述向量时提供了一种数学语言</p>
<p><strong>向量两个最基本的运算：</strong></p>
<ul>
<li><p>向量加法：遵循三角形法则 $\longrightarrow$ 用数组描述的向量通过对应元素相加可以很好的描述该法则</p>
</li>
<li><p>向量的数乘：表示对向量的伸长与缩短 </p>
</li>
</ul>
<h2 id="2-线性组合、基与张成空间"><a href="#2-线性组合、基与张成空间" class="headerlink" title="2.线性组合、基与张成空间"></a>2.线性组合、基与张成空间</h2><p>在标准的坐标系中，有两个特殊的向量，单位向量 $\hat i$ 和 $\hat j$ ，对于多维空间也同样。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060806.png" alt="image-20210715005154764" style="zoom:67%;" /></p>
<p>它们合起来称作坐标系的基，当把坐标中的每一个元素看作是标量时，每一个基向量就是这些标量所缩放的向量</p>
<h3 id="·-什么是线性组合"><a href="#·-什么是线性组合" class="headerlink" title="· 什么是线性组合"></a>· 什么是线性组合</h3><p>多个向量的数乘之和称为这些向量的线性组合</p>
<h3 id="·-向量张成的空间"><a href="#·-向量张成的空间" class="headerlink" title="· 向量张成的空间"></a>· 向量张成的空间</h3><p>给定一组向量，通过该组向量的线性组合生成的<strong>向量的集合</strong>，称为该组向量==张成的空间==</p>
<p>以二维空间为例，给定向量 $\vec w$ 和 $\vec v$ ，有以下三种情况：</p>
<ol>
<li><p>当$\vec w$ 和 $\vec v$ 不共线时，所张成的空间为二维平面，也就是二维空间中的任意向量都可以由这两个向量的线性组合得到</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060809.png" alt="image-20210715035555651" style="zoom: 33%;" /></p>
</li>
<li><p>当$\vec w$ 和 $\vec v$ 共线时，所张成的空间为一条直线，仅能表示终点在该直线上的向量</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060812.png" alt="image-20210715040223112" style="zoom:50%;" /></p>
</li>
<li><p>当$\vec w$ 和 $\vec v$ 都为0向量时，所张成的空间为一点，仅能表示0向量</p>
</li>
</ol>
<p><strong>同样对于我们常用的三维空间，当仅有两个不共面的向量时，这两个向量所张成的空间为一个平面</strong></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060822.png" alt="image-20210715040537951" style="zoom: 20%;" /></p>
<h3 id="·-线性相关与线性无关"><a href="#·-线性相关与线性无关" class="headerlink" title="· 线性相关与线性无关"></a>· 线性相关与线性无关</h3><p>从上面的表述中，便可以得到<strong>线性相关</strong>的定义：当一组向量中，其中一个向量处在其他向量所张成的空间中（这个向量可以由其他的向量线性组合表示出来），那么这一组向量就是线性相关的</p>
<p>而<strong>线性无关</strong>的定义与它正好相反：一组向量中，任何一个向量都不处在其他向量所张成的空间中（任何一个向量不可以由其他向量线性组合表示出来）</p>
<h3 id="·-空间中的一组基"><a href="#·-空间中的一组基" class="headerlink" title="· 空间中的一组基"></a>· 空间中的一组基</h3><p>某向量空间的一组基是张成该空间的一个线性无关的向量集合</p>
<h2 id="3-矩阵与线性变换"><a href="#3-矩阵与线性变换" class="headerlink" title="3.矩阵与线性变换"></a>3.矩阵与线性变换</h2><h3 id="·-首先需要知道的"><a href="#·-首先需要知道的" class="headerlink" title="· 首先需要知道的"></a>· 首先需要知道的</h3><p>我们之前所说向量的时候，当有基向量存在时，可以用一个数组也就是坐标来表示一个向量，现在我们定义一个永远不变的坐标系和基向量，这个坐标系的x轴和y轴垂直，且基向量是与x轴和y轴正方向相同的单位向量，暂且我们就称坐标系和基向量为<strong>永不变坐标系和永不变基向量</strong>，之后的所有向量或坐标系的基的描述都是在这个永不变基的基础上进行的</p>
<h3 id="·-线性变换"><a href="#·-线性变换" class="headerlink" title="· 线性变换"></a>· 线性变换</h3><p>变换实际上是函数的另一种说法，函数的作用是输入一个数，输出一个数；在线性代数中，变换的输入是一个向量，输出也是一个向量</p>
<p><strong>线性变换</strong>是变换的一种特殊形式，它有两个特点：</p>
<ul>
<li><p>直线在线性变换后，仍是直线</p>
</li>
<li><p>原点必须保持不变</p>
</li>
</ul>
<p>那么如何用数学语言来描述线性变换呢？答案就是用矩阵来描述</p>
<h3 id="·-矩阵"><a href="#·-矩阵" class="headerlink" title="· 矩阵"></a>· 矩阵</h3><p>矩阵就是一种数学语言，来描述线性变换，矩阵的每一列记录基向量在线性变换后的坐标</p>
<p>以二维空间为例：</p>
<script type="math/tex; mode=display">
\vec v = -1\vec i + 2\vec j\\
Transformed \ \vec v=-1(Transformed \ \vec i)+2(Transformed\ \vec j)</script><p>当经过一次线性变换后，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060826.png" alt="image-20210715034732752" style="zoom:67%;" /></p>
<script type="math/tex; mode=display">
[Transformed\ \vec i ,Transformed\ \vec j]=\left[\begin{array}{ll}
3 & 1 \\
0 & 2
\end{array}\right]</script><script type="math/tex; mode=display">
Transformed\ \vec v=
-1\left[\begin{array}{l}
3 \\
0
\end{array}\right]+2\left[\begin{array}{l}
1 \\
2
\end{array}\right]=\left[\begin{array}{ll}
3&1\\
0&2
\end{array}\right]\left[\begin{array}{l}
\ -1\\
\  \ 2\end{array}\right]
=\left[\begin{array}{l}
-1  \\
\ \ 4 
\end{array}\right]</script><p><strong>这也就定义了矩阵和向量的乘法</strong>，矩阵乘以向量，就是对该向量的一个线性变换</p>
<p>当变换后的两个基向量线性相关时，由这两个向量所张成的空间就变成了一条线，而原来的向量就被变换到这个空间上，也就是变换后的向量的终点在一条直线上</p>
<blockquote>
<p>总之，线性变换就是对向量的变换，对向量的变换的方法是对描述该向量的基进行变换，因此线性变换也是操纵空间的一种手段</p>
</blockquote>
<p>那么当有许多个矩阵乘以一个向量的时候，它的几何意义又是什么呢？</p>
<h3 id="·-复合变换与矩阵乘法"><a href="#·-复合变换与矩阵乘法" class="headerlink" title="· 复合变换与矩阵乘法"></a>· 复合变换与矩阵乘法</h3><p>矩阵A、B分别代表着线性变换1和2，AB代表着先进行线性变换2，然后再进行线性变换1（注意这里是先2后1），令AB=C，那么C就代表着先进行2再进行1的一个复合变换，也可以把C当作是一次独立的变换，它的效果和先2再1的效果相同</p>
<p>另外，AB $\neq$ BA，也就是说先进行2再进行1和先进行1再进行2的效果是不同的</p>
<blockquote>
<p>前面所说的线性变换理解成是一个处理向量的函数，现在从另一个角度来总结一下，线性变换用矩阵来描述，而矩阵的列向量表示线性变换后基向量的坐标，对一个向量进行线性变换，就是先对基向量进行线性变换，然后用这个向量的坐标对变换后的基向量进行线性组合，最终得到变换后的向量。因为基向量可以描述一个空间，因此基向量变了，其所对应的空间也发生了变化</p>
</blockquote>
<h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4.行列式"></a>4.行列式</h2><p>上节说过，线性变换是操纵空间的一种手段，那么如何刻画空间变化了多少呢，这就需要请出行列式了，行列式就是用来描述空间变化的多少</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060835.png" alt="image-20210715053137633" style="zoom:53%;" /></p>
<p>下面以二维空间为例：</p>
<p>我们在坐标系中用网格线来描述这个空间的形态，在标准坐标系中，绿色箭头代表i向量，红色箭头代表j向量，此时向量i和j所围成的区域是一个正方形，其面积为1</p>
<p>当进行线性变换后，基向量的方向和长度都发生了变化，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060839.png" alt="image-20210715053620420" style="zoom:50%;" /></p>
<p>那么此时由基向量i和j所围成的区域也发生了变化，变成了一个平行四边形，而该区域的面积等于矩阵的行列式</p>
<blockquote>
<p>矩阵的行列式是描述其线性变换所对空间变化的量度</p>
</blockquote>
<p>当行列式为0时，表示这个平面被压缩成了一条线，<strong>而0矩阵表示把平面压缩成一个点</strong></p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060842.png" alt="image-20210715054036323" style="zoom:50%;" /></p>
<p>当行列式为负时，表示这个平面发生了反转</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060845.png" alt="image-20210715054301501" style="zoom:50%;" /></p>
<p>注意：原来绿色的基向量在红色基向量的右边，此时发生了平面翻转</p>
<p>三维空间中，矩阵的行列式表示变换后基向量所围成空间区域的体积，当行列式为0时，表示该变换将三维空间压缩成一个平面或一条直线又或是一个点（这在后面会引出秩的用法）。更多维空间的道理是一样的，这里就不过多赘述</p>
<h2 id="5-逆矩阵、列空间、秩和零空间"><a href="#5-逆矩阵、列空间、秩和零空间" class="headerlink" title="5.逆矩阵、列空间、秩和零空间"></a>5.逆矩阵、列空间、秩和零空间</h2><p>线性代数的用处很多，其中的一个用处是解线性方程组</p>
<p>方程组的求解和之前所讲的行列式和矩阵以及线性变换密切相关</p>
<p>例如我们现在有一个方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
1x+2y+3z=5\\
3x+8y+7z=6\\
0x+3y+6z=0
\end{cases}</script><p>这是一个三阶线性方程组，因为它与矩阵和向量的乘法很像，所以可以写成矩阵的形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
1&2&3\\
3&8&7\\
0&3&6
\end{array}\right]
\left[\begin{array}{l}
x\\
y\\
z
\end{array}\right]=\left[\begin{array}{l}
5\\
6\\
0
\end{array}\right]</script><p>即：</p>
<script type="math/tex; mode=display">
A\vec x=\vec v</script><p>上述式子已知 $\vec v$ ，A矩阵表示一个线性变换，如若求 $\vec x$ ,则只需将A矩阵所表示的线性变换的逆变换作用到 $\vec v$ 上，那么是不是什么时候都可以用这种方法呢？</p>
<h3 id="·矩阵的逆"><a href="#·矩阵的逆" class="headerlink" title="·矩阵的逆"></a>·矩阵的逆</h3><p>矩阵的逆表示矩阵线性变换所对应的逆变换，如果矩阵A的行列式不等于0，那么矩阵A是可逆的</p>
<p>之前的方程组的解为： $\vec x = A^{-1}\vec v$</p>
<p>上面说到矩阵的逆表示逆变换，所以当进行一次变换再进行一次逆变换等同于没有变化</p>
<script type="math/tex; mode=display">
A^{-1}A=AA^{-1}=I</script><p><strong>但是当矩阵的行列式为0时</strong>，矩阵的逆不存在。背后的几何意义是线性变换将多维空间变换为低维空间，如果想找到<strong>一个</strong>低维空间还原成高维空间的逆变换，是得不到一个确定的变换的，因为有一维或多维的缺失，所以这个变换可以有任意多种形式</p>
<p>再回到我们的方程组，当矩阵的行列式为0时，解是可能存在的，这分为两种情况：</p>
<ul>
<li>一种是当 $\vec v$ 向量在A所压缩的空间上时，解存在</li>
<li>另一种是 $\vec v$ 向量在A所压缩的空间外时，无解</li>
</ul>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060850.png" alt="image-20210715085801043" style="zoom: 33%;" /></p>
<h3 id="·矩阵的秩"><a href="#·矩阵的秩" class="headerlink" title="·矩阵的秩"></a>·矩阵的秩</h3><p>可以发现，虽然原空间通过变换后，变成一个低维的空间，此时都会有无解的情况发生，但无解情况的出现的难易程度是不一样的。例如当三维空间变换成二维空间时，是一个平面，只要 $\vec v$ 在这个平面上，解存在。但是当变换成一维空间也就是一条线时，只有 $\vec v$ 在这条线上时，解存在。虽然上面两种情况的A矩阵的行列式都为0，但是它们出现无解的情况是不同的，这时就要引出秩的概念</p>
<p><strong>秩</strong>表示变换后空间的维数，例如三维矩阵的秩最大为3，它表示基向量可以张成整个三维空间，但是当矩阵的秩为2时，空间被压缩了，此时表示基向量只能张成二维空间，但是它没有秩为1的压缩情况严重</p>
<h3 id="·列空间"><a href="#·列空间" class="headerlink" title="·列空间"></a>·列空间</h3><p>矩阵的列向量所张成的空间即为列空间，当 $ \vec x$ 表示任意的向量时，$A\vec x$ 就是矩阵A的列空间</p>
<p>关于秩更准确的定义：矩阵秩表示矩阵列空间的维数</p>
<p><strong>当秩等于矩阵的列时，意味着它达到了它所能达到的最大值，此时叫作满秩</strong></p>
<p>0向量一定包含在列空间中，因为线性变换不改变原点的位置，也就是 $A\vec0=\vec 0$ </p>
<p>对于一个满秩变换来说，唯一能在变换后落在原点的向量就是0向量本身。但是对于一个非满秩的矩阵，它将空间压缩到一个低维的空间，也就是说有一系列向量在变换后被压缩到原点。例如对于原二维的空间，当进行压缩到一维空间的变换时，会使原二维空间中某一方向直线上的所有的向量都压缩到原点。再如原三维空间，压缩到一个二维空间时，也会使原三维空间中某一方向直线上所有的向量压缩到原点，当压缩到一个一维空间时，会使原三维空间中过原点的某一平面上的所有向量压缩到原点。</p>
<h3 id="·零空间-核空间"><a href="#·零空间-核空间" class="headerlink" title="·零空间/核空间"></a>·零空间/核空间</h3><p>变换后被压缩到原点的向量的集合，叫作矩阵的零空间或者核空间</p>
<p>==被压缩空间的维数==就是零空间的维数。例如三维空间中的一个向量经过一个方阵的线性变换后，被限制在二维平面上，那么该方阵的零空间维数为1，如果是将该向量变换成一个点，那么该方阵的零空间维数为2。零空间的维数就是表示方阵可以将几维的空间压缩到原点。也可以看作是方程 $A\vec x =0$​​​的解的情况，首先A得为方阵，当A的零空间为0时，也就是A满秩，那么只有零向量是该方程的解。如果A的零空间为2时，那么解向量的维数为2。</p>
<h3 id="·非方阵"><a href="#·非方阵" class="headerlink" title="·非方阵"></a>·非方阵</h3><p>非方阵的几何意义和之前的方阵稍稍有些不同，先来说之前的方阵，方阵表示将一个向量进行变换，这些变换有旋转这个向量，拉伸压缩这个向量，无论怎么变换这个向量，这个向量都处于原空间中，即变换前是一个n维的向量，变换后还是n维的向量。举一个例子，对于三维空间中的一个向量，当矩阵A的秩为2时，表示将这个向量压缩到一个二维的平面中，尽管是压缩到二维平面中，只是把这个向量限制在二维平面上，但这个向量仍是三维空间中的向量。</p>
<p>而非方阵就得用另一种方式来描述，和之前所提及的函数一样，非方阵可以看作是一个映射，输入一个m维的向量，映射出一个n维的向量，这两个向量分别处于不同的空间中。</p>
<p>例如一个矩阵为 $m\times n$ 维，那么它表示将一个n维空间中的向量映射到m维空间中，矩阵的列向量同样是原空间中的基向量在新空间中的映射</p>
<blockquote>
<p>小结：方阵表示线性变换，指在原有空间中对向量进行变换；非方阵表示线性映射，把原空间中的向量映射到一个新的空间中</p>
</blockquote>
<h2 id="6-向量的点积"><a href="#6-向量的点积" class="headerlink" title="6.向量的点积"></a>6.向量的点积</h2><h3 id="·向量点积的几何意义"><a href="#·向量点积的几何意义" class="headerlink" title="·向量点积的几何意义"></a>·向量点积的几何意义</h3><p>有两个向量 $\vec v$ 和 $\vec w$ ，点积的几何意义表示 $\vec v$ 在 $\vec w$ 方向上的投影的长度和 $\vec w$长度的乘积</p>
<p>点积的结果和向量的顺序无关，即$\vec v ·\vec w=\vec w·\vec v$ </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060858.png" alt="image-20210716055411474" style="zoom:33%;" /></p>
<p>利用对称性，可以直观证明上述结论，令 $\vec v$ 和 $\vec w$ 的长度相同，根据对称性可以知道， $\vec v$ 在 $\vec w$ 上的投影长度与 $\vec w $  在 $\vec v$ 上的投影长度相同。当 $ \vec v$ 放大两倍后，这种对称性就不再存在了，但此时 $\vec w$ 在 $2\vec v$ 上的投影不变，也可以说  $2\vec v$ 在 $\vec w$ 上的投影长度变为原来的2倍，所以 $(2\vec v)·\vec w=\vec w·(2\vec v)$ </p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060904.png" alt="image-20210716055903784"></p>
<h3 id="·向量点积的矩阵表示"><a href="#·向量点积的矩阵表示" class="headerlink" title="·向量点积的矩阵表示"></a>·向量点积的矩阵表示</h3><p>如果把一个向量当成一个 $n\times1$ 的矩阵来看时，那么对向量的转置就得到了一个 $1\times n$的矩阵，向量的点积可以用向量的转置乘以向量来计算</p>
<p><strong>那么为什么可以这样计算呢？</strong>首先可以想到，既然转置是一个矩阵，就可以表示一个线性变换了，这个线性变换的几何意义就是把多维空间中的向量映射到一个一维空间上。经过映射得到的一维向量是一个数，它表示在多维空间中的一个向量在某一方向上的投影长度。</p>
<p>现在以二维空间为例：</p>
<p>在二维空间中有一单位向量 $\vec u$ ，在该向量的方向上布置一个数轴，这个数轴也就是一个一维空间。如果想把 $\vec u$ ==映射==到这个一维空间中，则需要找到二维空间的基向量在这个一维空间上的位置，我们用投影位置来表示基向量在一维空间上的位置，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060910.png" alt="image-20210716092117757"></p>
<p>根据投影关系和对称关系，可以得到二维空间中的基向量 $\vec i 和 \vec j$ 在一维空间的位置</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060919.png" alt="image-20210716092532170"></p>
<p>则$\vec i 和 \vec j$在一维空间的坐标为：</p>
<script type="math/tex; mode=display">
[u_x \ u_y]</script><p>对于二维空间中任意的向量在这个轴上的投影，可以用这个矩阵乘以向量的坐标来得到</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060925.png" alt="image-20210716092801428"></p>
<p>最终得到的结果为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
u_{x} & u_{y}
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]=u_{x} \cdot x+u_{y} \cdot y</script><p>这与这个任意向量和 $\vec u$ 的点积完全相同</p>
<blockquote>
<p>总结：为什么点积可以用向量的转置乘以向量？向量的转置表示一个矩阵，这个矩阵又代表着一个线性变换，这个线性变换就表示把一个多维空间的向量==投影==到一个一维空间中。</p>
</blockquote>
<p>当 $\vec v=k\vec u$ 是任意的向量时</p>
<script type="math/tex; mode=display">
k\left[\begin{array}{ll}u_{x} & u_{y}\end{array}\right]\left[\begin{array}{l}x \\
y\end{array}\right]=\left[\begin{array}{ll}ku_{x} & ku_{y}\end{array}\right]\left[\begin{array}{l}x \\
y\end{array}\right]=ku_{x} \cdot x+ku_{y} \cdot y</script><p>两个任意向量的点积表示先将一个向量投影到另一向量所在的方向上，然后将投影长度和另一向量的长度相乘</p>
<h2 id="7-向量的叉积"><a href="#7-向量的叉积" class="headerlink" title="7.向量的叉积"></a>7.向量的叉积</h2><h3 id="·什么是叉积"><a href="#·什么是叉积" class="headerlink" title="·什么是叉积"></a>·什么是叉积</h3><p>两个向量的叉积会产生一个与这两个向量都垂直的新向量，并且其长度等于这两个向量所围成的四边形的面积，而且它们的方向满足右手定则。</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060932.png" alt="image-20210716095942997"></p>
<p>既然是表示面积，这就与之前说过的行列式有关系，但这只对二维向量成立（因为只有两个向量，只有二维向量才能满足方阵，才有行列式）</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060936.png" alt="image-20210716095517110"></p>
<p>两个向量所组成的矩阵对应着一个线性变换，线性变换的度量就是矩阵的行列式，也就是基向量所围成的四边形面积</p>
<h3 id="·关于三维空间中的叉积的计算"><a href="#·关于三维空间中的叉积的计算" class="headerlink" title="·关于三维空间中的叉积的计算"></a>·关于三维空间中的叉积的计算</h3><p>对于三维空间中的叉积，可以用下面的计算公式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
v_{1} \\
v_{2} \\
v_{3}
\end{array}\right] \times\left[\begin{array}{l}
w_{1} \\
w_{2} \\
w_{3}
\end{array}\right]=\operatorname{det}\left(\left[\begin{array}{ccc}
\vec{\imath} & v_{1} & w_{1} \\
\vec{\jmath} & v_{2} & w_{2} \\
\vec{k} & v_{3} & w_{3}
\end{array}\right]\right)</script><p>现在就来说明一下为什么可以用这个公式来计算叉积</p>
<p>由第4节可知，矩阵的行列式表示列向量所张成的平行六面体的体积，而上面行列式的第一列不是一个向量，而是三个基向量，下面先来定义一个线性映射 $L(\vec a)$</p>
<script type="math/tex; mode=display">
L(\vec a)=\operatorname{\det}\left(\left[\begin{array}{c}
{x} & v_{1} & w_{1} \\
{y} & v_{2} & w_{2} \\
{z} & v_{3} & w_{3}
\end{array}\right]\right)\quad(\vec a=\left[\begin{array}{l}\ x\\
y\\
z\end{array}\right])</script><p>这个线性映射将一个三维向量映射到一维空间中，表示一个数，于是可以写成这种形式：</p>
<script type="math/tex; mode=display">
L(\vec a)=[\begin{array}{}p_1&p_2&p_3\end{array}]\cdot\left[\begin{array}{}x\\
y\\
z\end{array}\right]=\operatorname{det}\left(\left[\begin{array}{ccc}
{x} & v_{1} & w_{1} \\
{y} & v_{2} & w_{2} \\
{z} & v_{3} & w_{3}
\end{array}\right]\right)</script><p>于是展开有：</p>
<script type="math/tex; mode=display">
\begin{array}{r}
\quad x\left(v_{2} \cdot w_{3}-v_{3} \cdot w_{2}\right)+ \\
p_{1} \cdot x+p_{2} \cdot y+p_{3} \cdot z=y\left(v_{3} \cdot w_{1}-v_{1} \cdot w_{3}\right)+ \\
z\left(v_{1} \cdot w_{2}-v_{2} \cdot w_{1}\right)
\end{array}</script><p>即：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&p_{1}=v_{2} \cdot w_{3}-v_{3} \cdot w_{2} \\
&p_{2}=v_{3} \cdot w_{1}-v_{1} \cdot w_{3} \\
&p_{3}=v_{1} \cdot w_{2}-v_{2} \cdot w_{1}
\end{aligned}</script><p>现在用 $\vec p=[p_1\ p_2\ p_3]^T$，然后来谈几何意义</p>
<p>行列式表示三个列向量所张成的平行六面体的体积，而 $\vec p$ 和 $\vec a$ 的点积就等于这个体积，那么 $\vec p$ 是一个什么向量才能满足它们两个的点积等于体积呢。对于$\vec a$来说，它是任意一个向量，而 $\vec v$ 和 $\vec w$ 向量是固定的，平行六面体的体积等于面积乘以高，也就是说，当面积确定后，只需要知道高就可以了</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060949.png" alt="image-20210716111418718"></p>
<p>这个高就是 $\vec a$ 在垂直于 $\vec v$ 和 $\vec w$ 的方向上的投影，于是现在就可以知道 $\vec p$ 的意义了，$\vec p$ 的方向垂直于$\vec v$ 和 $\vec w$ ，它的长度是$\vec v$ 和 $\vec w$ 所张成平行四边形的面积</p>
<h2 id="8-基变换"><a href="#8-基变换" class="headerlink" title="8.基变换"></a>8.基变换</h2><p>现在有两个二维世界中的人，猪猪侠和包包侠，在猪猪侠的世界中，基向量是这样的：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060953.png" alt="image-20210716112957364"></p>
<p>在包包侠的世界中，基向量是这样的：</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018060957.png" alt="image-20210716114150696"></p>
<p>当有同一个向量时，在两个人的眼中，描述是不同的</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018061002.png" alt="image-20210716114326652"></p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
\vec{e}_{i} & \vec{e}_{j}
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\vec{e}_{i}^{\prime}\ \ \ \  \ \vec{e}_{j}^{\prime}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]</script><p>现在包包侠把她所看到的向量的坐标告诉猪猪侠，那么猪猪侠必须要先知道包包侠的基向量在猪猪侠的基向量下的坐标，然后才能知道</p>
<p>于是包包侠的两个基向量在猪猪侠的基向量下的坐标为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}a&b\\
c&d\end{array}\right]</script><p>所以猪猪侠就知道了这个向量在他的基下的坐标：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\begin{array}{}a&b\\
c&d\end{array}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]=A\vec v^{\prime}</script><p>同理猪猪侠把这个他看到的向量的坐标告诉包包侠，包包侠也得转化到自己的基下来，即：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]
=\left[\begin{array}{}a&b\\
c&d\end{array}\right]^{-1}\left[\begin{array}{l}
x \\
y
\end{array}\right]=A^{-1}\vec v</script><p>现在猪猪侠想把这个向量变一变，比如旋转个90度，于是他用自己世界的基来描述变化后空间的位置，也就是新的坐标轴上单位向量的坐标为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]</script><p>于是变化后向量的坐标为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{new} \\
y_{new}
\end{array}\right]=\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]</script><p>现在包包侠也同样想把这个向量变一下，变得和猪猪侠一样，此时她直接乘以猪猪侠的M矩阵是不可以的，因为M是在猪猪侠的基上得到的，她想了一个好办法：</p>
<ul>
<li>她先把想变化的向量告诉猪猪侠，猪猪侠在自己的基下把这个向量表示出来</li>
<li>然后猪猪侠去变，乘以M矩阵</li>
<li>然后她再将猪猪侠变化后的向量换到自己的基下表示</li>
</ul>
<p>上述的过程就用下面的公式来表示：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{new}^{\prime} \\
y_{new}^{\prime}
\end{array}\right]=\left[\begin{array}{}a&b\\
c&d\end{array}\right]^{-1}\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]\left[\begin{array}{}a&b\\
c&d\end{array}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]=A^{-1}MA\vec v^{\prime}</script><h2 id="9-特征值和特征向量"><a href="#9-特征值和特征向量" class="headerlink" title="9.特征值和特征向量"></a>9.特征值和特征向量</h2><h3 id="·特征向量"><a href="#·特征向量" class="headerlink" title="·特征向量"></a>·特征向量</h3><p>矩阵乘以一个向量表示对这个向量的线性变换，以二维空间为例：</p>
<p>一个向量所张成的空间，就是这个向量所在的直线，当这个向量被变换后，很可能会离开这个空间，如下图所示</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018061009.png" alt="image-20210716121344977"></p>
<p>但是也会有一些向量，没有离开它本身的张成空间，线性变换只是对它进行了拉伸或压缩，此时矩阵的作用如同一个标量</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018061014.png" alt="image-20210716121501072"></p>
<p>这两个方向空间中的向量都不会偏离其原来所在的直线，而其他向量都会发生偏转</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018061020.png" alt="image-20210716121716491"></p>
<p>这些不发生偏转的向量就叫作特征向量</p>
<h3 id="·特征值"><a href="#·特征值" class="headerlink" title="·特征值"></a>·特征值</h3><p>每一个特征向量都有一个与其对应的特征值，特征值表征这个向量空间上的向量被拉伸和压缩多少</p>
<p>那么特征向量有啥用呢？</p>
<p>考虑一个三维旋转的线性变换，当找到了它的特征向量，就找到了它的旋转轴</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018061028.png" alt="image-20210716122229199"></p>
<p>当特征值为0时，表示没有特征向量 </p>
<h2 id="10-抽象向量空间"><a href="#10-抽象向量空间" class="headerlink" title="10.抽象向量空间"></a>10.抽象向量空间</h2><p>无论是什么东西，只要符合以下八条公理，那么这个东西就可以称作向量，它遵循着之前讲过的所用性质</p>
<p><img src="https://raw.githubusercontent.com/PiggyHero/Blog_Picture/master/20211018061033.png" alt="image-20210716125152513"></p>
<blockquote>
<p>任意向量都能表达为基向量以某种方式进行线性组合，所以求一个向量变换后的结果，就是求变换后基向量以相同方式进行线性组合的结果</p>
</blockquote>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
</search>
