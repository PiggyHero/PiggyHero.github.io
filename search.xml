<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac强制退出软件和打开未验证的软件</title>
    <url>/2021/10/18/Mac%E5%BC%BA%E5%88%B6%E9%80%80%E5%87%BA%E8%BD%AF%E4%BB%B6%E5%92%8C%E6%89%93%E5%BC%80%E6%9C%AA%E9%AA%8C%E8%AF%81%E7%9A%84%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="强制退出"><a href="#强制退出" class="headerlink" title="强制退出"></a>强制退出</h3><p>同时按 <code>option</code> ，<code>command</code> 和 <code>esc</code> 键，即可弹出强退窗口。</p>
<h3 id="无法打开“-”，因为无法验证开发者"><a href="#无法打开“-”，因为无法验证开发者" class="headerlink" title="无法打开“*”，因为无法验证开发者"></a>无法打开“<em>*</em>”，因为无法验证开发者</h3><ol>
<li>打开方达，在右侧菜单栏选择应用程序</li>
<li>找到提示无法验证的应用，右键点击打开</li>
<li>第一次会出现以下提示，继续点击打开即可</li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac无法抹掉硬盘问题解决</title>
    <url>/2021/10/18/Mac%E6%97%A0%E6%B3%95%E6%8A%B9%E6%8E%89%E7%A1%AC%E7%9B%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/31672180">解决方案</a></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac解决因为安全策略问题无法打开软件</title>
    <url>/2021/11/28/Mac%E8%A7%A3%E5%86%B3%E5%9B%A0%E4%B8%BA%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>M1报错问题</strong></p>
<p>无法打开“xxx”，因为“安全策略”已设为“宽松安全性”</p>
<span id="more"></span>
<p><strong>解决方案</strong></p>
<p><strong>1.</strong>关机，长按开机按钮，进入“恢复” App 中，选取“实用工具”&gt;“启动安全性实用工具”。</p>
<p><strong>2.</strong>选择要用来设定安全策略的系统。</p>
<p><strong>3.</strong>如果磁盘已使用文件保险箱加密，请点按“解锁”，输入密码，然后点按“解锁”。</p>
<p><strong>4.</strong>点按“安全策略”。</p>
<p><strong>5.</strong>检查以下安全性选项：</p>
<p>完整安全性：确保只有当前的操作系统或者当前 Apple 信任的签名操作系统软件才能运行。此模式在安装软件时需要网络连接。</p>
<p>降低安全性：允许运行 Apple 信任过的任何版本的签名操作系统软件。</p>
<p><strong>6.</strong>如果需要，请选择“降低安全性”，输入管理员用户名和密码，然后执行以下一项操作：</p>
<p>选择“允许用户管理来自被认可开发者的内核扩展”复选框以允许使用旧版内核扩展的软件进行安装。</p>
<p>选择“允许远程管理内核扩展和软件自动更新”复选框以授权使用移动设备管理 (MDM) 解决方案远程管理旧版内核扩展和软件更新。</p>
<p><strong>7.</strong>点按“好”。</p>
<p><strong>8.</strong>重新启动 Mac 以使更改生效。</p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown常用语法</title>
    <url>/2021/10/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown常用语法，方便使用时查阅。<br><span id="more"></span></p>
<h2 id="锚点和目录"><a href="#锚点和目录" class="headerlink" title="锚点和目录"></a>锚点和目录</h2><p>目录在前面用 <code>[toc]</code> 即可。</p>
<p>锚点: <code>[说明文字](#jump)</code>，然后在要跳跃的位置处写 <code>&lt;span id=&quot;jump&quot;&gt;跳转位置的名字&lt;/span&gt;</code></p>
<p>例如：<a href="#希腊字母">希腊字母</a> </p>
<p>超链接：<code>[网页名字](地址)</code>，如<a href="https://github.com/">github</a></p>
<h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol>
<li>行内公式：将公式插入到本行内，符号：<script type="math/tex">公式内容</script>，如：$xyz$</li>
<li>独行公式：将公式插入到新的一行内，并且居中，符号：<script type="math/tex">$公式内容$$$，如：</script>xyz$$</li>
</ol>
<h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol>
<li>上标符号，符号：<code>^</code>，如：$x^4$</li>
<li>下标符号，符号：<code>_</code>，如：$x_1$</li>
<li>组合符号，符号：<code>&#123;&#125;</code>，如：${16}_{8}O{2+}_{2}$</li>
</ol>
<h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol>
<li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：$V_{\mbox{初始}}$</li>
<li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li>
<li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li>
<li>标签，符号<code>\tag&#123;数字&#125;</code>，如：$\tag{11}$</li>
<li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li>
<li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li>
<li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li>
</ol>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol>
<li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li>
<li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li>
<li>大空格，符号<code>\</code>，如：$x \  y$ </li>
<li>中空格，符号<code>\:</code>，如：$x \: y$</li>
<li>小空格，符号<code>\,</code>，如：$x \, y$</li>
<li>没有空格，符号``，如：$xy$</li>
<li>紧贴，符号<code>\!</code>，如：$x ! y$</li>
</ol>
<h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol>
<li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li>
<li>中括号，符号：<code>[]</code>，如：$[x+y]$</li>
<li>大括号，符号：<code>\&#123; \&#125;</code>，如: $\{\}$</li>
<li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li>
<li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li>
<li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</li>
</ol>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol>
<li>加法运算，符号：<code>+</code>，如：$x+y=z$</li>
<li>减法运算，符号：<code>-</code>，如：$x-y=z$</li>
<li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li>
<li>减加运算，符号：<code>\mp</code>，如：$x \mp y=z$</li>
<li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li>
<li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li>
<li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li>
<li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li>
<li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li>
<li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：$\frac{x+y}{y+z}$</li>
<li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：${x+y} \over {y+z}$</li>
<li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li>
</ol>
<h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol>
<li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：$\overline{xyz}$</li>
<li>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li>
<li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：$\sqrt[3]{x+y}$</li>
<li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li>
<li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li>
<li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li>
<li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li>
<li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;5 &amp;6 &amp;\cdots &amp;8\\\vdots &amp;\vdots &amp;\ddots &amp;\vdots&amp; \vdots&amp;\cdots &amp;16\end{matrix} \right]$</li>
</ol>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol>
<li>等于运算，符号：<code>=</code>，如：$x+y=z$</li>
<li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li>
<li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li>
<li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li>
<li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li>
<li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li>
<li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li>
<li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li>
<li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li>
<li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li>
<li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li>
<li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li>
</ol>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol>
<li>属于运算，符号：<code>\in</code>，如：$x \in y$</li>
<li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li>
<li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li>
<li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li>
<li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li>
<li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li>
<li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li>
<li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li>
<li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li>
<li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li>
<li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li>
<li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li>
<li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li>
<li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li>
<li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li>
<li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li>
<li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li>
<li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li>
<li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li>
</ol>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol>
<li>无穷，符号：<code>\infty</code>，如：$\infty$</li>
<li>虚数，符号：<code>\imath</code>，如：$\imath$</li>
<li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li>
<li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</li>
<li>数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</li>
<li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</li>
<li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</li>
<li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</li>
<li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</li>
<li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</li>
<li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</li>
<li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</li>
<li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</li>
<li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</li>
<li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li>
<li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li>
<li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li>
<li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li>
<li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li>
<li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li>
<li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li>
<li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li>
<li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li>
<li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li>
<li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li>
<li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li>
</ol>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a><span id="希腊字母">希腊字母</span></h2><div class="table-container">
<table>
<thead>
<tr>
<th>字母</th>
<th>实现</th>
<th>字母</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td><code>A</code></td>
<td>α</td>
<td><code>\alhpa</code></td>
</tr>
<tr>
<td>B</td>
<td><code>B</code></td>
<td>β</td>
<td><code>\beta</code></td>
</tr>
<tr>
<td>Γ</td>
<td><code>\Gamma</code></td>
<td>γ</td>
<td><code>\gamma</code></td>
</tr>
<tr>
<td>Δ</td>
<td><code>\Delta</code></td>
<td>δ</td>
<td><code>\delta</code></td>
</tr>
<tr>
<td>E</td>
<td><code>E</code></td>
<td>ϵ</td>
<td><code>\epsilon</code></td>
</tr>
<tr>
<td>Z</td>
<td><code>Z</code></td>
<td>ζ</td>
<td><code>\zeta</code></td>
</tr>
<tr>
<td>H</td>
<td><code>H</code></td>
<td>η</td>
<td><code>\eta</code></td>
</tr>
<tr>
<td>Θ</td>
<td><code>\Theta</code></td>
<td>θ</td>
<td><code>\theta</code></td>
</tr>
<tr>
<td>I</td>
<td><code>I</code></td>
<td>ι</td>
<td><code>\iota</code></td>
</tr>
<tr>
<td>K</td>
<td><code>K</code></td>
<td>κ</td>
<td><code>\kappa</code></td>
</tr>
<tr>
<td>Λ</td>
<td><code>\Lambda</code></td>
<td>λ</td>
<td><code>\lambda</code></td>
</tr>
<tr>
<td>M</td>
<td><code>M</code></td>
<td>μ</td>
<td><code>\mu</code></td>
</tr>
<tr>
<td>N</td>
<td><code>N</code></td>
<td>ν</td>
<td><code>\nu</code></td>
</tr>
<tr>
<td>Ξ</td>
<td><code>\Xi</code></td>
<td>ξ</td>
<td><code>\xi</code></td>
</tr>
<tr>
<td>O</td>
<td><code>O</code></td>
<td>ο</td>
<td><code>\omicron</code></td>
</tr>
<tr>
<td>Π</td>
<td><code>\Pi</code></td>
<td>π</td>
<td><code>\pi</code></td>
</tr>
<tr>
<td>P</td>
<td><code>P</code></td>
<td>ρ</td>
<td><code>\rho</code></td>
</tr>
<tr>
<td>Σ</td>
<td><code>\Sigma</code></td>
<td>σ</td>
<td><code>\sigma</code></td>
</tr>
<tr>
<td>T</td>
<td><code>T</code></td>
<td>τ</td>
<td><code>\tau</code></td>
</tr>
<tr>
<td>Υ</td>
<td><code>\Upsilon</code></td>
<td>υ</td>
<td><code>\upsilon</code></td>
</tr>
<tr>
<td>Φ</td>
<td><code>\Phi</code></td>
<td>ϕ</td>
<td><code>\phi</code></td>
</tr>
<tr>
<td>X</td>
<td><code>X</code></td>
<td>χ</td>
<td><code>\chi</code></td>
</tr>
<tr>
<td>Ψ</td>
<td><code>\Psi</code></td>
<td>ψ</td>
<td><code>\psi</code></td>
</tr>
<tr>
<td>Ω</td>
<td><code>\v</code></td>
<td>ω</td>
<td><code>\omega</code></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS中命名和重命名</title>
    <url>/2021/10/22/ROS%E4%B8%AD%E5%91%BD%E5%90%8D%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<p>本文介绍ROS中命名和重命名的相关知识。</p>
<span id="more"></span>
<p>其实命名和重命名是一回事，只不过我们自己写的节点或者参数等，可以在编程的时候自己直接命名，别人写的包我们不能在其源码上进行命名，所以就需要其他方式进行重命名。</p>
<p>ROS中关于命名和重命名的情况主要为：</p>
<ul>
<li>ROS工作空间覆盖</li>
<li>ROS节点重命名</li>
<li>ROS话题名称设置</li>
<li>ROS参数名称设置</li>
</ul>
<p>ROS中命名的策略有两个，一个是重新起名字(重映射)，另一个是在现有的命名前加上命名空间。</p>
<h1 id="一、ROS工作空间覆盖"><a href="#一、ROS工作空间覆盖" class="headerlink" title="一、ROS工作空间覆盖"></a>一、ROS工作空间覆盖</h1><p>工作空间覆盖是指，在不同的工作空间下，有重名的功能包。</p>
<p>因为要运行某个包，需要在<code>.bashrc</code>文件中设置环境变量路径。ROS 解析 <code>.bashrc 文件</code>，并生成 <code>ROS_PACKAGE_PATH</code>包路径，该变量中按照 <code>.bashrc</code>中配置设置工作空间优先级，如果先设置工作空间A，再设置工作空间B，那么在调用重名包时，B空间中的重名包被调用，因为它的搜索路径是先搜索B，再搜索A，既然在B中找到了该包，就不会再到A中找了。</p>
<p>应该避免该种情况发生。</p>
<h1 id="二、ROS节点重命名"><a href="#二、ROS节点重命名" class="headerlink" title="二、ROS节点重命名"></a>二、ROS节点重命名</h1><p>ROS中不允许同时运行两个名字相同的节点。当如果出现节点名相同时，需要进行重映射或添加命名空间。实现的方式主要有三种</p>
<h2 id="1-rosrun命令"><a href="#1-rosrun命令" class="headerlink" title="1.rosrun命令"></a>1.rosrun命令</h2><p><strong>(1)添加命名空间</strong></p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun pkg_name node_name  __ns:=/namespace</span><br></pre></td></tr></table></figure>
<p>查看节点名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/namespace/node_name</span><br></pre></td></tr></table></figure>
<p><strong>(2)重映射</strong></p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun pkg_name node_name __name:=/new_name</span><br></pre></td></tr></table></figure>
<p>查看节点名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/new_name</span><br></pre></td></tr></table></figure>
<h2 id="2-launch文件"><a href="#2-launch文件" class="headerlink" title="2.launch文件"></a>2.launch文件</h2><p>在编写launch文件时，完成操作。</p>
<p><strong>(1)添加命名空间</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;new_name&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;namespace&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>节点名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/namespace/new_name</span><br></pre></td></tr></table></figure>
<p><strong>(2)重映射</strong></p>
<p>node标签下的name可以完成重映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;new_name&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-编码实现"><a href="#3-编码实现" class="headerlink" title="3.编码实现"></a>3.编码实现</h2><p><strong>(1)重映射</strong></p>
<p>在我们创建节点的时候，需要进行节点初始化，代码如下；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_name&quot;</span>,ros::init_option::AnonymousName);</span><br></pre></td></tr></table></figure>
<p>在参数列表中，<code>ros::init_option::AnoymousName</code>是一个随机的数，可以在原节点名上加上一个随机数。</p>
<p><strong>(2)添加命名空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; map;</span><br><span class="line">map[<span class="string">&quot;__ns&quot;</span>] = <span class="string">&quot;namespace&quot;</span>;</span><br><span class="line">ros::<span class="built_in">init</span>(map,<span class="string">&quot;node_name&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="三、话题名称设置"><a href="#三、话题名称设置" class="headerlink" title="三、话题名称设置"></a>三、话题名称设置</h1><p>在 ROS 中节点终端，不同的节点之间通信都依赖于话题，话题名称也可能出现重复的情况，这种情况下，系统虽然不会抛出异常，但是可能导致订阅的消息非预期的，从而导致节点运行异常。这种情况下需要将两个节点的话题名称由相同修改为不同。又或者，两个节点是可以通信的，两个节点之间使用了相同的消息类型，但是由于，话题名称不同，导致通信失败。这种情况下需要将两个节点的话题名称由不同修改为相同。</p>
<h2 id="0-话题分类"><a href="#0-话题分类" class="headerlink" title="0.话题分类"></a>0.话题分类</h2><p>根据话题前面添加的前缀的不同，又可以将话题分为：</p>
<ul>
<li>全局话题</li>
<li>相对话题</li>
<li>私有话题</li>
</ul>
<p>全局话题的前缀为<code>/</code>     <strong>E.g.</strong> <code>/topic_name</code> </p>
<p>相对话题的前缀为节点的命名空间        <strong>E.g.</strong> <code>/namespace/topic_name</code></p>
<p>私有话题的前缀为节点名        <strong>E.g.</strong>  <code>/namespace/node_name/topic_name</code></p>
<h2 id="1-rosrun设置话题重映射"><a href="#1-rosrun设置话题重映射" class="headerlink" title="1.rosrun设置话题重映射"></a>1.rosrun设置话题重映射</h2><p>需要先知道节点中话题的名字。</p>
<p>然后通过：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun pkg_name node_name /origin_topic_name:=/new_topic_name</span><br></pre></td></tr></table></figure>
<h2 id="2-launch文件设置话题重映射"><a href="#2-launch文件设置话题重映射" class="headerlink" title="2.launch文件设置话题重映射"></a>2.launch文件设置话题重映射</h2><p>在launch文件中完成话题名重映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node_name&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;origin_topic_name&quot;</span> <span class="attr">to</span>=<span class="string">&quot;new_topic_name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-编码设置话题名称"><a href="#3-编码设置话题名称" class="headerlink" title="3.编码设置话题名称"></a>3.编码设置话题名称</h2><p><strong>(1)全局话题名</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_name&quot;</span>);</span><br><span class="line"> </span><br><span class="line">ros::NodeHandle n;<span class="comment">//创建节点句柄，它可以实现一些功能，设置话题时就需要它</span></span><br><span class="line"></span><br><span class="line">ros::Publisher pub=n.advertise&lt;std::msgs::string&gt;(<span class="string">&quot;/topic_name&quot;</span>,<span class="number">10</span>);<span class="comment">//这里的/就表示全局话题</span></span><br></pre></td></tr></table></figure>
<p>生成的话题名为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/topic_name</span><br></pre></td></tr></table></figure>
<p><strong>(2)相对话题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_name&quot;</span>);</span><br><span class="line"> </span><br><span class="line">ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">ros::Publisher pub=n.advertise&lt;std::msgs::string&gt;(<span class="string">&quot;topic_name&quot;</span>,<span class="number">10</span>);<span class="comment">//这里没有/就表示相对话题</span></span><br></pre></td></tr></table></figure>
<p>生成的话题名为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/namespace/topic_name</span><br></pre></td></tr></table></figure>
<p><strong>(3)私有话题</strong></p>
<p>私有话题与前面的有一点不同，是在生成节点句柄的时候。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node_name&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">n</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;<span class="comment">//注意这里加上了~</span></span><br><span class="line"></span><br><span class="line">ros::Publisher pub=n.advertise&lt;std::msgs::string&gt;(<span class="string">&quot;topic_name&quot;</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>生成的话题名为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/namespace/node_name/topic_name</span><br></pre></td></tr></table></figure>
<h1 id="四、ROS参数名设置"><a href="#四、ROS参数名设置" class="headerlink" title="四、ROS参数名设置"></a>四、ROS参数名设置</h1><p>在参数名设置中，没有重映射机制，就是直接给参数命名。命名的时候为了避免重名，通过添加前缀的方式，实现全局参数，相对参数，私有参数三种。</p>
<h2 id="1-rosrun设置参数"><a href="#1-rosrun设置参数" class="headerlink" title="1.rosrun设置参数"></a>1.rosrun设置参数</h2><p>rosrun命令设置的是私有参数。参数名前面要加上<code>_</code></p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun pkg_name node_name _param_name:=10</span><br></pre></td></tr></table></figure>
<p>参数列表显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/namespace/node_name/param_name</span><br></pre></td></tr></table></figure>
<h2 id="2-launch文件设置"><a href="#2-launch文件设置" class="headerlink" title="2.launch文件设置"></a>2.launch文件设置</h2><p>通过 launch 文件设置参数的方式前面已经介绍过了，可以在 node 标签外，或 node 标签中通过 param 或 rosparam  来设置参数。在 node 标签外设置的参数是全局性质的，参考的是 / ，在 node 标签中设置的参数是私有性质的，参考的是  /命名空间/节点名称。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--全局参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--私有参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;t1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;p2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-编码设置参数"><a href="#3-编码设置参数" class="headerlink" title="3.编码设置参数"></a>3.编码设置参数</h2><p>在C++源码中，可以通过两种放式来设置参数：</p>
<p><strong>(1)通过<code>ros::param</code>设置参数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/set_A&quot;</span>,<span class="number">100</span>); <span class="comment">//全局参数,和命名空间以及节点名称无关</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;set_B&quot;</span>,<span class="number">100</span>); <span class="comment">//相对参数,参考命名空间</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;~set_C&quot;</span>,<span class="number">100</span>); <span class="comment">//私有参数,参考命名空间与节点名称</span></span><br></pre></td></tr></table></figure>
<p><strong>(2)<code>ros::NodeHandle</code>设置参数</strong></p>
<p>首先要创建<code>ros::NodeHandle</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ros::NodeHandle n1</span><br><span class="line"></span><br><span class="line">n1.<span class="built_in">setParam</span>(<span class="string">&quot;/param_name&quot;</span>,<span class="number">10</span>);<span class="comment">//设置全局参数</span></span><br><span class="line"></span><br><span class="line">n1.<span class="built_in">setParam</span>(<span class="string">&quot;param_name&quot;</span>,<span class="number">10</span>);<span class="comment">//设置相对参数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">n2</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">n2.<span class="title">setParam</span><span class="params">(<span class="string">&quot;param_name&quot;</span>,<span class="number">10</span>)</span><span class="comment">//设置私有参数</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>古月ROS21讲学习笔记</title>
    <url>/2021/10/18/ROS21%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习《古月ROS入门21讲》的学习笔记<br><span id="more"></span><br>课程总览：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032824.png" alt="image-20211007012207647"></p>
<h1 id="一、ROS是什么"><a href="#一、ROS是什么" class="headerlink" title="一、ROS是什么"></a>一、ROS是什么</h1><p>ROS1.0发布于2010年，其发布的根本目的就是在机器人开发过程中，提高代码的复用率。就是在开发一个机器人时，可以通过ROS提供的各种功能，驱动机器人移动，感知外部环境，做出决策等。这就极大的节省了机器人开发的时间。</p>
<p>ROS(Robot operation system)全名为机器人操作系统，具体的它包括四大部分，分别为<strong>通信机制，开发工具，应用功能和生态系统</strong>。</p>
<h2 id="1-通信机制"><a href="#1-通信机制" class="headerlink" title="1.通信机制"></a>1.通信机制</h2><p>ROS提供了一种松耦合分布式通信机制，机器人的内部各个模块可以依靠这种通信机制完成信息的传递。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032831.png" alt="image-20211005000749206" style="zoom:67%;" /></p>
<h2 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2.开发工具"></a>2.开发工具</h2><p>ROS提供了一系列的开发工具，可以为机器人开发提供很大的帮助。</p>
<p>常用的开发工具有TF坐标变换，QT工具箱，Rviz，Gazebo。会在后面进行具体的使用介绍。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032836.png" alt="image-20211005000718567"></p>
<h2 id="3-应用功能"><a href="#3-应用功能" class="headerlink" title="3.应用功能"></a>3.应用功能</h2><p>ROS中包含各种功能包，可供机器人开发中使用。例如有可以驱动相机的功能包，有进行图像处理的功能包，有控制机器人运动的功能包，还有SLAM功能包。这些功能包的存在可以大大简化机器人的开发过程。</p>
<h2 id="4-生态环境"><a href="#4-生态环境" class="headerlink" title="4.生态环境"></a>4.生态环境</h2><p>ROS的生态环境具体指的是依据ROS系统，建立起来的一个ROS社区，在这个社区中，包含着我们需要的各种东西。主要有以下几部分组成：</p>
<ul>
<li>发行版：ROS发行版包括一系列带有版本号，可以直接安装的功能包。</li>
<li>软件源：ROS依赖于共享网络上的开源代码，不同组织机构可以开发或共享自己的机器人软件。</li>
<li>ROS wiki：记录ROS信息文档的论坛。</li>
<li>ROs Answer：咨询ROS相关的网站。</li>
</ul>
<h1 id="二、ROS中的核心概念"><a href="#二、ROS中的核心概念" class="headerlink" title="二、ROS中的核心概念"></a>二、ROS中的核心概念</h1><p>从上一章所知，ROS主要有四部分组成，包括通信机制，开发工具，应用功能和生态环境。抛开生态环境不说，因为整个ROS生态环境是当我们遇到困难或有什么特殊需求的时候，寻求帮助的地方。在我们实际的开发中，我们需要非常了解前三个部分。</p>
<p>下面我们来细细的说明一下ROS中的核心概念。</p>
<h2 id="1-组成ROS的基本单元"><a href="#1-组成ROS的基本单元" class="headerlink" title="1.组成ROS的基本单元"></a>1.组成ROS的基本单元</h2><p>当我们要了解ROS的通信机制时，就要知道是什么和什么在进行通信，也就是通信的主体是什么。在ROS中，通信的主体有节点和节点管理器两部分组成。</p>
<h3 id="1-节点-Node-—工人"><a href="#1-节点-Node-—工人" class="headerlink" title="(1)节点(Node)—工人"></a>(1)节点(Node)—工人</h3><p>节点是ROS系统中最基本的执行单元，有如下特点：</p>
<ul>
<li>节点要执行具体的任务进程，是一个可独立运行的可执行文件。</li>
<li>不同的节点可以使用不同的编程语言，可分布式运行在不同的主机。</li>
<li>节点在系统中的名称必须是唯一的。</li>
</ul>
<h3 id="2-节点管理器-Ros-Master-—管理员"><a href="#2-节点管理器-Ros-Master-—管理员" class="headerlink" title="(2)节点管理器(Ros Master)—管理员"></a>(2)节点管理器(Ros Master)—管理员</h3><p>对于节点的管理工作，需要节点管理器来完成，它主要有如下作用：</p>
<ul>
<li>为节点提供命名和注册服务。</li>
<li>跟踪和记录话题/服务通信（后面会说），辅助节点相互查找、建立连接。</li>
<li>提供参数服务器，节点使用此服务器存储和检索运行时的参数。</li>
</ul>
<p>下面我们用工人和管理员对以上的功能进行类比。对于每一个节点，我们可以把它看成是一个工人。工人就需要做好自己特定的工作（执行具体的任务进程），比如这个工人负责搬砖，另一个工人负责盖楼。不管这个工人来自哪里（使用不同的编程语言），或者在哪个工地（可运行在不同主机），只要能干活就可以。另外，工人不能重名（节点的名称唯一），这样不方便管理员管理。</p>
<p>而对于管理员，首先就是要为工人注册信息，分配工号（为节点提供命名和注册服务），然后给每个工人分配一个工作内容，并记录下工人所汇报的工作情况，方便其他工人了解完成情况（跟踪记录通信，辅助节点查找，建立连接）。另外，管理员还要记录下工程的水泥灰号，垒砖高度等工程参数，以方便工人在工作时可以随时查询（提供参数服务器）。</p>
<h2 id="2-通信机制"><a href="#2-通信机制" class="headerlink" title="2.通信机制"></a>2.通信机制</h2><p>通信机制主要有两种，一种是异步通信机制，叫做话题（Topic），另一种是同步通信机制，叫做服务（Service）。</p>
<h3 id="1-异步通信机制"><a href="#1-异步通信机制" class="headerlink" title="(1)异步通信机制"></a>(1)异步通信机制</h3><p>在该通信机制下，节点间传输的数据不是实时的。我们要知道两个概念：</p>
<h4 id="a-话题-Topic"><a href="#a-话题-Topic" class="headerlink" title="a.话题(Topic)"></a>a.话题(Topic)</h4><ul>
<li>节点间用来传输数据的总线。</li>
<li>使用发布/订阅模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以不唯一。</li>
</ul>
<h4 id="b-消息-Message"><a href="#b-消息-Message" class="headerlink" title="b.消息(Message)"></a>b.消息(Message)</h4><ul>
<li>消息是话题的数据。</li>
<li>具有一定的数据类型和数据结构，包括ROS提供的标准类型和用户自定义类型。</li>
<li>使用与编程语言无关的.msg文件定义，编译过程中生成对应的代码文件。</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032845.png" alt="image-20211005005705788"></p>
<p>好了，说完这么抽象的概念，我们还是用一个生活的例子来类比一下。在我们生活中，异步通信机制一个很明显的例子就是Youtube视频。例如有一个篮球话题（Topic），有一群订阅者（subsciber）和一群发布者（publisher）。当某一个发布者发布了一条视频（message）时，订阅者并不会马上知道，而是等他想看的时候，才会查看该话题下的内容，这就是异步通信机制。对于发布的视频的内容结构，可以是先热身，后打球，也可以是先打球，后洗澡，虽然结构可以变，但是有一定结构的。另外，无论视频内容如何，都必须是.avi格式的（.msg）。</p>
<p>所以说话题（Topic）是一个传输数据的总线，也可以理解成一个频道，一个管道，我们订阅了这个频道后，其内容会保持一定的结构，但是会变化。</p>
<p>在ROS中，话题的一个例子如下：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032852.png" alt="image-20211005010719866"></p>
<h3 id="2-同步通信机制"><a href="#2-同步通信机制" class="headerlink" title="(2)同步通信机制"></a>(2)同步通信机制</h3><p>同步通信机制，也叫做服务。它可以保证数据的传递是实时的。它有如下特点：</p>
<ul>
<li>使用客户端/服务器模型，客户端发送请求，服务器完成处理后返回应答数据。</li>
<li>使用与编程语言无关的.srv文件定义请求和应答数据结构，编译过程中生成对应的代码文件。</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032859.png" alt="image-20211005011052269" style="zoom: 67%;" /></p>
<p>这就好比一个服务员和一个顾客，顾客首先需要说出一个需求，然后服务员要做出回应。比如，顾客说帮我订一张机票（request），服务员立即定了一张机票然后回复订完了（reponse）。</p>
<p>ROS中服务的一个例子：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032904.png" alt="image-20211005011405078"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032910.png" alt="image-20211005011450237" style="zoom:67%;" /></p>
<h2 id="3-参数—全局共享字典"><a href="#3-参数—全局共享字典" class="headerlink" title="3.参数—全局共享字典"></a>3.参数—全局共享字典</h2><p>前面讲了工人和管理员的关系，管理员要记录一些所有工人都要用的信息，例如水泥的灰号。ROS中的参数的功能也是这样。参数由节点管理器提供服务器存储。特点如下：</p>
<ul>
<li>可通过网络访问的共享、多变量字典。</li>
<li>节点可以使用此服务器（也就是字典）来存储和检索运行时的参数。</li>
<li>适合存储静态、非二进制的配置参数，不适合存储动态配置的数据。</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032916.png" alt="image-20211005012244569"></p>
<h2 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4.文件系统"></a>4.文件系统</h2><p>前面所讲的节点等所有的东西都需要存储在文件中，也就是真实存在的形式。ROS的文件系统由三部分组成。</p>
<h3 id="1-功能包-Package"><a href="#1-功能包-Package" class="headerlink" title="(1)功能包(Package)"></a>(1)功能包(Package)</h3><p>ROS软件中的基本单元，包含节点源码、配置文件、数据定义等。</p>
<h3 id="2-功能包清单-Package-Manifest"><a href="#2-功能包清单-Package-Manifest" class="headerlink" title="(2)功能包清单(Package Manifest)"></a>(2)功能包清单(Package Manifest)</h3><p>记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。</p>
<h3 id="3-元功能包-Meta-Package"><a href="#3-元功能包-Meta-Package" class="headerlink" title="(3)元功能包(Meta Package)"></a>(3)元功能包(Meta Package)</h3><p>多个用于同一目的的功能包构成一个元功能包。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032921.png" alt="image-20211005012811067"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032926.png" alt="image-20211005012906244"></p>
<h1 id="三、ROS命令行工具"><a href="#三、ROS命令行工具" class="headerlink" title="三、ROS命令行工具"></a>三、ROS命令行工具</h1><p>ROS中提供了命令行工具帮助我们实现各种功能。</p>
<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h2><p><code>roscore</code>     启动Ros Master（必须启动）。</p>
<p><code>rosrun    功能包名    节点</code>     运行节点，要加功能包名，然后要运行的节点名。</p>
<h2 id="2-节点命令"><a href="#2-节点命令" class="headerlink" title="2.节点命令"></a>2.节点命令</h2><p>以<code>rosnode</code> 开头的命令，是处理节点的命令。</p>
<h3 id="1-rosnode-list"><a href="#1-rosnode-list" class="headerlink" title="(1)rosnode list"></a>(1)<code>rosnode list</code></h3><p>列出当前系统的所有节点。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032933.png" alt="image-20211005015249575"></p>
<p>在这里有一个rosout节点，是默认打开的，该节点主要是接受各个节点的信息形成一个日志信息。</p>
<h3 id="2-rosnode-info-节点名"><a href="#2-rosnode-info-节点名" class="headerlink" title="(2)rosnode info 节点名"></a>(2)<code>rosnode info 节点名</code></h3><p>查看某个节点信息。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032939.png" alt="image-20211005015739389"></p>
<p>在这里显示出的发布或订阅的内容中，前面部分为话题名，后面的是消息名。</p>
<h2 id="3-话题命令"><a href="#3-话题命令" class="headerlink" title="3.话题命令"></a>3.话题命令</h2><p>以<code>rostopic</code> 开头的命令，是处理话题的命令。</p>
<h3 id="1-rostopic-list"><a href="#1-rostopic-list" class="headerlink" title="(1)rostopic list"></a>(1)<code>rostopic list</code></h3><p>查看当前系统的所有话题。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032951.png" alt="image-20211005020128092"></p>
<h3 id="2-rostopic-pub"><a href="#2-rostopic-pub" class="headerlink" title="(2)rostopic pub"></a>(2)<code>rostopic pub</code></h3><p>向话题发布消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic	 pub 	话题名 	消息名 	内容</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rostopic 	pub 	/turtle1/cmd_vel 	geometry_msgs/Twist 	<span class="string">&quot;消息内容(在这里ROS定义的结构)&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这里，/turtle1/cmd_vel是话题名，geometry_msgs/Twist 是消息内容，后面双引号内是具体的消息内容，消息内容会有特定的结构。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032959.png" alt="image-20211005020805272"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rostopic 	pub 	-r 		10 		话题名		消息名		内容</span><br></pre></td></tr></table></figure>
<p>-r表示发布循环发布，这里表示发布频率为10Hz。</p>
<p>按<code>Ctrl+C</code>可以停止发布。</p>
<h2 id="4-话题消息命令"><a href="#4-话题消息命令" class="headerlink" title="4.话题消息命令"></a>4.话题消息命令</h2><p>以<code>rosmsg</code> 开头的命令，是处理话题消息的命令。</p>
<h3 id="1-rosmsg-show"><a href="#1-rosmsg-show" class="headerlink" title="(1)rosmsg show"></a>(1)<code>rosmsg show</code></h3><p>查看某个消息的数据结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosmsg 		show	消息名</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033006.png" alt="image-20211005022203709"></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="5-服务命令"><a href="#5-服务命令" class="headerlink" title="5.服务命令"></a>5.服务命令</h2><p>以<code>rosservice</code> 开头的命令，是处理服务的命令。</p>
<h3 id="1-rosservice-list"><a href="#1-rosservice-list" class="headerlink" title="(1)rosservice list"></a>(1)<code>rosservice list</code></h3><p>查看服务端的服务。也就是查看可提供的服务。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033012.png" alt="image-20211005022505249"></p>
<h3 id="2-rosservice-call"><a href="#2-rosservice-call" class="headerlink" title="(2)rosservice call"></a>(2)<code>rosservice call</code></h3><p>对某个服务发送请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice		call		可提供服务名		<span class="string">&quot;请求内容&quot;</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">rosservice 		call 		/spawn 		<span class="string">&quot;x: 0.0</span></span><br><span class="line"><span class="string">y: 0.0</span></span><br><span class="line"><span class="string">theta: 0.0</span></span><br><span class="line"><span class="string">name:&#x27;	 &#x27; &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，服务名为/spawn，双引号内为请求的内容，具有系统定义的数据结构。</p>
<h2 id="6-服务消息命令"><a href="#6-服务消息命令" class="headerlink" title="6.服务消息命令"></a>6.服务消息命令</h2><p>以<code>rossrv</code>开头的命令，是处理服务消息的命令。</p>
<h3 id="1-rossrv-show"><a href="#1-rossrv-show" class="headerlink" title="(1)rossrv show"></a>(1)<code>rossrv show</code></h3><p>查看服务消息数据的内容结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rossrv 		show		服务消息名</span><br></pre></td></tr></table></figure>
<p>在标准的服务消息数据中，有—-分隔，在其上面的是request的内容，下面是response的内容。request可以是空的，如果是空的，直接call服务就可以。response能不能是空的还不知道。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033019.png" alt="image-20211006001820657"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033023.png" alt="image-20211006001952198"></p>
<h2 id="7-话题记录和复现"><a href="#7-话题记录和复现" class="headerlink" title="7.话题记录和复现"></a>7.话题记录和复现</h2><p>记录当前系统中所有话题的数据并保存下来，然后可以再用的时候复现出来。</p>
<h3 id="1-rosbag-record"><a href="#1-rosbag-record" class="headerlink" title="(1)rosbag record"></a>(1)<code>rosbag record</code></h3><p>记录想要保存的话题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosbag		record		-a		-O		储存的文件名</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rosbag 		record 		-a		-O		cmd_record</span><br></pre></td></tr></table></figure>
<p>在这里-a表示记录所有话题数据。-O表示保存数据为一个压缩包。</p>
<p>文件会被储存到终端当前的工作目录。</p>
<h3 id="2-rosbag-play"><a href="#2-rosbag-play" class="headerlink" title="(2)rosbag play"></a>(2)<code>rosbag play</code></h3><p>复现保存的话题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosbag 		play		储存的文件名</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">rosbag 		play		cmd_record</span><br></pre></td></tr></table></figure>
<h2 id="8-参数命令"><a href="#8-参数命令" class="headerlink" title="8.参数命令"></a>8.参数命令</h2><p>以<code>rosparam</code> 开头的命令，都是处理参数的命令。</p>
<h3 id="1-rosparam-list"><a href="#1-rosparam-list" class="headerlink" title="(1)rosparam list"></a>(1)<code>rosparam list</code></h3><p>查看当前的全局参数。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033032.png" alt="image-20211006013652641"></p>
<h3 id="2-rosparam-get"><a href="#2-rosparam-get" class="headerlink" title="(2)rosparam get"></a>(2)<code>rosparam get</code></h3><p>获取某个参数的具体值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	get 	参数名</span><br><span class="line">rosparam 	get 	/run_id</span><br></pre></td></tr></table></figure>
<h3 id="3-rosparam-set"><a href="#3-rosparam-set" class="headerlink" title="(3)rosparam set"></a>(3)<code>rosparam set</code></h3><p>修改某个参数的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	<span class="built_in">set</span>		参数名		参数值</span><br><span class="line">rosparam 	<span class="built_in">set</span> 	/turtlesim/background_b		255</span><br></pre></td></tr></table></figure>
<h3 id="4-rosparam-dump"><a href="#4-rosparam-dump" class="headerlink" title="(4)rosparam dump"></a>(4)<code>rosparam dump</code></h3><p>把现在系统中的全局参数保存到一个文件，文件的类型为.yaml，文件存储到终端的当前路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	dump 	文件名.yaml</span><br></pre></td></tr></table></figure>
<h3 id="5-rosparam-load"><a href="#5-rosparam-load" class="headerlink" title="(5)rosparam load"></a>(5)<code>rosparam load</code></h3><p>从文件中加载参数，我们可以在文件中修改参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	load 	文件名.yaml</span><br></pre></td></tr></table></figure>
<h3 id="6-rosparam-delete"><a href="#6-rosparam-delete" class="headerlink" title="(6)rosparam delete"></a>(6)<code>rosparam delete</code></h3><p>删除某个参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosparam 	delete 	参数名</span><br></pre></td></tr></table></figure>
<h1 id="四、创建工作空间与功能包"><a href="#四、创建工作空间与功能包" class="headerlink" title="四、创建工作空间与功能包"></a>四、创建工作空间与功能包</h1><p>工作空间是用来存储ROS工程开发相关文件的文件夹。就像我们在使用IDE写代码的时候，首先要建立一个工程文件。</p>
<p>工作空间主要有四个文件夹：</p>
<ul>
<li>src：代码空间，用来放置功能包，所有功能包的代码，配置文件，launch文件存储在该处。</li>
<li>build：编译空间，放置编译过程中产生的中间文件。（一般不用管）</li>
<li>devel：开发空间，放置一些生成的可执行文件，库或脚本。</li>
<li>install：安装空间，安装位置。</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033041.png" alt="image-20211005030701463"></p>
<h2 id="1-创建工作空间"><a href="#1-创建工作空间" class="headerlink" title="1.创建工作空间"></a>1.创建工作空间</h2><p>(1)建立工作空间的文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir	-p	~/catkin_Name/src</span><br><span class="line"><span class="built_in">cd</span>		~/catkin_Name/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<p>(2)编译工作空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>(3)设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>		devel/setup.bash		</span><br></pre></td></tr></table></figure>
<p>(4)检查环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 	<span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>
<h2 id="2-创建功能包"><a href="#2-创建功能包" class="headerlink" title="2.创建功能包"></a>2.创建功能包</h2><p>如果要写代码，必须要创建功能包，因为功能包是ROS里放置源码的最小单元。</p>
<p>创建功能包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name/src</span><br><span class="line">catkin_create_pkg	功能包名	依赖1		依赖2		……</span><br></pre></td></tr></table></figure>
<p>编译功能包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 		~/catkin_Name</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span>		~/catkin_Name/devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>注意：同一个工作空间下，不允许存在同名的功能包。</p>
<h1 id="五、话题中各部分的编程实现"><a href="#五、话题中各部分的编程实现" class="headerlink" title="五、话题中各部分的编程实现"></a>五、话题中各部分的编程实现</h1><h2 id="1-发布者编程实现"><a href="#1-发布者编程实现" class="headerlink" title="1.发布者编程实现"></a>1.发布者编程实现</h2><p>之前我们控制的海龟是用键盘控制或者命令行控制，现在我们想通过编写一个程序来控制海龟的运动。这就需要写一个发布者的程序。</p>
<p>我们要清楚的是，发布者应该由节点充当。但是一个节点还可以对很多话题发布数据，所以我们在节点中，定义publisher来代表向一个话题的发布。它们之间的关系如下图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033056.png" alt="image-20211005164112040"></p>
<p>但容易混淆的是，发布消息的节点本身也可以叫做publisher。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033102.png" alt="image-20211005140716108"></p>
<h3 id="1-编写程序之前"><a href="#1-编写程序之前" class="headerlink" title="(1)编写程序之前"></a>(1)编写程序之前</h3><p>写具体的代码之前，我们要创建好工作空间，这里就不多说了。</p>
<p>然后要创建一个功能包。因为ROS的可执行文件都放在功能包中存储。如第四章第2节所述。功能包在工作空间的src文件夹下。</p>
<p>然后进入功能包，在功能包下的src文件夹中编写代码。</p>
<h3 id="2-代码实现过程"><a href="#2-代码实现过程" class="headerlink" title="(2)代码实现过程"></a>(2)代码实现过程</h3><ul>
<li>初始化ROS节点：在这一步要设置节点的名字。（在这里要注意节点名和可执行文件名的区别，节点可以理解为一个可执行文件，但这个可执行文件有一个名字，这个文件运行后会产生节点，节点也会有一个名字，这两个名字可能会有些不同。例如：在海龟仿真器中，功能包名字为turtlesim，生成节点的可执行文件名为turtlesim_node，运行后产生的节点名字为turtlesim）这里设置的就是运行后的节点名。</li>
<li>创建publisher，</li>
<li>向ROS Master注册节点信息，包括发布的话题名和话题中的消息类型。</li>
<li>创建消息数据。</li>
<li>按照一定频率循环发布的消息。</li>
</ul>
<p>如海龟速度发布程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ROS节点初始化</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建节点句柄，配置节点资源。</span></span><br><span class="line">	ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建一个Publisher，设置要往哪个话题发布什么样的消息内容。</span></span><br><span class="line"><span class="comment">	一个节点，可以发布不同的内容，用publisher来代表节点中不同的发布内容。</span></span><br><span class="line"><span class="comment"> 	在这里：发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，</span></span><br><span class="line"><span class="comment"> 	队列长度10，不能及时发布的数据就被存在队列中。*/</span></span><br><span class="line">	ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置循环的频率</span></span><br><span class="line">	<span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">// 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">		geometry_msgs::Twist vel_msg;<span class="comment">//数据类型是一个类，创建一个对象</span></span><br><span class="line">		vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">		vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 发布消息</span></span><br><span class="line">		turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">		<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, </span><br><span class="line">				vel_msg.linear.x, vel_msg.angular.z);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 按照循环频率延时</span></span><br><span class="line">	    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-编译代码"><a href="#3-编译代码" class="headerlink" title="(3)编译代码"></a>(3)编译代码</h3><p>编译代码，需要修改该程序包中的CMakeLists文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行文件名 	src/源码名)<span class="comment">#注意这里的可执行文件名就是一会要rosrun 功能包  可执行文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件名	<span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#这里直接用变量代替依赖的库路径，因为前面会自己找到依赖库的路径。</span></span><br></pre></td></tr></table></figure>
<p>然后回到工作空间根目录，用<code>catkin_make</code> 命令完成编译。</p>
<p>生成的可执行文件会在工作空间根目录下的devel/lib中找到。</p>
<h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="(4)配置环境变量"></a>(4)配置环境变量</h3><p>一定要设置环境变量，要不然系统是找不到这个可执行文件的。设置环境变量的文件是工作空间根目录下的devel中的setup.bash文件。</p>
<p>用下面的命令完成设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> 		devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>如果想避免重复的设置环境变量，也可以在终端的隐藏文件中设置。</p>
<p>首先打开主文件夹，然后按Ctrl+H快捷键显示隐藏文件，然后打开.bashrc，在最后面写上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> 		/home/pigpighero/工作空间/devel/setup.bash</span><br></pre></td></tr></table></figure>
<h3 id="5-运行"><a href="#5-运行" class="headerlink" title="(5)运行"></a>(5)运行</h3><p>接下来就可以在终端中运行这个发布者节点了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun  	功能包		可执行文件名</span><br></pre></td></tr></table></figure>
<h2 id="2-订阅者编程实现"><a href="#2-订阅者编程实现" class="headerlink" title="2.订阅者编程实现"></a>2.订阅者编程实现</h2><p>现在编程实现一个订阅者节点，和发布者是一样的，我们同样在功能包的src文件中编写代码。</p>
<p>代码的实现过程：</p>
<ul>
<li>初始化ROS节点</li>
<li>订阅需要的话题</li>
<li>循环等待话题消息，接收到消息后进入回调函数</li>
<li>在回调函数中完成消息处理</li>
</ul>
<p>在这里要注意一下回调函数，这和单片机开发中的中断函数类似，在收到消息后，可以立即跳入到回调函数中，完成消息的处理。</p>
<p>以订阅海龟的位置消息为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::Pose::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span></span><br><span class="line">    ros::Subscriber pose_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/turtle1/pose&quot;</span>, <span class="number">10</span>, poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后同样要注意编写CMakeLists文件和设置环境变量，这里都和前面一样。</p>
<h2 id="3-自定义话题消息结构"><a href="#3-自定义话题消息结构" class="headerlink" title="3.自定义话题消息结构"></a>3.自定义话题消息结构</h2><p>我们之前发布和订阅的话题的消息结构都是定义好的，我们现在自己来完成消息结构的定义。</p>
<p>下面我们用一个实际的例子，按照以下步骤来完成自定义的消息结构：</p>
<h3 id="1-定义msg文件"><a href="#1-定义msg文件" class="headerlink" title="(1)定义msg文件"></a>(1)定义msg文件</h3><p>消息的结构载体为.msg文件，这就是简单的纯文本文件，每一行由字段类型和字段名称组成。</p>
<p>我们首先在功能包中创建一个新的msg文件夹，用来存储所有的消息结构。</p>
<p>我们定义一个人的消息结构在Person.msg文件中：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">string 	name</span><br><span class="line">uint8 	sex</span><br><span class="line">uint8 	age</span><br></pre></td></tr></table></figure>
<h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="(2)编辑配置文件"></a>(2)编辑配置文件</h3><p><strong>首先要在package.xml中添加功能包依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033115.png" alt="image-20211005185240266"></p>
<p><strong>然后在CMakeLists添加相关配置</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation <span class="comment">#这个是后加的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033128.png" alt="image-20211005185707368"></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_message_files(FILES 	Person.msg)<span class="comment">#配置msg源文件</span></span><br><span class="line">generate_messages(DEPENDENCIES		std_msgs)<span class="comment">#生成消息时依赖于std_msgs</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行时依赖</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES learning_topic</span></span><br><span class="line">  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="(3)使用"></a>(3)使用</h3><p>最后就是编译了，在工作空间目录下使用<code>catkin_make</code> 命令完成。生成的文件在devel/include中。</p>
<p>在ROS中，消息的结构需要在发布和订阅消息的时候使用，我们先用一个.msg纯文本文件把消息结构写好，然后通过编译，生成头文件结构，这里面是包含该消息结构的类，我们在编写程序的时候可以直接引用头文件并使用。</p>
<p><strong>person_publisher.cpp:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_topic/Person.h&quot;</span><span class="comment">//这里引用头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span></span><br><span class="line">    ros::Publisher person_info_pub = n.advertise&lt;learning_topic::Person&gt;(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置循环的频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化learning_topic::Person类型的消息</span></span><br><span class="line">    	learning_topic::Person person_msg;</span><br><span class="line">		person_msg.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">		person_msg.age  = <span class="number">18</span>;</span><br><span class="line">		person_msg.sex  = learning_topic::Person::male;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">		person_info_pub.<span class="built_in">publish</span>(person_msg);</span><br><span class="line"></span><br><span class="line">       	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">				  person_msg.name.<span class="built_in">c_str</span>(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照循环频率延时</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>person_subscriber.cpp:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">personInfoCallback</span><span class="params">(<span class="keyword">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">			 msg-&gt;name.<span class="built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span></span><br><span class="line">    ros::Subscriber person_info_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，在CMakeLists中加入：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(person_publisher src/person_publisher.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_publisher <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(person_subscriber src/person_subscriber.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_subscriber <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033149.png" alt="image-20211005193520292"></p>
<p>注意：在话题通信中，话题的建立是通过建立发布者或订阅者的。比如说上面的Person_publisher.cpp程序中，在建立publisher时，要注明发送的话题，此时便建立了话题。</p>
<h1 id="六、服务中各部分的编程实现"><a href="#六、服务中各部分的编程实现" class="headerlink" title="六、服务中各部分的编程实现"></a>六、服务中各部分的编程实现</h1><h2 id="1-客户端编程实现"><a href="#1-客户端编程实现" class="headerlink" title="1.客户端编程实现"></a>1.客户端编程实现</h2><p>前面我们使用命令行对海龟仿真节点发送了一个请求，又生成了一只海龟，现在我们通过程序来发送请求。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033200.png" alt="image-20211005230349178"></p>
<p>和编写发布者的过程类似，先创建一个新的功能包。在代码实现过程，也是在创建节点的基础上编写请求数据。具体的程序内容主要包括以下部分：</p>
<ul>
<li>初始化ROS节点。</li>
<li>创建一个Client实例。</li>
<li>发布服务请求数据。</li>
<li>等待Server处理之后的应答结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);<span class="comment">//查询当前系统中是否有spanw服务，如果没有一直等待</span></span><br><span class="line">	ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">	turtlesim::Spawn srv;</span><br><span class="line">	srv.request.x = <span class="number">2.0</span>;</span><br><span class="line">	srv.request.y = <span class="number">2.0</span>;</span><br><span class="line">	srv.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, </span><br><span class="line">			 srv.request.x, srv.request.y, srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示服务调用结果</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spwan turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-服务端编程实现"><a href="#2-服务端编程实现" class="headerlink" title="2.服务端编程实现"></a>2.服务端编程实现</h2><p>在这一节，我们实现这样一个功能，就是客户端向服务端发送一个请求，让服务端来控制海龟。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033212.png" alt="image-20211005235128008"></p>
<p>这里面，这个服务叫做/turtle_command，发送的request数据类型为std_srvs::Trigger。</p>
<p>服务端的程序主要有以下几部分组成：</p>
<ul>
<li>初始化ROS节点</li>
<li>创建Server实例</li>
<li>循环等待服务请求，进入回调函数</li>
<li>在回调函数中完成服务功能的处理，并反馈应答数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_srvs/Trigger.h&gt;</span><span class="comment">//服务数据类型的头文件</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher turtle_vel_pub;</span><br><span class="line"><span class="keyword">bool</span> pubCommand = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">commandCallback</span><span class="params">(std_srvs::Trigger::Request  &amp;req,<span class="comment">//客户端发送的请求</span></span></span></span><br><span class="line"><span class="params"><span class="function">         			std_srvs::Trigger::Response &amp;res)</span><span class="comment">//服务端的回应</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pubCommand = !pubCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="literal">true</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置反馈数据</span></span><br><span class="line">	res.success = <span class="literal">true</span>;</span><br><span class="line">	res.message = <span class="string">&quot;Change turtle command state!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_command_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span></span><br><span class="line">    ros::ServiceServer command_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/turtle_command&quot;</span>, commandCallback);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">	turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to receive turtle command.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置循环的频率</span></span><br><span class="line">	<span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 查看一次回调函数队列</span></span><br><span class="line">    	ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果标志为true，则发布速度指令</span></span><br><span class="line">		<span class="keyword">if</span>(pubCommand)</span><br><span class="line">		&#123;</span><br><span class="line">			geometry_msgs::Twist vel_msg;</span><br><span class="line">			vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">			vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line">			turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//按照循环频率延时</span></span><br><span class="line">	    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序运行的过程是这样的，先是创建好Server和Publisher，然后等待请求，当有请求指令时，立即跳入到回调函数。回调函数中设置了输入数据的类型为std_srvs::Trigger::Request，当有这种类型的数据输入时，才跳入回调函数（在本例中，Request是空的，所以可以不用输入内容）。进入到回调函数后，pubCommand变为真，这在主函数的循环中，if语句开始执行，将发送话题数据twist，控制海龟移动。</p>
<p>呼叫服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosservice 		call 		/turtle_command </span><br></pre></td></tr></table></figure>
<h2 id="3-服务数据的定义与使用"><a href="#3-服务数据的定义与使用" class="headerlink" title="3.服务数据的定义与使用"></a>3.服务数据的定义与使用</h2><p>上一节我们用的服务数据为Trigger，这是ROS定义好的，我们现在来自己定义一个服务的数据。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033222.png" alt="image-20211006003654128"></p>
<p>我们要实现的功能如上所示，我们自己定义一个服务消息数据为Person，客户端可以发送请求，获得show_person服务，服务端发出一个回应。</p>
<h3 id="1-定义数据"><a href="#1-定义数据" class="headerlink" title="(1)定义数据"></a>(1)定义数据</h3><p>请求数据和回应数据中间用<code>---</code>来隔开，和话题消息数据定义一样，我们用写在一个纯文本文件中，文件格式为.srv。</p>
<p>先在功能包目录下建立一个文件夹srv。然后创建.srv文件。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033227.png" alt="image-20211006004641504"></p>
<h3 id="2-编辑配置文件-1"><a href="#2-编辑配置文件-1" class="headerlink" title="(2)编辑配置文件"></a>(2)编辑配置文件</h3><p>与话题消息几乎一样，只不过在CMakeLists中，话题消息的配置使用的是add_message_files(FILES Person.msg)，而在服务数据的配置使用的是add_service_files(FILES Person.srv)。</p>
<p><strong>首先要在package.xml中添加功能包依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033236.png" alt="image-20211005185240266"></p>
<p><strong>然后在CMakeLists添加相关配置</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation <span class="comment">#这个是后加的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033245.png" alt="image-20211005185707368"></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_service_files(FILES 	Person.srv)<span class="comment">#配置msg源文件</span></span><br><span class="line">generate_messages(DEPENDENCIES		std_msgs)<span class="comment">#生成消息时依赖于std_msgs</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行时依赖</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES learning_topic</span></span><br><span class="line">  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-1"><a href="#3-使用-1" class="headerlink" title="(3)使用"></a>(3)使用</h3><p>最后就是编译了，在工作空间目录下使用<code>catkin_make</code> 命令完成。生成的文件在devel/include中。</p>
<p><strong>客户端：person_client.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line">	ros::ServiceClient person_client = node.serviceClient&lt;learning_service::Person&gt;(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化learning_service::Person的请求数据</span></span><br><span class="line">	learning_service::Person srv;</span><br><span class="line">	srv.request.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">	srv.request.age  = <span class="number">20</span>;</span><br><span class="line">	srv.request.sex  = learning_service::Person::Request::male;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, </span><br><span class="line">			 srv.request.name.<span class="built_in">c_str</span>(), srv.request.age, srv.request.sex);</span><br><span class="line"></span><br><span class="line">	person_client.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示服务调用结果</span></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>服务端：person_server.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">personCallback</span><span class="params">(learning_service::Person::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         			learning_service::Person::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="built_in">c_str</span>(), req.age, req.sex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置反馈数据</span></span><br><span class="line">	res.result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span></span><br><span class="line">    ros::ServiceServer person_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/show_person&quot;</span>, personCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to show person informtion.&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，在CMakeLists中加入：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(person_client src/person_client.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_client <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_client <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(person_server src/person_server.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_server <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_server <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="七、参数的使用与编程方法"><a href="#七、参数的使用与编程方法" class="headerlink" title="七、参数的使用与编程方法"></a>七、参数的使用与编程方法</h1><p>ROS Master中有一个参数服务器，它可以存储全局参数，各个节点都可以访问（不同的主机也可访问）。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033258.png" alt="image-20211006011750764"></p>
<p>还是创建一个节点来实现用程序使用全局参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程设置/读取海龟例程中的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_srvs/Empty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;parameter_config&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">	ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">	ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用服务，刷新背景颜色</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">	ros::ServiceClient clear_background = node.serviceClient&lt;std_srvs::Empty&gt;(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">	std_srvs::Empty srv;</span><br><span class="line">	clear_background.<span class="built_in">call</span>(srv);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、ROS中的常用组件"><a href="#八、ROS中的常用组件" class="headerlink" title="八、ROS中的常用组件"></a>八、ROS中的常用组件</h1><h2 id="1-坐标变换管理系统-TF功能包"><a href="#1-坐标变换管理系统-TF功能包" class="headerlink" title="1.坐标变换管理系统-TF功能包"></a>1.坐标变换管理系统-TF功能包</h2><p>TF功能包能管理机器人中的各个坐标系之间的变换关系。</p>
<p>TF可以在分布式系统中进行操作，也就是说，一个机器人系统中所有的坐标变换关系，对于所有的节点组件都是可用的，所有订阅TF消息的节点都会缓冲一份所有坐标系的变换关系数据，所以这种结构不需要中心服务器来存储任何数据。</p>
<p>想要使用TF功能包，需要一下两个步骤：</p>
<ul>
<li>广播TF变换：向系统中广播坐标系之间的变换关系。就是通过节点，根据自身的位置和对方的位置，计算出变换关系。</li>
<li>监听TF变换：接收并缓存系统中发布的所有坐标变换数据，并从中查询所需要的坐标变换关系。</li>
</ul>
<p>在ROS中，使用树结构来进行管理。</p>
<p>例如一个小车，小车的中心点为base_link坐标系原点，上面有一个激光雷达，激光雷达中心为base_laser坐标系原点。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033322.png" alt="image-20211006021136321"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033318.png" alt="image-20211006021150776"></p>
<h3 id="1-一个例程"><a href="#1-一个例程" class="headerlink" title="(1)一个例程"></a>(1)一个例程</h3><p>在ROS中有一个例程，海龟跟踪，这个就是通过TF坐标来实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo 	apt-get		install		ros-melodic-turtle-tf  //下载例程文件</span><br><span class="line">roslaunch  	turtle_tf	turtle_tf_demo.launch //roslaunch命令是启动.launch文件，这个文件中包括了很多个节点</span><br><span class="line">rosrun 		turtlesim		turtle_teleop_key //启动键盘控制</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun 		tf		view_frames  //运行tf的一个可视化工具，会在当前路径下生成pdf文件，来表示当前坐标系关系</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033329.png" alt="image-20211006023541876"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tf		tf_echo		turtle1		turtle2  //显示两个坐标系间的关系</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033335.png" alt="image-20211006023636826"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun 	rviz	 rviz 	-d 		&#x27;rospack find turtle_tf&#x27;/rviz/turtle_rviz.rviz		//运行rviz可视化工具，可以查看坐标关系</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033340.png" alt="image-20211006023829401" style="zoom:50%;" /></p>
<h3 id="2-创建TF广播器"><a href="#2-创建TF广播器" class="headerlink" title="(2)创建TF广播器"></a>(2)创建TF广播器</h3><p>首先，我们需要创建一个发布乌龟坐标系和世界坐标系之间TF变换的节点。然后这个节点可以把坐标变换关系发送到TF树中。</p>
<ul>
<li>定义TF广播器</li>
<li>创建坐标变换值</li>
<li>发布坐标变换</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程产生tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建tf的广播器</span></span><br><span class="line">	<span class="keyword">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化tf数据</span></span><br><span class="line">	tf::Transform transform;<span class="comment">//坐标变换矩阵4*4</span></span><br><span class="line">	transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );<span class="comment">//设置平移</span></span><br><span class="line">	tf::Quaternion q;</span><br><span class="line">	q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);<span class="comment">//设置四元数</span></span><br><span class="line">	transform.<span class="built_in">setRotation</span>(q);<span class="comment">//设置旋转</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 广播world与海龟坐标系之间的tf数据</span></span><br><span class="line">	br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));<span class="comment">//将坐标变换关系发送到坐标树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输入参数作为海龟的名字</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 订阅海龟的位姿话题</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line">	ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">	ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-创建TF监听器"><a href="#3-创建TF监听器" class="headerlink" title="(3)创建TF监听器"></a>(3)创建TF监听器</h3><p>监听器的作用就是从TF树中获取坐标变换关系。</p>
<ul>
<li>定义TF监听器</li>
<li>查找坐标变换</li>
</ul>
<p>现在我们从TF树中获取turtle2相对于turtle1的坐标变换，从而控制turtle2的移动。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化ROS节点</span></span><br><span class="line">	ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">	ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求产生turtle2</span></span><br><span class="line">	ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">	turtlesim::Spawn srv;</span><br><span class="line">	add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建发布turtle2速度控制指令的发布者</span></span><br><span class="line">	ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建tf的监听器</span></span><br><span class="line">	tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line">	<span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">		tf::StampedTransform transform;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));<span class="comment">//等待TF数据，看系统中是否有这个数据。</span></span><br><span class="line">			listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);<span class="comment">//查询数据，结果保存到transform里</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span> (tf::TransformException &amp;ex) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">			ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span></span><br><span class="line">		geometry_msgs::Twist vel_msg;</span><br><span class="line">		vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">				                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">		vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">				                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">		turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">		rate.<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-Launch文件"><a href="#2-Launch文件" class="headerlink" title="2.Launch文件"></a>2.Launch文件</h2><p>前面我们每启动一个节点，都需要在终端中输入一个命令，这十分麻烦，我们可以用启动文件来进行运行，这样一次就可以启动多个节点，还可以自动启动ROS Master节点管理器，并实现每个节点的各种配置。</p>
<p>Launch文件是一个.XML文件。它可以自动启动ROS Master。</p>
<h3 id="1-根元素"><a href="#1-根元素" class="headerlink" title="(1)根元素"></a>(1)根元素</h3><p>XML文件中必须包含一个根元素，采用<code>&lt;launch&gt;</code>标签定义，文件中其他的内容都必须在这个标签内。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">其他内容</span><br><span class="line">&lt;\launch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-节点元素"><a href="#2-节点元素" class="headerlink" title="(2)节点元素"></a>(2)节点元素</h3><p>采用节点标签定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span>	<span class="attr">pkg</span>=<span class="string">&quot;功能包名字&quot;</span>   <span class="attr">type</span>=<span class="string">&quot;可执行文件名字&quot;</span>	<span class="attr">name</span>=<span class="string">&quot;节点名字&quot;</span>		/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这三个属性是最基本的属性，后面节点的名字是定义运行该可执行文件产生的节点名字，会覆盖节点中init()赋予的节点名字。</p>
<p>在节点元素中，我们还可以增加其他属性。</p>
<p><code>output=&quot;screen&quot;</code> ：讲节点的标准输出打印到终端屏幕，默认输出为日志文档。</p>
<p><code>respawn=&quot;true&quot;</code>：复位属性，该节点停止时，会自动重启，默认为false。</p>
<p><code>required=&quot;true&quot;</code> ：必要节点，该节点终止时，launch文件中的其他节点也被终止。</p>
<p><code>ns=&quot;namespace&quot;</code> ：命名空间，为节点内的相对名称添加命名空间前缀。</p>
<p><code>args=&quot;arguments&quot;</code> ：节点需要的输入参数。</p>
<h3 id="3-参数元素"><a href="#3-参数元素" class="headerlink" title="(3)参数元素"></a>(3)参数元素</h3><p>为了方便全局参数的修改和设置，我们使用参数设置标签<code>&lt;param&gt;</code> 或 <code>&lt;rosparam&gt;</code> 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> 		<span class="attr">name</span>=<span class="string">&quot;参数名字&quot;</span>		<span class="attr">value</span>=<span class="string">&quot;设置参数值&quot;</span>   /&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是还是觉得一条一条的打很麻烦，我们还可以用加载参数文件的方式。</p>
<p><code>&lt;rosparam&gt;</code> 可以帮助我们将一个YAML格式文件中的参数全部加载到ROS参数服务器中，需要设置command属性为”load”，还可以设置命名空间”ns”。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span>  	<span class="attr">file</span>=<span class="string">&quot;文件名.YAML&quot;</span>		<span class="attr">command</span>=<span class="string">&quot;load&quot;</span>		<span class="attr">ns</span>=<span class="string">&quot;命名空间&quot;</span>		/&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有一个参数，就是launch文件中的参数，类似于文件内部的局部变量，仅限于在launch文件中使用，与ROS的参数无关。我们可以用<code>&lt;arg&gt;</code> 来设置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> 	<span class="attr">name</span>=<span class="string">&quot;参数名&quot;</span>		<span class="attr">default</span>=<span class="string">&quot;参数值&quot;</span>	/&gt;</span>   //设置参数</span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> 		<span class="attr">name</span>=<span class="string">&quot;foo&quot;</span>		<span class="attr">value</span>=<span class="string">&quot;$&#123;arg		设置的参数名&#125;&quot;</span>	/&gt;</span>		//使用这个参数</span><br></pre></td></tr></table></figure>
<h3 id="4-重映射机制"><a href="#4-重映射机制" class="headerlink" title="(4)重映射机制"></a>(4)重映射机制</h3><p>在别人的功能包的接口和自己要用的不一样的时候，我们可以将这个功能包改一个名字。例如，turtlebot的键盘控制节点发布的速度指令话题为/turtlebot/cmd_vel，但是我们的机器人订阅的速度控制话题是/cmd_vel，这是使用<code>&lt;remap&gt;</code> 就可以进行重映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span>	<span class="attr">from</span>=<span class="string">&quot;/turtlebot/cmd_vel&quot;</span>	<span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span>	/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-嵌套复用"><a href="#5-嵌套复用" class="headerlink" title="(5)嵌套复用"></a>(5)嵌套复用</h3><p>在复杂系统中，launch文件往往有很多，这些launch文件之间也可能会存在依赖关系，如果要直接服用一个已有launch文件中的内容，可以使用<code>&lt;include&gt;</code> 标签包含其他launch文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>	<span class="attr">file</span>=<span class="string">&quot;$&#123;dirname&#125;/other.launch&quot;</span>	/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-使用"><a href="#6-使用" class="headerlink" title="(6)使用"></a>(6)使用</h3><p>写好launch文件后，将其放在名为launch的文件夹中，然后在工作空间目录打开终端，使用<code>catkin_make</code> 进行编译，然后使用<code>roslaunch</code>直接运行launch文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch	功能包		launch文件</span><br></pre></td></tr></table></figure>
<h2 id="3-QT工具箱"><a href="#3-QT工具箱" class="headerlink" title="3.QT工具箱"></a>3.QT工具箱</h2><p>为了方便可视化调试和显示，ROS提供了QT工具箱。</p>
<p>以<code>rqt</code> 开头的命令即为QT工具的命令。</p>
<p><code>rqt_graph</code>     显示系统的计算图，通过这张图可以了解整个系统的全貌。</p>
<p><code>rqt_console</code>     显示工作日志信息。</p>
<p><code>rqt_plot</code>     数据绘图工具。</p>
<p><code>rosrun     rqt_reconfigure    rqt_reconfigure</code>    参数动态配置，可以在不重启系统时，动态配置ROS系统中的参数。</p>
<p><code>rqt_imag</code>     有摄像头时，显示图像。</p>
<p><code>rqt</code>    所有工具的集合窗口，在界面中选择工具。</p>
<h2 id="4-rviz三维可视化平台"><a href="#4-rviz三维可视化平台" class="headerlink" title="4.rviz三维可视化平台"></a>4.rviz三维可视化平台</h2><p>启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun	rviz	rviz</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033355.png" alt="image-20211007011943519"></p>
<h2 id="5-Gazebo"><a href="#5-Gazebo" class="headerlink" title="5.Gazebo"></a>5.Gazebo</h2><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033402.png" alt="image-20211007012012849"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033410.png" alt="image-20211007012025774"></p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用URDF创建机器人模型</title>
    <url>/2021/10/18/ROS%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>编写urdf文件，创建机器人模型，可以在rviz中可视化或导入到gazebo中仿真。<br><span id="more"></span></p>
<h1 id="一、介绍urdf"><a href="#一、介绍urdf" class="headerlink" title="一、介绍urdf"></a>一、介绍urdf</h1><p>urdf是一个xml文件，通过参数服务器读取URDF文件，可以建立机器人模型，并在rviz或gazebo中可视化机器人模型。xacro是可编程urdf文件，可以定义宏和变量来优化urdf文件的编写过程，然后在生成urdf文件。</p>
<p>在仿真的过程中，我们会接触两个软件，一个是rviz，另一个是gazebo。</p>
<p>rviz是一个可视化工具，它可以将ros中的数据可视化出来。</p>
<p>gazebo是一个仿真工具，它可以建立真实的物理仿真环境，产生实验结果数据。</p>
<p>内容包括：</p>
<ul>
<li>URDF文件编写</li>
<li>使用xacro来编写URDF文件</li>
<li>设置传感器</li>
</ul>
<h1 id="二、urdf文件编写与在rviz中可视化"><a href="#二、urdf文件编写与在rviz中可视化" class="headerlink" title="二、urdf文件编写与在rviz中可视化"></a>二、urdf文件编写与在rviz中可视化</h1><h2 id="1-创建功能包"><a href="#1-创建功能包" class="headerlink" title="1.创建功能包"></a>1.创建功能包</h2><p>创建功能包，功能包的依赖有urdf，xacro</p>
<p>在功能包下建立<code>urdf文件夹</code>，和<code>launch文件夹</code> 。</p>
<p>在urdf文件夹下建立<code>.urdf</code>文件。</p>
<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;foot_print&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- &lt;cylinder radius=&quot;1&quot; length=&quot;1&quot;/&gt;   --&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- &lt;box size=&quot;length width height&quot;/&gt; --&gt;</span></span><br><span class="line">           			<span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span>/&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- &lt;mesh filename=&quot;package://mesh/xxx.stl&quot; --&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>       <span class="comment">&lt;!--set origin position--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rbga</span>=<span class="string">&quot;0 0 0 1&quot;</span>/&gt;</span>         <span class="comment">&lt;!--set color--&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- &lt;box size=&quot;length width height&quot;/&gt; --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;sphere radius=&quot;r&quot;/&gt; --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;mesh filename=&quot;package://mesh/xxx.stl&quot; --&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>       <span class="comment">&lt;!--set origin position--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">color</span> <span class="attr">rbga</span>=<span class="string">&quot;0 0 0 1&quot;</span>/&gt;</span>         <span class="comment">&lt;!--set color--&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;body2foot_print&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span>   <span class="comment">&lt;!--set joint name and type(such as : fixed continous ...)--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;foot_print&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;body&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>    <span class="comment">&lt;!--set joint position--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>            <span class="comment">&lt;!--set rotation axis--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在编写urdf时可以直接复制，然后修改。</p>
<blockquote>
<p>注意urdf中的joint位置，就是child link的坐标系相对于parent link的位置和角度，然后旋转轴的选择是根据parent link坐标轴定的。</p>
</blockquote>
<h2 id="3-编写launch文件"><a href="#3-编写launch文件" class="headerlink" title="3.编写launch文件"></a>3.编写launch文件</h2><p>在launch文件夹下新建一个.launch文件。</p>
<p>我们需要启动rviz，并把urdf文件导入。rviz启动后可以自动载入解析urdf文件。</p>
<p>在ros中，我们要把urdf文件的路径设置到参数服务器中，使用参数名为 <code>robot_description</code> ,==注意参数名必须是这个==。</p>
<p>代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--set parameters--&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span>  <span class="attr">textfile</span>=<span class="string">&quot;$(find package)/urdf/xxx.urdf&quot;</span>/&gt;</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">&lt;!--run rviz node--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">	    <span class="comment">&lt;!--run robot and joint state publish node--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面还有两句话，是要启动机器人状态和关节状态发布节点。这样才能在rviz中正常显示出机器人。</p>
<h2 id="4-其他补充"><a href="#4-其他补充" class="headerlink" title="4.其他补充"></a>4.其他补充</h2><h3 id="1-保存和调用rviz配置文件"><a href="#1-保存和调用rviz配置文件" class="headerlink" title="(1)保存和调用rviz配置文件"></a>(1)保存和调用rviz配置文件</h3><p>我们在rviz中，设置的一些配置选项，可以保存成.rviz文件，并保存在功能包下的<code>config</code>文件夹。</p>
<p>在rviz中的工具栏<code>file</code>中，有<code>save config as</code> ，便可以保存配置信息。</p>
<p>然后在3中的launch文件中，修改一下最后一行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--run rviz node--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find package)/config/xxx.rviz/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-检查urdf文件"><a href="#2-检查urdf文件" class="headerlink" title="(2)检查urdf文件"></a>(2)检查urdf文件</h3><p>在写完urdf文件后，我们并不知道写的对不对，因此可以用<code>check_urdf</code>个工具来进行检查。</p>
<p>首先要进入urdf的文件目录。</p>
<p>然后在终端输入<code>check_urdf xxx.urdf</code> 来进行检查。</p>
<p>如果语法没有问题，终端就会显示root link和child link。</p>
<h3 id="3-查看刚体结构信息"><a href="#3-查看刚体结构信息" class="headerlink" title="(3)查看刚体结构信息"></a>(3)查看刚体结构信息</h3><p>我们生成的是机器人模型，机器人中各部分的关系我们也可以用图像的方式进行查看。</p>
<p>首先进入urdf文件所在目录。</p>
<p>在终端输入<code>urdf_to_graphiz xxx.urdf</code>，然后就会在该目录下生成一个pdf文件，显示各刚体间的关系。</p>
<h1 id="三、xacro文件编写"><a href="#三、xacro文件编写" class="headerlink" title="三、xacro文件编写"></a>三、xacro文件编写</h1><p>前面我们介绍了urdf文件的编写，但是有一个问题就是，每当编写一个link时，都要写一串代码，不能提高代码的复用率。所以，xacro文件就是一种可以编程的urdf文件，它可以定义宏（也就是函数）和变量，来编辑urdf，这样方便后面的参数修改和代码复用。</p>
<h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现"></a>1.代码实现</h2><h3 id="1-包含xlmns空间"><a href="#1-包含xlmns空间" class="headerlink" title="(1)包含xlmns空间"></a>(1)包含xlmns空间</h3><p>具体的urdf格式和之前都相同，不同的是就是可以把urdf的代码进行封装和调用。</p>
<p>这里要注意，使用xacro写urdf时，一定要加上<code>xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span> </span><br><span class="line">		</span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-变量封装与调用"><a href="#2-变量封装与调用" class="headerlink" title="(2)变量封装与调用"></a>(2)变量封装与调用</h3><p>封装：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;Param_Name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;body&quot;</span>/&gt;</span>     </span><br></pre></td></tr></table></figure>
<p>调用：在调用处，用花括号来使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;Param_Name&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-宏-函数-定义与调用"><a href="#3-宏-函数-定义与调用" class="headerlink" title="(3)宏(函数)定义与调用"></a>(3)宏(函数)定义与调用</h3><p>我们现在以生成刚体为例，首先要写清楚宏的名字，然后传入的变量名。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;creat_link&quot;</span> <span class="attr">params</span>=<span class="string">&quot;name  radius length color&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">gemometry</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;length&#125;&quot;</span>/&gt;</span>                                    	</span><br><span class="line">         <span class="tag">&lt;/<span class="name">gemometry</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;radius/2&#125; 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>调用的时候直接传入参数即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:creat_link</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span> <span class="attr">color</span>=<span class="string">&quot;black&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-头文件包含"><a href="#4-头文件包含" class="headerlink" title="(4)头文件包含"></a>(4)头文件包含</h3><p>一个xacro文件可以包含另一个xacro文件，因此我们可以分文件给机器人各个部分建模。</p>
<p>包含头文件的相对路径为当前xacro文件所在的路径，也可以使用绝对路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;xxx.xacro&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-xacro转换为urdf文件"><a href="#2-xacro转换为urdf文件" class="headerlink" title="2.xacro转换为urdf文件"></a>2.xacro转换为urdf文件</h2><p>可以通过ros中的节点将xacro文件转换成urdf文件。</p>
<p>进入xacro所在目录，在终端中输入<code>rosrun xacro xacro xxx.xacro &gt; xxx.urdf</code></p>
<h2 id="3-launch文件编写"><a href="#3-launch文件编写" class="headerlink" title="3.launch文件编写"></a>3.launch文件编写</h2><p>如2中所述，我们可以现将xacro文件转换成urdf文件，然后再将其导入参数服务器。</p>
<p>还有一种方法是不生成中间的urdf文件，在launch文件中编写直接导入到参数服务器。</p>
<p>代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> = <span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span> = <span class="string">&quot;$(find xacro)/xacro $(find package)/urdf/xxx.xacro&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>加载robot_description 时使用command属性，属性值是调用xacro功能包的xacro程序直接解析xacro文件。</p>
<p>这样就可以在正常显示机器人了。</p>
<blockquote>
<p>注意：在使用gazebo插件时，例如后面提到的相机传感器等，使用的是xacro配置文件，那么就必须要调用xacro功能包中的xacro程序来进行解析，否则传感器是不能仿真成功的。切记切记，我之前就直接把xacro文件当成urdf文件了，结果摄像头显示失败。</p>
</blockquote>
<h1 id="四、urdf集成到gazebo"><a href="#四、urdf集成到gazebo" class="headerlink" title="四、urdf集成到gazebo"></a>四、urdf集成到gazebo</h1><p>从urdf集成到gazebo与集成到rviz不同，因为rviz是可视化工具，所以不需要知道机器人各部分的物理属性，而到gazebo中，则需要将这些物理属性配置出来。</p>
<p>主要的不同点有：</p>
<ul>
<li>在urdf编写时，还要加入<code>&lt;collision&gt;</code>和<code>&lt;inertial&gt;</code>两个标签。</li>
<li>urdf的颜色属性，由gazebo来配置。</li>
</ul>
<p>在创建功能包的时候，我们添加的依赖有urdf,xacro,gazebo_ros,gazebo_ros_control,gazebo_plugins</p>
<h2 id="1-urdf代码实现"><a href="#1-urdf代码实现" class="headerlink" title="1.urdf代码实现"></a>1.urdf代码实现</h2><h3 id="1-添加-lt-collision-gt-和-lt-inertial-gt"><a href="#1-添加-lt-collision-gt-和-lt-inertial-gt" class="headerlink" title="(1)添加&lt;collision&gt;和&lt;inertial&gt;"></a>(1)添加<code>&lt;collision&gt;</code>和<code>&lt;inertial&gt;</code></h3><p>第一个不同就是要添加<code>&lt;collision&gt;</code>和<code>&lt;inertial&gt;</code>两个标签，<code>&lt;collision&gt;</code>的子标签和<code>&lt;geometry&gt;</code>类似。而<code>&lt;inertial&gt;</code>标签是添加刚体的惯性属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;car&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;foot_print&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">geometry</span>&gt;</span>                           </span><br><span class="line">        		<span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span>/&gt;</span>                              </span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span>       <span class="comment">&lt;!--set origin position--&gt;</span></span><br><span class="line">   		  <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">color</span> <span class="attr">rbga</span>=<span class="string">&quot;0 0 0 1&quot;</span>/&gt;</span>         <span class="comment">&lt;!--set color--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">                    </span><br><span class="line">		<span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span>                           </span><br><span class="line">        		<span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span>/&gt;</span>                              </span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">                    </span><br><span class="line">		<span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;1&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-计算惯性矩阵宏"><a href="#2-计算惯性矩阵宏" class="headerlink" title="(2)计算惯性矩阵宏"></a>(2)计算惯性矩阵宏</h3><p>在ros中有通过xacro定义的宏来计算。</p>
<p>球体惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Macro for inertia matrix --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;sphere_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>圆柱惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;cylinder_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m r h&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="attr">iyz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*r*r/2&#125;&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>立方体惯性矩阵</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;Box_inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;m l w h&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;$&#123;m*(h*h + l*l)/12&#125;&quot;</span> <span class="attr">ixy</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ixz</span> = <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">iyy</span>=<span class="string">&quot;$&#123;m*(w*w + l*l)/12&#125;&quot;</span> <span class="attr">iyz</span>= <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">izz</span>=<span class="string">&quot;$&#123;m*(w*w + h*h)/12&#125;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，原则上，除了 base_footprint 外，机器人的每个刚体部分都需要设置惯性矩阵，且惯性矩阵必须经计算得出，如果随意定义刚体部分的惯性矩阵，那么可能会导致机器人在 Gazebo 中出现抖动，移动等现象。</p>
<h3 id="3-添加颜色"><a href="#3-添加颜色" class="headerlink" title="(3)添加颜色"></a>(3)添加颜色</h3><p>如果要在gazebo中显示link的颜色，必须使用gazebo指定的标签。</p>
<p>其中Gazebo的G必须大写，颜色首字母也必须大写。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;link_name&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Blue<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-launch文件"><a href="#2-launch文件" class="headerlink" title="2.launch文件"></a>2.launch文件</h2><p>启动gazebo，我们调用gazebo功能包中的launch文件。</p>
<p>在这里我们用include包含<code>empty_world.launch</code>文件，然后我们用参数导入我们需要的世界环境。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find package)/worlds/box_house.world&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在gazebo中加载机器人模型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model car -param robot_description&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这句话的意思是启动<code>gazebo_ros</code>中的<code>spawn_model</code>节点，然后加载参数服务器中的<code>robot_description</code>。</p>
<p><code>-urdf</code>是说加载的是urdf文件 </p>
<p><code>-model car</code>是把这个模型命名为car</p>
<p><code>-param robot_description</code> 从参数robot_description 中载入模型。</p>
<p>最终的launch文件为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span> = <span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span> = <span class="string">&quot;$(find xacro)/xacro $(find package)/urdf/xxx.xacro&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  	<span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find package)/world/xx.world&quot;</span></span></span><br><span class="line"><span class="tag">    &lt;/<span class="attr">include</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model car  -param robot_description&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-配置传感器"><a href="#3-配置传感器" class="headerlink" title="3.配置传感器"></a>3.配置传感器</h2><p>gazebo作为仿真工具，有一些插件，在urdf文件编写的时候，可以将这些插件赋予机器人的各个部分。</p>
<p>例如可以为轮子赋予驱动器，也就是电机。为我们建立的相机模型，赋予相机的功能。这些都需要gazebo提供的插件。</p>
<h3 id="1-运动控制器"><a href="#1-运动控制器" class="headerlink" title="(1)运动控制器"></a>(1)运动控制器</h3><p>gazebo自带运动控制器，它可以为驱动器输入控制信号。</p>
<p>首先，我们要设置驱动器位置，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;joint_trans&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- Transmission is important to link the joints and the controller --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_trans&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_motor&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;wheel_front_left2body&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;wheel_front_right2body&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里我们输入放置驱动器部位的关节名称。</p>
<p>驱动器建立好后，我们再配置控制器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;differential_drive_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_diff_drive.so&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">rosDebugLevel</span>&gt;</span>Debug<span class="tag">&lt;/<span class="name">rosDebugLevel</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">publishWheelTF</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publishWheelTF</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">robotNamespace</span>&gt;</span>/<span class="tag">&lt;/<span class="name">robotNamespace</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">publishTf</span>&gt;</span>1<span class="tag">&lt;/<span class="name">publishTf</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">publishWheelJointState</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publishWheelJointState</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>100.0<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">legacyMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">legacyMode</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">leftJoint</span>&gt;</span>wheel_front_left2body<span class="tag">&lt;/<span class="name">leftJoint</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">rightJoint</span>&gt;</span>wheel_front_right2body<span class="tag">&lt;/<span class="name">rightJoint</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">wheelSeparation</span>&gt;</span>$&#123;body_width * 2&#125;<span class="tag">&lt;/<span class="name">wheelSeparation</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">wheelDiameter</span>&gt;</span>$&#123;wheel_radius * 2&#125;<span class="tag">&lt;/<span class="name">wheelDiameter</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">broadcastTF</span>&gt;</span>1<span class="tag">&lt;/<span class="name">broadcastTF</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">wheelTorque</span>&gt;</span>300<span class="tag">&lt;/<span class="name">wheelTorque</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">wheelAcceleration</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">wheelAcceleration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">commandTopic</span>&gt;</span>cmd_vel<span class="tag">&lt;/<span class="name">commandTopic</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">odometryFrame</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometryFrame</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">odometryTopic</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometryTopic</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">robotBaseFrame</span>&gt;</span>foot_print<span class="tag">&lt;/<span class="name">robotBaseFrame</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-相机"><a href="#2-相机" class="headerlink" title="(2)相机"></a>(2)相机</h3><p>在建立好相机刚体模型后，我们可以为这个刚体模型赋予相机的功能。</p>
<p>另外要注意的是，相机的视角是沿着所依附link的x轴正方向，例如相机的x轴朝前，相机的视角就是超前。如果想让相机朝下看，那么在设置相机joint的时候，就让link的x轴朝下方。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;camera&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera_node&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>30.0<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="tag">&lt;<span class="name">camera</span> <span class="attr">name</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">horizontal_fov</span>&gt;</span>1.3962634<span class="tag">&lt;/<span class="name">horizontal_fov</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">width</span>&gt;</span>1280<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">height</span>&gt;</span>720<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">format</span>&gt;</span>R8G8B8<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clip</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">near</span>&gt;</span>0.02<span class="tag">&lt;/<span class="name">near</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">far</span>&gt;</span>300<span class="tag">&lt;/<span class="name">far</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">clip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>gaussian<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mean</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">mean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">stddev</span>&gt;</span>0.007<span class="tag">&lt;/<span class="name">stddev</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noise</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_camera&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_camera.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cameraName</span>&gt;</span>/camera<span class="tag">&lt;/<span class="name">cameraName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageTopicName</span>&gt;</span>image_raw<span class="tag">&lt;/<span class="name">imageTopicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cameraInfoTopicName</span>&gt;</span>camera_info<span class="tag">&lt;/<span class="name">cameraInfoTopicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>camera<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hackBaseline</span>&gt;</span>0.07<span class="tag">&lt;/<span class="name">hackBaseline</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionK3</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionK3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionT1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionT1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">distortionT2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortionT2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-雷达"><a href="#3-雷达" class="headerlink" title="(3)雷达"></a>(3)雷达</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;laser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;ray&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rplidar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pose</span>&gt;</span>0 0 0 0 0 0<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">visualize</span>&gt;</span>true<span class="tag">&lt;/<span class="name">visualize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>5.5<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ray</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scan</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horizontal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">samples</span>&gt;</span>360<span class="tag">&lt;/<span class="name">samples</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resolution</span>&gt;</span>1<span class="tag">&lt;/<span class="name">resolution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">min_angle</span>&gt;</span>-3<span class="tag">&lt;/<span class="name">min_angle</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max_angle</span>&gt;</span>3<span class="tag">&lt;/<span class="name">max_angle</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">horizontal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">scan</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">range</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">min</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">min</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">max</span>&gt;</span>30.0<span class="tag">&lt;/<span class="name">max</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resolution</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">resolution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">range</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noise</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>gaussian<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mean</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">mean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">stddev</span>&gt;</span>0.01<span class="tag">&lt;/<span class="name">stddev</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noise</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ray</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_rplidar&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_laser.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">topicName</span>&gt;</span>/scan<span class="tag">&lt;/<span class="name">topicName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>laser<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-深度相机"><a href="#4-深度相机" class="headerlink" title="(4)深度相机"></a>(4)深度相机</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_sensors&quot;</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;support&quot;</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;depth&quot;</span> <span class="attr">name</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">always_on</span>&gt;</span>true<span class="tag">&lt;/<span class="name">always_on</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">camera</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">horizontal_fov</span>&gt;</span>$&#123;60.0*PI/180.0&#125;<span class="tag">&lt;/<span class="name">horizontal_fov</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">format</span>&gt;</span>R8G8B8<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">width</span>&gt;</span>640<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">height</span>&gt;</span>480<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">clip</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">near</span>&gt;</span>0.05<span class="tag">&lt;/<span class="name">near</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">far</span>&gt;</span>8.0<span class="tag">&lt;/<span class="name">far</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">clip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">camera</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;kinect_camera_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_openni_kinect.so&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cameraName</span>&gt;</span>camera<span class="tag">&lt;/<span class="name">cameraName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">alwaysOn</span>&gt;</span>true<span class="tag">&lt;/<span class="name">alwaysOn</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">updateRate</span>&gt;</span>10<span class="tag">&lt;/<span class="name">updateRate</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">imageTopicName</span>&gt;</span>rgb/image_raw<span class="tag">&lt;/<span class="name">imageTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">depthImageTopicName</span>&gt;</span>depth/image_raw<span class="tag">&lt;/<span class="name">depthImageTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pointCloudTopicName</span>&gt;</span>depth/points<span class="tag">&lt;/<span class="name">pointCloudTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cameraInfoTopicName</span>&gt;</span>rgb/camera_info<span class="tag">&lt;/<span class="name">cameraInfoTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">depthImageCameraInfoTopicName</span>&gt;</span>depth/camera_info<span class="tag">&lt;/<span class="name">depthImageCameraInfoTopicName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">frameName</span>&gt;</span>body<span class="tag">&lt;/<span class="name">frameName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">baseline</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">baseline</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_k3</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_k3</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_t1</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_t1</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">distortion_t2</span>&gt;</span>0.0<span class="tag">&lt;/<span class="name">distortion_t2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pointCloudCutoff</span>&gt;</span>0.4<span class="tag">&lt;/<span class="name">pointCloudCutoff</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">sensor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS开发环境搭建</title>
    <url>/2021/10/21/ROS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本文介绍如何创建ROS的工作空间，编程的开发环境。<br><span id="more"></span></p>
<h1 id="一、文件系统介绍"><a href="#一、文件系统介绍" class="headerlink" title="一、文件系统介绍"></a>一、文件系统介绍</h1><p>首先介绍一下ROS中的文件系统。<br>ROS文件系统指的是在硬盘上，ROS源码的组织形式。大致结构如下图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033529.png" alt="image-20211021164223501"></p>
<p>Workspace：为自定义的工作空间。</p>
<ul>
<li>build：编译空间，放置编译过程中产生的文件。（我们可以不用管）</li>
<li>devel：开发空间，用于存放编译后生成的目标文件，包括头文件、动态或静态链接库、可执行文件。</li>
<li>src：存放源码。各个功能包的源码文件就在该目录下。<ul>
<li>CMakeLists.txt：存储编译的基本配置。</li>
<li>Package：功能包，包含多个节点、库与配置文件源码。<ul>
<li>CMakeLists.txt：配置编译规则(与上层CMakeLists不同的是，此处仅配置该功能包下的编译规则)。</li>
<li>package.xml：包信息，比如：包名、版本、作者、依赖项等。</li>
<li>scripts：存储python源文件。</li>
<li>src：存储C++源文件。</li>
<li>include：头文件</li>
<li>msg：存储话题消息通信格式文件。</li>
<li>srv：存储服务通信格式文件。</li>
<li>launch：存储launch文件。</li>
<li>config：存储配置文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>关于文件系统的相关命令</strong></p>
<h2 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h2><p><code>catkin_create_pkg 自定义包名 依赖包</code>     创建新的ROS功能包</p>
<p><code>sudo apt install xxx</code>       安装 ROS功能包</p>
<h2 id="2-删"><a href="#2-删" class="headerlink" title="2.删"></a>2.删</h2><p><code>sudo apt purge xxx</code>       删除某个功能包</p>
<h2 id="3-查"><a href="#3-查" class="headerlink" title="3.查"></a>3.查</h2><p><code>rospack list</code>     列出所有功能包</p>
<p><code>rospack find 包名</code>      查找某个功能包是否存在，如果存在返回安装路径</p>
<p><code>roscd 包名</code>      进入某个功能包</p>
<p><code>rosls 包名</code>        列出某个包下的文件</p>
<p><code>apt search xxx</code>    搜索某个功能包</p>
<h2 id="4-改"><a href="#4-改" class="headerlink" title="4.改"></a>4.改</h2><p><code>rosed 包名 文件名</code>        修改功能包文件</p>
<p>需要安装 vim</p>
<p><strong>比如:</strong><code>rosed turtlesim Color.msg</code></p>
<h1 id="二、ROS开发环境搭建"><a href="#二、ROS开发环境搭建" class="headerlink" title="二、ROS开发环境搭建"></a>二、ROS开发环境搭建</h1><p>在介绍完了文件系统后，我们就可以搭建开发环境了。开发环境就是我们写代码然后又能运行所需要的环境。如果想运行我们写的代码，大致分为三个阶段。分别为准备阶段，编写阶段，编译阶段。</p>
<p>在前期的准备阶段，我们要创建一个写代码的地方。</p>
<h2 id="1-创建工作空间"><a href="#1-创建工作空间" class="headerlink" title="1.创建工作空间"></a>1.创建工作空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p 自定义工作空间名/src</span><br><span class="line"><span class="built_in">cd</span> 自定义工作空间名</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>上述命令，首先会创建一个工作空间以及一个<code>src</code>子目录，然后再进入工作空间调用 catkin_make命令编译。</p>
<p>==注意：如果想要<code>catkin_make</code>，就必须要有<code>src</code>目录。==</p>
<h2 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h2><p>环境变量就是让系统知道当前工作空间下的功能包和launch文件的名字，这方便我们在终端可以直接运行这些命令。</p>
<p>首先在创建完工作空间后，工作空间目录下的<code>devel</code>中，有一个<code>setup.bash</code>的文件。</p>
<p>然后我们来到linux的用户文件夹下，使用快捷键<code>Ctrl+H</code>显示出隐藏文件。</p>
<p>找到<code>.bashrc</code>文件，打开。</p>
<p>在后面添上一句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>	setup.bash的路径</span><br></pre></td></tr></table></figure>
<p>这样就配置好了环境变量，如果不配置，那么每次想要在终端运行该空间中的功能包节点时，就需要source 该文件路径。</p>
<h2 id="3-创建功能包"><a href="#3-创建功能包" class="headerlink" title="3.创建功能包"></a>3.创建功能包</h2><p>==进入工作空间中的<code>src</code>目录==。输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg 自定义的功能包名 roscpp rospy std_msgs</span><br></pre></td></tr></table></figure>
<p>这样就创建了功能包，产生了功能包目录，后面的<code>roscpp</code>等是该功能包的依赖。</p>
<h2 id="4-编写源文件"><a href="#4-编写源文件" class="headerlink" title="4.编写源文件"></a>4.编写源文件</h2><p>在功能包目录下建立<code>src</code>目录，在这里我们就可以创建要编写的C++源文件了。</p>
<p>在源文件中，要包括以下几个部分：</p>
<p>(1)头文件</p>
<p>(2)节点初始化</p>
<p>​    在<code>main</code>函数中，使用<code>ros::init(argc,argv,&quot;节点名&quot;)</code>函数初始化节点。这里初始化节点的名字就是运行节点后节点    的名字，但是名字也可在 launch文件中重映射。</p>
<p>(3)输出信息</p>
<p>​    可以用<code>ROS_INFO(&quot;输出信息&quot;)</code>函数输出节点运行后的信息，来验证节点是否启动成功。</p>
<p>C++源文件代码事例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//执行 ros 节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建 ros 节点句柄(非必须)</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//控制台输出 hello world</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-编写配置文件"><a href="#5-编写配置文件" class="headerlink" title="5.编写配置文件"></a>5.编写配置文件</h2><p>我们写完代码后，如果想要运行该程序，还要进行编译，编译就要按照一定的规则，所以我们要编写编译的规则文件，也就是配置文件<code>CMakeLists.txt</code></p>
<p>主要改的地方有两个：</p>
<p>(1)添加生成可执行文件。</p>
<p>(2)链接库文件。</p>
<h2 id="6-编译"><a href="#6-编译" class="headerlink" title="6.编译"></a>6.编译</h2><p>配置好<code>CMakeLists.txt</code>文件后，我们便可以进行编译了。</p>
<p>回到工作空间目录，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>生成了可执行文件，可执行文件存放在工作空间下的<code>devel</code>目录。</p>
<p>接下来要运行某个功能包的节点，就直接可以使用<code>rosrun</code>命令了。</p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu常用命令</title>
    <url>/2021/12/16/Ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>常用命令，方便查阅。</p>
<span id="more"></span>
<p>Ubuntu操作系统中，通常是通过命令行来操作的，命令行应用的扩展性和灵活性较好，在早期的Windows系统中也是用命令行来操作电脑的。</p>
<p>命令行在终端中输入，用 <code>Ctrl</code>+<code>Alt</code>+<code>T</code> 快捷键可以打开终端窗口。</p>
<h2 id="1-pwd"><a href="#1-pwd" class="headerlink" title="1.pwd"></a>1.pwd</h2><p>查看当前的路径。</p>
<h2 id="2-cd"><a href="#2-cd" class="headerlink" title="2.cd"></a>2.cd</h2><p>切换当前路径。后面可以接相对路径，也可接绝对路径。</p>
<h2 id="3-mkdir"><a href="#3-mkdir" class="headerlink" title="3.mkdir"></a>3.mkdir</h2><p>创建文件夹。</p>
<h2 id="4-ls"><a href="#4-ls" class="headerlink" title="4.ls"></a>4.ls</h2><p>查看当前路径下的文件和文件夹。</p>
<h2 id="5-touch"><a href="#5-touch" class="headerlink" title="5.touch"></a>5.touch</h2><p>创建文件。</p>
<h2 id="6-mv"><a href="#6-mv" class="headerlink" title="6.mv"></a>6.mv</h2><p>将一个文件或文件夹移动到另外一个路径，相当于剪切的作用。</p>
<p>具体用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv file new_path</span><br></pre></td></tr></table></figure>
<p>将一个文件或文件夹拷贝到另一个路径，相当于复制粘贴。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv file new_path</span><br></pre></td></tr></table></figure>
<h2 id="8-rm"><a href="#8-rm" class="headerlink" title="8.rm"></a>8.rm</h2><p>删除文件或文件夹。</p>
<p>具体用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm file</span><br><span class="line">rm -r folder</span><br></pre></td></tr></table></figure>
<h2 id="9-sudo"><a href="#9-sudo" class="headerlink" title="9.sudo"></a>9.sudo</h2><p>sudo 的作用是提升当前用户的权限。比如安装软件时，必须要使用sudo命令。</p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu更改文件权限</title>
    <url>/2021/12/16/Ubuntu%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>Ubuntu中，文件属性介绍。</p>
<span id="more"></span>
<h2 id="1-Linux-文件基本属性"><a href="#1-Linux-文件基本属性" class="headerlink" title="1.Linux 文件基本属性"></a>1.Linux 文件基本属性</h2><p><a href="https://www.runoob.com/linux/linux-file-attr-permission.html">参考</a></p>
<p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>
<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>
<ul>
<li>chown (change ownerp) ： 修改所属用户与组。</li>
<li>chmod (change mode) ： 修改用户的权限。</li>
</ul>
<p>下图中通过 chown 来授权用户，通过 chmod 为用户设置可以开门的权限。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033851.png" alt="img"></p>
<p>在 Linux 中我们可以使用 <strong>ll</strong> 或者 <strong>ls –l</strong> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www /]<span class="comment"># ls -l</span></span><br><span class="line">total 64</span><br><span class="line">dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</span><br><span class="line">dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>实例中，<strong>bin</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul>
<li>当为 <strong>d</strong> 则是目录</li>
<li>当为 <strong>-</strong> 则是文件；</li>
<li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li>
<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033905.jpg" alt="img"></p>
<p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033910.png" alt="363003_1227493859FdXT"></p>
<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>
<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p>
<p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p>
<p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>
<hr>
<h2 id="2-Linux文件属主和属组"><a href="#2-Linux文件属主和属组" class="headerlink" title="2.Linux文件属主和属组"></a>2.Linux文件属主和属组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www /]# ls -l</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron</span><br><span class="line">drwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p>
<p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p>
<hr>
<h2 id="3-更改文件属性"><a href="#3-更改文件属性" class="headerlink" title="3.更改文件属性"></a>3.更改文件属性</h2><h3 id="1-chgrp：更改文件属组"><a href="#1-chgrp：更改文件属组" class="headerlink" title="(1)chgrp：更改文件属组"></a>(1)chgrp：更改文件属组</h3><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>
<p>参数选项</p>
<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<h3 id="2-chown：更改文件属主，也可以同时更改文件属组"><a href="#2-chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="(2)chown：更改文件属主，也可以同时更改文件属组"></a>(2)chown：更改文件属主，也可以同时更改文件属组</h3><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>
<p>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~] <span class="built_in">cd</span> ~</span><br><span class="line">[root@www ~]<span class="comment"># chown bin install.log</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</span><br></pre></td></tr></table></figure>
<p>将install.log的拥有者与群组改回为root：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># chown root:root install.log</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</span><br></pre></td></tr></table></figure>
<h3 id="3-chmod：更改文件9个属性"><a href="#3-chmod：更改文件9个属性" class="headerlink" title="(3)chmod：更改文件9个属性"></a>(3)chmod：更改文件9个属性</h3><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux 文件的基本权限就有九个，分别是 <strong>owner/group/others(拥有者/组/其他)</strong> 三种身份各有自己的 <strong>read/write/execute</strong> 权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为： <strong>-rwxrwxrwx</strong> ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： <strong>-rwxrwx—-</strong> 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= —- = 0+0+0 = 0</li>
</ul>
<p>所以等一下我们设定权限的变更时，该文件的权限数字就是 <strong>770</strong>。变更权限的指令 chmod 的语法是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<p>举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc</span><br><span class="line">[root@www ~]<span class="comment"># chmod 777 .bashrc</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</span><br></pre></td></tr></table></figure>
<p>那如果要将权限变成 <em>-rwxr-xr—</em> 呢？那么权限的分数就成为 [4+2+1] [4+0+1] [4+0+0]=754。</p>
<h3 id="4-符号类型改变文件权限"><a href="#4-符号类型改变文件权限" class="headerlink" title="(4)符号类型改变文件权限"></a>(4)符号类型改变文件权限</h3><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p>
<ul>
<li>user：用户</li>
<li>group：组</li>
<li>others：其他</li>
</ul>
<p>那么我们就可以使用 <strong>u, g, o</strong> 来代表三种身份的权限。</p>
<p>此外， <strong>a</strong> 则代表 <strong>all</strong>，即全部的身份。读写的权限可以写成 <strong>r, w, x</strong>，也就是可以使用下表的方式来看：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>chmod</th>
<th>u g o a</th>
<th>+(加入) -(除去) =(设定)</th>
<th>r w x</th>
<th>文件或目录</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>如果我们需要将文件权限设置为 <strong>-rwxr-xr—</strong> ，可以使用 <strong>chmod u=rwx,g=rx,o=r 文件名</strong> 来设定:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  touch test1    // 创建 test1 文件</span></span><br><span class="line"><span class="comment"># ls -al test1    // 查看 test1 默认权限</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br><span class="line"><span class="comment"># chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限</span></span><br><span class="line"><span class="comment"># ls -al test1</span></span><br><span class="line">-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</span><br></pre></td></tr></table></figure>
<p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  chmod  a-x test1</span></span><br><span class="line"><span class="comment"># ls -al test1</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu软件安装</title>
    <url>/2021/10/18/Ubuntu%E7%9A%84%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>Unbuntu中软件安装介绍。<br><span id="more"></span></p>
<h2 id="1-软件源介绍"><a href="#1-软件源介绍" class="headerlink" title="1.软件源介绍"></a>1.软件源介绍</h2><p>软件源,在Ubuntu下,它相当于==软件库==,需要什么软件,只要记得正确的软件名就可以用命令安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install 软件名</span><br></pre></td></tr></table></figure>
<p>例如:你要安装gcc软件,那么你就可以再终端中输<code>sudo apt-get install gcc</code>,这样就能帮你装好gcc软件,如果源里没有这个软件时,此命令就没法完成。</p>
<p>当然,如果你要删除软件时,可以再终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove 软件名</span><br></pre></td></tr></table></figure>
<h2 id="2-软件安装方式"><a href="#2-软件安装方式" class="headerlink" title="2.软件安装方式"></a>2.软件安装方式</h2><ul>
<li>通过apt包管理工具从软件源中安装</li>
<li>通过deb、snap、AppImage格式的软件包安装</li>
<li>用软件源码手动编译安装</li>
</ul>
<p>其实通过软件源安装软件的原理非常简单，Ubuntu 系统中自带了一个名为 ==apt的软件包管理工具==，它的主要功能就是负责 Ubuntu  系统中所有软件包的管理，包括从软件源中下载软件，卸载系统中已经安装的软件等。而每当我们通过<code>sudo apt-get install  &lt;package-name&gt;</code>命令去安装一个软件时，apt  包管理工具就会从系统中一个叫做==源列表的文件==中去读取软件源的网址信息，查找可以包含该软件的软件源的网址，然后就从这个网址上把指定的软件给下载下来，然后由 apt 包管理工具在本地进行一些解压和安装的其他操作。</p>
<p>在 Ubuntu 中软件源其实还细分为下面两种：</p>
<ul>
<li>Ubuntu 官方软件源</li>
<li>PPA 软件源</li>
</ul>
<p><strong>Ubuntu 官方软件源:</strong><br> Ubuntu 官方软件源中包含了 Ubuntu 系统中所用到的绝大部分的软件，它对应的源列表<br> 是<code>/etc/apt/sources.list</code>。在这个文件中，记录了 Ubuntu 官方源的地址，基本格式内容如下所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033808.webp" alt="pic"></p>
<p>如果想要更换软件源，可以到<a href="https://link.jianshu.com?t=https://segmentfault.com/a/1190000000375848">国内开源镜像站点汇总</a>去找，更换后需要运行<code>sudo apt-get update</code>来更新软件源列表。</p>
<p><strong>PPA 软件源:</strong></p>
<p>PPA 源出现的背景是因为系统自带的源是很有限的，我们肯定需要一些其他的软件包然而如果是直接下载deb格式的文件的话，又不能获取到更新和维护，所以这就用到了十分重要的 PPA 源了。</p>
<p>所谓 PPA 源，就是指 “Personal Package Archives”  ，也就是==个人软件包集==。这其实是一个网站，即launchpad.net。Launchpad 是 Ubuntu 母公司 Canonical 公司所架设的网站，是一个提供维护、支援或联络 Ubuntu 开发者的平台。由于不是所有的软件都能进入 Ubuntu 的官方的软件库，launchpad.net 提供了 PPA，允许开发者建立自己的软件仓库，自由的上传软件。供用户安装和查看更新。</p>
<p>添加和删除PPA软件源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:user/ppa-name</span><br><span class="line">sudo add-apt-repository --remove ppa:user/ppa-name    </span><br></pre></td></tr></table></figure>
<p>例如，我们想要添加一个 Wireshark 软件的 PPA 源，我们可以根据它官网上提供的命令来进行添加，如下图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033826.webp" alt="img"></p>
<p>当我们添加完 PPA 源之后，系统就会在 <code>/etc/apt/sources.list.d/</code>文件夹里创建了两个文件：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033835.webp" alt="img"></p>
<p>我们再来打开一下 <code>wireshark-dev-stable-trusty.list</code><br> 文件看看里面的内容是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://ppa.launchpad.net/wireshark-dev/stable/ubuntu trusty main</span><br><span class="line"># deb-src http://ppa.launchpad.net/wireshark-dev/stable/ubuntu trusty main</span><br></pre></td></tr></table></figure>
<p>哈哈～原来文件里就是添加了一个跟软件源一模一样的东西，他们的作用殊途同归啊。我想这其实是 Ubuntu  为了分辨官方的源和第三方的源才设计成在<code>sources.list</code>和  <code>sources.list.d/</code>这两个地方中存储软件源信息。因为第三方的源毕竟不太可信，如果随便更新的话可是会出事情的。</p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode编译环境配置</title>
    <url>/2021/10/18/VScode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在linux或mac中编译C++,首先要配置好编译环境。<br><span id="more"></span></p>
<h3 id="1-首先编写CMakeLists-txt文件"><a href="#1-首先编写CMakeLists-txt文件" class="headerlink" title="1.首先编写CMakeLists.txt文件"></a>1.首先编写CMakeLists.txt文件</h3><p>注意：在<code>c_cpp_properties.json</code>中设置了头文件路径，在编译的过程中就会有头文件内容的提示，但仍需要在<code>CMakeLists.txt</code>中写好包含的头文件路径，否则编译器只会在<code>usr/include文件夹下</code>和<code>CMakeLists.txt</code>所在文件夹下寻找头文件</p>
<p>如果不在<code>c_cpp_properties.json</code>中设置头文件路径，在写代码的时候可能会没有提示，而且头文件名字下会有红波浪线，但可以正常编译</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(文件名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ VAR) <span class="comment">#把当前路径下的所有源文件打包程VAR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(添加头文件路径)<span class="comment">#如果在vscode中已经添加了头文件路径了，就不需要再添加了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(搜索库)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;添加库的头文件&#125;</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)<span class="comment">#如果想调试，加上这一句，生成可调试文件</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS<span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;</span>)<span class="comment">#生成错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(可执行文件名 <span class="variable">$&#123;VAR&#125;</span>)<span class="comment">#生成可执行文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件 库名) <span class="comment">#链接库</span></span><br></pre></td></tr></table></figure>
<h3 id="2-文件根目录中建立一个build文件夹"><a href="#2-文件根目录中建立一个build文件夹" class="headerlink" title="2.文件根目录中建立一个build文件夹"></a>2.文件根目录中建立一个build文件夹</h3><p>编译过程中生成的中间文件和可执行文件全在该文件夹下，可执行文件的位置可在CMakeLists.txt中改变路径</p>
<h3 id="3-建立-json文件夹，编写launch-json文件"><a href="#3-建立-json文件夹，编写launch-json文件" class="headerlink" title="3.建立.json文件夹，编写launch.json文件"></a>3.建立.json文件夹，编写launch.json文件</h3><p>新建launch.json文件，该文件是在VSCODE中按F5后所执行的命令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/可执行文件名&quot;</span>,**<span class="comment">//执行文件的路径加上可执行文件，$&#123;workspaceFolder&#125;为根目录**</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,<span class="comment">//打开外部终端</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">             <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;Build&quot;</span>,<span class="comment">//该命令表示执行launch.json的命令之前的预执行任务，要在tasks.json中设置</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-编写tasks-json文件"><a href="#4-编写tasks-json文件" class="headerlink" title="4.编写tasks.json文件"></a>4.编写tasks.json文件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>:<span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOrder&quot;</span>: <span class="string">&quot;sequence&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span>:[<span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;make&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Word中使用Endnote插件</title>
    <url>/2021/10/18/Word%E4%B8%AD%E4%BD%BF%E7%94%A8Endnote%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在mac中使用Endnote的Word插件。<br><span id="more"></span></p>
<h2 id="一、安装插件"><a href="#一、安装插件" class="headerlink" title="一、安装插件"></a>一、安装插件</h2><ol>
<li>关闭word，打开endnote</li>
<li>EndNote —&gt;Customizer —&gt;勾选Cite While You Write</li>
<li>等待完成</li>
<li>打开word 工具—&gt; 模版与加载项 —&gt; 勾选CWYW</li>
<li>重启word</li>
</ol>
<p>因为新的Macbook air 和Macbook pro使用的是苹果自身的M1芯片，endnote x9和20版本的软件并不兼容这样的芯片，虽然可以用rosetta打开，但是它的word插件确不能被word打开，表现为word运行不了endnote加载项目提示<strong>“Word 无法加载加载项。加载项与此版本的 Word 不兼容。</strong>请向加载项提供者索取更新。(EndNote CWYW Word 16.bundle)”。</p>
<p><a href="https://zhuanlan.zhihu.com/p/359185025">解决方案</a></p>
<h2 id="二、插入与删除参考文献"><a href="#二、插入与删除参考文献" class="headerlink" title="二、插入与删除参考文献"></a>二、插入与删除参考文献</h2><p>插入文献：直接在Word的菜单栏中找到Endnote，点击。然后点击工具栏中insert citation，选择要插入的文献。也可直接在Endnote中复制文献或直接拖拽文献到Word中。</p>
<p>删除文献：在引用处将被引文献的标号删除，然后点击update citation。</p>
<p>引用文献的格式可以在Word中设置。</p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>git最基本的用法</title>
    <url>/2021/10/18/git%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>git的一些用法<br><span id="more"></span></p>
<p><a href="https://www.runoob.com/git/git-tutorial.html">参考</a></p>
<p><a href="https://docs.github.com/cn">git官方文档</a></p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先需要知道几个关系    </p>
<p>git本地分为工作区、暂存区、本地库三个地方</p>
<p>工作区(workspace)：即为写代码，写文件的地方</p>
<p>暂存区(staging area)：保存着待提交的文件</p>
<p>本地库(local repository)：提交后文件所在的地方</p>
<p>远程仓库(remote repository)：云端的仓库</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032438.png" alt="image-20210711044151491"></p>
<h3 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h3><p>github要想访问使用的电脑，需要先告诉github通往电脑的钥匙，在（<a href="https://www.jianshu.com/p/7edb6b838a2e">与远程库建立连接</a>）中介绍了怎么获取电脑的钥匙。</p>
<p>一般我会在远程建立一个仓库，在本地建立一个仓库，然后在本地仓库中写，再传到远程仓库。</p>
<p>具体过程：</p>
<ol>
<li><p>先在github上建立一个仓库。</p>
</li>
<li><p>然后把这个仓库<code>git clone</code>到本地。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 地址(在github上有)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在得到的文件夹中就可以进行写代码了。</p>
</li>
<li><p>想要添加到缓存区，就用<code>git add</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add 文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要提交，就用下面的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;描述信息&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在第一次git commit 时候，需要配置好提交人的姓名和邮箱。</p>
<p>git config —global user.name=”Piggy”</p>
<p>git config —global user.email=”a363158526@gmail.com”</p>
</blockquote>
</li>
<li><p>如果要发送到github上，用<code>git push</code>。</p>
<blockquote>
<p>注意，如果这里是第一次git push，要登录用户名和密码。这里的用户名是github上的用户名，我的叫做PiggyHero，密码不是登录的密码，而是github的token，token的获取是在github的设置中，找到Developer settings-&gt;Personal access tokens，然后点击Generate new token，根据需求自己设置token的权限。</p>
<p>token是一串字符，需要保存下来，因为我们只能看见一次，然后就被隐藏起来了。</p>
</blockquote>
</li>
</ol>
<h3 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h3><p>也可以不像一中那样，现在github上建立仓库，而是先在本地建立仓库。</p>
<ol>
<li><p>先建立一个文件夹，作为仓库所在的文件夹，然后<code>git init</code>。</p>
</li>
<li><p>在远程建立一个仓库，记下来SSH地址。</p>
</li>
<li><p>在终端中到本地仓库所在文件夹，使用以下代码建立关联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin SSH地址 //建立本地库与远程库的关系</span><br><span class="line">git push -u origin master //把当前的分支master上的内容转移到远程的库上</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="git-基本命令介绍"><a href="#git-基本命令介绍" class="headerlink" title="git 基本命令介绍"></a>git 基本命令介绍</h2><h3 id="1-git-help"><a href="#1-git-help" class="headerlink" title="1.git help"></a>1.git help</h3><p><code>git help -命令名称或手册名称</code></p>
<p>按F向下翻页，按B向上翻页</p>
<h3 id="2-git-config"><a href="#2-git-config" class="headerlink" title="2.git config"></a>2.git config</h3><p>配置的范围有三种：</p>
<p>（1）系统：无论是哪个用户，在整个系统的范围内，都使用同一配置</p>
<p>（2）全局：只在用户范围内使用该配置</p>
<p>（3）项目：在该项目范围内，使用该配置</p>
<p>一般设置用户的配置文件，用global</p>
<p><code>git config --global 想要配置的东西</code></p>
<p><code>git config --unset --global</code>   恢复原来的配置</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#x27;labixiaoxin&#x27;</span><br><span class="line">git config --unset --global user.name</span><br><span class="line">git config --global user.email ‘labixiaoxin@email.com’</span><br></pre></td></tr></table></figure>
<p>配置的文件在当前的主目录下面，用 <code>cat</code>命令来查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.gitconfig</span><br></pre></td></tr></table></figure>
<h3 id="3-git-init"><a href="#3-git-init" class="headerlink" title="3.git init"></a>3.git init</h3><p>初始化文件夹，会生成repository，文件夹里面会生成git需要的各种文件</p>
<p>如果不想跟踪这个项目，就把 <strong>.git</strong>文件删掉，一般情况下不去改这些文件</p>
<p><strong>.config</strong>文件是项目级别的配置信息，之前的<strong>~/.config </strong>文件是用户级别的配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 文件目录</span><br><span class="line">git init </span><br></pre></td></tr></table></figure>
<h3 id="4-git-status"><a href="#4-git-status" class="headerlink" title="4.git status"></a>4.git status</h3><p>查看当前的状态，显示当前所在的分支和变动的文件</p>
<p><code>git status</code></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032549.png" alt="image-20210708115817078"></p>
<h3 id="5-git-add"><a href="#5-git-add" class="headerlink" title="5.git add"></a>5.git add</h3><p>git添加的流程：先修改文件或增加文件 $\longrightarrow$ 然后告诉git哪些文件想要提交（git add）$\longrightarrow$ 提交（git commit）</p>
<p>添加要提交的文件</p>
<p><code>git add 要添加的文件</code></p>
<p><code>git add .</code>添加所有的文件</p>
<h3 id="6-git-commit"><a href="#6-git-commit" class="headerlink" title="6.git commit"></a>6.git commit</h3><p>提交，后面可以加上提交的信息</p>
<p><code>git commit -m &#39;想要说明的信息&#39;</code></p>
<h3 id="7-git-log"><a href="#7-git-log" class="headerlink" title="7.git log"></a>7.git log</h3><p>使用 <code>git log</code>查看以往的提交信息</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032601.png" alt="image-20210708120726347"></p>
<h3 id="8-git-diff"><a href="#8-git-diff" class="headerlink" title="8.git diff"></a>8.git diff</h3><p><code>git diff 要查看的文件</code>比较的是工作区和暂存区该文件的不同</p>
<p><code>git diff --staged</code>比较的是暂存区和仓库中该文件的不同</p>
<p>这里如果没添加文件，会对比所有修改的文件</p>
<p>红色是修改前的，绿色是修改后的</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032607.png" alt="image-20210708121041581"></p>
<h3 id="8-git-rm"><a href="#8-git-rm" class="headerlink" title="8.git rm"></a>8.git rm</h3><p><code>git rm</code> 表示从暂存区和工作区删除文件，并且将修改后的文件加入暂存区。</p>
<blockquote>
<p>该命令只能删除已经提交到本地库中的文件。当在工作目录中修改，则不能删除；或者及时在工作目录中修改了， 又<code>git add</code>到暂存区了，也是不能用该命令删除的。</p>
</blockquote>
<p>其背后的原理是这样的：例如有一个test.md文件，当你提交后，暂存区里是你最后一次提交后的目录。然后你修改了test.md文件，此时你再删除，git记录的是修改后的test.md被删除了，当你再提交时，git的记录会发生冲突，版本库中的文件是没修改的test.md，你删除的是修改的test.md，两个文件不一样，所以会出错</p>
<p>如果你想硬要针对这种情况删除修改的test.md，并且git能够识别，要用 <code>git rm -f</code>命令，此时便可以删除修改了的test.md</p>
<p>如果仅想在暂存区中删除文件，也就是说仅从跟踪清单中删除，使用 <code>git rm --cached</code></p>
<hr>
<p><strong>另外还有当重命名一个文件时</strong>，直接在文件夹中重命名，然后 <code>git status</code> 会显示该文件被删除，此时可以 <code>git rm</code>原名文件，然后 <code>git add</code>重命名后的文件，git会自动识别该文件名</p>
<h3 id="9-git-mv"><a href="#9-git-mv" class="headerlink" title="9.git mv"></a>9.git mv</h3><p>也可以直接用git mv重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv 现在名 原来名</span><br></pre></td></tr></table></figure>
<p>git mv也可以移动文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv 文件名 目录 </span><br></pre></td></tr></table></figure>
<h3 id="10-git-reset"><a href="#10-git-reset" class="headerlink" title="10.git reset"></a>10.git reset</h3><p>回退版本命令，指定退回某一次提交的版本</p>
<p>共有三种模式</p>
<p>(1)—mixed</p>
<p>首先是 <code>--mixed</code>为默认模式，当变更到指定的版本后，工作区的文件保持不变，会重置暂存区，暂存区的目录和指定的版本的目录相同</p>
<p>例如第一次提交的文件有a.cpp，第二次提交的文件有b.cpp</p>
<p>如果回退到第一个版本，那么b.cpp变为未跟踪文件，暂存区与第一次提交的版本目录相同</p>
<p><code>git reset HEAD^</code> 变更到上一个版本</p>
<p><code>git reset HEAD^ hello.cpp</code>此时最新的版本还在，只是这个最新版本中的hello.cpp回到上一个版本，而工作目录中的文件不变，暂存区中的hello.cpp是上一个版本</p>
<p><code>git reset 版本号</code>回退到指定的版本</p>
<p>(2)—soft</p>
<p>soft只更改HEAD的位置，暂存区和工作目录都不改变，暂存区的文件等待重新提交</p>
<p>例如：<strong>9e78i</strong> 提交添加了 style.css 文件，<strong>035cc</strong> 提交添加了 index.js 文件。使用软重置，我们可以撤销提交记录，但是保留新建的 style.css 和 index.js 文件。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032615.png" alt="img"></p>
<p>如果是mixed模式，需要先 <code>git add</code>才与soft效果相同</p>
<p>(3)—hard</p>
<p>hard模式，是把暂存区和工作目录都变更到指定版本，也就是说本地的文件也和目标的版本相同，就是把当前工作目录的文件，已暂存的文件全部清除（如果记下最后一次版本号，也可以复原）</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032622.gif" alt="img"></p>
<blockquote>
<p><code>git reset HEAD^^^</code>  几个就表示 <code>^</code>，就表示当前版本的前几个版本</p>
<p><code>git reset HEAD~3</code> 也可以用 <code>~数字</code>表示</p>
</blockquote>
<h3 id="11-git-revert"><a href="#11-git-revert" class="headerlink" title="11.git revert"></a>11.git revert</h3><p><code>git revert</code>也同样有三种模式，和reset相同，不同的是reset是回到指定版本，而它表示在现有版本上继续向下走，也就是把之前的版本添加到现在版本之后</p>
<p>举个例子，我们在 ec5be 上添加了 index.js 文件。之后发现并不需要这个文件。那么就可以使用 git revert ec5be 指令还原之前的更改。如下图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032630.gif" alt="img"></p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git背后的原理</title>
    <url>/2021/12/15/git%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>细细介绍git背后原理</p>
<span id="more"></span>
<p>在git跟踪一个项目时，有以下三个部分：</p>
<ul>
<li>工作区：就是在电脑里能看到的目录</li>
<li>暂存区：英文叫做stage和index，一般存放在<strong>.git/index</strong>中</li>
<li>版本库：工作区有一个隐藏的目录，<strong>.git</strong>，这就是版本库</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032636.png" alt="image-20210711045622504"></p>
<ul>
<li>首先介绍暂存区中的内容，暂存区就是一个目录树，该目录树上的内容是文件的索引，可以理解为是一个指针，它指向一个文件</li>
<li>这个文件都存在 <strong>objects</strong>中，<strong>objects</strong>表示git的对象库，里面包含了创建的各种对象及内容，它们被存在 <strong>.git/objects</strong>中</li>
<li>当工作区的文件被修改后，使用 <code>git add</code>命令，暂存区的目录树便会被更新，同时工作区中修改的文件会被复制到objects中生成一个新的对象，而该对象的🆔就被记录在刚刚所说的暂存区的目录树中</li>
<li>当使用 <code>git commit</code>后，暂存区的目录树也变成了一个对象，该对象的🆔被记录在版本库中的<strong>master</strong>中，master分支同时也作出相应的更新，master所代表的版本树中的每一个叶子都指向不同版本的目录树。<strong>HEAD</strong>是指向master版本树的一个指针，表示当前所在的版本（它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点）</li>
<li>当执行 <code>git reset HEAD</code>命令后，暂存区的目录会被重写，变成了HEAD所指向的版本所对应的目录树，但此时工作区不受影响</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code>后，会直接从暂存区删除文件（把索引删掉，objects中的文件也删掉），工作区则不做出改变</li>
</ul>
<p>如果还不明白，看下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032656.png" alt="image-20210711063540634"></p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv的数据类型</title>
    <url>/2021/12/02/opencv%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>OpenCV的数据类型分为三类：</p>
<ol>
<li>直接从C++的标准库继承来的，例如int和float等。还包括一些简单的矩阵和数组，代表了一些几何意思，比如点，矩形等。我的理解是就是用标准库提供的容器，然后换了一个名字。</li>
<li>辅助对象，这些对象代表较为抽象的概念。比如，垃圾收集指针类，范围类等。</li>
<li>大型数组类型。例如Mat，这一类我的理解是使用标准库提供的容器进行整合，形成新的类。</li>
</ol>
<span id="more"></span>
<h2 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1.基础类型"></a>1.基础类型</h2><p>在opencv中，基础类型有以下几个：</p>
<ul>
<li><code>cv::Vec&lt;&gt;</code> 向量类</li>
<li><code>cv::Matx&lt;&gt;</code> 矩阵类</li>
<li><code>cv::Point</code> 点类</li>
<li><code>cv::Scalar</code> 四维向量，用于描述颜色，四元数</li>
<li><code>cv::Size</code> 二维向量，用于描述图像大小</li>
<li><code>cv::Rect</code> 四维向量，用于描述矩形</li>
<li><code>cv::RotatedRect</code> 包含一个Point，一个Size和一个浮点数角度，表示非轴对称矩形</li>
<li><code>cv::Complex</code> 复数类</li>
</ul>
<p>上面这几个类型是基础类型。在opencv中通常用 typedef来定义别名。</p>
<p>例如：</p>
<p><code>cv::Point2d</code>，<code>cv::Vec2i</code>，<code>cv::Matx33f</code> </p>
<p>在这里数字表示维度，后面的字母表示数据类型。有{b,w,s,i,f,d}，分别对应{unsigned char,unsigned short,short,int,float,double}。</p>
<p>==下面写对各个类型的介绍：用到时后再写==</p>
<h2 id="2-辅助对象"><a href="#2-辅助对象" class="headerlink" title="2.辅助对象"></a>2.辅助对象</h2><p>辅助对象被用来对控制各种各样的算法和各种在容器上的操作。</p>
<p>==等学到这的时候再写==</p>
<h2 id="3-图像和大型数组"><a href="#3-图像和大型数组" class="headerlink" title="3.图像和大型数组"></a>3.图像和大型数组</h2><p><code>cv::Mat</code>是该类型中的代表，它用来表示一个图像。</p>
<blockquote>
<p>它可以表示任意维度的稠密数组，这个稠密表示数组中的所有元素都有一个存储值。</p>
<p>而稀疏数组是非0的地方才会被存储，这样回更节约内存。但是当数组比较稠密的时候，用稀疏数组来存反而会浪费内存。一个比较常用的使用稀疏数组的例子是用其来存储直方图。</p>
</blockquote>
<p>本节就主要介绍<code>cv::Mat</code></p>
<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1)基本介绍"></a>1)基本介绍</h3><h4 id="Mat的结构是什么样子的？"><a href="#Mat的结构是什么样子的？" class="headerlink" title="Mat的结构是什么样子的？"></a>Mat的结构是什么样子的？</h4><p>Mat是一个类，由两部分组成：</p>
<ul>
<li>矩阵的头（包含矩阵的尺寸、存储方法、存储地址等）</li>
<li>图像数据矩阵</li>
</ul>
<h4 id="Mat存储机制是什么样子的？"><a href="#Mat存储机制是什么样子的？" class="headerlink" title="Mat存储机制是什么样子的？"></a>Mat存储机制是什么样子的？</h4><p><strong>矩阵那么大，经常复制太占用资源了！</strong></p>
<p>opencv引用计数机制来管理图像的存储，让给个Mat对象都有自己的信息头，但各个对象共享同一个矩阵，通过矩阵指针来进行访问矩阵。拷贝构造函数只复制信息头和矩阵指针。这样就可以避免频繁的复制整个矩阵了。</p>
<p>如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat A,C;</span><br><span class="line">A=<span class="built_in">imread</span>(<span class="string">&quot;image.png&quot;</span>);</span><br><span class="line"><span class="function">Mat <span class="title">B</span><span class="params">(A)</span></span>;</span><br><span class="line">C=A;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，A B C三个对象都指向同一个数据矩阵，当通过其中一个对象修改数据矩阵后，通过显示这三个对象的图像，就都发生了变化。</p>
<blockquote>
<p>当建立新对象，并用已有的对象为其复制，实质上就是改变了访问原图像数据矩阵的途径而已。</p>
</blockquote>
<p>另外，也可以创建新的对象，使其仅指向感兴趣的区域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">D</span><span class="params">(A,Rect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>))</span></span>;<span class="comment">//框出一个矩形区域</span></span><br></pre></td></tr></table></figure>
<h4 id="数据矩阵由谁来清理？"><a href="#数据矩阵由谁来清理？" class="headerlink" title="数据矩阵由谁来清理？"></a>数据矩阵由谁来清理？</h4><p>在这个数据矩阵多一个指向者的时候，它的引用就会加一，当一个指向它的对象被释放后，它的引用就会减一，当引用数为0时，那么数据矩阵就会被释放。</p>
<h4 id="如何才能复制一份数据矩阵？"><a href="#如何才能复制一份数据矩阵？" class="headerlink" title="如何才能复制一份数据矩阵？"></a>如何才能复制一份数据矩阵？</h4><p>可以使用对象的clone()函数或copyTo()函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat F=A.<span class="built_in">clone</span>();</span><br><span class="line">Mat G;</span><br><span class="line">A.<span class="built_in">copyTo</span>(G);</span><br></pre></td></tr></table></figure>
<h3 id="2-像素值的存储方式"><a href="#2-像素值的存储方式" class="headerlink" title="2)像素值的存储方式"></a>2)像素值的存储方式</h3><p>我们知道了图像是以什么样的一种方式存在计算机中，那么每个像素或者说矩阵中的每一个元素的值是怎么确定的呢？</p>
<h4 id="什么是颜色空间？"><a href="#什么是颜色空间？" class="headerlink" title="什么是颜色空间？"></a>什么是颜色空间？</h4><p>首先我们要知道颜色空间的概念。</p>
<p>颜色空间就是给定了你一定的颜色，如何通过组合这几个颜色来表示我们想要的颜色。这就是根据颜色空间对图像进行编码。</p>
<p>例如：给定了一个颜色空间，红黄蓝。当我们想要表示一个贼红的东西，我们就可以用向量(1,0,0)来表示。</p>
<p>无论哪种颜色空间，都把颜色分成三个或四个基元素。</p>
<p><strong>图像的颜色空间主要有以下几种：</strong></p>
<ul>
<li>RGB：基色为红绿蓝</li>
<li>RGBA：在RGB的基础上，加上一个透明度通道</li>
<li>HSV和HLS：把颜色分解成色调、饱和度和亮度/明度。</li>
<li>YCrCb ==我不知道是啥==</li>
<li>CIE L*a*b* ==我也不知道是啥==</li>
</ul>
<h4 id="什么是像素值定义域？"><a href="#什么是像素值定义域？" class="headerlink" title="什么是像素值定义域？"></a>什么是像素值定义域？</h4><p>还是上面的例子，在红黄蓝空间上，我们用(1,0,0)来表示贼红。但是这样表示的颜色数量太少，因为最红的值是1，这就说明我们只用了一bit来表示 一个颜色占的分量。那么如果用1byte，就是8个bit来表示最红，浅红，淡红都可以表示出来了。所以就用8bit来表示一个颜色通道。二进制8位最大值对应的10进制的值为255，所以我们就可以用(255,0,0)来表示贼红。这样就可以表示出很多种颜色了。</p>
<p>这就是像素值的定义域，它取决于存储它的元素的数据类型。最小的数据类型为char，占1个byte，可以是有符号(-127—127)，也可以是无符号(0—255)。还可以使用float(4个byte)和double(8个byte)来表示。可以让颜色粒度更低。</p>
<h4 id="什么是图像深度？"><a href="#什么是图像深度？" class="headerlink" title="什么是图像深度？"></a><strong>什么是图像深度？</strong></h4><p>另外，在opencv中，经常会说到图像的深度，这个和像素的定义域的意思差不多，图像的深度是指描述一个像素值所占的位数。例如：int型的深度是32。</p>
<h4 id="opencv中封装了图像数据类型！"><a href="#opencv中封装了图像数据类型！" class="headerlink" title="opencv中封装了图像数据类型！"></a>opencv中封装了图像数据类型！</h4><p>在opencv中，图像的数据类型和通道数已经被封装好了，命名规则如下：</p>
<p>类型的命名为：<code>CV_&#123;8U,16S,16U,32S,32F,64F&#125;C&#123;1,2,3&#125;</code></p>
<p>例如：<code>CV_8UC1</code>表示8位unsigned char型1通道的图像。</p>
<h3 id="3-显式创建Mat对象"><a href="#3-显式创建Mat对象" class="headerlink" title="3)显式创建Mat对象"></a>3)显式创建Mat对象</h3><p>==Mat的构造函数 ，用时候再学==</p>
<h3 id="4-操作Mat对象中的数据元素"><a href="#4-操作Mat对象中的数据元素" class="headerlink" title="4)操作Mat对象中的数据元素"></a>4)操作Mat对象中的数据元素</h3><p>有三种方法可以获得图像数据的每一个元素，完成对其进行操作。</p>
<p>我们画一个图来说明图像数据矩阵的样子。图像数据矩阵是一个二维的数组。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000123.png" alt="Snipaste_2021-11-15_09-54-57"></p>
<p>如果是三通道的，那么每一个元素存的是一个三维的数组，那么图像数组真实的列数=图像矩阵列数 * 图像的通道数。</p>
<h4 id="（1）使用at成员函数"><a href="#（1）使用at成员函数" class="headerlink" title="（1）使用at成员函数"></a>（1）使用at成员函数</h4><p><code>at&lt;&gt;()</code>可以直接返回某一个元素的值，模板参数需要指定好元素中的数据类型。例如图像是CV_8UC3，那么调用该函数的时候就要写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vec3b element = img.at&lt;Vec3b&gt;(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p> 这表示第1行的第1个元素，是一个3维向量。</p>
<p>下面是<code>at&lt;&gt;()</code>支持的用法</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000148.png" alt="image-20211115101040117"></p>
<p>如果想要遍历所有的元素，那么就需要通过多级嵌套循环来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">800</span>,<span class="number">600</span>,CV_8UC3)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n_r=img.rows;</span><br><span class="line"><span class="keyword">int</span> n_c=img.cols;</span><br><span class="line"><span class="comment">//输出该图像的每一个元素</span></span><br><span class="line">Vec3b element;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;n_c;ii++)</span><br><span class="line">    &#123;</span><br><span class="line">        element[<span class="number">0</span>]=img.at&lt;Vec3b&gt;(i,ii)[<span class="number">0</span>];</span><br><span class="line">        element[<span class="number">1</span>]=img.at&lt;Vec3b&gt;(i,ii)[<span class="number">1</span>];</span><br><span class="line">        element[<span class="number">2</span>]=img.at&lt;Vec3b&gt;(i,ii)[<span class="number">2</span>];</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;行第&quot;</span>&lt;&lt;ii&lt;&lt;<span class="string">&quot;列的元素为&quot;</span>&lt;&lt;element[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>element[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;element[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以通过该种方式操作像素值</span></span><br><span class="line">img.at&lt;uchar&gt;(<span class="number">100</span>,<span class="number">100</span>)[<span class="number">0</span>]=<span class="number">50</span>;</span><br></pre></td></tr></table></figure>
<h4 id="（2）使用C语言风格的指针"><a href="#（2）使用C语言风格的指针" class="headerlink" title="（2）使用C语言风格的指针"></a>（2）使用C语言风格的指针</h4><p>还有另外的一个模板成员函数<code>ptr&lt;&gt;()</code> ，该函数返回的是某一行的指针。通过这种方法获取数组的元素是最快的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vec3b * pointer1 = img.ptr&lt;Vec3b&gt;(<span class="number">0</span>);<span class="comment">//返回的是第1行的指针(第一行数组的指针)</span></span><br><span class="line"></span><br><span class="line">Vec3b a =pointer1[<span class="number">0</span>];<span class="comment">//指第1行的第1个元素</span></span><br><span class="line">Vec3b b=img.ptr&lt;Vec3b&gt;(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//返回的是第1行第2个元素</span></span><br><span class="line">Vec3b c=img.ptr&lt;Vec3b&gt;(<span class="number">0</span>)[<span class="number">2</span>];<span class="comment">//返回的是第1行第3个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********还有另一种情况************/</span></span><br><span class="line">uchar * pointer3=img.ptr&lt;uchar&gt;(<span class="number">0</span>);<span class="comment">//返回第1行的指针</span></span><br><span class="line">uchar d=pointer3[<span class="number">0</span>];<span class="comment">//表示第1行第1个元素的第一个通道</span></span><br><span class="line">uchar e=pointer3[<span class="number">1</span>];<span class="comment">//表示第1行第1个元素的第二个通道</span></span><br><span class="line">uchar f=pointer3[<span class="number">3</span>];<span class="comment">//表示第1行第2个元素的第一个通道</span></span><br></pre></td></tr></table></figure>
<p>上面模板参数Vec3b和uchar的区别，就是指针的区别，Vec3b的指针[1]，一次跳过3个字节地址。uchar的指针[1]，一次跳过1个字节地址。</p>
<blockquote>
<p>图像的同一行的所有元素的内存地址是连续的，但是不同行之间的内存地址不一定是连续的，可以使用<code>isContinuous()</code>来判断。</p>
</blockquote>
<h4 id="（3）使用iterator"><a href="#（3）使用iterator" class="headerlink" title="（3）使用iterator"></a>（3）使用iterator</h4><p>Mat的iterator有两种：</p>
<ul>
<li><code>cv::MatIterator&lt;&gt;</code> non-const array iterator</li>
<li><code>cv::MatConstIterator&lt;&gt;</code> const array iterator</li>
</ul>
<p>iterator是一个更智能的指针，它不用我们来考虑各个数据的内存地址是否连续。它的指向是数组中的每一个元素。</p>
<blockquote>
<p>non-const array iterator 和 const array iterator 应该就是该iterator可不可以操作图像，如果是const array iterator，就不可以操作图像。(？？？)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">800</span>,<span class="number">600</span>,CV_32FC3)</span></span>;</span><br><span class="line">MatConstIterator&lt;Vec3f&gt; it=img.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!=img.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;(*it)[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;(*it)[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;(*it)[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-成块操作数据元素"><a href="#5-成块操作数据元素" class="headerlink" title="5)成块操作数据元素"></a>5)成块操作数据元素</h3><p>通过Mat的成员函数可以获得其子区域的数据。还有两个运算符重载函数。</p>
<blockquote>
<p>在做这些操作的时候，不是把数据矩阵复制到mat对象中，而是为mat对象建立一个新的header来指向所选的区域，如果修改这个对象所指的数据，那么原来的数据也会变动。</p>
</blockquote>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000155.png" alt="image-20211115115344641"></p>
<p><code>diag()</code> 提取对角线上的元素</p>
<ul>
<li>参数0，提取对角线上的元素</li>
<li>参数为正，提取上三角元素</li>
<li>参数为负，提取下三角元素</li>
</ul>
<h3 id="6-矩阵元素运算表达式"><a href="#6-矩阵元素运算表达式" class="headerlink" title="6)矩阵元素运算表达式"></a>6)矩阵元素运算表达式</h3><p>可以直接通过运算符对矩阵进行操作。</p>
<p>这里要注意，=赋值操作，例如m2=m1，这表示对m1所指的数据增加了一个引用m1和m2共享同一份数据，而m2=m1+m0表示m2指向一份新的数据，这个数据的值由m1和m0相加得到。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000202.png" alt="image-20211115123615830"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000241.png" alt="image-20211115123635416"></p>
<h3 id="7-Saturation-casting"><a href="#7-Saturation-casting" class="headerlink" title="7)Saturation casting"></a>7)Saturation casting</h3><p>当我们的图像在处理时，有可能会发生内存溢出现象。比如说我的图像原来是uchar型的，当我们操作的时候出现了负数，这就不允许了。所以我们需要加上一个饱和过滤的函数，来把这些不符合的给滤掉。</p>
<p>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uchar&amp; Vxy = m0.at&lt;uchar&gt;( y, x );</span><br><span class="line">Vxy = cv::saturate_cast&lt;uchar&gt;((Vxy<span class="number">-128</span>)*<span class="number">2</span> + <span class="number">128</span>);</span><br></pre></td></tr></table></figure>
<h3 id="8-Mat的成员函数们"><a href="#8-Mat的成员函数们" class="headerlink" title="8)Mat的成员函数们"></a>8)Mat的成员函数们</h3><p>Mat中还有很多的成员函数可供使用。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000212.png" alt="image-20211115125610273"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000338.png" alt="image-20211115125627092"></p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>【git问题解决1】git连不上远端库问题解决</title>
    <url>/2021/12/02/%E3%80%90git%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B31%E3%80%91git%E8%BF%9E%E4%B8%8D%E4%B8%8A%E8%BF%9C%E7%AB%AF%E5%BA%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在使用 Git 时发现在使用 <code>git clone</code> 或 <code>git pull</code> 等需要访问远程仓库的操作时，总是无法连接 GitHub 服务器。</p>
<span id="more"></span>
<p>报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/xxx/xxx.git</span><br><span class="line">fatal: unable to access &#x27;https://github.com/xxx/xxx.git/&#x27;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<p>在 clone GitHub 仓库时可以使用 HTTPS 或者 SSH 进行 clone，而 SSH 却没有 HTTPS 的网络连接问题，所以可以将 push/pull 的连接方式由 HTTPS 改为 SSH。</p>
<blockquote>
<p>要求：你需要提前生成 SSH 公私钥对，并将公钥添加到你的 GitHub 账户中。关于这一部分的详细信息，请参阅 <a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">Connecting to GitHub with SSH</a>。</p>
</blockquote>
<p>进入仓库对应目录，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>
<p>更改完成后，可以使用如下命令查看当前的 origin 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【git问题解决2】解决github无法访问</title>
    <url>/2021/12/14/%E3%80%90git%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B32%E3%80%91%E8%A7%A3%E5%86%B3github%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6844904193170341896">原文链接</a></p>
<span id="more"></span>
<blockquote>
<p>你是不是在访问全球最大的【交友网站】（GitHub）也遇到过以下情况:<br> 1.突然电脑无法访问github了.无论你重启电脑，重置网络，重置你的大脑都无法正常访问了。<br> 2.使用昂贵的【绿色上网】却可以神奇的访问到GitHub。<br> 3.当你使用昂贵的【绿色上网】，开心的在命令行上敲上你熟悉的git 、pull、push等命令进行访问远程库的时候，却给命令行甩你一行【Failed to connect to github.com port 443: Operation timed out】</p>
</blockquote>
<p>身为一个专业的开发人员，这些错误是难不到你的！然后你疯狂的百度、Google搜索，然后得到的是为git的设置代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你以为你很快速的解决的时候！！！现实却是打脸的！！！ 你得到的命令行再一次甩你一行【connect to 127.0.0.01 port 1080: Connection refused】</p>
</blockquote>
<p>如果你也遇到这些情况，那你很幸运，这篇文章可以帮你解决90%的问题。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p><strong>1.打开<a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com/</a>  如下图：</strong></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032306.awebp" alt="140.jpeg" style="zoom: 33%;" /></p>
<p>把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！</p>
<p><strong>2.打开<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo</a> 如下图：</strong></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032314.awebp" alt="fas.png" style="zoom: 33%;" /></p>
<p>把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！</p>
<p><strong>3.打开<a href="https://github.com.ipaddress.com/assets-cdn.github.com">https://github.com.ipaddress.com/assets-cdn.github.com</a> 如下图：</strong></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032318.awebp" alt="153.png" style="zoom: 33%;" /></p>
<p>把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！</p>
<p><strong>4.打开电脑的hosts文件，把下列的东东写在最后，然后保存即可</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.113.4(图1的IP Address) github.com </span><br><span class="line">199.232.69.194(图2的IP Address) github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153(图3的IP Address)  assets-cdn.github.com</span><br><span class="line">185.199.109.153(图3的IP Address)  assets-cdn.github.com</span><br><span class="line">185.199.110.153(图3的IP Address)  assets-cdn.github.com</span><br><span class="line">185.199.111.153(图3的IP Address)  assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032323.awebp" alt="WX20200616-233432.png" style="zoom: 50%;" /></p>
<p><strong>5.在终端在输以下指令刷新DNS（需要权限）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder;say DNS cache has been flushed</span><br></pre></td></tr></table></figure>
<p><strong>然后就见证神奇的时刻！！！！！</strong></p>
<p><strong>小提示</strong></p>
<blockquote>
<p>提示1:<br> 我是用Mac电脑,Mac的Hosts文件可以通过以下路径进行找打： </p>
<p>1.Finder-&gt;Go-&gt;Go to Folder</p>
<p>2.然后输入/etc/hosts即可找到.</p>
<p>3.Windows请自行解决</p>
<p>提示2:<br>这个Hosts文件一般的编辑器还真打不开，可以使用NotePad++、SubLineText等编辑器进行编辑</p>
</blockquote>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【数字图像处理1】什么是数字图像处理</title>
    <url>/2021/12/19/%E3%80%90%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%861%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>主要参考：冈萨雷斯《数字图像处理》</p>
<p>计算机视觉是现在最火的研究领域，一开始我以为数字图像处理是计算机视觉的一部分，然而事实并非如此。接下来会通过比较数字图像处理，图像分析，计算机视觉的关系来介绍什么是数字图像处理。</p>
<span id="more"></span>
<h3 id="1-什么是数字图像处理"><a href="#1-什么是数字图像处理" class="headerlink" title="1.什么是数字图像处理"></a>1.什么是数字图像处理</h3><p>图像我们大家都十分熟悉，平常在手机和电脑上看到的都是数字图像。与之对应的可以叫作非数字图像，例如我们小时候用胶卷相机拍出来的照片，或者是在医院拍的CT，得到的图片在胶片上呈现，是非数字化的。因为计算机能看懂的只有0和1，也就是二进制数，所以用数字来描述一幅图像，得到的就是数字图像。数字图像处理最早的起源可以追溯到上世纪二十年代，那时候人们为了实现远距离传输图像，先将一张图像编码成信号的形式（例如白色就用高电位表示，黑色用低电位表示），然后接收端再解码进行打印。显然，那时候并没有对图像进行什么实质意义上的处理，但是此时已经涉及到了数字图像的概念。</p>
<p>数字图像处理，图像分析，计算机视觉三者并没有十分明确的分界。但是一般认为，数字图像处理的输入和输出都是一张图片，例如我们平常用到的P图软件。而计算机视觉的目标是模拟人类的视觉系统，是人工智能的一个分支，其输入是图像，输出就不一定是啥了，这要根据任务的需要，如果理解一张图片，那么输出可能就是一段描述图像内容的话。图像分析介于二者之间，是中间的过程，与这两个领域都有交集，其输入是图片，输出是图像中的一些特征信息，但这些信息并没有上升到语义的级别。</p>
<blockquote>
<p>我的理解是，图像分析没有用到数据驱动的方法，而是单纯的通过数学的方法对图像进行处理，从而得到图像中的一些信息。</p>
</blockquote>
<p>以文本识别为例，从图像中提取出文本并将其描述成计算机可以处理的形式便属于图像分析。而要理解全文的意思，就属于计算机视觉的领域了。在《数字图像处理》这本书中，会涉及到图像处理和分析这两部分内容。</p>
<h3 id="2-数字图像处理的步骤"><a href="#2-数字图像处理的步骤" class="headerlink" title="2.数字图像处理的步骤"></a>2.数字图像处理的步骤</h3><p><img src="https://piggyhero.gitee.io/pic/img/20211222004857.png" alt="image-20211222004850371"></p>
<p>在本书中，其章节安排是按照图像处理的顺序进行的。</p>
<blockquote>
<p>注意：在一个图像处理系统里，上述过程不一定全都有。</p>
</blockquote>
]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【数字图像处理2】人类视觉系统</title>
    <url>/2021/12/19/%E3%80%90%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%862%E3%80%91%E4%BA%BA%E7%B1%BB%E8%A7%86%E8%A7%89%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>在学习数字图像处理之前，先了解一下人类的视觉系统。</p>
<span id="more"></span>
<h3 id="1-眼睛的结构"><a href="#1-眼睛的结构" class="headerlink" title="1.眼睛的结构"></a>1.眼睛的结构</h3><p><img src="https://piggyhero.gitee.io/pic/img/20211222011221.png" alt="image-20211222011220881"></p>
<p>人眼结构可以分为三层，从外到内为：</p>
<ul>
<li>第一层：角膜+巩膜外壳（Cornea+Sclera)</li>
<li>第二层：脉络膜（Choroid）</li>
<li>第三层：视网膜（Retina）</li>
</ul>
<p>这三层组成了眼球结构，在最内层的视网膜上布满了感受光线的细胞。这些细胞分为：</p>
<ul>
<li>视锥细胞（Cone）：在明亮环境下，对颜色十分敏感。用于亮视觉。</li>
<li>视杆细胞（Rod）：对颜色不敏感，仅在暗光条件下感受光照强度。用于暗视觉。</li>
</ul>
<p>在视网膜上有一个直径约1.5mm的圆形凹陷处，在该区域布满了视锥细胞。在该区域周围则布满了视杆细胞，视锥细胞和视杆细胞的分布情况如上图右边所示。</p>
<p>眼球前部的晶状体（Len）相当于相机中的透镜。在相机中，透镜的焦距固定，通过改变透镜到成像平面的距离来使不同距离处的物体所反射的光线投射到成像平面上。在人眼中，晶状体的焦距可通过周围肌肉的控制改变（焦距的变化范围大约是14mm到17mm），而晶状体到视网膜的距离是固定不变的，这个距离大约为17mm。</p>
<h3 id="2-人眼图像的形成"><a href="#2-人眼图像的形成" class="headerlink" title="2.人眼图像的形成"></a>2.人眼图像的形成</h3><p><img src="https://piggyhero.gitee.io/pic/img/20211222023735.png" alt="image-20211222023735357"></p>
<p>人眼的成像系统可以看做是一个小孔成像模型，如上图所示。</p>
<p>当光线投射到视网膜上后，视网膜上的感受细胞将根据感受到的光强度（intensity）生成电信号，通过神经传入到大脑中，然后再通过大脑实现理解。</p>
<blockquote>
<p>补充：视锥细胞有三种，分别可以感受红蓝绿三色光的光强，这和相机中的传感器一样，通过三色光的强度不同来分辨不同的颜色。</p>
</blockquote>
<h3 id="3-亮适应（Brightness-Adaptation）"><a href="#3-亮适应（Brightness-Adaptation）" class="headerlink" title="3.亮适应（Brightness Adaptation）"></a>3.亮适应（Brightness Adaptation）</h3><p>那么人眼可以感受到的光强范围是多少呢？从最暗到最亮的范围大约是 $10^{10}$ ，根据一些实验结果显示，人们主观感受到的亮度（subjective brightness）是实际投射到视网膜上的光强的对数函数，如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211222025514.png" alt="image-20211222025514601"></p>
<p>但是人眼并不能同时感受这么大范围的光照强度变化，而仅仅感受到一小部分范围的光强变化。例如在夜晚我们关灯后，我们看到的是一片漆黑，并不能看出桌子在哪，床在哪，但过了一会虽然没有灯，我们还是可以看见一些物体的轮廓，这就是人眼的适应能力，称为Brightness Adaptation。当环境的光强在上图的点 $B_a$ 时，人眼所能感受的光强范围为交叉的曲线所示，视觉系统当前的适应范围称为Brightness Adaptation Level，只要是低于 $B_b$ 处的光强，人主观感受到的光强就都一样，都是该范围中的最低值。而当环境光强提高时，Brightness Adaptation Level会升高，$B_a$ 也会到一个新的位置。</p>
<h3 id="4-光强分辨能力"><a href="#4-光强分辨能力" class="headerlink" title="4.光强分辨能力"></a>4.光强分辨能力</h3><p>下面我们来介绍一下当光强变化多少时，人们才能感受到。通过实验发现这取决于周围环境的光强。</p>
<p>有这样的一个实验，在一个矩形区域A中设置一个圆形区域B，A区域的光强为 $I$ ，B区域的光强为 $I+\Delta I$ 。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211222032737.png" alt="image-20211222032737793"></p>
<p>通过不断增加 $\Delta I$ ，让观察者来观察，当观察者发现变化时记录下来 $\Delta I /I$ 。$\Delta I /I$ 和环境光强的关系如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211222032800.png" alt="image-20211222032800529"></p>
<p>$\Delta I /I$ 较大表示分辨能力较弱，可以看出当环境的光强较低时，分辨能力较弱，而环境光强较高时，分辨能力较强。图中两段曲线说明了在暗光环境下，是由视杆细胞来感受光线的，视杆细胞对光强的辨别能力较弱。而在强光环境下，由视锥细胞来感受光线，视锥细胞对光强变化感受灵敏。</p>
<h3 id="5-人眼视觉系统的另外一些特点"><a href="#5-人眼视觉系统的另外一些特点" class="headerlink" title="5.人眼视觉系统的另外一些特点"></a>5.人眼视觉系统的另外一些特点</h3><p>之前我们说到，人主观感受到的光强是实际光强的对数函数，但事实远非如此，这只是一种宏观上的近似。</p>
<p>首先我们看下面这幅图像：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211222033725.png" alt="image-20211222033725163"></p>
<p>主观感受到的光强在不同强度的边界上会倾向于有一些”超调“或”衰减“。机理暂时不明确。</p>
<p>再看下面这幅图像：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211222034137.png" alt="image-20211222034137201"></p>
<p>中间的正方形的灰度值都是一样的，但是当背景较暗时，就感觉稍微亮一点。这也说明了主观感受到的光强还和环境的光强有关。</p>
<p>人类视觉系统还会有一种叫光幻觉（optical illusions）的现象。如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211222034647.png" alt="image-20211222034647771"></p>
]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM学习1】视觉SLAM框架</title>
    <url>/2021/10/18/%E3%80%90%E8%A7%86%E8%A7%89SLAM%E5%AD%A6%E4%B9%A01%E3%80%91%E8%A7%86%E8%A7%89SLAM%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>视觉SLAM的结构框架。<br><span id="more"></span></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032349.png" alt="视觉SLAM框架"></p>
<p>SLAM就是一个根据传感器数据（如相机测出的位置信息和路标点的位置信息），来进行最优估计的过程。</p>
]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>【视觉SLAM学习2】SLAM的数学描述</title>
    <url>/2021/10/18/%E3%80%90%E8%A7%86%E8%A7%89SLAM%E5%AD%A6%E4%B9%A02%E3%80%91SLAM%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<p>主要介绍如何使用数学语言来描述SLAM问题。<br><span id="more"></span><br>设 $\vec{x}$ 表示相机的位置，$\vec x_1\ , \ \vec x_2 \ …\ ,\vec x_k$表示不同时刻的位置信息，$\vec y_1 \ , \vec y_2 \ ,\ …\ \vec y_n$表示路标的位置，共有n个路标点</p>
<hr>
<p>我们的<strong>目标是：</strong>描述以下两件事情：</p>
<ol>
<li>什么是运动 ：k-1时刻到k时刻，$\vec x$是如何变化的</li>
<li>什么是观测：在k时刻，相机在 $\vec x_k$处探测到某一路标，$\vec y_j$​ </li>
</ol>
<hr>
<p>首先来说关于 <strong><u>运动</u></strong> 的数学描述：</p>
<script type="math/tex; mode=display">
\vec x_k = f(\vec x_{k-1}\ , \vec u_k\ ,\vec w_k)</script><p>$\vec u_k$表示k时刻运动的输入(可以是传感器读出来的速度或者是通过视觉里程计估算出来的速度)，$\vec w_k$表示噪声</p>
<p>接下来说关于 <strong><u>观测</u></strong> 的表述：</p>
<script type="math/tex; mode=display">
\vec z_{k,j}=h(\vec y_j\ ,\vec x_k \ ,\vec {v_{k,j}})</script><p>该式表示的是相机在位置 $\vec x_k$上看到某个路标点 $\vec y_j$时，产生了一个观测数据 $\vec z_{k,j}$ ，而 $\vec v_{k,j}$表示观测噪声</p>
<hr>
<p>以二维运动为例：</p>
<p>如图所示</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033742.png" style="zoom:60%;" /></p>
<p>已知上一时刻k-1的相机位姿 $\vec x_{k-1}$ 和运动输入$\vec{u}_{k}$（在视觉SLAM中可以由视觉里程计得出或通过传感器得出）</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\vec{x}_{k}=\left[x_{1}, x_{2}, \theta\right]_{k}^{\top} \\
&\vec{u}_{k}=\left[\Delta x_{1}, \Delta x_{2}, \Delta \theta\right]_{k}^{\top}
\end{aligned}</script><p>运动方程为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{1} \\
x_{2} \\
\theta
\end{array}\right]_{k}=\left[\begin{array}{l}
x_{1} \\
x_{2} \\
\theta
\end{array}\right]_{k-1}+\left[\begin{array}{c}
\Delta x_{1} \\
\Delta x_{2} \\
\Delta \theta
\end{array}\right]_{k}+\vec{w}_{k}</script><p>对于观测方程，以二维激光传感器为例，如图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215033747.png" alt="img" style="zoom:60%;" /></p>
<p>路标点j与相机位置关系由距离r和夹角 $\varphi$表示，即观测数据 $z_{k,j}=[r_{j},\varphi_{j}]^T_k$（这是由传感器测出的值），这里的k表示k时刻下的观测数据</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
r_{j} \\
\varphi_{j}
\end{array}\right]_k=\left[\begin{array}{c}
\sqrt{\left(x_{1,k}-y_{1, j}\right)^{2}+\left(x_{2,k}, -y_{2, j}\right)^{2}} \\
\arctan \left(\frac{y_{2,j} -x_{2, k}}{y_{1, j}-x_{1, k}}\right)
\end{array}\right]+\vec{v}</script><p>$\vec{v}$是观测误差，现在就要求 $\vec x_k$和 $\vec y_j$</p>
<blockquote>
<p>注意：这里求 $\vec x_k$表示定位问题，即求出相机自己本身在世界坐标系下的坐标，而求出 $\vec y_j$表示建图问题，即求出周围环境中路标点在世界坐标系下的坐标</p>
</blockquote>
<p>如果求出了 $\vec x_k$和 $\vec y_j$，这样就可以确定相机位置与路标点的位置，也就完成了定位和建图，而反看上面的运动方程和观测方程，假如没有噪声的存在，那么直接解方程就是了，就可以准确的求出相机和路标点在世界坐标系下的位置，然而现实并不是这样，由于噪声的存在，<strong>解方程的问题就变成了一个状态估计问题</strong>，这也是SLAM的最基本问题。</p>
<p>按照运动和观测方程是否为线性和噪声是否服从高斯分布，可以分为以下几类以及解决其状态估计的办法：</p>
<p>线性高斯分布（LG）$\longrightarrow$ 卡尔曼滤波（KF）</p>
<p>非线性非高斯分布（NLNG）$\longrightarrow$扩展卡尔曼滤波（EKF）或非线性优化</p>
]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖包是什么</title>
    <url>/2021/10/21/%E4%BE%9D%E8%B5%96%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>我们在Ubuntu中常说的依赖是什么呢？</p>
<span id="more"></span>
<p>依赖包就是某个软件用到的库文件。</p>
<p>任何程序员写程序都有可能会依赖一些别人已经写成的库，所以几乎一定规模的程序必然有依赖。</p>
<p>不同体系用不同的方法解决依赖问题。</p>
<p>GNU/Linux：通常这个系统大多数软件是自由软件，换句话说，他们通常依赖的库也是自由的，所以软件开发者认为你可以自由的获取这些依赖库，自然就不需要自己再提供了。由系统“发行版”负责维护属于这个系统的所有依赖库，并且安装软件时确定依赖。<br>这个体系的特点是：</p>
<ul>
<li>系统依赖通常是统一的，如果有多个程序依赖同一个库，在这个系统中通常是同一份。</li>
<li>具有庞大的资源。例如 Debian 系现成的可依赖软件多达 30G，所以通常不可能预先把所有依赖都安装全，但庞大的依赖库给编程人员提供了很多方便。</li>
<li>你安装的软件越多，共同依赖所体现出的价值越高，解决依赖问题就越简单（因为当你安装足够多软件时，主流的依赖已经全部在你系统了）。</li>
<li>由于巨大的共同依赖库存在，软件本身可以很小。</li>
</ul>
<p>Windows：通常而言，这个系统的软件是商业软件，因此，他们依赖的库也很有可能是商业软件，所以，不可能要求用户自行获取这些依赖，这些依赖通常在发布软件的时候提供。如果你安装的软件少，这个体系很方便。<br>不过这造成了一些缺点：</p>
<ul>
<li>没有一个庞大的公共库，很多功能以及基础库都是每个公司自己实现一套，浪费很多劳动力，编程人员到每个公司得学习一套不同的库，给编程人员带来不便。</li>
<li>所有应用程序都自己带依赖，因此很可能有许多程序同时附带了相同的依赖，并且这些相同依赖还有可能是不同的版本，这会造成许多混乱。</li>
<li>由于所有应用程序都自己提供所有依赖，每个软件体积都很庞大。</li>
<li>系统中安装的软件越多，越容易出问题。</li>
</ul>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>侯捷老师C++学习笔记——大气编程(上)</title>
    <url>/2021/11/10/%E4%BE%AF%E6%8D%B7%E8%80%81%E5%B8%88C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%A7%E6%B0%94%E7%BC%96%E7%A8%8B(%E4%B8%8A)/</url>
    <content><![CDATA[<p>本课程要有一点点C或C++的基础，学习效果会更好哦。<br>侯捷老师讲的特别通透，听完收获很大。<br><span id="more"></span></p>
<h1 id="Lesson1-简介"><a href="#Lesson1-简介" class="headerlink" title="Lesson1 简介"></a>Lesson1 简介</h1><p><strong>课程基础：</strong></p>
<ul>
<li>曾经学过某种面向过程的编程语言(procedural language)</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215004928.png" alt="image-20211110062021618"></p>
<ul>
<li><p>知道程序的编译链接过程</p>
</li>
<li><p>知道如何编译链接，如何建立一个可执行程序</p>
</li>
</ul>
<p><strong>课程目标：</strong></p>
<ul>
<li>培养正规大气的编程习惯</li>
<li><p>以良好的方式编写C++ Class（对于单一的类，我们叫做基于对象的编程）</p>
<ul>
<li>有指针的Class</li>
<li>没有指针的Class</li>
</ul>
</li>
<li><p>学习Class之间的关系（对于多个Class之间的关系，称为面向对象的编程）</p>
<ul>
<li>继承(inheritance)</li>
<li>复合(composition)</li>
<li>委托(deligation)</li>
</ul>
</li>
</ul>
<blockquote>
<p>学会了一种语言，编程思想掌握了，除了具体语法有一些差异，其他语言也就学会了。</p>
</blockquote>
<p>C++包括：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215004935.png" alt="image-20211110064133887" style="zoom: 25%;" /></p>
<p>标准库很重要，一个C++程序员一定会用标准库。</p>
<p><strong>C++推荐书籍：</strong></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005323.png" alt="image-20211215005323692" style="zoom:33%;" /></p>
<p>还有Effective C++ ，STL源码剖析。</p>
<p>本课程有两个例子，一个是写一个复数complex，另一个是写字符串string。后面都是用到这两个例子，就不再多说明了。</p>
<h1 id="Lesson2-头文件与类声明文件"><a href="#Lesson2-头文件与类声明文件" class="headerlink" title="Lesson2 头文件与类声明文件"></a>Lesson2 头文件与类声明文件</h1><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005345.png" alt="image-20211110064729929" style="zoom: 25%;" /></p>
<p>一个程序中，包括数据和函数，函数是用来处理数据的，但是在C中，数据是全局的，各个函数都可以去处理它们，C++的思想就是把数据和处理这种数据的函数包在一起，这就是类。类是C语言中的Structure的升级，带有一些新的特性。</p>
<h2 id="带指针的class和不带指针的class"><a href="#带指针的class和不带指针的class" class="headerlink" title="带指针的class和不带指针的class"></a>带指针的class和不带指针的class</h2><p>不带指针的class，如复数，class创建了多个对象，这些对象中的数据部分占用的大小是一样的，然后用class中的函数可以处理这些数据，注意这里的函数只有一份，不是每个对象里都有一个函数。</p>
<p>而带指针的class，如字符串，每个字符串的长度不同，所以大小也是不同的，class中的数据类型是固定的，大小不可以变化，所以class中定义了指针，用指针指向字符串，然后每个指针占用的大小是相同的。</p>
<h2 id="代码的基本形式"><a href="#代码的基本形式" class="headerlink" title="代码的基本形式"></a>代码的基本形式</h2><p> 包括：</p>
<ul>
<li>头文件</li>
<li>主程序</li>
</ul>
<p>其实是一样的，只不过有角色的区分，所以分为头文件和主程序。</p>
<p>引用标准库的头文件用<code>&lt;&gt;</code> ，自己写的用<code>&quot;&quot;</code></p>
<p>而且，头文件的延伸文件名不一定是<code>.h</code> <code>.cpp</code>，也可能是<code>.hpp</code>或其他的扩展名 。</p>
<p>Eg. <code>complex.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLEX__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上述的代码是一个防卫式声明，防止头文件被反复的包含。</p>
<h2 id="头文件布局"><a href="#头文件布局" class="headerlink" title="头文件布局"></a>头文件布局</h2><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005426.png" alt="image-20211215005426587" style="zoom:50%;" /></p>
<p>头文件最主要的是上图中的1和2，1是类的声明，就是声明一下类中有哪些变量，哪些函数。2是类中函数的具体定义。但有时在做1和2时，一些东西应该先声明过，所以这就有了0前置声明。</p>
<h2 id="class语法部分"><a href="#class语法部分" class="headerlink" title="class语法部分"></a>class语法部分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>		//<span class="keyword">class</span> <span class="title">head</span></span></span><br><span class="line"><span class="class">&#123;</span>								<span class="comment">//class body</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span> (<span class="keyword">double</span> r=<span class="number">0</span>,<span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，类的声明部分，要有class head，也就是类的名字，然后下面的大括号里面是class body。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>下面我们慢慢发展我们的代码。</p>
<p>看上面类中的数据部分，re和im是double类型的，但是如果我们想要写成别的类型时，也不能反复的写好多个类呀，所以这时候就可以用到模板，这样我们就可以在定义对象的时候再制定里面数据的类型了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//使用模板，要在类前加上这句话,这里的T是一个符号，任何符号都行。这就是告诉编译器T是一个模板。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>		</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	T re，im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在用的时候，我们就可以把T替换成我们制定的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex&lt;<span class="keyword">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">1.5</span>)</span></span>;</span><br><span class="line"><span class="function">complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="Lesson3-构造函数"><a href="#Lesson3-构造函数" class="headerlink" title="Lesson3 构造函数"></a>Lesson3 构造函数</h1><p>我们现在不再介绍模板，回到我们的代码继续发展。</p>
<h2 id="内联-inline-函数"><a href="#内联-inline-函数" class="headerlink" title="内联(inline)函数"></a>内联(inline)函数</h2><p>在声明类的时候，我们也可以直接在类中定义函数，这种定义就叫做内联函数。</p>
<p>内联函数的好处就是调用的时候很快，但是是否是内联函数还要由编译器决定。编译器会根据函数的复杂程度自行决定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>		</span></span><br><span class="line"><span class="class">&#123;</span>								</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span> (<span class="keyword">double</span> r=<span class="number">0</span>,<span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> re;&#125;<span class="comment">//这个函数很简单，很有可能被编译器编程内联函数。</span></span><br><span class="line">  	<span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码是直接在类的声明的时候定义了函数。我们也可以在后面具体定义函数的时候定义内联函数，此时就要加上关键字<code>inline</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">complex::imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>在class body中，定义了访问级别。主要有public，private和protect。</p>
<p>主要介绍public和private。</p>
<p>public就是公开的，外部可以看的到。</p>
<p>private就是只有该class里可以看的到，一般数据部分会放到private里。</p>
<p>函数也分为类自己的函数还有给外部用的函数。</p>
<p>在写代码时，各个段落是可以互相交错的。先public再private然后再public。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建一个对象，构造函数会被自动调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;<span class="comment">//赋初始值</span></span><br><span class="line">complex c2;<span class="comment">//不赋值，默认创建</span></span><br><span class="line">complex* p = <span class="keyword">new</span> <span class="built_in">complex</span>(<span class="number">3</span>,<span class="number">1</span>);<span class="comment">//动态创建，创建了一个该类的指针</span></span><br></pre></td></tr></table></figure>
<p>构造函数名一定要和类的名字相同。</p>
<p>函数的参数是可以有默认值的，在创建对象的时候没有指明参数，就使用默认值。</p>
<p>构造函数是没有返回类型的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>		</span></span><br><span class="line"><span class="class">&#123;</span>								</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span> (<span class="keyword">double</span> r=<span class="number">0</span>,<span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的写法是一种大气规范的写法。只有构造函数有这种写法。</p>
<p><code>re(r)</code> 和 <code>im(i)</code> 就是把r和i的值赋值给class的数据。当然也可以写到大括号里，但是这样的写法不好。</p>
<blockquote>
<p>不带指针的类一般不用写西沟函数。</p>
</blockquote>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>构造函数可以有多个重载。因为要被初始化，可能有很多种情况的设定，所以需要不同方法的构造函数。</p>
<blockquote>
<p>当然一般的函数也可以重载，事实上，在我们写代码的时候，函数名是一样的，但是当进行编译的时候，由于传入的参数类型，个数还有返回值的类型不同，编译器编译后的代码显示的函数名是不一样的。只是我们人类在看的时候是一样的。</p>
</blockquote>
<p>下面这种重载是不允许的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span>(<span class="keyword">double</span> r=<span class="number">0</span> , <span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">  	<span class="built_in">complex</span>()<span class="built_in">re</span>(<span class="number">0</span>),<span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;<span class="comment">//这两种写法是不行的，编译后的代码是一样的，这时编译器就不知道调用哪个函数了。</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Lesson4-参数传递与返回值"><a href="#Lesson4-参数传递与返回值" class="headerlink" title="Lesson4 参数传递与返回值"></a>Lesson4 参数传递与返回值</h1><p>构造函数一般不可以被放在private，如果放在private里，就说明外界不可以创建对象。</p>
<p>有一种设计模式叫做singleton就是把构造函数写到private里。</p>
<h2 id="常数成员函数"><a href="#常数成员函数" class="headerlink" title="常数成员函数"></a>常数成员函数</h2><p>class中的函数有两种，会改变数据内容的和不会改变数据内容的。</p>
<p>不改变数据内容的函数一定要加 <code>const</code> ，这是大气的编程习惯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span>(<span class="keyword">double</span> r=<span class="number">0</span> , <span class="keyword">double</span> i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">double</span> <span class="title">real</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数名后加 <code>const</code> 说明该函数一定不会改变class的数据。如果不加，就说明可以改动。</p>
<p>那么不加会有什么后果呢？</p>
<p>看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;c1.<span class="built_in">real</span>();</span><br><span class="line">cout&lt;&lt;c1.<span class="built_in">imag</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> complex <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;<span class="comment">//这里说明该对象是一个常量，内部的数据一定不会改</span></span><br><span class="line">cout&lt;&lt;c2.<span class="built_in">real</span>();<span class="comment">//那么在调用该函数的时候，如果函数没有加const，就说明内部的数据可以该，这就与定义时相矛盾</span></span><br><span class="line">cout&lt;&lt;c2.<span class="built_in">imag</span>();</span><br></pre></td></tr></table></figure>
<h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><h3 id="1-pass-by-value"><a href="#1-pass-by-value" class="headerlink" title="1.pass by value"></a>1.pass by value</h3><p>pass by value就是把要传入的变量的值整包传过去，这个变量有多少个字节，就传多少个。这样的效率很低。</p>
<h3 id="2-pass-by-reference"><a href="#2-pass-by-reference" class="headerlink" title="2.pass by reference"></a>2.pass by reference</h3><p>在C中，可以用指针来传递，就是把这个变量的地址传进去。在C++中，可以用reference(引用)来进行传递。</p>
<p>其实引用的底层就是传指针。引用的形式很漂亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">complex</span>(<span class="keyword">double</span> &amp;r=<span class="number">0</span>,<span class="keyword">double</span> &amp;i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;<span class="comment">//这就是传引用</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">double</span> re;</span><br><span class="line">  	<span class="keyword">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上面的例子，传引用就相当于 <code>double &amp; r = varies</code> ，这时，就相当于为varies变量起了一个别名r，当改变r的时候，varies也会改变。r的地址和varies的地址一样。</p>
<p>当不想让varies改变时，就可以在r前面加上 <code>const</code> 关键字。此时改变r的值时，编译就会出错。</p>
<blockquote>
<p>参数传递尽量都传引用。</p>
</blockquote>
<h2 id="返回值的传递"><a href="#返回值的传递" class="headerlink" title="返回值的传递"></a>返回值的传递</h2><h3 id="1-return-by-value"><a href="#1-return-by-value" class="headerlink" title="1.return by value"></a>1.return by value</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">function</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-return-by-reference"><a href="#2-return-by-reference" class="headerlink" title="2.return by reference"></a>2.return by reference</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span>&amp; <span class="title">function</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong>什么时候不可以return by reference呢？</strong></p>
<p>当返回的东西是函数内创建的，这是一个local变量，当函数运行完之后，就直接消失了，所以此时renturn by reference，指向到一个消失的东西。这就不可以了。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>class中的数据在private下，外界不可以获取。但是想让一些函数可以直接获取，就可以加上 <code>friend</code>  关键字，表明这个函数是该class的朋友，可以直接获取class中的数据。</p>
<p>定义友元函数，要在class中声明一下子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">friend</span> complex&amp; __doap1(complex*,<span class="keyword">const</span> comp1ex)<span class="comment">//在class中声明一下子，该函数是该class的友元，写在哪个标签下都无所谓</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp; __doap1(complex* ths,<span class="keyword">const</span> comp1ex&amp; r)<span class="comment">//定义函数</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要注意：相同class的各个object互为友元</strong>，这就是说对象1中的函数可以直接处理对象2中的数据。</p>
<h1 id="Lesson5-操作符重载与临时对象"><a href="#Lesson5-操作符重载与临时对象" class="headerlink" title="Lesson5 操作符重载与临时对象"></a>Lesson5 操作符重载与临时对象</h1><p>事实上，在C++中，操作符就是一种函数，是可以重新定义的。也就是操作符重载。</p>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>操作符重载的函数可以写成成员函数的形式，也可以写成非成员函数的形式</p>
<h3 id="1-成员函数的形式"><a href="#1-成员函数的形式" class="headerlink" title="1.成员函数的形式"></a>1.成员函数的形式</h3><p>这就是把操作符重载函数写在class内，对该class的object进行操作。</p>
<p>首先我们来看一下编译器是如何看待操作符的。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005449.png" alt="image-20211110090019793" style="zoom:25%;" /></p>
<p><code>+=</code> 这是一个二元操作符，就是有两个操作数的。</p>
<p>编译器看待这个符号，就是把这个符号作用在左边身上，如果左边对这个符号进行了定义，那么编译器就找到了这个函数。</p>
<p>所有的操作符重载都有一个隐藏的参数，就是<code>this</code>，谁调用这个函数，那个谁就是this，this是那个谁的指针。这里就是c2的指针。</p>
<p>在写重载的时候，这个this就不写在形参列表里（也不能写，写出来就错了），但是是有的，如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; complex::<span class="keyword">operator</span> +=(<span class="keyword">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __doap1(<span class="keyword">this</span>,r);<span class="comment">//这个函数的功能是修改this指向变量的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的二元操作符都是这种规则。</p>
<blockquote>
<p>在这里补充一下by reference传递的另一个好处，就是传递者不需要知道接收者的形式，如果要用指针进行传递，一定要搞清楚，接收者接收的是指针还是value，因为接收者如果是一个指针，那么它只能接收指针，所以传递的时候要取地址。</p>
</blockquote>
<p>注意上面代码，操作符重载函数有一个返回值类型，<code>complex&amp;</code> 。虽然该函数可以直接通过this为操作符前面的变量赋值，有没有这个都无关紧要。但是下面这种形式，就需要有返回值了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c3+=c2+=c1</span><br></pre></td></tr></table></figure>
<h3 id="2-非成员函数的写法"><a href="#2-非成员函数的写法" class="headerlink" title="2.非成员函数的写法"></a>2.非成员函数的写法</h3><p>之前的+=操作符重载成员函数写法，函数的形参里面自动包含了一个隐藏的this指针，可以直接操作this，从而改变操作符左边的变量。</p>
<p>但是有的时候，不是改变操作符左边的变量。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c3=c1+c2;</span><br><span class="line">c2=c1+<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>此时，就需要使用非成员函数的写法。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005524.png" alt="image-20211215005524527" style="zoom:50%;" /></p>
<p>这里是没有this的存在的。</p>
<blockquote>
<p>这种情况必是return by reference ，因为返回的必定是local object。</p>
</blockquote>
<h2 id="临时对象-typename"><a href="#临时对象-typename" class="headerlink" title="临时对象 typename()"></a>临时对象 typename()</h2><p>在上面的return中，我们可以看见，<code>complex (,)</code> ，这就是一个临时对象。</p>
<p>这种形如 <code>typename ()</code> ，是临时对象。它的声明到下一行就结束了。</p>
<p>例如熟悉的int类型，临时对象就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);<span class="comment">//这并不是一个函数，就是一个值为5的int型的临时变量，当运行到下一句话时，这个变量就消失了。</span></span><br></pre></td></tr></table></figure>
<h1 id="Lesson6-复习complex"><a href="#Lesson6-复习complex" class="headerlink" title="Lesson6 复习complex"></a>Lesson6 复习complex</h1><p>本节课是复习课，回顾了complex类的创建过程。</p>
<h1 id="Lesson7-三大函数"><a href="#Lesson7-三大函数" class="headerlink" title="Lesson7 三大函数"></a>Lesson7 三大函数</h1><p>介绍完complex类之后，我们现在继续学习带指针的类的写法。以string字符串这个类为例子。</p>
<p>在创建一个新的字符串时，我们会遇到以下的几个情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">s1</span><span class="params">()</span></span>;<span class="comment">//创建一个没有初值的对象</span></span><br><span class="line">	<span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;<span class="comment">//创建有初值的对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;<span class="comment">//创建一个新的对象，以另一个对象为初值，是一个拷贝的动作</span></span><br><span class="line">	s3=s2;<span class="comment">//赋值，也是一个拷贝的动作，这里与上一句的区别就是这里的s3不是第一次出现</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的complex的例子，我们没有写，但是编译器会自己制定一个规则，就是一项一项的对应，去拷贝和赋值。但是复数是很规则的，有实部和虚部，默认的拷贝和赋值完全可以满足。</p>
<p>但是字符串创建的是指针，两个指针不能指向同一个地方，这样会弄乱，所以带指针的类一定要自己写拷贝和赋值。</p>
<p>下面我们来看String类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>);</span><br><span class="line">  	<span class="built_in">String</span>(<span class="keyword">const</span> String&amp; str);</span><br><span class="line">  	String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp; str);</span><br><span class="line">  	~<span class="built_in">String</span>();</span><br><span class="line">  	<span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> m_data;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字符串就是指针指着头，最后有一个结束符号。</p>
<p>我们先来看第一个构造函数，是没有初始值得构造函数。函数的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cstr)</span><br><span class="line">  &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];<span class="comment">//如果指针不是空，那么运行这段话，分配一个空间，大小为字符串的长度再加上1，因为后面还有一个结束符。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,cstr);<span class="comment">//然后调用这个函数，把指针地址拷贝到数据中。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_data=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];<span class="comment">//如果是空指针，那么就在该空间放一个结束符。</span></span><br><span class="line">    *m_data=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数应对下面这两句话，会被调用</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">String <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">  String*p = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//这里也会调用上面的构造函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>当这个对象被清理的时候，会自动调用析构函数，需要把这块的内存给释放，否则就内存泄漏了。</p>
<p>析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p><strong>三大函数有拷贝构造，拷贝赋值，析构函数</strong>。析构函数我们上面说了。下面说前两个。</p>
<p>只要是带有指针的类，就要有这三大函数。</p>
<p>如果没有拷贝构造函数，用编译器自动生成的拷贝构造，就会发生<strong>浅拷贝</strong>。</p>
<p>浅拷贝就是，自动生成的拷贝构造函数，只会把指针本身拷贝过去，这样就会造成两个指针指向同一个东西。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="keyword">const</span> String&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_data=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data)+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data,str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造适用的条件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">String <span class="title">s1</span><span class="params">(s2)</span></span>;</span><br><span class="line">  String s3=s1;<span class="comment">//这个虽然是赋值符，但是s3是新建立的，此时也是调用拷贝构造函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h2><p>拷贝赋值的过程：</p>
<ul>
<li>先将原来的东西清空</li>
<li>然后再拷贝字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>==&amp;str)<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//自我检查，看是不是自己赋值自己。</span></span><br><span class="line">  <span class="keyword">delete</span>[] m_data;<span class="comment">//删除原来的空间内容</span></span><br><span class="line">  m_data=<span class="keyword">new</span>[<span class="built_in">strlen</span>(str.m_data)+<span class="number">1</span>];<span class="comment">//重新指向一个空间</span></span><br><span class="line">  <span class="built_in">sctrcpy</span>(m_data,str.m_data);<span class="comment">//拷贝内容</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回自己，这样可以连=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>上面的自我检查很重要，如果是自己赋值自己，没有自我检查，会先把原空间的内容删掉，结果赋值后字符串的内容变成空了。</p>
<h1 id="Lesson8-内存管理"><a href="#Lesson8-内存管理" class="headerlink" title="Lesson8 内存管理"></a>Lesson8 内存管理</h1><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><p>是存在某作用域的一块内存空间，例如调用的函数，函数本身会形成一个栈来放置它所接收的参数，以及返回地址。</p>
<p>在函数本体（function body）内声明的变量所使用的内存块都取自上述的栈。</p>
<p>该空间中的变量会被自动清理掉。</p>
<h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h2><p>是操作系统提供的一块全局（global）的内存空间，程序可动态分配（dynamic allocated）该空间。</p>
<p>所以我们需要手动开辟出一块空间，并且手动清理该空间。</p>
<h2 id="生命期"><a href="#生命期" class="headerlink" title="生命期"></a>生命期</h2><ol>
<li>stack object：其生命在作用域结束之后结束。</li>
<li>static object：其生命在作用域结束之后仍然存在，直到整个程序结束。</li>
<li>global object：其生命也是在程序结束之后才结束，也可以把它当成是一个static object。</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="1-new"><a href="#1-new" class="headerlink" title="1.new"></a>1.new</h3><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005540.png" alt="image-20211110140453980" style="zoom:25%;" /></p>
<p>如果不delete，那么随着程序的运行，指针p会消亡，那剩下所指的空间就没人管了。所以称为内存泄漏。</p>
<p>分配内存的分解动作：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005626.png" alt="image-20211215005626031" style="zoom: 50%;" /></p>
<ol>
<li>先调用一个叫operator new的函数，分配内存，得到一个指针。</li>
<li>然后将这个指针转型。</li>
<li>然后通过指针调用该类的构造函数。</li>
</ol>
<h3 id="2-delete"><a href="#2-delete" class="headerlink" title="2.delete"></a>2.delete</h3><p>再来分解delete的动作：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005657.png" alt="image-20211110141305647" style="zoom: 33%;" /></p>
<ol>
<li>首先调用析构函数。</li>
<li>释放内存。</li>
</ol>
<p><strong>良好的编程习惯：</strong></p>
<p><code>new[]</code> 要搭配 <code>delete[]</code>使用。</p>
<h1 id="Lesson9-复习String"><a href="#Lesson9-复习String" class="headerlink" title="Lesson9 复习String"></a>Lesson9 复习String</h1><p>本节课主要是复习之前的String类。</p>
<h1 id="Lesson10-类模板-函数模板-及其他补充"><a href="#Lesson10-类模板-函数模板-及其他补充" class="headerlink" title="Lesson10 类模板 函数模板 及其他补充"></a>Lesson10 类模板 函数模板 及其他补充</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>每创建一个对象，对象中的非静态数据都会被创建一份。</p>
<p>而函数只有一份，不同的对象调用成员函数，其实就是给函数传入不同的地址，让成员函数来处理该地址对应对象的数据。这靠的就是this pointer。</p>
<p>可能有点绕，好好想一下。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005802.png" alt="image-20211215005802555"></p>
<p>函数的参数列表中一定不要写this，编译器会自动加，否则就会报错。黄色的地方呢就是可加可不加。 </p>
<p>当成员变量加上<code>static</code>关键字，就和对象脱离了，在内存中只有一份。</p>
<p>而静态成员函数和一般的成员函数几乎一样，都只有一份。但是唯一的区别是，<strong>静态成员函数没有this pointer</strong>。所以它不能直接去处理对象中的数据，而是去处理静态成员变量。</p>
<p><strong>静态变量的使用：</strong></p>
<p>静态变量在类中声明，但是在使用的时候，需要在类外进行定义。</p>
<blockquote>
<p>这里辨析一下声明和定义。无论是变量还是函数。声明是告诉编译器有该东西存在，但是不分配内存。</p>
<p>而分配内存，就称为定义。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">  	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span></span>&#123;m_rate=x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">double</span> Account::m_rate=<span class="number">1</span>;<span class="comment">//这里是定义，可以赋初值也可以不赋值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Account::<span class="built_in">set_rate</span>(<span class="number">5</span>);<span class="comment">//调用静态函数可以直接调用，不通过对象。</span></span><br><span class="line">  Account a;</span><br><span class="line">  a.<span class="built_in">set_rate</span>(<span class="number">7</span>);<span class="comment">//也可以通过对象来调用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：凡是类里面的一切东西，无论是变量还是函数，拿到外面的名字都要加上类名。就是在家里可以直接叫名字，但是到外面，就必须要加上姓氏。</p>
<p>就像上面的 <code>static double m_date</code>，在外面的名字就是 <code>Account::m_date</code>。</p>
</blockquote>
<p><strong>静态函数的使用：</strong></p>
<ul>
<li>通过对象调用。</li>
<li>通过类名调用，也就是直接用函数的全名调用。</li>
</ul>
<h2 id="Singleton设计模式"><a href="#Singleton设计模式" class="headerlink" title="Singleton设计模式"></a>Singleton设计模式</h2><p>只能创建一个对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">static</span> A&amp; <span class="title">getinstance</span><span class="params">(<span class="keyword">return</span> a;)</span></span>;</span><br><span class="line">  	<span class="built_in">setup</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="built_in">A</span>();</span><br><span class="line">  	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; rhs);<span class="comment">//构造函数都写在私有里，外界不能创建。</span></span><br><span class="line">  	<span class="keyword">static</span> A a;<span class="comment">//这里创建了一个静态变量，没有任何人创建A的对象时，就已经存在一个了。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果要使用这个对象，就通过静态函数来获取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A::getinstance.<span class="built_in">setup</span>()；<span class="comment">//通过静态函数便可以操作这个对象的所有成员函数。</span></span><br></pre></td></tr></table></figure>
<p>这样写呢也有一个弊端，就是在没有使用这个对象的时候，它已经出现了。</p>
<p>所以有下面这种改进：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">static</span> A&amp; <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">  	<span class="built_in">A</span>();</span><br><span class="line">  	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">A::getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> A a;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进后，在静态成员函数内声明了这个对象，这样的好处就是当使用这个静态成员函数一次，该对象就会被创建，并且会一直存在到程序结束。</p>
<h2 id="函数模板-function-template"><a href="#函数模板-function-template" class="headerlink" title="函数模板(function template)"></a>函数模板(function template)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b&lt;a?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在使用时，与类模板不同，不用再指出具体的类型</span></span><br><span class="line">r3=<span class="built_in">min</span>(r1,r2);</span><br></pre></td></tr></table></figure>
<p>编译器会做实参推导，自动推导出类型。</p>
<p>例如上面的比大小，编译器会自动推导，a和b的类型，然后在下面有&lt;，编译器会根据该类型寻找是否有重载。那么定义该类的人就需要写好重载&lt;的函数。这样职责分开，是特别好的。在C++中标准库中，有很多这样的模板函数，称为算法。</p>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子是把所有的东西都包在std里面，这样可以避免同名的函数混淆。</p>
<p>在使用的时候，就要打开这种包裹。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//全开 using directive</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;<span class="comment">//就开这一个 using declaration</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cin&lt;&lt;...;</span><br><span class="line">  cout&lt;&lt;...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Lesson11-组合与继承"><a href="#Lesson11-组合与继承" class="headerlink" title="Lesson11 组合与继承"></a>Lesson11 组合与继承</h1><p>前面我们学的是写一个单一的class，这种叫基于对象设计。</p>
<p>下面我们要学习，类和类之间的关系。也就是面向对象编程。</p>
<p>类与类的关系大致上可以分为三种：组合，委托，继承。</p>
<h2 id="Composition组合-表示has-a"><a href="#Composition组合-表示has-a" class="headerlink" title="Composition组合(表示has-a)"></a>Composition组合(表示has-a)</h2><p>一个class里面包含了另一个class的对象。</p>
<p>对于复杂的程序，通常会使用图来表示。组合关系的表示方法如下：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005817.png" alt="image-20211110162419332" style="zoom: 33%;" /></p>
<p>下面讨论这种组合关系时的构造函数和析构函数。</p>
<p><strong>构造函数</strong></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005824.png" alt="img" style="zoom:33%;" /></p>
<p>构造函数规则，由内而外，先调用内部包含class的默认构造函数。如果想调用别的构造函数，需要自己写明。</p>
<p>放一个慢动作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>():<span class="built_in">Component</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>内部的构造函数可以不用自己写，编译器会帮我们自动完成。</p>
<p><strong>析构函数</strong></p>
<p>由外而内，先调用Container的析构函数。再放一个慢动作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Container::~<span class="built_in">Container</span>()&#123;~Component&#125;</span><br></pre></td></tr></table></figure>
<p>这也是编译器自动帮我们完成的。</p>
<h2 id="Delegation委托-composition-by-reference"><a href="#Delegation委托-composition-by-reference" class="headerlink" title="Delegation委托(composition by reference)"></a>Delegation委托(composition by reference)</h2><p>类中包含另一个类的指针。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005832.png" alt="image-20211110164453307" style="zoom:33%;" /></p>
<p> 在这里有一个很有名的设计模式，就是一个类中包含了另一个类的指针，而这个指针所指的类中包含了要实现的所有功能，这种模式称为 <strong>pimpl</strong> 。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005930.png" alt="image-20211215005930376"></p>
<h2 id="Inheritance继承-表示is-a"><a href="#Inheritance继承-表示is-a" class="headerlink" title="Inheritance继承(表示is-a)"></a>Inheritance继承(表示is-a)</h2><p>继承的关系，子类可以包含父类的数据。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> B<span class="comment">//public公有继承，还可以是private protect</span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>用图表示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215005944.png" alt="image-20211110165524489" style="zoom:33%;" /></p>
<p>下面是子类，上面的是父类，由儿子指向父亲。</p>
<p>就如同生物学的那样，界门纲目科属种。一直往下分，每一个门都是一个界的一种。所以是is-a。</p>
<blockquote>
<p>继承最有价值的地方是和虚函数搭配使用。</p>
</blockquote>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215010208.png" alt="image-20211215010208419" style="zoom:50%;" /></p>
<blockquote>
<p>父类的析构函数要是virtual</p>
</blockquote>
<p>在这里我们只探讨public继承。</p>
<h1 id="Lesson12-虚函数与多态"><a href="#Lesson12-虚函数与多态" class="headerlink" title="Lesson12 虚函数与多态"></a>Lesson12 虚函数与多态</h1><p>使用继承的时候，要搭配虚函数使用，效果最佳。</p>
<p>继承的时候，数据会被继承下来，在创建子类对象的时候，会分配内存空间。</p>
<p>成员函数也会被继承下来，但是函数是不会被分配内存空间的。函数的继承是<strong>继承函数的调用权。</strong></p>
<p>什么事虚函数呢？就是在成员函数的声明钱加上<code>virtual</code>。</p>
<p>成员函数可以分为三类：</p>
<ol>
<li>non-virtual函数：不希望子类重新定义(override)</li>
<li>virtual函数：希望子类重新定义 <code>virtual void function()</code></li>
<li>pure virtual函数：子类必须重新定义 <code>virtual void function()=0</code></li>
</ol>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215010237.png" alt="image-20211110171243449" style="zoom: 33%;" /></p>
<p>例如，定义一个形状的类。世界上并没有叫形状的形状，所以该类一定会有子类。</p>
<p>上面就会定义一个画出形状的函数，这个函数一定要被子类override。</p>
<p>我们还会给每个形状都附一个编号，这个和具体的形状无关，所以用non-virtual函数。</p>
<p>我们还要打出操作各种形状的一些信息，如果子类不特别说明，就用父类定义的内容。如果子类想单独说明，也可以重写，所以这里用virtual函数。</p>
<h1 id="Lesson13-委托相关设计"><a href="#Lesson13-委托相关设计" class="headerlink" title="Lesson13 委托相关设计"></a>Lesson13 委托相关设计</h1><p>本节课介绍了一些设计模式。</p>
<p>就用到composition, delegation,inheritance这三种模式，进行组合，来解决现实的问题。</p>
<p>其中delegation+inheritance的功能最强大。</p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>侯捷老师C++学习笔记——大气编程(下)</title>
    <url>/2021/11/10/%E4%BE%AF%E6%8D%B7%E8%80%81%E5%B8%88C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%A7%E6%B0%94%E7%BC%96%E7%A8%8B(%E4%B8%8B)/</url>
    <content><![CDATA[<p>侯捷老师C++课程下半部分。本课程是对之前课程中所提的一些东西的补充，以及C++11新特性的一些讲解。</p>
<span id="more"></span>
<h1 id="Lesson1-介绍"><a href="#Lesson1-介绍" class="headerlink" title="Lesson1 介绍"></a>Lesson1 介绍</h1><p>本课程会讲的内容：</p>
<ul>
<li>泛型编程</li>
<li>深入探索面向对象继承关系所形成的的对象模型，包括隐藏在底层的this指针，虚指针，虚表等。</li>
</ul>
<h1 id="Lesson2-转换函数-conversion-function"><a href="#Lesson2-转换函数-conversion-function" class="headerlink" title="Lesson2 转换函数 conversion function"></a>Lesson2 转换函数 conversion function</h1><p>转换有两个方向，一个是我这个类型转换成那个，也可以是那个转换成这个。</p>
<p>现在有一个分数class：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014552.png" alt="image-20211110201213702" style="zoom:33%;" /></p>
<p>黄色的部分就是转换函数。转换肯定不会改变数据的值，所以要加上const。</p>
<p>不需要返回值类型，因为很明确，函数名就表示了要转换的那个类型。</p>
<p>调用的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d=<span class="number">3</span>+f;<span class="comment">//调用operator double()将f转为0.6</span></span><br></pre></td></tr></table></figure>
<p>在这里，编译器会首先找一个全局函数，看是不是有<code>+</code>运算符重载函数，如果没有，就去找转换函数，此时再调用转换函数。</p>
<p>只要你认为合理，可以有很多个转换函数。</p>
<h2 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h2><p>再来看下面这种情况，构造函数前可以加 <code>explicit</code> 关键字。现在是不加这个关键字的情况。</p>
<p>首先构造函数有两个形参，其中一个给了初值。其实调用的时候，只要给一个实参即可。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014604.png" alt="image-20211110202233538" style="zoom:33%;" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d=f+<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这时在执行上述代码时，类中的运算符重载函数并没有分数加整型数这种情况，只有分数加分数。当看到没有这种重载<code>+</code> 这种函数，所以就想着可不可以把整型数3变为Fraction，那就看其构造函数，如果满足构造函数的参数，那么就会调用构造函数来进行类型的转换。这是让其他类型的数据转化成本类型。</p>
<p>但是当有下面这种情况时，既可以用构造函数，又可以用类型转换函数。此时编译器会报错，因为它不知道调用哪个函数。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014615.png" alt="image-20211110203235669" style="zoom:33%;" /></p>
<h2 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h2><p>当在构造函数加上关键字<code>explicit</code>后，就可以避免上述问题发生。expilcit意思为明白的，明确的。在该关键字的限制下，构造函数就是创建新对象的时候调用，告诉编译器，不要在隐形转换的时候调用。</p>
<p>看下面的例子：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014637.png" alt="image-20211111065659372" style="zoom: 25%;" /></p>
<p>这里出错显示：<code>[Error]conversion from &#39;double&#39; to &#39;Fraction&#39; request</code> ，在一开始看到<code>f+4</code>时，编译器会先找重载运算符函数，发现只有分数加分数，所以要把4转化成分数，但是该构造函数前加上了explict，所以不能走这条路。于是又找到类型转换函数，这条路可以走通，最终得到结果4.6，但是要把4.6赋值给d2，没有这种类型转换函数。</p>
<h1 id="Lesson3-pointer-like-classes"><a href="#Lesson3-pointer-like-classes" class="headerlink" title="Lesson3 pointer-like classes"></a>Lesson3 pointer-like classes</h1><p>设计一个class，让它像指针。为什么这么做呢，就是想设计一个比指针功能更强大的东西。</p>
<h2 id="关于智能指针"><a href="#关于智能指针" class="headerlink" title="关于智能指针"></a>关于智能指针</h2><p><img src="https://piggyhero.gitee.io/pic/img/20211216014631.png" alt="image-20211111072414463" style="zoom: 25%;" /></p>
<p>shared_ptr是一个智能指针的模板类。我们写了一个Foo类，然后创建一个智能指针sp，这个过程中<code>shared_ptr&lt;Foo&gt; sp(new Foo)</code> 会调用构造函数，向智能指针中传入指针的值。</p>
<p><code>*sp</code>调用了重载运算符*函数。返回值为该对象。</p>
<p>这里要注意<code>sp-&gt;method()</code>，这句话会调用重载运算符函数，返回值是一个指针，虽然<code>-&gt;</code>在调用函数后就已经“消耗了”，返回的是一个指针，相当于已经没有了<code>-&gt;</code> ，但是为了保证符号的一致性，总不能写成<code>sp-&gt;-&gt;method()</code>，所以它就相当于<code>px-&gt;method()</code> ，就不用再写一遍了。</p>
<h2 id="关于迭代器"><a href="#关于迭代器" class="headerlink" title="关于迭代器"></a>关于迭代器</h2><p>迭代器也是一种智能指针，指向容器中的一个元素。但是和上面说的智能指针略有不同。</p>
<p>它不但要处理<code>* -&gt;</code> ，还要处理 <code>++ -- == !=</code> 等。</p>
<h1 id="Lesson4-function-like-classes"><a href="#Lesson4-function-like-classes" class="headerlink" title="Lesson4 function-like classes"></a>Lesson4 function-like classes</h1><p>写一个class，让它像一个函数。即仿函数。</p>
<p>形式为<code>typername()()</code>，前面的括号是创建一个临时对象，然后再加一个括号，是调用运算符重载函数。</p>
<h1 id="Lesson5-member-template-成员模板"><a href="#Lesson5-member-template-成员模板" class="headerlink" title="Lesson5 member template 成员模板"></a>Lesson5 member template 成员模板</h1><p>模板主要分三大类：</p>
<ul>
<li>class template</li>
<li>function template</li>
<li>member template</li>
</ul>
<p>下面是member template的代码：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014652.png" alt="image-20211111080704918" style="zoom:33%;" /></p>
<p>在类中，构造函数为一个模板函数，这样在初始化的时候，会有更大的弹性。 因为模板函数不需要特别指定具体的类型，会自动推导。所以只在外面写好要创建的类，待传入初始化值时，类中的模板函数会自动推导出初始化值得类型。</p>
<h1 id="Lesson6-模板特化-specialization"><a href="#Lesson6-模板特化-specialization" class="headerlink" title="Lesson6 模板特化(specialization)"></a>Lesson6 模板特化(specialization)</h1><p>在使用模板的时候，我们可以随机指定任何的类型，然后把该类型放到模板中。这就是泛化的概念。</p>
<p>但是有时候，我们想在一些特定的类型时，不使用泛化的模板，而是有一些特别之处。这就是模板特化。</p>
<p><strong>语法：</strong></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014659.png" alt="image-20211111082640173" style="zoom:33%;" /></p>
<p>在使用的时候，例如上面的例子，编译器会找，泛化也可以，特化也可以，正如代码所写，特别指定的类型是long，所以就找到对应的模板。</p>
<h1 id="Lesson7-偏特化-partial-specialization"><a href="#Lesson7-偏特化-partial-specialization" class="headerlink" title="Lesson7 偏特化(partial specialization)"></a>Lesson7 偏特化(partial specialization)</h1><h2 id="个数上的偏"><a href="#个数上的偏" class="headerlink" title="个数上的偏"></a>个数上的偏</h2><p><strong>语法：</strong></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014718.png" alt="image-20211111083230419" style="zoom:33%;" /></p>
<p>在这里，我们只想让模板中的某几个类型特化，如上，我们想让T特化，而且Alloc有默认类型。</p>
<p>那么语法就是，在下面写上不特化的类型（特化的类型那块还是空着，对比全特化，尖括号里全是空）。</p>
<h2 id="范围上的偏"><a href="#范围上的偏" class="headerlink" title="范围上的偏"></a>范围上的偏</h2><p>泛化的模板输入的类型可以是任意的，当我们想缩小一下范围，指定具体的某几个类型，例如，是指针类型，但是没有说明是什么的指针。</p>
<p><strong>语法：</strong></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014725.png" alt="image-20211111083910643" style="zoom:33%;" /></p>
<p>这是后，obj1用的就是泛化的模板。obj2用的是特化的模板。</p>
<h1 id="Lesson8-template-template-parameter-模板模板参数"><a href="#Lesson8-template-template-parameter-模板模板参数" class="headerlink" title="Lesson8 template template parameter 模板模板参数"></a>Lesson8 template template parameter 模板模板参数</h1><p><img src="https://piggyhero.gitee.io/pic/img/20211216014731.png" alt="image-20211111084146414" style="zoom: 25%;" /></p>
<p>Container可以是任意的字。模板模板参数就是，尖括号内第一项的模板参数，告诉有T这个模板类型存在。然后第二项模板参数是一个模板类，该模板类还需要模板参数，这样就形成了模板模板参数。</p>
<p>模板类的名字我们可以指定（因为类就可以当做是一个数据类型）</p>
<p>就是很绕，但其实不难的。</p>
<p>然后我们使用的时候，是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">XCLs&lt;string,list&gt; mylst1;</span><br></pre></td></tr></table></figure>
<p>这句话虽然是报错的，但是我们写的模板模板参数啥的都没有问题，报错的主要原因是<code>list</code>这个容器的模板参数有好几个，虽然模板参数是有默认值的，但是在模板中使用必须要指出。所以得加上中间那两句话。</p>
<blockquote>
<p>模板中参数前面的关键字，有时候是typename，有时也可以是class，有什么区别呢。注意这里只有在 <code>&lt;&gt;</code>中，定义模板参数的时候，是共通的。如<code>template&lt;typename T,class U&gt;</code> ，这是共通的。但是当像上面写模板模板参数的时候，用到的class，这是不能共通的，这里的class表示是一个类，而不是一个模板参数。</p>
</blockquote>
<h1 id="Lesson9-关于标准库"><a href="#Lesson9-关于标准库" class="headerlink" title="Lesson9 关于标准库"></a>Lesson9 关于标准库</h1><p>任何语言的标准库都十分重要，应该能熟练的使用。</p>
<p>C++的标准库主要有以下几个部分：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014737.png" alt="image-20211111093957659" style="zoom:33%;" /></p>
<ul>
<li>容器：就是数据结构。</li>
<li>算法：实现一些功能的方法。</li>
</ul>
<blockquote>
<p>程序就是靠算法和数据搭建起来的，algorithms+data=program。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建课程笔记</title>
    <url>/2021/10/18/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习北邮鲁鹏老师《机器视觉》笔记。<br>三维重建的目标就是从单张或多张场景图片中重构出三维场景的结构信息。<br><span id="more"></span></p>
<h2 id="一、摄像机几何"><a href="#一、摄像机几何" class="headerlink" title="一、摄像机几何"></a>一、摄像机几何</h2><h3 id="A-针孔摄像机模型"><a href="#A-针孔摄像机模型" class="headerlink" title="A.针孔摄像机模型"></a>A.针孔摄像机模型</h3><p>首先，我们要知道三维世界中的点是如何映射到像素平面的，完成这个映射过程就是摄像机。</p>
<p>如果直接让胶片放置在物体的前方，如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014942.png" alt="image-20210818224820393"></p>
<p>那么此时胶片上的一个点会记录真实世界多个点的信息。这样是不行的，于是我们采用针孔模型：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014947.png" alt="image-20210818224930850"></p>
<p>通过一个带有小孔的屏障，我们便可以使像素平面上的点与真实世界上的点形成一一对应的关系，这就是针孔相机模型。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014955.png" alt="image-20210818225105759"></p>
<p>下面具体描述一下<strong>针孔摄像机模型：</strong></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015003.png" alt="image-20210818230044519"></p>
<blockquote>
<p>要注意三个坐标系：</p>
<p>1.相机坐标系：以针孔为原点，建立的三维坐标系，其坐标轴单位是米</p>
<p>2.像平面坐标系：以像平面中心为原点的三维坐标系，坐标轴单位是米</p>
<p>3.像素坐标系：与像平面重合的二维坐标系，其坐标轴单位是像素</p>
</blockquote>
<p>根据三角形相似法则，最终可以得到相机坐标系下的P点到像平面坐标系的P‘点的映射关系：</p>
<script type="math/tex; mode=display">
P=\left[\begin{array}{l}
x \\
y \\
z
\end{array}\right] \rightarrow P^{\prime}=\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]\tag{1.1}</script><script type="math/tex; mode=display">
\quad\left\{\begin{array}{l}
x^{\prime}=f \frac{x}{z} \\
y^{\prime}=f \frac{y}{z}
\end{array}\right.\tag{1.2}</script><h3 id="B-摄像机和透镜"><a href="#B-摄像机和透镜" class="headerlink" title="B.摄像机和透镜"></a>B.摄像机和透镜</h3><p>光圈就是针孔模型中的小孔，小孔的大小决定了像的清晰程度和亮度</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015010.png" alt="image-20210818231502207"></p>
<p>如果光圈太大，像中的一个点会对应真实世界中的多个点，此时图像会模糊，但是光圈太小，又会使透过的光变少，像变暗。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015013.png" alt="image-20210818231844139"></p>
<p>那么如何才能使像既清晰又明亮呢？</p>
<p>增加透镜！！！</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015018.png" alt="image-20210818232135974"></p>
<p>透镜的特点：</p>
<p>1.所有平行于光轴的光线都会会聚到焦点，焦点到透镜中心的距离称为焦距</p>
<p>2.穿过中心的光线的方向不发生改变</p>
<h4 id="1-加上透镜后的针孔模型"><a href="#1-加上透镜后的针孔模型" class="headerlink" title="1.加上透镜后的针孔模型"></a>1.加上透镜后的针孔模型</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015021.png" alt="image-20210818232418455"></p>
<p>该模型与之前的针孔模型区别不大，只是针孔模型中的 $f$ 变为 $z’$ </p>
<script type="math/tex; mode=display">
z^{\prime}=f+z_{0} \quad\left\{\begin{array}{l}
x^{\prime}=z^{\prime} \frac{x}{z} \\
y^{\prime}=z^{\prime} \frac{y}{z}
\end{array}\right.\tag{1.3}</script><p>此处的 $f$ 是透镜的焦距，其与透镜的自身性质有关。</p>
<h4 id="2-透镜引起的问题"><a href="#2-透镜引起的问题" class="headerlink" title="2.透镜引起的问题"></a>2.透镜引起的问题</h4><h5 id="a-失焦"><a href="#a-失焦" class="headerlink" title="a.失焦"></a>a.失焦</h5><p>可以看到加上了透镜好处多多，但是也会引起一个问题，在一定的范围内，光线会会聚到像平面上，但是当超过了这个范围，光线就不会会聚到像平面上，此时便发生失焦。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015027.png" alt="image-20210818233432270"></p>
<h5 id="b-径向畸变"><a href="#b-径向畸变" class="headerlink" title="b.径向畸变"></a>b.径向畸变</h5><p>图像像素点以畸变中心为中心点，沿着径向产生位置偏差，从而导致图像中所成的像发生形变</p>
<p>枕形畸变：畸变像点相对于理想像点沿径向向外偏移，远离中心</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015032.png" alt="image-20210818233754147"></p>
<p>桶形畸变：畸变像点相对于理想像点沿径向向内偏移，向中心靠拢</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015038.png" alt="image-20210818233846093"></p>
<h3 id="C-摄像机几何"><a href="#C-摄像机几何" class="headerlink" title="C.摄像机几何"></a>C.摄像机几何</h3><p>在我们分析图像时，是在像素坐标系下分析的，像素坐标系和像平面坐标系的区别是，像素坐标系</p>
<p>是二维的，其坐标轴单位是像素，且其坐标原点一般不是在最中心，这就会发生一个坐标的偏移。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015042.png" alt="image-20210818234715959" style="zoom: 67%;" /></p>
<p>因此，需要根据像平面坐标系中点的坐标，求出该点在像素坐标系下的坐标：</p>
<script type="math/tex; mode=display">
P=(x, y, z) \rightarrow P^{\prime}=\left(u,v\right)\\
\left\{\begin{array}{l}
u=\alpha \frac{x}{z}+c_{x}\\
v=\beta \frac{y}{z}+c_{y}
\end{array}\right.\tag{1.4}</script><p>可是此时，空间点 $P$ 到 像素点 $P’$ 的坐标变换并不是一个线性变换，如果想变成一个线性变换，需要引入齐次坐标来表达。</p>
<h4 id="1-齐次坐标"><a href="#1-齐次坐标" class="headerlink" title="1.齐次坐标"></a>1.齐次坐标</h4><p>我们之前所使用的都是欧式坐标，例如三维空间中的一点，可以用 $(x,y,z)$ 来表示，此时在原有维数的基础上再添一维，就变成了齐次坐标。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015050.png" alt="image-20211004222903357" style="zoom:50%;" /></p>
<p>对于齐次坐标 $(1,1,1)$ 和 $(2,2,2)$ ，其所对应的欧式坐标都是 $(1,1)$ ，所以，对于齐次坐标 P 和 Q，如果P=kQ，那么 P 和 Q 对应同一个欧式坐标。</p>
<h4 id="2-齐次坐标的投影变换"><a href="#2-齐次坐标的投影变换" class="headerlink" title="2.齐次坐标的投影变换"></a>2.齐次坐标的投影变换</h4><p>引入齐次坐标后，空间点的齐次坐标与所对应的像素点的齐次坐标可以用一个线性变换来表达：</p>
<script type="math/tex; mode=display">
P_{h}^{\prime}=\left[\begin{array}{c}
\alpha x+c_{x} z \\
\beta y+c_{y} z \\
z
\end{array}\right]=\left[\begin{array}{cccc}
\alpha & 0 & c_{x} & 0 \\
0 & \beta & c_{y} & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
z \\
1
\end{array}\right]=MP_h\tag{1.5}</script><script type="math/tex; mode=display">
\overbrace{P_{h}^{\prime}}^{\text {齐次坐标 }} \rightarrow \overbrace{P^{\prime}=\left(\alpha \frac{x}{z}+c_{x}, \beta \frac{y}{z}+c_{y}\right)}^{\text {欧式坐标}}\tag{1.6}</script><p>M矩阵是摄像机的投影矩阵。</p>
<h4 id="3-摄像机偏斜"><a href="#3-摄像机偏斜" class="headerlink" title="3.摄像机偏斜"></a>3.摄像机偏斜</h4><p>有的时候，像素坐标系的两个坐标轴不是垂直的</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015057.png" alt="image-20210819004057419"></p>
<p>此时投影矩阵M为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{cccc}
\alpha & -\alpha \cot \theta & c_{x} & 0 \\
0 & \frac{\beta}{\sin \theta} & c_{y} & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\tag{1.7}</script><h4 id="4-摄像机内参数矩阵"><a href="#4-摄像机内参数矩阵" class="headerlink" title="4.摄像机内参数矩阵"></a>4.摄像机内参数矩阵</h4><p>上文提到的M前三列所构成的3*3矩阵称为摄像机的内参数矩阵K，它由摄像机的制作工艺决定。</p>
<script type="math/tex; mode=display">
M=K[I\ 0]\tag{1.8}</script><p>摄像机的内参数决定了空间点到图像点的映射。</p>
<p>摄像机的内参数矩阵共有5个自由度。</p>
<p>当K矩阵为单位阵时，此时的相机称为规范化相机，其变换叫做规范化投影变换。</p>
<blockquote>
<p>小结：当已知空间点坐标和相机内参时，一定可以求出像素点坐标。而仅知道像素点坐标和内参时，反求不出空间点坐标。因为像素点的欧式坐标对应无数个齐次坐标（尺度不确定问题）</p>
</blockquote>
<h4 id="5-世界坐标系的点到像素坐标系"><a href="#5-世界坐标系的点到像素坐标系" class="headerlink" title="5.世界坐标系的点到像素坐标系"></a>5.世界坐标系的点到像素坐标系</h4><p>在世界坐标系下，同一个点在不同相机的坐标系下坐标不同。</p>
<p>世界坐标系的坐标到相机坐标系的坐标可由下面式子来描述：</p>
<script type="math/tex; mode=display">
P=\left[\begin{array}{ll}
R & T \\
0 & 1
\end{array}\right] P_{w}=\left[\begin{array}{ll}
R & T \\
0 & 1
\end{array}\right] \left[\begin{array}{c}
x_{w} \\
y_{w} \\
z_{w} \\
1
\end{array}\right]\tag{1.9}</script><p>已知世界坐标系一点坐标，映射到像素坐标系中为：</p>
<script type="math/tex; mode=display">
P^{\prime}=K\left[\begin{array}{ll}
I & 0
\end{array}\right] P=K\left[\begin{array}{ll}
I & 0
\end{array}\right]\left[\begin{array}{cc}
R & T \\
0 & 1
\end{array}\right] P_{w}=\overbrace{K}^{内部参数}
\overbrace{[R \quad T]}^{外部参数}
P_{w}=M P_{w}\tag{1.10}</script><p>此时的投影矩阵M，既包含相机的内参信息，又包含了相机的运动信息（外部参数），M共有11个自由度。</p>
<h4 id="6-透视投影相机"><a href="#6-透视投影相机" class="headerlink" title="6.透视投影相机"></a>6.透视投影相机</h4><p>之前所得到的M矩阵叫做投影矩阵，它代表着透视投影模型，也就是三维真实空间到图像上的投影过程。符合该模型的相机称为透视投影相机，我们生活中的大多数相机都是透视投影相机，人类的眼睛也符合该模型。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015104.jpg" alt="img"></p>
<p>透视投影有以下几个特点：</p>
<ol>
<li>点投影为点</li>
<li>线投影为线</li>
<li>近大远小</li>
<li>角度不再保持</li>
<li>平行线相交</li>
</ol>
<h4 id="7-Faugeras定理"><a href="#7-Faugeras定理" class="headerlink" title="7.Faugeras定理"></a>7.Faugeras定理</h4><p>我们知道投影矩阵M是3 <em> 4的矩阵，当已知任意3 </em> 4的矩阵时，是否是投影矩阵呢？可以用Faugeras定理来进行判断。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015109.png" alt="image-20210819012316783"></p>
<h3 id="D-其他摄像机模型"><a href="#D-其他摄像机模型" class="headerlink" title="D.其他摄像机模型"></a>D.其他摄像机模型</h3><h4 id="1-弱透视投影摄像机"><a href="#1-弱透视投影摄像机" class="headerlink" title="1.弱透视投影摄像机"></a>1.弱透视投影摄像机</h4><p>当空间点的深度相差不多时，即相对场景深度小于其与相机的距离。可以简化为在同一深度。此时便是弱透视投影相机模型。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015117.png" alt="image-20210819101236994" style="zoom: 67%;" /></p>
<p>这里与透视投影相机的不同是其各点的深度是一个定值，且相同</p>
<script type="math/tex; mode=display">
\left\{\begin{array} { l } 
{ x ^ { \prime } = \frac { f ^ { \prime } } { z } x } \\
{ y ^ { \prime } = \frac { f ^ { \prime } } { z } y }
\end{array} \rightarrow \left\{\begin{array}{l}
x^{\prime}=\frac{f^{\prime}}{z_{0}} x \\
y^{\prime}=\frac{f^{\prime}}{z_{0}} y
\end{array}\right.\right.\tag{1.11}</script><p>通过这个简化后，投影矩阵的第三行变成了 $[0,0,0,1]$ </p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015123.png" alt="image-20210819103539119" style="zoom:67%;" /></p>
<p>当物体较小且较远时准确，常用于图像识别任务。</p>
<h4 id="2-正交投影摄像机"><a href="#2-正交投影摄像机" class="headerlink" title="2.正交投影摄像机"></a>2.正交投影摄像机</h4><p>摄像机中心到像平面的距离无限远时</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015130.png" alt="image-20210819104040178" style="zoom: 50%;" /></p>
<p>此时像平面上投影点的x，y方向的坐标等于实际空间点的坐标。</p>
<p>该模型常用于CAD制图时使用。</p>
<h2 id="二、摄像机标定"><a href="#二、摄像机标定" class="headerlink" title="二、摄像机标定"></a>二、摄像机标定</h2><p>摄像机标定就是求解摄像机的内外参数，更为准确的说，一般的相机内参数是不变的，而外参代表着相机的运动，是时刻改变的，所以一般的相机标定是对相机的内参的计算。</p>
<h3 id="A-标定方法-PnP的直接线性变换解法"><a href="#A-标定方法-PnP的直接线性变换解法" class="headerlink" title="A.标定方法(PnP的直接线性变换解法)"></a>A.标定方法(PnP的直接线性变换解法)</h3><h4 id="1-标定设备"><a href="#1-标定设备" class="headerlink" title="1.标定设备"></a>1.标定设备</h4><p> 如下图所示，有一个标定板，上面的每个点的坐标都已知。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015135.png" alt="image-20210820145956320"></p>
<p>然后对该标定板拍照，得到图像，可以得到空间点的坐标 $P_i$ 和其对应点的像素坐标 $p_i$ 。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015141.png" alt="image-20210820150231966"></p>
<h4 id="2-建立线性方程组"><a href="#2-建立线性方程组" class="headerlink" title="2.建立线性方程组"></a>2.建立线性方程组</h4><p>由上文提到，投影矩阵M是一个3*4的矩阵，可以表示为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{l}
m_1\\
m_2\\
m_3\\
\end{array}\right]\tag{2.1}</script><p>其中 $m_i$ 是一个4阶的行向量。</p>
<p>根据前面的透视投影关系，可以得到像素坐标和世界坐标的关系：</p>
<script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=\left[\begin{array}{l}
\frac{m_{1} P_{i}}{m_{3} P_{i}} \\
\frac{m_{2} P_{i}}{m_{3} P_{i}}
\end{array}\right]\tag{2.2}</script><p>知道一对对应点（ $P_i$ 和 $p_i$ 为已知），就可以得到两个方程，而M矩阵共有11个自由度，理论上用6对点便可以求解。但实际中会选6对以上的点来计算，这样可以提高结果的鲁棒性。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&u_{i}=\frac{m_{1} P_{i}}{m_{3} P_{i}} \rightarrow u_{i}\left(m_{3} P_{i}\right)=m_{1} P_{i} \rightarrow u_{i}\left(m_{3} P_{i}\right)-m_{1} P_{i}=0 \\
&v_{i}=\frac{m_{2} P_{i}}{m_{3} P_{i}} \rightarrow v_{i}\left(m_{3} P_{i}\right)=m_{2} P_{i} \rightarrow v_{i}\left(m_{3} P_{i}\right)-m_{2} P_{i}=0
\end{aligned}\tag{2.3}</script><p>可以将每个点的方程整理成(2.3)的形式，便可以得到一个线性方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
u_{1}\left(m_{3} P_{1}\right)-m_{1} P_{1}=0 \\
v_{1}\left(m_{3} P_{1}\right)-m_{2} P_{1}=0 \\
\vdots \\
u_{i}\left(m_{3} P_{i}\right)-m_{1} P_{i}=0 \\
v_{i}\left(m_{3} P_{i}\right)-m_{2} P_{i}=0 \\
\vdots \\
u_{n}\left(m_{3} P_{n}\right)-m_{1} P_{n}=0 \\
v_{n}\left(m_{3} P_{n}\right)-m_{2} P_{n}=0
\end{array}\right.\tag{2.4}</script><p>然后将上式写成矩阵的形式：</p>
<script type="math/tex; mode=display">
Pm=0\tag{2.5}\\
\begin{aligned}
P \stackrel{\text { def }}{=}\left(\begin{array}{ccc}
P_{1}^{T} & 0^{T} & -u_{1} P_{1}^{T} \\
0^{T} & P_{1}^{T} & -v_{1} P_{1}^{T} \\
& \vdots & \\
P_{n}{ }^{T} & 0^{T} & -u_{n} P_{n}{ }^{T} \\
0^{T} & P_{n}^{T} & -v_{n} P_{n}{ }^{T}
\end{array}\right)_{2 n \times 12}m \stackrel{\text { def }}{=}\left(\begin{array}{c}
{m_{1}^{T}} \\
{m_{2}^{T}} \\
m_{3}^{T}
\end{array}\right)_{12 \times 1}
\end{aligned}</script><blockquote>
<p>注意这里的 $P_i$ 是空间点的齐次坐标</p>
</blockquote>
<h4 id="3-求解方程组"><a href="#3-求解方程组" class="headerlink" title="3.求解方程组"></a>3.求解方程组</h4><p>P矩阵中所有的元素是已知的，下面求解该线性方程：P的行数有2n个，列数有12个。</p>
<p>当P的秩小于12时，该方程组有非零解。</p>
<p>当P的秩大于等于12时，此时为超定方程，该方程组只有0解。</p>
<p>通常情况下，P矩阵的秩都大于12，这样就解不了该方程。</p>
<p><strong>现在该怎么办呢？答案是采用优化的思想，找到合适的m， 让其$||m||$为1 ，使 $||Pm||$ 最小。</strong></p>
<p>对于该优化问题的解，先对P矩阵进行奇异值分解，可以得到：</p>
<script type="math/tex; mode=display">
P=U_{2n\times12}D_{12\times12}V_{12\times12}^T\tag{2.6}</script><p>m为P矩阵最小奇异值的右奇异向量，且 $||m||=1$ ，求得m后，便可以得到投影矩阵M。</p>
<script type="math/tex; mode=display">
\boldsymbol{m} \stackrel{\text { def }}{=}\left(\begin{array}{c}
m_{1}^{T} \\
m_{2}^{T} \\
m_{3}^{T}
\end{array}\right) \rightarrow M=\left[\begin{array}{c}
m_{1} \\
m_{2} \\
m_{3}
\end{array}\right]=[A\ b]\tag{2.7}</script><h4 id="4-提取摄像机参数"><a href="#4-提取摄像机参数" class="headerlink" title="4.提取摄像机参数"></a>4.提取摄像机参数</h4><p>我们知道，投影矩阵M包括相机的内参和外参信息，当得到M后，需要提取出内参和外参的信息。</p>
<p>先来看看已知R，T，K后，如何得到M</p>
<script type="math/tex; mode=display">
M=K[R\ \ T]_{3\times4}\tag{2.8}</script><script type="math/tex; mode=display">
K=\left[\begin{array}{ccc}
\alpha & -\alpha \cot \theta & u_{0} \\
0 & \frac{\beta}{\sin \theta} & v_{0} \\
0 & 0 & 1
\end{array}\right] \quad R=\left[\begin{array}{c}
r_{1}^{T} \\
r_{2}^T \\
r_{3} ^T
\end{array}\right] \quad T=\left[\begin{array}{c}
t_{x} \\
t_{y} \\
t_{z}
\end{array}\right]\tag{2.9}</script><p>所以：</p>
<script type="math/tex; mode=display">
M=K[R\ \ T]=\left(\begin{array}{cc}
\alpha r_{1}^{T}-\alpha \cot \theta r_{2}^{T}+u_{0} r_{3}^{T} & \alpha t_{x}-\alpha \cot \theta t_{y}+u_{0} t_{z} \\
\frac{\beta}{\sin \theta} r_{2}^{T}+v_{0} r_{3}^{T} & \frac{\beta}{\sin \theta} t_{y}+v_{0} t_{z} \\
r_{3}^{T} & t_{z}
\end{array}\right)_{3 \times 4}\tag{2.10}</script><p>因为我们之前规定了m向量的模长为1，所以我们求出的M和真实的M相差一个系数 $\rho$ </p>
<script type="math/tex; mode=display">
\rho M=\rho[A\ \ b]=K[R\ \ T]\tag{2.11}</script><p>令：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{l}
a_{1}{ }^{T} \\
a_{2}{ }^{T} \\
a_{3}{ }^{T}
\end{array}\right] \quad \mathbf{b}=\left[\begin{array}{l}
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right]\tag{2.12}</script><p>则：</p>
<script type="math/tex; mode=display">
\rho A=\rho\left(\begin{array}{c}
a_{1}^{T} \\
a_{2}{ }^{T} \\
a_{3}{ }^{T}
\end{array}\right)=\left(\begin{array}{c}
\alpha r_{1}^{T}-\alpha \cot \theta r_{2}^{T}+u_{0} r_{3}^{T} \\
\frac{\beta}{\sin \theta} r_{2}^{T}+v_{0} r_{3}^{T} \\
r_{3}{ }^{T}
\end{array}\right)=K R\tag{2.13}</script><h5 id="a-提取内参数"><a href="#a-提取内参数" class="headerlink" title="a.提取内参数"></a>a.提取内参数</h5><p>从(2.13)最后一行可以看出：</p>
<script type="math/tex; mode=display">
\rho a_3=r_3\\\tag{2.14}</script><p>因为 $r_3$ 是旋转矩阵的列向量，其模长为1，因此可以得到：</p>
<script type="math/tex; mode=display">
\rho=\frac{\pm 1}{\left|a_{3}\right|}\tag{2.15}</script><p>然后分别将(2.13)左右两侧第3行的向量和第1行的向量点乘，第3行的向量和第2行的向量点乘，因为旋转矩阵的列向量互相正交，所以可以得到：</p>
<script type="math/tex; mode=display">
\quad \begin{aligned}
&u_{0}=\rho^{2}\left(a_{1} \cdot a_{3}\right) \\
&v_{0}=\rho^{2}\left(a_{2} \cdot a_{3}\right)
\end{aligned}\tag{2.16}</script><p>同理再将(2.13)的行向量进行叉乘，可以得到下面的式子：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{ l } 
{ \rho ^ { 2 } ( a _ { 1 } \times a _ { 3 } ) = \alpha r _ { 2 } - \alpha \operatorname { cot\theta} r _ { 1 } } \\
{ \rho ^ { 2 } ( a _ { 2 } \times a _ { 3 } ) = \frac { \beta } { \operatorname { sin } \theta } r _ { 1 } }
\end{array} 
\right.\tag{2.17}</script><p>在将(2.17)上下两行进行点乘，可以得到</p>
<script type="math/tex; mode=display">
\rho^4(a_1 \times a_3)(a_2 \times a_3)=- \frac{\alpha \beta \cos{\theta}}{\sin\theta^2} \tag{2.18}</script><p>然后对(2.17)的向量两边取模：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\rho^{2}\left|a_{1} \times a_{3}\right|=\frac{|\alpha|}{\sin \theta} \\
\rho^{2}\left|a_{2} \times a_{3}\right|=\frac{|\beta|}{\sin \theta}
\end{array}\right.\tag{2.19}</script><p>最后可以得到内参矩阵中的所有参数：</p>
<script type="math/tex; mode=display">
\cos \theta=-\frac{\left(a_{1} \times a_{3}\right) \cdot\left(a_{2} \times a_{3}\right)}{\left|a_{1} \times a_{3}\right| \cdot\left|a_{2} \times a_{3}\right|}\\
\begin{array}{l}
\alpha=\rho^{2}\left|a_{1} \times a_{3}\right| \sin \theta \\
\beta=\rho^{2}\left|a_{2} \times a_{3}\right| \sin \theta
\end{array}\tag{2.20}</script><p>到此，摄像机的内参数全部求出。</p>
<h5 id="b-提取外参数"><a href="#b-提取外参数" class="headerlink" title="b.提取外参数"></a>b.提取外参数</h5><p>根据(2.14)和(2.17)可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&r_{1}=\frac{\left(a_{2} \times a_{3}\right)}{\left|a_{2} \times a_{3}\right|}\\
&r_{3}=\frac{\pm a_{3}}{\left|a_{3}\right|} \\
&r_{2}=r_{3} \times r_{1}\end{aligned}\tag{2.21}</script><p>下面再计算T，根据：</p>
<script type="math/tex; mode=display">
\rho b=KT\tag{2.22}</script><p>可以得到：</p>
<script type="math/tex; mode=display">
T=\rho K^{-1}b\tag{2.23}</script><blockquote>
<p>注意：选取的点不能在同一平面</p>
</blockquote>
<h3 id="B-径向畸变标定"><a href="#B-径向畸变标定" class="headerlink" title="B.径向畸变标定"></a>B.径向畸变标定</h3><h4 id="1-径向畸变的描述"><a href="#1-径向畸变的描述" class="headerlink" title="1.径向畸变的描述"></a>1.径向畸变的描述</h4><p>在原有的透视投影矩阵M基础上，加上一个缩放矩阵 $S_\lambda$ ，如下：</p>
<script type="math/tex; mode=display">
{\left[\begin{array}{ccc}
\frac{1}{\lambda} & 0 & 0 \\
0 & \frac{1}{\lambda} & 0 \\
0 & 0 & 1
\end{array}\right]}
M P_{i} \rightarrow\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=p_{i}\quad 其中
\lambda=1 \pm \sum_{p=1}^{3} k_pd^{2p} \quad (d^2=u^{2}+v^{2})\tag{2.24}</script><p>当 $\lambda=1$ 时，真实的像和理想的像重叠，此时无畸变</p>
<p>当 $\lambda&lt;1$时，真实的像比理想的像的位置靠外，枕形畸变</p>
<p>当$\lambda&gt;1$ 时，真实的像比理想的像的位置靠里，桶形畸变</p>
<h4 id="2-径向畸变的标定"><a href="#2-径向畸变的标定" class="headerlink" title="2.径向畸变的标定"></a>2.径向畸变的标定</h4><p>令</p>
<script type="math/tex; mode=display">
S_\lambda M=Q=
\left[\begin{array}{}
q_1\\
q_2\\
q_3
\end{array}{}\right]_{3\times 4}\tag{2.25}</script><script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{l}
u_{i} \\
v_{i}
\end{array}\right]=\left[\begin{array}{l}
\frac{q_{1} p_{i}}{q_{3} p_{i}} \\
\frac{q_{2} p_{i}}{q_{3} p_{i}}
\end{array}\right] \quad \longrightarrow \quad\left\{\begin{array}{l}
u_{i} q_{3} P_{i}=q_{1} P_{i} \\
v_{i} q_{3} P_{i}=q_{2} P_{i}
\end{array}\right.\tag{2.26}</script><p>(2.26)右边的方程组并不是线性方程组，因为 $q_i$ 是变化的，如果想要求解该方程，需要采用非线性优化方法，使观测值和理论值的误差最小，可以采用牛顿法或LM方法。</p>
<p>但是可以求解出系统的线性部分以找到近似解，然后使用该解作为整个系统的初始条件，再使用数值方法进行求解。</p>
<p>根据(2.23)和(2.25)，Q矩阵的前两行等于 $\frac{1}\lambda M$ 的前两行，于是可以将 $\lambda$ 约去</p>
<script type="math/tex; mode=display">
p_{i}=\left[\begin{array}{c}
u_{i} \\
v_{i}
\end{array}\right]=\frac{1}{\lambda}\left[\begin{array}{l}
\frac{m_{1} p_{i}}{m_{3} p_{i}} \\
\frac{m_{2} p_{i}}{m_{3} p_{i}}
\end{array}\right] \quad \longrightarrow \quad \frac{u_{i}}{v_{i}}=\frac{\frac{1}{\lambda} \frac{\left(m_{1} P_{i}\right)}{\left(m_{3} p_{i}\right)}}{\frac{1}{\lambda} \frac{\left(m_{2} p_{i}\right)}{\left(m_{3} p_{i}\right)}}=\frac{m_{1} p_{i}}{m_{2} p_{i}}\tag{2.27}</script><p>建立如下的线性方程组</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
v_{1}\left(m_{1} P_{1}\right)-u_{1}\left(m_{2} P_{1}\right)=0  \\
v_{i}\left(m_{1} P_{i}\right)-u_{i}\left(m_{2} P_{i}\right)=0 
\\
\vdots \\
v_{n}\left(m_{1} P_{n}\right)-u_{n}\left(m_{2} P_{n}\right)=0
\end{array} \longrightarrow\quad 
\\ L \boldsymbol{n}=0 \\

\right. \\\tag{2.28}</script><p>其中</p>
<script type="math/tex; mode=display">
L \stackrel{\operatorname{dec}}{=}\left(\begin{array}{cc}
v_{1} p_{1}^{T} & -u_{1} p_{1}^{T} \\
v_{2} p_{2}^{T} & -u_{2} p_{2}^{T} \\
\vdots & \vdots \\
v_{n} p_{n}^{T} & -u_{n} p_{n}^{T}
\end{array}\right)\tag{2.29}\\\\
n=\left[\begin{array}{c}
m_{1}{ }^{T} \\
m_{2}{ }^{T}
\end{array}\right]</script><p>和(2.6)的方法类似，可以通过奇异值分解求出 $m_1$和 $m_2$ 。然后再通过非线性优化的方法求出 $k_p$ 和 $m_3$。</p>
<h2 id="三、单视图几何"><a href="#三、单视图几何" class="headerlink" title="三、单视图几何"></a>三、单视图几何</h2><p><img src="https://piggyhero.gitee.io/pic/img/20211216015151.png" alt="image-20210820213946776"></p>
<p>已知摄像机的内参和外部参数，是否可以根据单个图片的测量值p去估计空间点P呢？</p>
<p>ans：是不能的，只能确定P点位于c和p的连线上的任意位置。原因是单目相机无法获得深度信息，在这条线上的任意点的投影都位于该像素点上，当对空间有一些先验的信息时，是可以获得空间点P的位置信息的。</p>
<h3 id="A-2D变换"><a href="#A-2D变换" class="headerlink" title="A.2D变换"></a>A.2D变换</h3><h4 id="1-等距变换"><a href="#1-等距变换" class="headerlink" title="1.等距变换"></a>1.等距变换</h4><p>等距变换也叫做欧式变换，是将平面上的点经过旋转平移，不改变图形的形状，面积。仅仅改变图形的位置和朝向。</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{l}
R & \boldsymbol{t} \\
0 & 1\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1\end{array}\right]=H_{e}\left[\begin{array}{l}
x \\
y \\
1\end{array}\right]\tag{3.1}</script><p>有3个自由度(1个旋转角度+2个平移量)</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015156.png" alt="image-20210823171132345"></p>
<h4 id="2-相似变换"><a href="#2-相似变换" class="headerlink" title="2.相似变换"></a>2.相似变换</h4><p>在等距变换的基础上，如式(3.1)所示，增加了一个S矩阵(对角阵)，对原图形进行缩放。</p>
<p>它不改变图形长度的比值，还有线段间的角度。</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
S R & \boldsymbol{t} \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=H_{S}\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right] \quad S=\left[\begin{array}{ll}
s & 0 \\
0 & s
\end{array}\right]\tag{3.2}</script><p>有4个自由度(1个缩放系数+1个旋转角度+2个平移量)</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015200.png" alt="image-20210823171619104"></p>
<h4 id="3-仿射变换"><a href="#3-仿射变换" class="headerlink" title="3.仿射变换"></a>3.仿射变换</h4><p>（直观意义后续再学习，现在先搞懂数学表达）</p>
<p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
A & \boldsymbol{t} \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]=H_{a}\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]\tag{3.3}</script><p>注意这里的矩阵与(3.1)和(3.2)不同，A矩阵是任意的一个2阶方阵，有4个自由度。整个矩阵共有6个自由度(4个自由度+2个平移量)</p>
<p><strong>特点</strong>：它不改变图形中的平行线关系，还有面积比值。但不能保持线段之间的夹角关系。</p>
<h4 id="4-透视变换-射影变换"><a href="#4-透视变换-射影变换" class="headerlink" title="4.透视变换(射影变换)"></a>4.透视变换(射影变换)</h4><p>数学表达：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{cc}
A & \boldsymbol{t} \\
v & 1
\end{array}\right]\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]=H_{p}\left[\begin{array}{l}
\mathrm{x} \\
y \\
1
\end{array}\right]\tag{3.4}</script><p><img src="https://piggyhero.gitee.io/pic/img/20211216015207.png" alt="image-20210823233103207"></p>
<p><strong>特点</strong>：</p>
<p>共线性，原来在一条直线上的点变换后还在一条直线上。</p>
<p>四共线点的交比</p>
<p>交比的定义为：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015213.png" alt="image-20210823225125021" style="zoom:50%;" /></p>
<script type="math/tex; mode=display">
\frac{|| P_{3}-P_{1}||\left\|P_{4}-P_{2}\right\|}{|| P_{3}-P_{2}||\left\|P_{4}-P_{1}\right\|} \quad P_{i}=\left[\begin{array}{c}
X_{i} \\
Y_{i} \\
Z_{i} \\
1
\end{array}\right]\tag{3.5}</script><h3 id="B-二维空间点和直线的投影变换"><a href="#B-二维空间点和直线的投影变换" class="headerlink" title="B.二维空间点和直线的投影变换"></a>B.二维空间点和直线的投影变换</h3><p>我们的目的是用单张图像来重建三维场景，就要建立图像上几何元素和三维空间中的几何元素的对应关系。</p>
<p>我们先通过<strong><u>二维空间中</u></strong>的点和线来学习。</p>
<h4 id="1-平面上的线"><a href="#1-平面上的线" class="headerlink" title="1.平面上的线"></a>1.平面上的线</h4><p>我们可以用ax+by+c=0来表示一条平面上的线。我们可以用向量的形式来表达这个式子：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
x \\
y \\
1
\end{array}\right]^{T}\left[\begin{array}{l}
a \\
b \\
c
\end{array}\right]=0\tag{3.6}</script><p>(3.6)左边第一项是直线上点的齐次坐标，右边是直线的参数，所以直线可以表示成向量的形式：</p>
<script type="math/tex; mode=display">
l=\left[\begin{array}{l}
a\\
b\\
c
\end{array}\right]\tag{3.7}</script><h4 id="2-两条直线的交点"><a href="#2-两条直线的交点" class="headerlink" title="2.两条直线的交点"></a>2.两条直线的交点</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015219.png" alt="image-20210823231412876"></p>
<p>两条直线的交点可以用式(3.7)的叉积来表示：</p>
<script type="math/tex; mode=display">
x=l\times l'\tag{3.8}</script><p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&l \times l^{\prime} \perp l \rightarrow\left(l \times l^{\prime}\right) \cdot l=0 \rightarrow x \in l \\
&l \times l^{\prime} \perp l' \rightarrow\left(l \times l^{\prime}\right) \cdot l'=0 \rightarrow x \in l^{\prime}
\end{aligned}\tag{3.9}</script><p>(3.9)中，两个表示直线的向量叉乘，与这两个直线向量的点乘为0，这说明了如果叉乘表示一个点，那么这个点在这两条直线上，所以该点为交点。</p>
<h4 id="3-无穷远点"><a href="#3-无穷远点" class="headerlink" title="3.无穷远点"></a>3.无穷远点</h4><p>首先定义无穷远点：平面上一个点的齐次坐标的第三维为0，该点为无穷远点。</p>
<p>因为转化成欧式坐标后，前两维都除以第三维0，为无穷大，所以是无穷远点。</p>
<script type="math/tex; mode=display">
x_\infty =\left[\begin{array}{}
x_1\\
x_2\\
0
\end{array}\right]\tag{3.10}</script><p>两条平行线的交点就是无穷远点。 </p>
<h4 id="4-无穷远直线"><a href="#4-无穷远直线" class="headerlink" title="4.无穷远直线"></a>4.无穷远直线</h4><p>无穷远点集位于无穷远线上。</p>
<p>无穷远线的向量表示为：</p>
<script type="math/tex; mode=display">
l_\infty =\left[\begin{array}{}
0\\
0\\
1
\end{array}\right]\tag{3.11}</script><p><img src="https://piggyhero.gitee.io/pic/img/20211216015224.png" alt="image-20210823233249621" style="zoom: 67%;" /></p>
<h4 id="5-无穷远点的透视变换"><a href="#5-无穷远点的透视变换" class="headerlink" title="5.无穷远点的透视变换"></a>5.无穷远点的透视变换</h4><p>透视变换矩阵：</p>
<script type="math/tex; mode=display">
H=\left[ \begin{array}{l}
A & t \\
v & b
\end{array}\right] \tag{3.12}</script><p>无穷远点的<strong>透视变换</strong>：</p>
<script type="math/tex; mode=display">
p^{\prime}=Hp_\infty=\left[\begin{array}{l}
A & t \\
v & b
\end{array}\right]\left[\begin{array}{l}
1 \\
1 \\
0
\end{array}\right]=\left[\begin{array}{c}
p_{x}^{\prime} \\
p_{y}^{\prime} \\
p_{z}^{\prime}
\end{array}\right]\longrightarrow
\left[\begin{array}{}
\frac{p_x'}{p_z'}\\
\frac{p_y'}{p_z'}
\end{array}\right]\tag{3.13}</script><p>无穷远点的透视变换后，就不再是一个无穷远点了。</p>
<p>而无穷远点的<strong>仿射变换</strong>：</p>
<script type="math/tex; mode=display">
H_{A} p_{\infty}=\left[\begin{array}{cc}
A & t \\
0 & b
\end{array}\right]\left[\begin{array}{l}
1 \\
1 \\
0
\end{array}\right]=\left[\begin{array}{c}
p_{x}^{\prime} \\
p_{y} \\
0
\end{array}\right]\tag{3.14}</script><p>仍然是无穷远点。</p>
<h4 id="6-无穷远线的透视变换"><a href="#6-无穷远线的透视变换" class="headerlink" title="6.无穷远线的透视变换"></a>6.无穷远线的透视变换</h4><p>线的变换和点的变换不同，不能直接对直线向量进行变换。</p>
<p>我们知道对线的变换，等价于对线上所有的点的变换。</p>
<p>变换前的直线方程为：</p>
<script type="math/tex; mode=display">
x^Tl=0\tag{3.15}</script><p>对直线上的点的变换为：</p>
<script type="math/tex; mode=display">
Hx\tag{3.16}</script><p>则变换后的直线方程为：</p>
<script type="math/tex; mode=display">
(Hx)^Tl'=0\longrightarrow x^TH^Tl'=0\tag{3.17}</script><p>如果让(3.17)成立，则：</p>
<script type="math/tex; mode=display">
l'=H^{-T}l\tag{3.18}</script><p>所以直线的变换如式(3.18)所示。</p>
<p>无穷远线经过<strong>透视变换</strong>为：</p>
<script type="math/tex; mode=display">
H^{-T} l_{\infty}=\left[\begin{array}{ll}
A & t \\
v & b
\end{array}\right]^{-T}\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{c}
t_{x} \\
t_{y} \\
b
\end{array}\right]\tag{3.19}</script><p>显然变换后不再是无穷远线了。</p>
<p>无穷远线在<strong>仿射变换</strong>后：</p>
<script type="math/tex; mode=display">
{H}^{-T} l_{\infty}=\left[\begin{array}{cc}
A & t \\
0 & b
\end{array}\right]^{-T}\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{cc}
A^{-T} & 0 \\
-t^{T} A^{-T} & 1
\end{array}\right]\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]=\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]\tag{3.20}</script><p>仍是无穷远线。</p>
<h3 id="C-三维空间中的变换"><a href="#C-三维空间中的变换" class="headerlink" title="C.三维空间中的变换"></a>C.三维空间中的变换</h3><p>学完了二维空间中的点和线以及变换关系，接下来学习三维空间的点和线以及变换关系。</p>
<h4 id="1-空间中的点和面"><a href="#1-空间中的点和面" class="headerlink" title="1.空间中的点和面"></a>1.空间中的点和面</h4><p>与二维空间不同的是，三维空间是点和面可以用方程来表示。而直线用两个平面的交线来表示。</p>
<p>和二维空间中的直线的表示类似，三维空间中的平面表示为：</p>
<script type="math/tex; mode=display">
ax+by+cz+d=0\tag{3.21}</script><p>用向量的形式表示为：</p>
<script type="math/tex; mode=display">
x^T\Pi=0\quad\Pi=\left[\begin{array}{}
a\\
b\\
c\\d
\end{array}\right]\tag{3.22}</script><h4 id="2-空间中的线"><a href="#2-空间中的线" class="headerlink" title="2.空间中的线"></a>2.空间中的线</h4><p>如上所说，空间中的线不容易直接用方程来表示，但可以用向量表示出直线的方向。</p>
<script type="math/tex; mode=display">
d=\left[\begin{array}{}
a\\
b\\
c
\end{array}\right]\tag{3.23}</script><h4 id="3-影消点"><a href="#3-影消点" class="headerlink" title="3.影消点"></a>3.影消点</h4><p>影消点是三维空间中的无穷远点在二维平面上的投影点。</p>
<p>前面的二维空间中的无穷远点，经过投影变换后，变为一个有限点。那么三维空间中的无穷远点，经过投影变换后，在二维平面上，也为有限点。 </p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015232.png" alt="image-20210824001710255" style="zoom:67%;" /></p>
<h4 id="4-影消点和直线方向的关系"><a href="#4-影消点和直线方向的关系" class="headerlink" title="4.影消点和直线方向的关系"></a>4.影消点和直线方向的关系</h4><p>影消点的齐次坐标为v，影消点和直线方向有如下关系</p>
<script type="math/tex; mode=display">
v=Kd\tag{3.24}</script><p>该式成立的条件是，相机坐标系和世界坐标系重合，否则和直线方向向量相差一个旋转平移的关系。</p>
<p>证明：</p>
<p>无穷远点坐标为：</p>
<script type="math/tex; mode=display">
X_\infty=\left[\begin{array}{}
a\\
b\\
c\\
0
\end{array}\right]\tag{3.25}</script><p>经过摄像机投影变换后</p>
<script type="math/tex; mode=display">
v=MX_\infty=K[I\ \ 0]\left[\begin{array}{}
a\\
b\\
c\\
0
\end{array}\right]=K\left[\begin{array}{}
a\\
b\\
c\\

\end{array}\right]\tag{3.26}</script><p>所以知道直线的方向就可以知道影消点，反过来知道影消点也可以知道直线的方向。</p>
<h4 id="5-影消线（视平线）"><a href="#5-影消线（视平线）" class="headerlink" title="5.影消线（视平线）"></a>5.影消线（视平线）</h4><p>三维空间中的无穷远线在二维空间中的投影。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015238.png" alt="image-20210824003405552"></p>
<h4 id="6-影消线和平面法向量"><a href="#6-影消线和平面法向量" class="headerlink" title="6.影消线和平面法向量"></a>6.影消线和平面法向量</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015242.png" alt="image-20210824003743383"></p>
<p>这个平面是指影消线所对应的平行线所在的平面。</p>
<p>平面法向量为n，影消线和平面法向量的关系为：</p>
<script type="math/tex; mode=display">
n=K^Tl_{horiz}\tag{3.27}</script><p>证明：</p>
<p>这里还是仅考虑相机坐标系和世界坐标系重合的情况。</p>
<p>设某一平面有一无穷远点x，其所在平面的方程为：</p>
<script type="math/tex; mode=display">
x^T\Pi=0\tag{3.28}</script><p>该点经过投影变换后，在影消线上，影消线方程为：</p>
<script type="math/tex; mode=display">
(Mx)^Tl_{horiz}=0\\
x^TM^Tl_{horiz}=0\tag{3.29}</script><p>比较(3.28)和(3.29)可知：</p>
<script type="math/tex; mode=display">
\Pi=M^Tl_{horiz}\tag{3.30}\\
因为M=K[I\ \ 0],\Pi\ 就是平面的法向量，所以有：
n=K^Tl_{horiz}</script><h4 id="7-无穷远平面"><a href="#7-无穷远平面" class="headerlink" title="7.无穷远平面"></a>7.无穷远平面</h4><p>影消线所在的平面。</p>
<p>表示向量的形式为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}
0\\
0\\
0\\
1
\end{array}\right]\tag{3.31}</script><h4 id="8-两组平行线的夹角和影消点的关系"><a href="#8-两组平行线的夹角和影消点的关系" class="headerlink" title="8.两组平行线的夹角和影消点的关系"></a>8.两组平行线的夹角和影消点的关系</h4><p>两平行线夹角：</p>
<script type="math/tex; mode=display">
co s\theta=\frac{d_1d_2}{|d_1||d_2|}\tag{3.32}</script><p>由式(3.24)可知，知道影消点坐标和相机内参矩阵后，可以反求出平行线方向向量d。</p>
<p>将 $d_1和d_2$ 代入(3.32)，可得：</p>
<script type="math/tex; mode=display">
co s\theta=\frac{d_1d_2}{|d_1||d_2|}=\frac{(K^{-1}v_1)^T(K^{-1}v_2)}{\sqrt{(K^{-1}v_1)^T(K^{-1}v_1)}\sqrt{(K^{-1}v_2)^T(K^{-1}v_2)}}\\
=\frac{v_{1}^{T} \omega v_{2}}{\sqrt{v_{1}^{T} \omega v_{1}} \sqrt{v_{2}^{T} \omega v_{2}}}\quad \omega= (KK^T)^{-1}\tag{3.33}</script><script type="math/tex; mode=display">
当\theta=90^{\circ} \rightarrow v_{1}^{T} \omega v_{2}=0\tag{3.34}</script><p>$\omega$ 的性质：</p>
<script type="math/tex; mode=display">
\omega=\left[\begin{array}{lll}
\omega_{1} & \omega_{2} & \omega_{4} \\
\omega_{2} & \omega_{3} & \omega_{5} \\
\omega_{4} & \omega_{5} & \omega_{6}
\end{array}\right]\tag{3.35}</script><p>对称阵</p>
<p>有5个自由度</p>
<p>$\omega _2=0$ ，无倾斜</p>
<p>$\omega_2=0,\omega_1=\omega_3$ ，方形像素</p>
<h3 id="D-单视图重构"><a href="#D-单视图重构" class="headerlink" title="D.单视图重构"></a>D.单视图重构</h3><h4 id="1-标定内参数"><a href="#1-标定内参数" class="headerlink" title="1.标定内参数"></a>1.标定内参数</h4><p>首先根据图像上的信息，可以标定出相机的内参数矩阵</p>
<p>如图：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015254.png" alt="image-20210824015723059"></p>
<p>找到图像上两组垂直的平行线，可以找到两个影消点，根据影消点的坐标，以及式(3.34)可以得到一组方程。因为 $\omega $ 有5个自由度，所以还需要增加限制方程来求解。</p>
<p>我们找到三组平行线，可以得到三个方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
v_{1}^{T} \omega v_{2}=0 \\
v_{1}^{T} \omega v_{3}=0 \\
v_{2}^{T} \omega v_{3}=0
\end{array}\right.\tag{3.36}</script><p>我们可以再添加上两个限制方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\omega _{2}=0 \\
 \omega_1=\omega_3
\end{array}\right.\tag{3.37}</script><p>便可以求解出 $\omega$ 矩阵。</p>
<h4 id="2-恢复面的信息"><a href="#2-恢复面的信息" class="headerlink" title="2.恢复面的信息"></a>2.恢复面的信息</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015300.png" alt="image-20210824020434618"></p>
<p>然后连接两个影消点，可以得到影消线，从而得到影消线的方程。然后由式(3.27)可知，该平面的空间方程。这样就可以求得三个平面的方程。</p>
<blockquote>
<p>单视图恢复的场景，是无法知道场景尺寸的。而且必须要有场景的先验信息。</p>
</blockquote>
<h2 id="四、三维重建基础和极几何"><a href="#四、三维重建基础和极几何" class="headerlink" title="四、三维重建基础和极几何"></a>四、三维重建基础和极几何</h2><h3 id="A-三维重建基础"><a href="#A-三维重建基础" class="headerlink" title="A.三维重建基础"></a>A.三维重建基础</h3><h4 id="1-三角化"><a href="#1-三角化" class="headerlink" title="1.三角化"></a>1.三角化</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015305.png" alt="image-20210824021622264"></p>
<p>三角化的适用条件：用两个摄像机来感受外部空间。</p>
<p>如图所示，现在有两个摄像机，分别在 $O_1和O_2$ 点，空间点p在两个相机的成像平面上投影分别为 $p和p’$ 。</p>
<p>通常情况下，P点的坐标通过l和l’的叉乘来求得。</p>
<p>但是由于噪声的存在，$l和l’$ 一般是不相交的。现在想求P点的三维坐标。</p>
<p>ques：已知 $p和p’$ ，$K和K’$ ，以及R，T，求解P点的三维坐标。</p>
<p>非线性解法：建模成最小化问题。我们要找到一个点 $P^*$ ，使其投影到两个成像平面上的点和观测点的距离最小。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015308.png" alt="image-20210824022452348"></p>
<p>解法：寻找 $P^{\star}$ ，最小化 $d\left(p, M P^{\star}\right)+d\left(p^{\prime}, M^{\prime} P^{\star}\right)$ 。</p>
<h4 id="2-多视图几何的关键问题"><a href="#2-多视图几何的关键问题" class="headerlink" title="2.多视图几何的关键问题"></a>2.多视图几何的关键问题</h4><ol>
<li>摄像机几何：从一张或者多张图片中求解摄像机的内外参数</li>
<li>场景几何：从二至多幅图中找到场景的三维坐标</li>
<li>对应关系：已知一个图像的p点，如何在另一张图中找到p‘点</li>
</ol>
<h3 id="B-极几何—解决对应关系问题"><a href="#B-极几何—解决对应关系问题" class="headerlink" title="B.极几何—解决对应关系问题"></a>B.极几何—解决对应关系问题</h3><h4 id="1-极几何"><a href="#1-极几何" class="headerlink" title="1.极几何"></a>1.极几何</h4><p>极几何描述了同一场景或者物体在两个视点的几何关系。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015313.png" alt="image-20210824024244259"></p>
<p>极线：极平面与成像平面的交线</p>
<p>极点：极线与成像平面的交点</p>
<h5 id="a-极几何的特点："><a href="#a-极几何的特点：" class="headerlink" title="a.极几何的特点："></a>a.极几何的特点：</h5><ol>
<li>极平面相交于基线</li>
<li>极线相交于极点</li>
<li>$p$ 的对应点在极线 $l’$ 上</li>
<li>$p’$ 的对应点在极线 $l$ 上</li>
</ol>
<h5 id="b-极几何的两个特例："><a href="#b-极几何的两个特例：" class="headerlink" title="b.极几何的两个特例："></a>b.极几何的两个特例：</h5><h6 id="1-平行视图"><a href="#1-平行视图" class="headerlink" title="(1)平行视图"></a><strong>(1)平行视图</strong></h6><p><img src="https://piggyhero.gitee.io/pic/img/20211216015318.png" alt="image-20210824024726436"></p>
<p>特点：</p>
<ol>
<li>两个图像平面平行；</li>
<li>基线平行于成像平面，极点在无穷远处；</li>
<li>基线平行于像素坐标系u轴</li>
</ol>
<h6 id="2-前向平移（无旋转）"><a href="#2-前向平移（无旋转）" class="headerlink" title="(2)前向平移（无旋转）"></a><strong>(2)前向平移（无旋转）</strong></h6><p><img src="https://piggyhero.gitee.io/pic/img/20211216015322.png" alt="image-20210824024950629"></p>
<p>两个图像的极点有着相同的像素坐标</p>
<h4 id="2-本质矩阵"><a href="#2-本质矩阵" class="headerlink" title="2.本质矩阵"></a>2.本质矩阵</h4><p>本质矩阵：对规范化摄像机拍摄的两个视点图像间的极几何关系进行代数描述。</p>
<h5 id="a-规范化摄像机"><a href="#a-规范化摄像机" class="headerlink" title="a.规范化摄像机"></a>a.规范化摄像机</h5><p>摄像机的内参数K是单位矩阵</p>
<script type="math/tex; mode=display">
P^{\prime}=\left[\begin{array}{l}x \\ y \\ z\end{array}\right]=\left[\begin{array}{llll}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0\end{array}\right]\left[\begin{array}{l}x \\ y \\ z \\ 1\end{array}\right]\tag{4.1}</script><p>三维点的欧式坐标=像素点的齐次坐标</p>
<h5 id="b-极几何关系推导—对应点关系推导"><a href="#b-极几何关系推导—对应点关系推导" class="headerlink" title="b.极几何关系推导—对应点关系推导"></a>b.极几何关系推导—对应点关系推导</h5><p><img src="https://piggyhero.gitee.io/pic/img/20211216015329.png" alt="image-20210824025523590"></p>
<p>我们现在已经知道，K=K‘，且为规范化相机，p和p’的像素坐标。</p>
<p>由规范化相机还可以知道，空间点 $p$ 在 $O_1$ 坐标系下的欧式坐标为 $(u,v,1)$ ，以及 $p’$ 在 $O_2$ 坐标系下的欧式坐标 $(u’,v’,1)$</p>
<blockquote>
<p>因为是规范化相机，空间点的欧式坐标等于像素点的齐次坐标。已知p的空间坐标为(x,y,1)，p的像素齐次坐标为(u,v,1)，可以知道x=u,y=v。</p>
</blockquote>
<p>现在我们来求p和p‘的代数关系。</p>
<p>先把.$O_2$ 和 p‘的坐标转化到 $O_1$ 坐标系中为 $p’_{o_1}$：</p>
<p>因为</p>
<script type="math/tex; mode=display">
p'=Rp'_{o_1}+T\tag{4.2}</script><p>所以</p>
<script type="math/tex; mode=display">
p'_{o_1}=R^T(p'-T)\tag{4.3}</script><p>同理可得 $O_2$ 在 $O_1$ 坐标系下的坐标为：</p>
<script type="math/tex; mode=display">
O_2'=-R^TT\tag{4.4}</script><p><img src="https://piggyhero.gitee.io/pic/img/20211216015336.png" alt="image-20210824031818767"></p>
<p>现在如上图找到几何关系： $O_1p’ 和 O_1O_2$向量的叉积与 $O_1p$ 向量垂直，则有如下方程：</p>
<script type="math/tex; mode=display">
[R^T(p'-T)\times R^TT]\cdot p=0\tag{4.5}</script><p>最终可得到两个对应点的约束关系：</p>
<script type="math/tex; mode=display">
p^{\prime T}[T \times R] p=0\tag{4.6}</script><p>我们将中间的矩阵记作E，E就是本质矩阵。</p>
<script type="math/tex; mode=display">
p^{\prime T} E p=0\tag{4.7}</script><p>上面p‘和p都是三维坐标，它与像素坐标的齐次形式相同。</p>
<blockquote>
<blockquote>
<p> 补充：两个向量的叉乘可以写成矩阵的表示形式</p>
</blockquote>
<script type="math/tex; mode=display">
a \times b=\left[\begin{array}{ccc}
0 & -a_{z} & a_{y} \\
a_{z} & 0 & -a_{x} \\
-a_{y} & a_{x} & 0
\end{array}\right]\left[\begin{array}{l}
b_{x} \\
b_{y} \\
b_{z}
\end{array}\right]=\left[a_{\times}\right] b\tag{4.8}</script><blockquote>
<p> 这里的 $\left[a_{\times}\right]$ 的秩为2。</p>
</blockquote>
</blockquote>
<h5 id="c-本质矩阵的特点"><a href="#c-本质矩阵的特点" class="headerlink" title="c.本质矩阵的特点"></a>c.本质矩阵的特点</h5><ol>
<li>p对应的极线是 $l’$ （$l’=Ep$）这里的 $l’$ 是二维空间中的直线向量，表示直线方程</li>
<li>p’对应的极线是 $l$ （$l=E^Tp’$）</li>
<li>$Ee=0$ 与 $E^Te’=0$</li>
<li>E 的秩为2</li>
<li>E有5个自由度（三个旋转+三个平移，det(E)=0去掉了一个自由度）</li>
</ol>
<h4 id="3-基础矩阵"><a href="#3-基础矩阵" class="headerlink" title="3.基础矩阵"></a>3.基础矩阵</h4><p>对一般透视相机在两个视点的图像间的极几何关系的代数描述</p>
<p>此时相机不再是规范化相机。</p>
<h5 id="a-基础矩阵推导"><a href="#a-基础矩阵推导" class="headerlink" title="a.基础矩阵推导"></a>a.基础矩阵推导</h5><p>思路：把相机转化为规范化相机</p>
<script type="math/tex; mode=display">
p=K[I\ \ 0]P\tag{4.9}</script><script type="math/tex; mode=display">
p_c=K^{-1} p=K^{-1} K[I\ \  0] P=\left[\begin{array}{llll}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0
\end{array}\right] P\tag{4.10}</script><p>同理</p>
<script type="math/tex; mode=display">
p'_c=K'^{-1}p'\tag{4.11}</script><p>于是有：</p>
<script type="math/tex; mode=display">
p_{c}^{\prime T} E p_{c}=p_{c}^{\prime T}\left[T_{\times}\right] R p_{c}=\left(K^{\prime-1} p^{\prime}\right)^{T} \cdot\left[T_{\times}\right] R K^{-1} p=p^{\prime T} K^{\prime-T}\left[T_{x}\right] R K^{-1} p=0\tag{4.12}</script><p>令中间的部分为F，F即为基础矩阵</p>
<script type="math/tex; mode=display">
p^{\prime T} F p=0\tag{4.13}</script><script type="math/tex; mode=display">
F=K^{\prime-T}\left[T_{x}\right] R K^{-1}\tag{4.14}</script><h5 id="b-基础矩阵性质"><a href="#b-基础矩阵性质" class="headerlink" title="b.基础矩阵性质"></a>b.基础矩阵性质</h5><ol>
<li>p对应的极线是 $l’$ （$l’=Fp$）这里的 $l’$ 是二维空间中的直线向量，表示直线方程</li>
<li>p’对应的极线是 $l$ （$l=F^Tp’$）</li>
<li>$Fe=0$ 与 $F^Te’=0$</li>
<li>F 的秩为2</li>
<li>F 有7个自由度（尺度无法确定，det(F)=0去掉了一个自由度）</li>
</ol>
<h4 id="4-基础矩阵的估计"><a href="#4-基础矩阵的估计" class="headerlink" title="4.基础矩阵的估计"></a>4.基础矩阵的估计</h4><p>已知对应点的像素坐标，来求解F矩阵。</p>
<h5 id="a-八点算法"><a href="#a-八点算法" class="headerlink" title="a.八点算法"></a>a.八点算法</h5><p>首先，对应点间有以下关系</p>
<script type="math/tex; mode=display">
p^{\prime T} F p=0 \quad p=\left[\begin{array}{l}
u \\
v \\
1
\end{array}\right] \quad p^{\prime}=\left[\begin{array}{l}
u^{\prime} \\
v^{\prime} \\
1
\end{array}\right]\tag{4.15}</script><script type="math/tex; mode=display">
\\

\left(u^{\prime}, v^{\prime}, 1\right)\left(\begin{array}{lll}
F_{11} & F_{12} & F_{13} \\
F_{21} & F_{22} & F_{23} \\
F_{31} & F_{32} & F_{33}
\end{array}\right)\left(\begin{array}{l}
u \\
v \\
1
\end{array}\right)=0 \\\tag{4.16}</script><p>将(4.16)写成另外一种形式，如下式：</p>
<script type="math/tex; mode=display">
\left(u u^{\prime}, v u^{\prime}, u^{\prime}, u v^{\prime}, v v^{\prime}, v^{\prime}, u, v, 1\right)\left(\begin{array}{l}
F_{11} \\
F_{12} \\
F_{13} \\
F_{21} \\
F_{22} \\
F_{23} \\
F_{31} \\
F_{32} \\
F_{33}
\end{array}\right)=0\tag{4.17}</script><p>我们要求的就是后面的列向量，前面是对应点的坐标构成的一个行向量，一对对应点可列得一个(4.17)方程。</p>
<p>现在来看式(4.17)，这是一个齐次线性方程，虽然有9个未知数，当确定8个未知数后，第9个便可以确定。因此，仅需要8对点即可求解出基础矩阵F。</p>
<p>选取8对对应点后，可得到下式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}
u_{1} u_{1}^{\prime} & v_{1} u_{1}^{\prime} & u_{1}^{\prime} & u_{1} v_{1}^{\prime} & v_{1} v_{1}^{\prime} & v_{1}^{\prime} & u_{1} & v_{1} & 1 \\
u_{2} u_{2}^{\prime} & v_{2} u_{2}^{\prime} & u_{2}^{\prime} & u_{2} v_{2}^{\prime} & v_{2} v_{2}^{\prime} & v_{2}^{\prime} & u_{2} & v_{2} & 1 \\
u_{3} u_{3}^{\prime} & v_{3} u_{3}^{\prime} & u_{3}^{\prime} & u_{3} v_{3}^{\prime} & v_{3} v_{3}^{\prime} & v_{3}^{\prime} & u_{3} & v_{3} & 1 \\
u_{4} u_{4}^{\prime} & v_{4} u_{4}^{\prime} & u_{4}^{\prime} & u_{4} v_{4}^{\prime} & v_{4} v_{4}^{\prime} & v_{4}^{\prime} & u_{4} & v_{4} & 1 \\
u_{5} u_{5}^{\prime} & v_{5} u_{5}^{\prime} & u_{5}^{\prime} & u_{5} v_{5}^{\prime} & v_{5} v_{5}^{\prime} & v_{5}^{\prime} & u_{5} & v_{5} & 1 \\
u_{6} u_{6}^{\prime} & v_{6} u_{6}^{\prime} & u_{6}^{\prime} & u_{6} v_{6}^{\prime} & v_{6} v_{6}^{\prime} & v_{6}^{\prime} & u_{6} & v_{6} & 1 \\
u_{7} u_{7}^{\prime} & v_{7} u_{7}^{\prime} & u_{7}^{\prime} & u_{7} v_{7}^{\prime} & v_{7} v_{7}^{\prime} & v_{7}^{\prime} & u_{7} & v_{7} & 1 \\
u_{8} u_{8}^{\prime} & v_{8} u_{8}^{\prime} & u_{8}^{\prime} & u_{8} v_{8}^{\prime} & v_{8} v_{8}^{\prime} & v_{8}^{\prime} & u_{8} & v_{8} & 1
\end{array}\right]\left[\begin{array}{c}
F_{11} \\
F_{12} \\
F_{13} \\
F_{21} \\
F_{22} \\
F_{23} \\
F_{31} \\
F_{32} \\
F_{33}
\end{array}\right]=0\tag{4.18}</script><p>(4.18)还可以写成：</p>
<script type="math/tex; mode=display">
Wf=0\tag{4.19}</script><p>当W的秩为8时，存在唯一非零解。</p>
<p>而实际中，我们会选取超过8对点，来估计F矩阵，以防止个别点出现偏差时影响F的估计。</p>
<p>当选取超过8个点的时候，会变成一个超定方程组，超定方程组只有0解。此时我们需要用非线性优化的方法来求解。</p>
<script type="math/tex; mode=display">
\begin{gathered}
\min _{\boldsymbol{f}}\|\boldsymbol{W} \boldsymbol{f}\| \\
\text { s. } t .\|\boldsymbol{f}\|=1
\end{gathered}\longrightarrow \hat{F}\tag{4.20}</script><p>当f的模为1时(因为这是一个齐次线性方程组，f的模可以是任意的，在这里我们取1)，使Wf最小。具体的过程就是奇异值分解，和式(2.7)求法相同。</p>
<p>这里 $\hat{F}$ 并不是我们要求的基础矩阵，因为基础矩阵的秩为2，此处的 $\hat{F}$ 的秩为3 。</p>
<p>继续用最优化思想来求解。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\text { 寻找F最小化 }\|F-\widehat{F}\|_{\mathrm{F}}\\
&\text { s.t. } \operatorname{det}(F)=0
\end{aligned}</script><p>具体过程也很简单，就是对 $\hat{F}$ 进行奇异值分解。</p>
<script type="math/tex; mode=display">
S V D(\hat{F})=U\left[\begin{array}{ccc}
s_{1} & 0 & 0 \\
0 & s_{2} & 0 \\
0 & 0 & s_{3}
\end{array}\right] V^{T} \Rightarrow F=U\left[\begin{array}{ccc}
s_{1} & 0 & 0 \\
0 & s_{2} & 0 \\
0 & 0 & 0
\end{array}\right] V^{T}\tag{4.21}</script><h5 id="b-八点算法的问题"><a href="#b-八点算法的问题" class="headerlink" title="b.八点算法的问题"></a>b.八点算法的问题</h5><p>精度低！！！</p>
<p>因为W矩阵中的各个元素的数值差异过大</p>
<h5 id="c-归一化八点法"><a href="#c-归一化八点法" class="headerlink" title="c.归一化八点法"></a>c.归一化八点法</h5><p>对每幅图施加变换T(平移与缩放)，让其满足以下条件：</p>
<ol>
<li>新原点=图像上点的重心</li>
<li>每个像点到坐标原点的均方根距离为 $\sqrt {2}$</li>
</ol>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015347.png" alt="image-20210825010953797"></p>
<p>归一化八点算法的步骤：</p>
<ol>
<li>先计算左图和右图的T和T‘</li>
<li>坐标归一化$q_{i}=T p_{i} \quad q^{\prime}{ }_{i}=T^{\prime} p_{i}{ }^{\prime}$</li>
<li>通过八点算法计算 $F_q$</li>
<li>逆归一化$F=T^{\prime T} F_{q} T$</li>
</ol>
<h2 id="五、双目立体视觉系统"><a href="#五、双目立体视觉系统" class="headerlink" title="五、双目立体视觉系统"></a>五、双目立体视觉系统</h2><h3 id="A-平行视图下的极几何"><a href="#A-平行视图下的极几何" class="headerlink" title="A.平行视图下的极几何"></a>A.平行视图下的极几何</h3><p>利用两个视点来观察物体，和人的眼睛一样。</p>
<p>可以让对应点搜索和深度求解更加简单。</p>
<h4 id="0-补充："><a href="#0-补充：" class="headerlink" title="0.补充："></a>0.补充：</h4><h5 id="a-极点坐标"><a href="#a-极点坐标" class="headerlink" title="a.极点坐标"></a>a.极点坐标</h5><p><img src="https://piggyhero.gitee.io/pic/img/20211216015354.png" alt="image-20210825160039966" style="zoom:50%;" /></p>
<p>我们前面说过，极点是基线和成像平面的交点。从另外一个角度来看，极点还可以是相机中心在成像平面上的投影点。那么如上图所示，极点 $e$ 是点 $O_2$ 在成像平面的投影。极点 $e’$ 是 $O_1$ 在成像平面的投影。</p>
<p>那么点 $O_1$ 在坐标系 $O_1$ 中的齐次坐标为 $[0\ 0\ 0\ 1]^T$ ，其在坐标系 $O_2$ 中的欧式坐标为：</p>
<script type="math/tex; mode=display">
[R\ T]\left[\begin{array}{}0\\0\\0\\1\end{array}\right]\tag{5.1}</script><p>所以 $e’$ 的齐次坐标就为：</p>
<script type="math/tex; mode=display">
e'=K'[R\ T]\left[\begin{array}{}0\\0\\0\\1\end{array}\right]=K'T\tag{5.2}</script><h5 id="b-叉乘性质"><a href="#b-叉乘性质" class="headerlink" title="b.叉乘性质"></a>b.叉乘性质</h5><p>对于任意向量t，如果M可逆，相差一个尺度的情况下，有如下关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&{\left[t_{\times}\right] M=M^{-T}\left[\left(M^{-1} t\right)_{\times}\right]} \\

\end{aligned}\tag{5.3}</script><p>然后我们令$ t=T, M=K^{\prime-1}$ ，代入到式(5.3)中</p>
<script type="math/tex; mode=display">
{\left[T_{\times}\right] K^{\prime-1}=K^{\prime T}\left[\left(K^{\prime} T\right)_{x}\right]} \\\tag{5.4}</script><p>便可以得到：</p>
<script type="math/tex; mode=display">
\left[T_{\times}\right]=K^{\prime T}\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime}\tag{5.5}</script><p>然后将式(5.5)代入基础矩阵(4.14)中：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F&=K^{\prime-T}\left[T_{x}\right] R K^{-1}\\
&=K^{\prime-T} K^{\prime T}\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime} R K^{-1}\\
&=\left[\left(K^{\prime} T\right)_{\times}\right] K^{\prime} R K^{-1}\\
&=\left[e_{x}^{\prime}\right] K^{\prime} R K^{-1}
\end{aligned}\tag{5.6}</script><h4 id="1-平行视图的基础矩阵"><a href="#1-平行视图的基础矩阵" class="headerlink" title="1.平行视图的基础矩阵"></a>1.平行视图的基础矩阵</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015401.png" alt="image-20210825164325338" style="zoom:50%;" /></p>
<p>两个成像平面平行</p>
<p>基线平行于成像平面，极点 $e$ 和 $e’$ 位于无穷远处</p>
<p>我们假定两个摄像机的内参是一样的，$K=K’$。旋转矩阵 $R=I$ 。平移向量$T=[T\ 0\ 0]^T$ 和极点坐标 $e’=[1\ 0\ 0]^T$ 。</p>
<p>将上面的表达式代入到(5.6)中：</p>
<script type="math/tex; mode=display">
F=\left[e_{x}^{\prime}\right] K^{\prime} R K^{-1}=\left[e^{\prime}{ }_{x}\right]=\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & -1 \\
0 & 1 & 0
\end{array}\right]\tag{5.7}</script><p>这就是平行视图的基础矩阵。</p>
<h4 id="2-平行视图下的极线"><a href="#2-平行视图下的极线" class="headerlink" title="2.平行视图下的极线"></a>2.平行视图下的极线</h4><p>一对对应点p和p‘，像素坐标为：$\left(p_{u}, p_{v}\right) 和<br>\left(p_{u}^{\prime}, p_{v}^{\prime}\right)$</p>
<p>极线的方程为：</p>
<script type="math/tex; mode=display">
l=F^{T} p^{\prime}=\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & 1 \\
0 & -1 & 0
\end{array}\right]\left[\begin{array}{c}
p_{u}^{\prime} \\
p_{v}^{\prime} \\
1
\end{array}\right]=\left[\begin{array}{c}
0 \\
1 \\
-p_{v}^{\prime}
\end{array}\right]\tag{5.8}</script><p>可以看出，该极线是平行于u轴的。</p>
<h4 id="3-对应点关系"><a href="#3-对应点关系" class="headerlink" title="3.对应点关系"></a>3.对应点关系</h4><script type="math/tex; mode=display">
p'^TFp=0\tag{5.9}</script><p>即：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{lll}
p_{u}^{\prime} & p_{v}^{\prime} & 1
\end{array}\right)\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & -1 \\
0 & 1 & 0
\end{array}\right]\left[\begin{array}{l}
p_u \\
p_v \\
1
\end{array}\right]=0\tag{5.10}</script><p>最后得到：</p>
<script type="math/tex; mode=display">
p_v=p_v'\tag{5.11}</script><p>这说明对应点的v坐标是一样的。寻找对应点时，直接在扫描线上找即可。</p>
<h4 id="4-平行视图的三角测量"><a href="#4-平行视图的三角测量" class="headerlink" title="4.平行视图的三角测量"></a>4.平行视图的三角测量</h4><p>因为对应点的v坐标相同，所以可以很方便的测量P点的深度值。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015408.png" alt="image-20210825171253726" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
p_{u}-p_{u}^{\prime}=\frac{B \cdot f}{z}\tag{5.12}</script><p>知道视差和基线长度后，便可以计算出深度。</p>
<h3 id="B-图像校正"><a href="#B-图像校正" class="headerlink" title="B.图像校正"></a>B.图像校正</h3><p>平行视图让我们寻找对应点和三角化更加简单，但通常情况下我们构建的双目立体视觉系统是很难得到平行视图的。我们可以将非平行视图转化到平行视图，这就是图像校正。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015415.png" alt="image-20210825175411272" style="zoom: 33%;" /></p>
<p>完成校正这一目标需要构建两个矩阵H和H‘，我们可以通过以下5个步骤来求得这两个矩阵。</p>
<ol>
<li><p>找8个以上的匹配点对。</p>
</li>
<li><p>计算基础矩阵F，然后来求解两幅图像中的极点。具体可以通过上一步的匹配点通过八点算法求出基础矩阵F，然后可以通过基础矩阵的性质求得极线方程。再根据所有极线都经过极点这一性质，求得极点的齐次坐标。</p>
</li>
<li><p>选择透视变换 $H’$ 将 $e’$ 映射到无穷远点 $(f,0,0)$。其中 $H’=T^{-1}GRT$ 。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015418.png" alt="image-20210825180734367" style="zoom:50%;" /></p>
</li>
<li><p>寻找透视变换矩阵H，使得 $\sum_{i} d\left(H p_{i}, H^{\prime} p_{i}^{\prime}\right)$ 最小。</p>
</li>
<li><p>分别用H和H‘对左右两幅图进行重采样。</p>
</li>
</ol>
<p><strong>图像校正例子：</strong></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015450.png" alt="image-20210825181026118" style="zoom: 33%;" /></p>
<h3 id="C-对应点搜索"><a href="#C-对应点搜索" class="headerlink" title="C.对应点搜索"></a>C.对应点搜索</h3><p>给定一个空间点P，在左右图像中找到相应的观测值，也称为双目融合问题。 </p>
<p>图像经过校正后，对应点在扫描线上搜索即可。</p>
<h4 id="1-相关法"><a href="#1-相关法" class="headerlink" title="1.相关法"></a>1.相关法</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015434.png" style="zoom:50%;" /></p>
<p>首先建立一个窗口</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015430.png" alt="image-20210825193829734" style="zoom:50%;" /></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015502.png" alt="image-20211009194933364" style="zoom: 33%;" /></p>
<h4 id="2-归一化相关法"><a href="#2-归一化相关法" class="headerlink" title="2.归一化相关法"></a>2.归一化相关法</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015506.png" alt="image-20210825194834081" style="zoom:50%;" /></p>
<p>当两幅图在光照不同的情况下，会使其像素点的灰度值发生剧烈变化。</p>
<p>此时只需要将窗口内的像素点的灰度值进行去均值即可。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015513.png" alt="image-20210825195133785" style="zoom:150%;" /></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015518.png" alt="image-20210825195236089"></p>
<p>窗口大小的影响：上面我们选取的是 $3\times 3$ 窗口，当选取其他大小窗口的时候会有什么样的变化呢？</p>
<p>ans：较小的窗口，细节丰富，但噪声较大。较大的窗口，视差图更为平滑，但是细节丢失。</p>
<p>例如下图所示，右边两幅图为视差图：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015528.png" alt="image-20210825195947480"></p>
<h4 id="3-相关法存在的问题"><a href="#3-相关法存在的问题" class="headerlink" title="3.相关法存在的问题"></a>3.相关法存在的问题</h4><h5 id="a-透视缩短"><a href="#a-透视缩短" class="headerlink" title="a.透视缩短"></a>a.透视缩短</h5><p>一个物体的长度在一个成像平面上是正常的，但可能在另一成像平面上非常的短。此时在相同范围邻域的内容有很大的不同。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015537.png" alt="image-20210825235305290" style="zoom:50%;" /></p>
<h5 id="b-遮挡"><a href="#b-遮挡" class="headerlink" title="b.遮挡"></a>b.遮挡</h5><p><img src="https://piggyhero.gitee.io/pic/img/20211216015541.png" alt="image-20210825235332461" style="zoom:50%;" /></p>
<p>以上两种问题的解决办法：</p>
<p>合理的选择基线与深度的比值。</p>
<script type="math/tex; mode=display">
\frac{B}{z}\tag{5.13}</script><p>减小B/z时，可以有效的避免透视缩短和遮挡的问题。用我们最直观的感受就是离物体远点，就看的更全了。</p>
<p>但缩小B/z，也会造成一个问题，就是当匹配点有很小的误差时，就会造成深度估算的大误差。</p>
<p>如下面两幅图所示，红色的点就是根据对应点估算空间点的位置。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015548.png" alt="image-20210825235821706" style="zoom: 25%;" /></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015556.png" alt="image-20210825235841876" style="zoom: 50%;" /></p>
<p>可以看到，当B/z较小时，所估算的深度误差和真实的相差很大。</p>
<h5 id="c-同质区域"><a href="#c-同质区域" class="headerlink" title="c.同质区域"></a>c.同质区域</h5><p>有多个地方与要匹配的点相似。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015603.png" alt="image-20210826000100677" style="zoom:50%;" /></p>
<h5 id="d-重复模式"><a href="#d-重复模式" class="headerlink" title="d.重复模式"></a>d.重复模式</h5><p>和上面的问题类似。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015613.png" alt="image-20210826000215422" style="zoom:50%;" /></p>
<p>容易产生误匹配。所以对应点匹配问题是一个很难的问题。</p>
<p>要解决这些问题，我们需要增加约束来解决对应点匹配问题。</p>
<h4 id="4-其他约束"><a href="#4-其他约束" class="headerlink" title="4.其他约束"></a>4.其他约束</h4><ol>
<li>唯一性约束：一张图像中的任何点，在另一张图像中最多只有一个匹配点。</li>
<li>顺序约束/单调性约束：左右视图中对应点的次序一致</li>
<li>平滑性约束：视差函数通常是平滑的（除了边界遮挡）</li>
</ol>
<p>这些方法可以参考：《计算机视觉：一种现代方法》</p>
<h2 id="六、多视图几何"><a href="#六、多视图几何" class="headerlink" title="六、多视图几何"></a>六、多视图几何</h2><h3 id="A-运动恢复结构问题"><a href="#A-运动恢复结构问题" class="headerlink" title="A.运动恢复结构问题"></a>A.运动恢复结构问题</h3><p>通过三维场景的多张图像，恢复出该场景的三维结构信息以及每张图片所对应的摄像机参数。这也就是SLAM，恢复机构等价于建图，求对应的摄像机参数等价于定位，因为摄像机参数包括内参和外参，外参数就是摄像机的运动信息。</p>
<h4 id="1-问题的具体描述"><a href="#1-问题的具体描述" class="headerlink" title="1.问题的具体描述"></a>1.问题的具体描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$ </p>
<p>且 $x_{ij}=M_iX_j$ ，其中 $M_i$ 为第 $i$ 张图片对应的摄像机投影矩阵</p>
<p><strong>求解</strong>：$m$ 个摄像机的投影矩阵 $M_i$ ；<strong>运动</strong></p>
<p>​            $n$ 个三维点 $X_j$ 的坐标；<strong>三维结构</strong></p>
<p>该类问题也称作运动恢复结构问题。</p>
<h4 id="2-三种典型的运动恢复结构任务"><a href="#2-三种典型的运动恢复结构任务" class="headerlink" title="2.三种典型的运动恢复结构任务"></a>2.三种典型的运动恢复结构任务</h4><h5 id="a-欧式结构恢复"><a href="#a-欧式结构恢复" class="headerlink" title="a.欧式结构恢复"></a>a.欧式结构恢复</h5><p>摄像机内参已知，外参未知。</p>
<p>应用场景：扫地机器人，无人驾驶汽车</p>
<h5 id="b-仿射结构恢复"><a href="#b-仿射结构恢复" class="headerlink" title="b.仿射结构恢复"></a>b.仿射结构恢复</h5><p>摄像机为仿射相机，内、外参数均未知。</p>
<p>应用场景：待重构场景离摄像机较远，而且场景的深度变化不大。</p>
<h5 id="c-透视结构恢复"><a href="#c-透视结构恢复" class="headerlink" title="c.透视结构恢复"></a>c.透视结构恢复</h5><p>摄像机为透视相机，内、外参数均未知。</p>
<p>应用场景：只知道图片，还不能忽略深度变化。</p>
<h3 id="B-欧式结构恢复"><a href="#B-欧式结构恢复" class="headerlink" title="B.欧式结构恢复"></a>B.欧式结构恢复</h3><h4 id="0-问题描述"><a href="#0-问题描述" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>$m$ 张图片对应的摄像机内参数矩阵 $K_i\ (i=1,…m)$</p>
<p>有$x_{ij}=M_iX_j=K_i[R_i\ T_i]X_j$ </p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的外参数 $R_i$ 和 $T_i$ 。</p>
<p>先来看两视图情况，令 $O_1$ 坐标系与世界坐标系固定。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015622.png" alt="image-20210826014140627" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
\begin{aligned}
&x_{1j}=M_{1} X_{j}=K_{1}\left[\begin{array}{ll}
I & 0
\end{array}\right] X_{j} \\
&x_{2 j}=M_{2} X_{j}=K_{2}\left[\begin{array}{ll}
R \ \ \ T
\end{array}\right] X_{j}
\end{aligned}\tag{6.1}</script><h4 id="1-基本求法"><a href="#1-基本求法" class="headerlink" title="1.基本求法"></a>1.基本求法</h4><p>可以分为四步：</p>
<ol>
<li>求解基础矩阵F，归一化八点法</li>
<li>利用F与摄像机内参数求解本质矩阵E，$E=K_{2}^{T} F K_{1}$</li>
<li>分解本质矩阵获得R和T</li>
<li>三角化求解三维点 $X_j$ 的坐标。$X_{j}^{*}=\underset{X_{j}}{\operatorname{argmin}}\left(d\left(x_{1 j}, M_{1} X_{j}\right)+d\left(x_{2 j}, M_{2} X_{j}\right)\right)$</li>
</ol>
<p>这里要说明一下步骤1，2之前都已经学过，而最重要的本质矩阵分解将在下面介绍。</p>
<h4 id="2-本质矩阵分解"><a href="#2-本质矩阵分解" class="headerlink" title="2.本质矩阵分解"></a>2.本质矩阵分解</h4><h5 id="a-本质矩阵推导"><a href="#a-本质矩阵推导" class="headerlink" title="a.本质矩阵推导"></a>a.本质矩阵推导</h5><blockquote>
<p>重要说明：在我们使用八点法求解基础矩阵F时，是无法确定F的符号和尺度的。求解F的方程为 $x_2^TFx_1=0$ ，而-F和kF都满足这个方程，所以说解出来的F可能不是真正的F。同理由F得到的E也是无法确定符号和尺度的。</p>
</blockquote>
<p>先定义两个矩阵：</p>
<script type="math/tex; mode=display">
W=\left[\begin{array}{ccc}
0 & -1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1
\end{array}\right] \quad Z=\left[\begin{array}{ccc}
0 & 1 & 0 \\
-1 & 0 & 0 \\
0 & 0 & 0
\end{array}\right]\tag{6.2}</script><p>这两个矩阵有一个重要的性质：</p>
<script type="math/tex; mode=display">
Z=-diag(1,1,0)W=diag(1,1,0)W^T\tag{6.3}</script><p>本质矩阵E中的 $[T_{\times}]$ 可以写成：</p>
<script type="math/tex; mode=display">
\left[T_{\times}\right]=k U Z U^{T}\tag{6.4}</script><p>其中U是单位正交阵。(6.4)中的Z用W来表示：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}

\left[T_{\times}\right]&=k U Z U^{T}\\
&=-kUdiag(1,1,0)WU^T\\
&=kUdiag(1,1,0)W^TU^T
\end{aligned}\tag{6.5}</script><p>当忽略尺度和符号的情况下，可以认为(6.5)为：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}

\left[T_{\times}\right]&=k U Z U^{T}\\
&=Udiag(1,1,0)WU^T\\
&=Udiag(1,1,0)W^TU^T
\end{aligned}\tag{6.6}</script><p>所以本质矩阵为：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}
E&=[T_{\times}]R\\
&=Udiag(1,1,0)(WU^TR)\\
&=Udiag(1,1,0)(W^TU^TR)
\end{aligned}\tag{6.7}</script><h5 id="b-本质矩阵分解"><a href="#b-本质矩阵分解" class="headerlink" title="b.本质矩阵分解"></a>b.本质矩阵分解</h5><p>现在我们有通过八点法计算出来的本质矩阵E，我们对其进行奇异值分解：</p>
<script type="math/tex; mode=display">
E=Udiag(1,1,0)V^T\tag{6.8}</script><p>(6.8)和(6.7)进行比较，可以得到：</p>
<script type="math/tex; mode=display">
\quad V^T=WU^TR\\
or\quad V^T=W^TU^TR\tag{6.9}</script><p>因为W矩阵和U矩阵都是可逆矩阵，所以可以求得R为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R&=(WU^T)^{-1}V^T\\
&=-UWV^T
\\
or\quad R&=(W^TU^T)^{-1}V^T\\
&=-UW^TV^T
\end{aligned}\tag{6.10}</script><blockquote>
<p>这里：$W^{-1}=-W\ and \ W^{-T}=W^T$</p>
</blockquote>
<p>忽略正负号，最终可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R&=UWV^T
\\
or\quad R
&=UW^TV^T
\end{aligned}\tag{6.11}</script><p>(6.11)中R有两个值，分别对应着在E推导的过程中，使用 $W\ and \ W^T$ 的两种情况。</p>
<p>然后我们再来求解平移向量T。首先根据叉乘性质：</p>
<script type="math/tex; mode=display">
T\times T=[T_{\times}]T=UZU^TT=0\tag{6.12}</script><p>因为U是单位正交阵，将U矩阵写出：</p>
<script type="math/tex; mode=display">
U=[u_1\ u_2 \ u_3]\quad note:u_i\ 是单位列向量\tag{6.13}</script><p>(6.12)展开可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
UZU^TT&=[u_1\ u_2 \ u_3]diag(1,1,0)W
\left[\begin{array}{l}
u_1^T\\
u_2^T\\
u_3^T
\end{array}\right]T
\\
&=(u_2u_1^T-u_1u_2^T)T=0
\end{aligned}\tag{6.14}</script><p>因为 $u_i$  间两两正交，所以当 $T=\pm ku_3$ 时，式(6.14)成立。</p>
<p>现在R和T对应着两个结果，而两两组合就会出现四种情况。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left\{\begin{array}{lc}
R= U W V^{T} &T=u_{3} \\
R= U W V^{T} &T=-u_{3} \\
R=U W^{T} V^{T} &T=u_{3} \\
R=U W^{T} V^{T} &T=-u_{3}
\end{array}\right.
\end{aligned}\tag{6.15}</script><p>分别对应着下面的四种情况：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015630.png" alt="image-20210828023242724" style="zoom:50%;" /></p>
<p>选择一个或多个点，分别用不同的R和T进行三角化计算，只有深度值都为正的R和T才为最终所求。</p>
<h4 id="3-欧式结构恢复存在的问题"><a href="#3-欧式结构恢复存在的问题" class="headerlink" title="3.欧式结构恢复存在的问题"></a>3.欧式结构恢复存在的问题</h4><p>正如我们在2.a中的推导，是忽略了尺度上差异和正负号差异的基础上建立的，通过求目标点的深度我们可以去除掉正负号的影响，但是尺度上的差异是去除不掉的。对于单目相机来说，凭借序列图是无法重构出正确尺度下的三维场景。</p>
<p>例如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015638.png" alt="image-20210828030716063"></p>
<p>从上图可以看出，两个空间点在两成像平面的像素坐标都是相同的，但两个空间点的深度不同，两个视点间的变换也不同，右边的平移矩阵T与左边的T相差一个系数k。另外，在真实空间中P1和P2的朝向也是不同的，这通过欧式重构也是求解不出来的。</p>
<p>我们可以这样认为，恢复出来的欧式结构和真实场景相差一个相似变换(旋转+平移+缩放)。这个相似变换的重构被称为度量重构。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015645.png" alt="image-20210828031302492" style="zoom:50%;" /></p>
<p>所以在没有先验知识的情况下，仅凭单目相机是不能恢复出三维空间结构的。</p>
<h3 id="C-仿射结构恢复"><a href="#C-仿射结构恢复" class="headerlink" title="C.仿射结构恢复"></a>C.仿射结构恢复</h3><p>由(3.3)知道，仿射变换矩阵为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{l}
m_{1} \\
m_{2} \\
m_{3}
\end{array}\right]=\left[\begin{array}{cc}
A_{2 \times 3} & b_{2 \times 1} \\
0_{1 \times 3} & 1
\end{array}\right]=\left[\begin{array}{ccc}
&m_{1} \\
&m_{2} \\
0&0&0&1
\end{array}\right]\tag{6.16}</script><p>则空间中的三维点经过仿射变换到像素坐标系中：</p>
<script type="math/tex; mode=display">
x=\left[\begin{array}{l}u\\
v\\
1\end{array}\right]=MX=M\left[\begin{array}{l}x\\
y\\
z\\
1\end{array}\right]=AX^E+b\quad(X^E为空间点的欧式坐标)\tag{6.17}</script><h4 id="0-问题描述-1"><a href="#0-问题描述-1" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>有$x_{ij}=A_iX_j+b_i$ </p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的投影矩阵 $A_i\ and\ b_i$ 。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015652.png" alt="image-20210829191114401"></p>
<h4 id="1-因式分解法"><a href="#1-因式分解法" class="headerlink" title="1.因式分解法"></a>1.因式分解法</h4><h5 id="a-数据中心化"><a href="#a-数据中心化" class="headerlink" title="a.数据中心化"></a>a.数据中心化</h5><p>中心化就是减去图像点的质心。</p>
<script type="math/tex; mode=display">
\hat{x}_{i j}=x_{i j}-\bar{x}_{i} \\ 其中：\begin{aligned}\bar{x}_{i}=\frac{1}{n} \sum_{k=1}^{n} x_{i k} \\ 
x_{\mathrm{ij}}=A_{i} X_{j}+b_{i}\end{aligned}\tag{6.18}</script><p><img src="https://piggyhero.gitee.io/pic/img/20211216015657.png" alt="image-20210829191737903"></p>
<p>然后可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{x}_{i j}=x_{i j}-\frac{1}{n} \sum_{k=1}^{n} x_{i k} &=A_{i} X_{j}+b_{i}-\frac{1}{n} \sum_{k=1}^{n} A_{i} X_{k}-\frac{1}{n} \sum_{k=1}^{n} b_{i} \\
&=A_{i}\left(X_{j}-\frac{1}{n} \sum_{k=1}^{n} X_{k}\right)\\&=A_{i}\left(X_{j}-\bar{X}\right)\\&=A_{i} \hat{X}_{j}
\end{aligned}\tag{6.19}</script><p>如果令三维空间点的质心=世界坐标系的远点。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015705.png" alt="image-20210829191948530"></p>
<p>那么：</p>
<script type="math/tex; mode=display">
\hat{x}_{i j}=A_{i} \hat{X}_{j}=A_{i} X_{j}\tag{6.20}</script><h5 id="b-因式分解"><a href="#b-因式分解" class="headerlink" title="b.因式分解"></a>b.因式分解</h5><p>现在我们把去均值以后的 $m\times n$ 个测量值写成矩阵的形式：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{cccc}
\hat{x}_{11} & \hat{x}_{12} & \cdots & \hat{x}_{1 n} \\
\hat{x}_{21} & \hat{x}_{22} & \cdots & \hat{x}_{2 n} \\
& & \ddots & \\
\hat{x}_{m 1} & \hat{x}_{m 2} & \cdots & \hat{x}_{m n}
\end{array}\right]\tag{6.21}</script><p>其中每个 $\hat{x}_{ij}$ 是一个 $2\times1$ 的向量，它是图像点的像素坐标。</p>
<p>根据式(6.20)，可以推导出D的由来：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{llll}
\hat{x}_{11} & \hat{x}_{12} & \cdots & \hat{x}_{1 n} \\
\hat{x}_{21} & \hat{x}_{22} & \cdots & \hat{x}_{2 n} \\
& & \ddots & \\
\hat{x}_{m 1} & \hat{x}_{m 2} & \cdots & \hat{x}_{m n}
\end{array}\right]=\left[\begin{array}{c}
A_{1} \\
A_{2} \\
\vdots \\
A_{m}
\end{array}\right]
\left[\begin{array}{c} X_{1} & X_{2} & \cdots & X_{n}
\end{array}\right]=MS\tag{6.22}</script><p>下面对D进行奇异值分解：</p>
<script type="math/tex; mode=display">
D=UWV^T\tag{6.23}</script><p>(6.22)中，M矩阵的最大秩为3，S矩阵的最大秩也为3。所以D的最大秩为3</p>
<p>那么我们就可以选择前三个最大的奇异值来进行分解，如图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015711.png" style="zoom: 67%;" /></p>
<p>所以：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015717.png" alt="image-20210829193956389" style="zoom:67%;" /></p>
<script type="math/tex; mode=display">
D=U_3W_3V_3^T=U_3(W_3V_3^T)=M^\star S^\star \tag{6.24}</script><p>(6.24)中，我们用后面 $W_3V_3^T$ 来重构S矩阵，当然也可以用 $V_3^T$ 来重构S。</p>
<p>这就引出了一个问题，对于同一结构，为什么可以有不同种恢复机构呢？</p>
<p>这个问题就是仿射结构的恢复歧义。</p>
<h5 id="c-因式分解法的问题"><a href="#c-因式分解法的问题" class="headerlink" title="c.因式分解法的问题"></a>c.因式分解法的问题</h5><p>当我们构建D矩阵时，是假设所有的三维点在图像上都能找得到，但当三维点被遮挡后，图像上找不到它的投影点，此时D矩阵中的元素就会空缺。这就会造成求解失败。</p>
<h4 id="2-仿射结构恢复歧义"><a href="#2-仿射结构恢复歧义" class="headerlink" title="2.仿射结构恢复歧义"></a>2.仿射结构恢复歧义</h4><p>先来看看D矩阵的推导过程，可用下图来表示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015723.png" alt="image-20210829194730339"></p>
<p>当我们在M矩阵和S矩阵间乘上一个可逆矩阵H和它的逆后：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015728.png" alt="image-20210829194843158"></p>
<p>最后的结果还是D矩阵，但是M和S矩阵却不相同了。其中H矩阵可以是任意的可逆的 $3\times3$ 的矩阵</p>
<p>所以必须利用其他的约束条件来解决歧义的问题。</p>
<p>仿射歧义的可视化如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015734.png" alt="image-20210829195044317"></p>
<p>真实的三维结构和恢复的三维结构之间相差了一个任意的 $3\times 3$ 的可逆矩阵H。</p>
<h3 id="D-透视结构恢复"><a href="#D-透视结构恢复" class="headerlink" title="D.透视结构恢复"></a>D.透视结构恢复</h3><h4 id="0-问题描述-2"><a href="#0-问题描述-2" class="headerlink" title="0.问题描述"></a>0.问题描述</h4><p>已知 $n$ 个三维点 $X_j$ 在 $m$ 张图像中的对应点像素坐标 $x_{ij}(i=1,…m;j=1,…,n)$</p>
<p>有$x_{ij}=M_iX_j$ </p>
<p>$M_i$ 是第i张图片对应的摄像机投影矩阵</p>
<p>目标：求解空间点的坐标 $X_j$ 和摄像机的投影矩阵 $M_i$ 。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015739.png" alt="image-20210829195526866"></p>
<h4 id="1-透视结构恢复歧义"><a href="#1-透视结构恢复歧义" class="headerlink" title="1.透视结构恢复歧义"></a>1.透视结构恢复歧义</h4><p>根据透视相机投影规律，当不知道相机的内参和外参时，可用M矩阵来表示透视投影关系，M是一个 $3\times4$ 矩阵，透视关系如下：</p>
<script type="math/tex; mode=display">
x_{ij}=M_iX_j\tag{6.25}</script><p>当 $M_i$ 和 $X_j$ 之间，可以加上任意一个 $4\times 4$ 的可逆矩阵H和其逆矩阵的乘积。</p>
<script type="math/tex; mode=display">
x_{ij}=M_iHH^{-1}X_j\tag{6.26}</script><p>这样，在恢复结构的时候，所恢复出的 $M_i$ 和真实的 $M_i$ 可能会相差一个H投影变换矩阵。这就是透视结构恢复歧义。</p>
<p>所以我们恢复透视结构时，是在相差一个 $4\times4$ 的可逆变换的情况下，恢复摄像机运动和场景结构的。</p>
<h4 id="2-代数方法（通过基础矩阵）"><a href="#2-代数方法（通过基础矩阵）" class="headerlink" title="2.代数方法（通过基础矩阵）"></a>2.代数方法（通过基础矩阵）</h4><p><img src="https://piggyhero.gitee.io/pic/img/20211216015748.png" alt="image-20210829202031145"></p>
<p>代数方法主要用于两视图情况，尽管我们要使用的是一个图像序列，但是我们可以将其分成多个两视图情况来进行求解。</p>
<p>具体求解有三个步骤：</p>
<p>(1) 八点算法来求得基础矩阵F</p>
<p>(2)由基础矩阵F求得摄像机的投影矩阵。</p>
<p>(3)用三角化计算三维点的坐标。</p>
<h5 id="a-基础矩阵和投影矩阵的关系"><a href="#a-基础矩阵和投影矩阵的关系" class="headerlink" title="a.基础矩阵和投影矩阵的关系"></a>a.基础矩阵和投影矩阵的关系</h5><p>在这里，第(2)步中，<strong>如何通过F矩阵来求投影矩阵M我们之前没有说过</strong>。下面介绍该步骤的解法。</p>
<p>由于透视歧义的存在，我们总是可以找到一个可逆矩阵H，使得：</p>
<script type="math/tex; mode=display">
M_{1} H^{-1}=[I \mid 0] \quad M_{2} H^{-1}=[A \mid b]\tag{6.27}</script><p>用X表示三维点，$x\ and \ x’$ 分别称为摄像机1和2的对应观测值。</p>
<p>令：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\widetilde{M}_{1}=M_{1} H^{-1}=\left[\begin{array}{ll}
I & 0
\end{array}\right] \\
\widetilde{M}_{2}=M_{2} H^{-1}=\left[\begin{array}{ll}
A & b
\end{array}\right] \\
\widetilde{X}=H X
\end{array}\right.\tag{6.28}</script><p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x=M_{1} X=M_{1} H^{-1} H X=[I \mid 0] \tilde{X} \\
&x^{\prime}=M_{2} X=M_{2} H^{-1} H X=[A \mid b] \tilde{X}
\end{aligned}\tag{6.29}</script><p>对于摄像机1和2的观测值 $x\ and \ x’$ 有如下关系：</p>
<script type="math/tex; mode=display">
x^{\prime}=[A \mid b] \widetilde{X}=[A \mid b]\left[\begin{array}{c}
\widetilde{X}_{1} \\
\widetilde{X}_{2} \\
\widetilde{X}_{3} \\
1
\end{array}\right]=A[I \mid 0]\left[\begin{array}{c}
\widetilde{X}_{1} \\
\widetilde{X}_{2} \\
\widetilde{X}_{3} \\
1
\end{array}\right]+b=A[I \mid 0] \widetilde{X}+b=A x+b\tag{6.30}</script><p>然后我们将(6.30)中的  $x’$ 叉乘b：</p>
<script type="math/tex; mode=display">
x'\times b=(Ax+b)\times b=Ax\times b\tag{6.31}</script><p>再用 $x’$ 点乘 $x’\times b$ ，它的结果为0，所以：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x'^T \cdot(x'\times b)&=x'^T\cdot(Ax\times b)\\
&=-x'^T\cdot(b\times Ax)\\
&=-x'^T[b_{\times}]Ax=0
\end{aligned}\tag{6.32}</script><p>由极几何关系，可以知道两个视图的对应点的像素坐标的关系是：</p>
<script type="math/tex; mode=display">
x'^TFx=0\tag{6.33}</script><p>所以比较(6.32)和(6.33)，有：</p>
<script type="math/tex; mode=display">
F=[b_{\times}]A\tag{6.34}</script><p><strong>有了这个关系，我们现在就可以用八点法得到的基础矩阵F来分解出A矩阵和b</strong></p>
<h5 id="b-计算投影矩阵中的b"><a href="#b-计算投影矩阵中的b" class="headerlink" title="b.计算投影矩阵中的b"></a>b.计算投影矩阵中的b</h5><p>考虑：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F^Tb&=([b_{\times}]A)^Tb\\
&=A^T[b_{\times}]^Tb\\
&=-A^T[b_{\times}]b\\
&=0
\end{aligned}\tag{6.35}</script><p>所以可通过(6.35)的线性方程组来求解出b</p>
<p>b为 $F^T$ 矩阵的最小奇异值的右奇异向量，且 $||b||=1$ 。</p>
<h5 id="c-计算A矩阵"><a href="#c-计算A矩阵" class="headerlink" title="c.计算A矩阵"></a>c.计算A矩阵</h5><p>直接定义：</p>
<script type="math/tex; mode=display">
A'=-[b_{\times}]F\tag{6.36}</script><p>下面来验证 $[b_{\times}]A’$ 是否等于 $F$ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\ [b_{\times}]A'&=-[b_\times][b_\times]F\\
&=-(bb^T-|b|^2I)F\\
&=-bb^TF+|b|^2F\\
&=-b(F^Tb)^T+|b|^2F\\
&=1\cdot F\\
&=F
\end{aligned}\tag{6.37}</script><p>所以可以得到：</p>
<script type="math/tex; mode=display">
A=A'=-[b_\times]F\tag{6.38}</script><p>最后我们就可以计算出两个投影矩阵了：</p>
<script type="math/tex; mode=display">
\widetilde{M}_{1}=\left[\begin{array}{ll}
I & 0
\end{array}\right] \quad \widetilde{M}_{2}=\left[-\left[b_{\times}\right] F \quad b\right]</script><blockquote>
<p>这里的b是有具体的几何含义的，在第四章3小节b中，基础矩阵的性质可知，$F^Te=0$ ，而这里的 $F^Tb=0$ ，所以b是一个极点。</p>
</blockquote>
<h5 id="d-代数法的问题"><a href="#d-代数法的问题" class="headerlink" title="d.代数法的问题"></a>d.代数法的问题</h5><p>在实际的应用中，我们拥有的是一个图像序列，我们需要在两两视图间进行求解，然后再将得到的结果累加，例如求得了 $M_1$ 和 $M_2$ ，然后再求 $M_2 \ and \ M_3$ 之间的关系，最后再进行累加得到 $M_1\ and \ M_3$ 的关系，这样一点一点累积，但凡每步都有一点点小误差，但当不断积累后，就会变成一个较大的误差。</p>
<h4 id="3-捆绑调整"><a href="#3-捆绑调整" class="headerlink" title="3.捆绑调整"></a>3.捆绑调整</h4><p>考虑到因式分解法和代数法的缺点，我们又提出了一种新的方法，捆绑法。</p>
<p>捆绑法主要采用非线性优化方法，通过最小化重投影误差，来优化得到 $X_j\ and\ M_i$ </p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015800.png" alt="image-20210829232507094"></p>
<p>最小化重投影误差：</p>
<script type="math/tex; mode=display">
E(M, X)=\sum_{i=1}^{m} \sum_{j=1}^{n} D\left(x_{i j}, M_{i} X_{j}\right)^{2}\tag{6.39}</script><p>我们可以使用牛顿法或列文伯格-马夸尔特方法来进行非线性优化。</p>
<p>该方法的优势是可以同时处理大量视图，处理丢失的数据。</p>
<p>但该方法的弊端也十分致命，就是需要优化的参数过多，所以需要良好的初始条件。</p>
<p>因此在实际的应用中，常用作结构恢复SFM(structure from motion)的最后一步，通过因式分解法或代数法来求的优化问题的初始解，然后在通过捆绑法进行优化。</p>
]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>单应矩阵</title>
    <url>/2021/10/18/%E5%8D%95%E5%BA%94%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>单应矩阵学习。<br><span id="more"></span></p>
]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>头文件 库文件 命名空间</title>
    <url>/2021/10/21/%E5%A4%B4%E6%96%87%E4%BB%B6-%E5%BA%93%E6%96%87%E4%BB%B6-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>介绍了头文件，库文件，命名空间之间的关系</p>
<span id="more"></span>
<p>头文件是一个文本文件。里面包括了变量声明，数据结构定义，库文件中函数的使用方法和接口(函数具体的实现都在库文件中)。<br>库文件是二进制文件。<br>命名空间是为了避免不同库中有命名相同的函数，相当于给这些函数加上了姓氏。</p>
<p>以C为例，最早的时候，只有一个C文件，然后需要编译为可执行的二进制文件。但是后来发现，实现复杂功能的时候，代码行数太多了，于是便把这个文件分割一下，分别来看。</p>
<p>于是，就把方法(函数)和声明单独放在同一个文件中，然后把这个文件加进来，放在头部，这样就可以在C文件中随意的摆放函数了，整理起来比较方便。久而久之，这个文件都是通常放在C文件的头部，因此就有了头文件的名字。头文件就是把一些常量的定义、数据结构的定义、函数的功能实现啥的放在里面，本质上就是一个文本文件，和写在C文件里是一样的，并没有什么特别的。<code>#include</code>进来的头文件都是原封不动的在编译阶段直接插入到C源文件中。</p>
<p>而库文件是已经编译好的二进制文件，因为没有<code>main()</code>这个入口函数，所以没有办法直接启动，但是里面是实实在在的二进制代码。那么它有什么用呢？</p>
<p>以前编译一个程序，就是输入C源文件，然后输出一个可执行的二进制文件。但是当C源文件的代码越写越多，越来越复杂，编译的时间特别长。这样一来，只要是修改了代码，就需要整体的重新编译一遍，消耗很多不必要的时间。于是人们为了避免反复的编译未改动的代码，就产生了库文件。</p>
<p>把一个完整的C文件分开，分成不同功能的文件，然后只要把这些文件编译成一个二进制的软件包，最后把它们拼在一起，就是库文件。这样一来基本不会被改动的代码就不需要再一次编译了，只需要编译改动的文件就可以啦。</p>
<p>库文件出现了，有的人灵光一闪，我可以只发布库文件啊，源代码还是在我这里，这样不就可以卖钱了吗？真是一个伟大的想法！但是光卖库文件不行啊，都被编译成二进制文件了，里面有哪些方法，有哪些常量别人没法知道啊！没关系我可以写文档啊。但是编译器不知道，而且也不懂读文档怎么办？好办，不是有头文件么，反正头文件只有声明，没有实现代码，就用头文件当编译器的文档好了。就这样人类读文档，编译器读头文件，然后有人卖库文件，一条产业链就此形成。</p>
<p>后来发现一个问题，有两个聪明人编写了两个库，两个库里面居然有相同的方法名称，这下编译器就糊涂了，后来发现一个问题，有两个聪明人编写了两个库，两个库里面居然有相同的方法名称，这下编译器就糊涂了，在自己写的库中，所有的函数名、常量名、解构名都带上自己的姓名做前缀名，这样就算方法名是一样的，但是有不同的前缀名，这样就能区分到底该链接哪个方法了。后来又来一个聪明人，觉得你们这样在每个方法、常量、结构体中都写上你们的姓名累不累啊，这样，我给你们设计一套规则，只要在库的最前面写上你们的姓名不就行了么，用的时候编译器先去找找你们的姓名，然后再你们的姓名下面找方法，这不就多快好省了么。那这样吧我们就给这个姓名取名字<code>namespace</code>吧。</p>
]]></content>
      <categories>
        <category>动手实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>极大似然估计和后验估计</title>
    <url>/2021/10/18/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E5%92%8C%E5%90%8E%E9%AA%8C%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<p>极大似然估计和后验估计。<br><span id="more"></span></p>
<h1 id="一、概率和统计的区别"><a href="#一、概率和统计的区别" class="headerlink" title="一、概率和统计的区别"></a>一、概率和统计的区别</h1><h2 id="1-概率研究"><a href="#1-概率研究" class="headerlink" title="1.概率研究"></a>1.概率研究</h2><p>已知一个模型和模型的参数，研究根据这个模型产生结果的概率和结果的一些特性（例如均值，方差等）</p>
<p>例子：以某地人口的身高统计研究为例，假设已经知道某地的人口的身高呈正态分布，因此根据该模型，可以知道该地人口身高的均值，方差等特点，也可以知道某人身高为1.9的概率</p>
<h2 id="2-统计研究"><a href="#2-统计研究" class="headerlink" title="2.统计研究"></a>2.统计研究</h2><p>统计研究与概率研究相反，是已知一组数据，但并不知道该模型和模型的具体参数</p>
<p>例子：已知某地一个小区的人口身高的数据，想要推测出该地整个人口身高分布的数学模型，假设已经知道该模型为正态分布，但不知道正态分布中具体的参数等信息，所以需要统计研究来得出</p>
<p>总结：概率研究是已知模型和参数，推数据。统计是已知数据，推模型和参数</p>
<h1 id="二、独立事件"><a href="#二、独立事件" class="headerlink" title="二、独立事件"></a>二、独立事件</h1><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032140.png" alt="image-20211008173107621" style="zoom:50%;" /></p>
<p>独立事件A和B，发生的概率为 $p(AB)=p(A)p(B)$</p>
<p>当A和B有某种关系的时候，也就是说不独立的时候，$p(AB)=p(A|B)p(B)$，可以根据此来判断AB是否独立</p>
<h1 id="三、极大似然估计和后验估计"><a href="#三、极大似然估计和后验估计" class="headerlink" title="三、极大似然估计和后验估计"></a>三、极大似然估计和后验估计</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><a href="https://zhuanlan.zhihu.com/p/32480810">参考</a></p>
<p>这两者都属于统计类别下的。对于统计估计出的模型参数$\theta$，有两个学派：</p>
<p><strong>频率学派</strong>：在进行参数估计时，所估计的参数$\theta$存在唯一的真值，也就是说$p(\theta)=1$。</p>
<p><strong>贝叶斯学派</strong>：认为$\theta$是一个随机变量，符合一定的概率分布，$p(\theta)$是有概率分布的。</p>
<p>抽象一点来讲，频率学派和贝叶斯学派对世界的认知有本质不同：频率学派认为世界是确定的，有一个本体，这个本体的真值是不变的，我们的目标就是要找到这个真值或真值所在的范围；而贝叶斯学派认为世界是不确定的，人们对世界先有一个预判，而后通过观测数据对这个预判做调整，我们的目标是要找到最优的描述这个世界的概率分布。</p>
<p>贝叶斯概率公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(A \mid B)&=\frac{P(A,B)}{P(B)}=\frac{P(B\mid A)P(A)}{P(A,B)+P(\tilde A,B)}\\
&=\frac{P(B\mid A)P(A)}{P(B\mid  A)P(A)+P(B\mid \tilde A)P(\tilde A)}
\end{aligned}\tag{1}</script><p><strong>E.g.</strong> 有一辆汽车，它被砸记作事件A，警报器响，记作事件B，现在想求得警报器响时，是车被砸的概率。那么，有以下几种表示：</p>
<ul>
<li>$P(A\mid B)$：在B发生时，A发生的概率。即警报器响了，是车被砸了的概率。</li>
<li>$P(A,B)$ ：A，B同时发生的概率。即警报器响和车被砸同时发生的概率。</li>
<li>$P(B\mid A)$ ：车被砸了，警报器响的概率。</li>
<li>$P(B\mid \tilde A)$ ：车没被砸，警报器响的概率。</li>
</ul>
<p>现在(1)式中，在警报响时，车被砸的概率=警报响与车被砸同时发生的概率 $\div$ 警报响的概率。</p>
<p>继续拆分：</p>
<p>警报响与车被砸同时发生的概率=车被砸的概率 $\times$ 车被砸时，警报响的概率。</p>
<p>警报响的概率=车被砸警报响的概率+车没被砸警报响的概率。</p>
<p><strong>在生活中为什么警报响了，通常是车没有被砸呢？</strong></p>
<p><strong>角度一：</strong></p>
<p>为了提高警报响时，就是车被砸了的说服力。我们希望警报响时，是车被砸的概率变为1。那么我们再看(1)，当 $P(B\mid \tilde A)P(\tilde A)=0$ 时，也就是车没被砸，警报响的概率为0。这样，我们就避免了干扰情况的影响，提高了说服力。但是，$P(B\mid \tilde A)P(\tilde A)=0$ 会等于0么。虽然车没被砸时，警报响的概率很小，但是车没有被砸的概率很大，接近于1，所以它们的乘积也不会太小。</p>
<p><strong>角度二：</strong></p>
<p>我们再来看式(1)，现在我们刨除其他的影响不说（例如，放炮导致的警报响），让其他影响的概率保持不变。来看分子，前面是车被砸时，警报响的概率。这个概率很大，我们可以认为其等于1，但是它还要乘以车被砸的概率，车被砸的概率很小很小，因此它们的乘积也很小。所以，即使是警报响了，车被砸的概率也会很小。在这里，车被砸的概率是<strong>先验</strong>。</p>
<p>从上面两个角度来看，其实就是$P(B\mid \tilde A)P(\tilde A)和P(B\mid  A)P(A)$ 间的比较，$P(B\mid A)$ 虽然很大，但是 $P(A)$ 很小；$P(B\mid \tilde A)$ 虽然很小，但是 $P(\tilde A)$ 很大。在这个例子中，就是 $P(B\mid \tilde A)比P(A)$ 胜了一筹，也就是车没被砸时警报响的概率比车被砸的大，才导致的即使警报响了，车被砸的概率也很小。</p>
<p>从以上两个角度，我们可以知道贝叶斯公式考虑事情发生的因素：一件本来就难以发生的事情，就算出现某个证据和它强烈相关，也要谨慎考虑（就是考虑这件事情本身的先验概率）。而一个不是那么相关，但是极其容易发生的事情，也需要考虑。</p>
<h2 id="2-似然函数"><a href="#2-似然函数" class="headerlink" title="2.似然函数"></a>2.似然函数</h2><p>对于 $P(X\mid \theta)$ 这个函数，它的输入有两个，分别是 $X和\theta$ 。</p>
<p>当 $\theta$ 已经确定，$X$ 是变量时，这个函数叫做概率函数，它描述对于不同的样本点$x$，其出现的概率为多少。</p>
<p>当 $X=x$ 时，$\theta$ 是变量时，这个函数就叫做似然函数，它描述对于不同的模型参数，出现$x$这个样本点的概率是多少。 </p>
<h2 id="3-最大似然估计——MLE"><a href="#3-最大似然估计——MLE" class="headerlink" title="3.最大似然估计——MLE"></a>3.最大似然估计——MLE</h2><p>最大似然估计是<strong>频率学派</strong>的方法，即认为参数 $\theta$ 是一个固定的常数。</p>
<p>假设数据 $x_1,x_2\cdots x_n$ 是独立同分布的一组样本，那么令 $X=\{x_1,\cdots x_n\}$ 。我们可以计算出出现这样样本的概率：</p>
<script type="math/tex; mode=display">
P(X,\theta)=P(X\mid\theta)P(\theta)\tag{2}</script><p>在(2)中，因为 $P(\theta)=1$ ，所以：</p>
<script type="math/tex; mode=display">
P(X,\theta)=P(X\mid\theta)\tag{3}</script><p>我们就可以假设我们已经知道了 $\theta$ ，然后求出在该概率模型参数下，出现此时样本的概率，这个概率是 $\theta$ 的函数。因为既然能出现此时的</p>
<p>样本情况，那么概率函数应该是最大值，所以 $\theta$ 是极大值点。</p>
<script type="math/tex; mode=display">
\hat \theta=\max _\theta P(X\mid\theta)\tag{4}</script><p> <strong>E.g.</strong> 我们现在有一个硬币，这个硬币服从二项分布，我们设正面朝上的概率为 $\theta$ 。现在想通过试验来求出硬币的正面朝上的概率为多少。假设我们做了一组试验，扔了10次，其中正面朝上的次数为7。</p>
<script type="math/tex; mode=display">
P(X=\{7次正，3次反\},\theta)=P(X\mid\theta)=\theta^7(1-\theta)^3=f(\theta)\tag{5}</script><p>现在既然出现了7次正面向上，3次反面向上的数据样本，我们就可以认为此时的概率一定是所有情况中最大的。我们可以把似然函数$f(\theta)$ 的图像画出来：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032227.png" alt="image-20211009211806463" style="zoom:50%;" /></p>
<p>可以看出 $\theta=0.7$ 时，似然函数取极大值。但是我们知道，一般的硬币都是均匀分布的，为什么正面朝上的概率会是0.7呢。这就包含了贝叶斯学派的思想，即引入先验估计。</p>
<h2 id="4-最大后验估计——MAP"><a href="#4-最大后验估计——MAP" class="headerlink" title="4.最大后验估计——MAP"></a>4.最大后验估计——MAP</h2><p>最大后验估计是贝叶斯学派的方法，他们认为参数 $\theta$ 是不确定的，也是一个随机变量。需要求出在该样本情况下，参数的概率分布，然后选取概率最大的样本点。</p>
<script type="math/tex; mode=display">
P(\theta\mid X)=\frac{P(X,\theta)}{P(X)}=\frac{P(X\mid\theta)P(\theta)}{P(X)}\tag{6}</script><p>式（6）中，$P(\theta\mid X)$ 是后验估计，实际上我们的目标就是找到 $\theta$ ，让它最大。$P(\theta)$ 是先验估计。$P(X)$ 是试验得到的概率，仅与试验结果有关，当我们已经获取试验结果后，可以认为它是一个常数。</p>
<script type="math/tex; mode=display">
\hat\theta=\max_\theta P(\theta \mid X)=\max_\theta P(X\mid\theta)P(\theta)\tag{7}</script><p>最大后验的思想是不仅仅需要似然函数最大，也需要先验的概率很大。</p>
<p>同样是抛硬币的例子：</p>
<p>我们先验的知道正面朝上的概率为0.5，因此认为 $\theta$ 服从均值为0.5，方差为1的正态分布。</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X,\theta)&=P(X\mid\theta)P(\theta)\\
&=f(\theta)P(\theta)
\end{aligned}\tag{8}</script><p>图像为：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032233.png" alt="image-20211009220826964" style="zoom:50%;" /></p>
<p>此时 $\theta$ 已经向左偏移，为0.558。即用最大后验估计，得到的结果。</p>
<p>当试验次数为1000次，其中正面朝上的次数为700次时，$f(\theta)P(\theta)$ 的图像为：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215032237.png" alt="image-20211009221159457" style="zoom:50%;" /></p>
<p>此时 $\theta=0.696$ 。</p>
<p>从这个例子可以知道：当数据量增大时，估计的参数分布会越来越向数据靠拢，先验的影响力会越来越小。</p>
]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数可视化学习笔记</title>
    <url>/2021/10/18/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>3Blue1Brown 线代课程学习笔记，受益匪浅。<br><span id="more"></span></p>
<h1 id="线性代数可视化"><a href="#线性代数可视化" class="headerlink" title="线性代数可视化"></a>线性代数可视化</h1><p><a href="https://www.bilibili.com/video/BV1ib411t7YR?p=1">参考</a></p>
<h2 id="1-向量是什么"><a href="#1-向量是什么" class="headerlink" title="1.向量是什么"></a>1.向量是什么</h2><p>对于向量的理解，可以分为三个层面：</p>
<ul>
<li><p><strong>物理学家眼中</strong>：向量是一个空间中箭头，它只包括长度和方向两个信息，而与其所在的空间位置无关</p>
</li>
<li><p><strong>计算机专业眼中</strong>：向量是一个有序数组，这个有序数组可以表示物理学家眼中的向量在空间中的坐标，而且这个向量通常是以坐标系原点为起点的。为了区分于点的坐标，向量通常竖着写</p>
</li>
<li><p><strong>数学家眼中</strong>：向量可以是任何东西，只要能保证两个向量相加和数与向量相乘满足一定的条件即可</p>
</li>
</ul>
<p>通过建立坐标系，可以使一个向量与有序的数组相联系，每一个数组对应一个向量，每一个向量也可以用数组来表示，这就为物理学家在描述向量时提供了一种数学语言</p>
<p><strong>向量两个最基本的运算：</strong></p>
<ul>
<li><p>向量加法：遵循三角形法则 $\longrightarrow$ 用数组描述的向量通过对应元素相加可以很好的描述该法则</p>
</li>
<li><p>向量的数乘：表示对向量的伸长与缩短 </p>
</li>
</ul>
<h2 id="2-线性组合、基与张成空间"><a href="#2-线性组合、基与张成空间" class="headerlink" title="2.线性组合、基与张成空间"></a>2.线性组合、基与张成空间</h2><p>在标准的坐标系中，有两个特殊的向量，单位向量 $\hat i$ 和 $\hat j$ ，对于多维空间也同样。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015953.png" alt="image-20210715005154764" style="zoom:67%;" /></p>
<p>它们合起来称作坐标系的基，当把坐标中的每一个元素看作是标量时，每一个基向量就是这些标量所缩放的向量</p>
<h3 id="·-什么是线性组合"><a href="#·-什么是线性组合" class="headerlink" title="· 什么是线性组合"></a>· 什么是线性组合</h3><p>多个向量的数乘之和称为这些向量的线性组合</p>
<h3 id="·-向量张成的空间"><a href="#·-向量张成的空间" class="headerlink" title="· 向量张成的空间"></a>· 向量张成的空间</h3><p>给定一组向量，通过该组向量的线性组合生成的<strong>向量的集合</strong>，称为该组向量==张成的空间==</p>
<p>以二维空间为例，给定向量 $\vec w$ 和 $\vec v$ ，有以下三种情况：</p>
<ol>
<li><p>当$\vec w$ 和 $\vec v$ 不共线时，所张成的空间为二维平面，也就是二维空间中的任意向量都可以由这两个向量的线性组合得到</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216015958.png" alt="image-20210715035555651" style="zoom: 33%;" /></p>
</li>
<li><p>当$\vec w$ 和 $\vec v$ 共线时，所张成的空间为一条直线，仅能表示终点在该直线上的向量</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020002.png" alt="image-20210715040223112" style="zoom:50%;" /></p>
</li>
<li><p>当$\vec w$ 和 $\vec v$ 都为0向量时，所张成的空间为一点，仅能表示0向量</p>
</li>
</ol>
<p><strong>同样对于我们常用的三维空间，当仅有两个不共面的向量时，这两个向量所张成的空间为一个平面</strong></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020007.png" alt="image-20210715040537951" style="zoom: 20%;" /></p>
<h3 id="·-线性相关与线性无关"><a href="#·-线性相关与线性无关" class="headerlink" title="· 线性相关与线性无关"></a>· 线性相关与线性无关</h3><p>从上面的表述中，便可以得到<strong>线性相关</strong>的定义：当一组向量中，其中一个向量处在其他向量所张成的空间中（这个向量可以由其他的向量线性组合表示出来），那么这一组向量就是线性相关的</p>
<p>而<strong>线性无关</strong>的定义与它正好相反：一组向量中，任何一个向量都不处在其他向量所张成的空间中（任何一个向量不可以由其他向量线性组合表示出来）</p>
<h3 id="·-空间中的一组基"><a href="#·-空间中的一组基" class="headerlink" title="· 空间中的一组基"></a>· 空间中的一组基</h3><p>某向量空间的一组基是张成该空间的一个线性无关的向量集合</p>
<h2 id="3-矩阵与线性变换"><a href="#3-矩阵与线性变换" class="headerlink" title="3.矩阵与线性变换"></a>3.矩阵与线性变换</h2><h3 id="·-首先需要知道的"><a href="#·-首先需要知道的" class="headerlink" title="· 首先需要知道的"></a>· 首先需要知道的</h3><p>我们之前所说向量的时候，当有基向量存在时，可以用一个数组也就是坐标来表示一个向量，现在我们定义一个永远不变的坐标系和基向量，这个坐标系的x轴和y轴垂直，且基向量是与x轴和y轴正方向相同的单位向量，暂且我们就称坐标系和基向量为<strong>永不变坐标系和永不变基向量</strong>，之后的所有向量或坐标系的基的描述都是在这个永不变基的基础上进行的</p>
<h3 id="·-线性变换"><a href="#·-线性变换" class="headerlink" title="· 线性变换"></a>· 线性变换</h3><p>变换实际上是函数的另一种说法，函数的作用是输入一个数，输出一个数；在线性代数中，变换的输入是一个向量，输出也是一个向量</p>
<p><strong>线性变换</strong>是变换的一种特殊形式，它有两个特点：</p>
<ul>
<li><p>直线在线性变换后，仍是直线</p>
</li>
<li><p>原点必须保持不变</p>
</li>
</ul>
<p>那么如何用数学语言来描述线性变换呢？答案就是用矩阵来描述</p>
<h3 id="·-矩阵"><a href="#·-矩阵" class="headerlink" title="· 矩阵"></a>· 矩阵</h3><p>矩阵就是一种数学语言，来描述线性变换，矩阵的每一列记录基向量在线性变换后的坐标</p>
<p>以二维空间为例：</p>
<script type="math/tex; mode=display">
\vec v = -1\vec i + 2\vec j\\
Transformed \ \vec v=-1(Transformed \ \vec i)+2(Transformed\ \vec j)</script><p>当经过一次线性变换后，如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020013.png" alt="image-20210715034732752" style="zoom:67%;" /></p>
<script type="math/tex; mode=display">
[Transformed\ \vec i ,Transformed\ \vec j]=\left[\begin{array}{ll}
3 & 1 \\
0 & 2
\end{array}\right]</script><script type="math/tex; mode=display">
Transformed\ \vec v=
-1\left[\begin{array}{l}
3 \\
0
\end{array}\right]+2\left[\begin{array}{l}
1 \\
2
\end{array}\right]=\left[\begin{array}{ll}
3&1\\
0&2
\end{array}\right]\left[\begin{array}{l}
\ -1\\
\  \ 2\end{array}\right]
=\left[\begin{array}{l}
-1  \\
\ \ 4 
\end{array}\right]</script><p><strong>这也就定义了矩阵和向量的乘法</strong>，矩阵乘以向量，就是对该向量的一个线性变换</p>
<p>当变换后的两个基向量线性相关时，由这两个向量所张成的空间就变成了一条线，而原来的向量就被变换到这个空间上，也就是变换后的向量的终点在一条直线上</p>
<blockquote>
<p>总之，线性变换就是对向量的变换，对向量的变换的方法是对描述该向量的基进行变换，因此线性变换也是操纵空间的一种手段</p>
</blockquote>
<p>那么当有许多个矩阵乘以一个向量的时候，它的几何意义又是什么呢？</p>
<h3 id="·-复合变换与矩阵乘法"><a href="#·-复合变换与矩阵乘法" class="headerlink" title="· 复合变换与矩阵乘法"></a>· 复合变换与矩阵乘法</h3><p>矩阵A、B分别代表着线性变换1和2，AB代表着先进行线性变换2，然后再进行线性变换1（注意这里是先2后1），令AB=C，那么C就代表着先进行2再进行1的一个复合变换，也可以把C当作是一次独立的变换，它的效果和先2再1的效果相同</p>
<p>另外，AB $\neq$ BA，也就是说先进行2再进行1和先进行1再进行2的效果是不同的</p>
<blockquote>
<p>前面所说的线性变换理解成是一个处理向量的函数，现在从另一个角度来总结一下，线性变换用矩阵来描述，而矩阵的列向量表示线性变换后基向量的坐标，对一个向量进行线性变换，就是先对基向量进行线性变换，然后用这个向量的坐标对变换后的基向量进行线性组合，最终得到变换后的向量。因为基向量可以描述一个空间，因此基向量变了，其所对应的空间也发生了变化</p>
</blockquote>
<h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4.行列式"></a>4.行列式</h2><p>上节说过，线性变换是操纵空间的一种手段，那么如何刻画空间变化了多少呢，这就需要请出行列式了，行列式就是用来描述空间变化的多少</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020020.png" alt="image-20210715053137633" style="zoom:53%;" /></p>
<p>下面以二维空间为例：</p>
<p>我们在坐标系中用网格线来描述这个空间的形态，在标准坐标系中，绿色箭头代表i向量，红色箭头代表j向量，此时向量i和j所围成的区域是一个正方形，其面积为1</p>
<p>当进行线性变换后，基向量的方向和长度都发生了变化，如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020024.png" alt="image-20210715053620420" style="zoom:50%;" /></p>
<p>那么此时由基向量i和j所围成的区域也发生了变化，变成了一个平行四边形，而该区域的面积等于矩阵的行列式</p>
<blockquote>
<p>矩阵的行列式是描述其线性变换所对空间变化的量度</p>
</blockquote>
<p>当行列式为0时，表示这个平面被压缩成了一条线，<strong>而0矩阵表示把平面压缩成一个点</strong></p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020028.png" alt="image-20210715054036323" style="zoom:50%;" /></p>
<p>当行列式为负时，表示这个平面发生了反转</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020030.png" alt="image-20210715054301501" style="zoom:50%;" /></p>
<p>注意：原来绿色的基向量在红色基向量的右边，此时发生了平面翻转</p>
<p>三维空间中，矩阵的行列式表示变换后基向量所围成空间区域的体积，当行列式为0时，表示该变换将三维空间压缩成一个平面或一条直线又或是一个点（这在后面会引出秩的用法）。更多维空间的道理是一样的，这里就不过多赘述</p>
<h2 id="5-逆矩阵、列空间、秩和零空间"><a href="#5-逆矩阵、列空间、秩和零空间" class="headerlink" title="5.逆矩阵、列空间、秩和零空间"></a>5.逆矩阵、列空间、秩和零空间</h2><p>线性代数的用处很多，其中的一个用处是解线性方程组</p>
<p>方程组的求解和之前所讲的行列式和矩阵以及线性变换密切相关</p>
<p>例如我们现在有一个方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
1x+2y+3z=5\\
3x+8y+7z=6\\
0x+3y+6z=0
\end{cases}</script><p>这是一个三阶线性方程组，因为它与矩阵和向量的乘法很像，所以可以写成矩阵的形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
1&2&3\\
3&8&7\\
0&3&6
\end{array}\right]
\left[\begin{array}{l}
x\\
y\\
z
\end{array}\right]=\left[\begin{array}{l}
5\\
6\\
0
\end{array}\right]</script><p>即：</p>
<script type="math/tex; mode=display">
A\vec x=\vec v</script><p>上述式子已知 $\vec v$ ，A矩阵表示一个线性变换，如若求 $\vec x$ ,则只需将A矩阵所表示的线性变换的逆变换作用到 $\vec v$ 上，那么是不是什么时候都可以用这种方法呢？</p>
<h3 id="·矩阵的逆"><a href="#·矩阵的逆" class="headerlink" title="·矩阵的逆"></a>·矩阵的逆</h3><p>矩阵的逆表示矩阵线性变换所对应的逆变换，如果矩阵A的行列式不等于0，那么矩阵A是可逆的</p>
<p>之前的方程组的解为： $\vec x = A^{-1}\vec v$</p>
<p>上面说到矩阵的逆表示逆变换，所以当进行一次变换再进行一次逆变换等同于没有变化</p>
<script type="math/tex; mode=display">
A^{-1}A=AA^{-1}=I</script><p><strong>但是当矩阵的行列式为0时</strong>，矩阵的逆不存在。背后的几何意义是线性变换将多维空间变换为低维空间，如果想找到<strong>一个</strong>低维空间还原成高维空间的逆变换，是得不到一个确定的变换的，因为有一维或多维的缺失，所以这个变换可以有任意多种形式</p>
<p>再回到我们的方程组，当矩阵的行列式为0时，解是可能存在的，这分为两种情况：</p>
<ul>
<li>一种是当 $\vec v$ 向量在A所压缩的空间上时，解存在</li>
<li>另一种是 $\vec v$ 向量在A所压缩的空间外时，无解</li>
</ul>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020036.png" alt="image-20210715085801043" style="zoom: 33%;" /></p>
<h3 id="·矩阵的秩"><a href="#·矩阵的秩" class="headerlink" title="·矩阵的秩"></a>·矩阵的秩</h3><p>可以发现，虽然原空间通过变换后，变成一个低维的空间，此时都会有无解的情况发生，但无解情况的出现的难易程度是不一样的。例如当三维空间变换成二维空间时，是一个平面，只要 $\vec v$ 在这个平面上，解存在。但是当变换成一维空间也就是一条线时，只有 $\vec v$ 在这条线上时，解存在。虽然上面两种情况的A矩阵的行列式都为0，但是它们出现无解的情况是不同的，这时就要引出秩的概念</p>
<p><strong>秩</strong>表示变换后空间的维数，例如三维矩阵的秩最大为3，它表示基向量可以张成整个三维空间，但是当矩阵的秩为2时，空间被压缩了，此时表示基向量只能张成二维空间，但是它没有秩为1的压缩情况严重</p>
<h3 id="·列空间"><a href="#·列空间" class="headerlink" title="·列空间"></a>·列空间</h3><p>矩阵的列向量所张成的空间即为列空间，当 $ \vec x$ 表示任意的向量时，$A\vec x$ 就是矩阵A的列空间</p>
<p>关于秩更准确的定义：矩阵秩表示矩阵列空间的维数</p>
<p><strong>当秩等于矩阵的列时，意味着它达到了它所能达到的最大值，此时叫作满秩</strong></p>
<p>0向量一定包含在列空间中，因为线性变换不改变原点的位置，也就是 $A\vec0=\vec 0$ </p>
<p>对于一个满秩变换来说，唯一能在变换后落在原点的向量就是0向量本身。但是对于一个非满秩的矩阵，它将空间压缩到一个低维的空间，也就是说有一系列向量在变换后被压缩到原点。例如对于原二维的空间，当进行压缩到一维空间的变换时，会使原二维空间中某一方向直线上的所有的向量都压缩到原点。再如原三维空间，压缩到一个二维空间时，也会使原三维空间中某一方向直线上所有的向量压缩到原点，当压缩到一个一维空间时，会使原三维空间中过原点的某一平面上的所有向量压缩到原点。</p>
<h3 id="·零空间-核空间"><a href="#·零空间-核空间" class="headerlink" title="·零空间/核空间"></a>·零空间/核空间</h3><p>变换后被压缩到原点的向量的集合，叫作矩阵的零空间或者核空间</p>
<p>==被压缩空间的维数==就是零空间的维数。例如三维空间中的一个向量经过一个方阵的线性变换后，被限制在二维平面上，那么该方阵的零空间维数为1，如果是将该向量变换成一个点，那么该方阵的零空间维数为2。零空间的维数就是表示方阵可以将几维的空间压缩到原点。也可以看作是方程 $A\vec x =0$​​​的解的情况，首先A得为方阵，当A的零空间为0时，也就是A满秩，那么只有零向量是该方程的解。如果A的零空间为2时，那么解向量的维数为2。</p>
<h3 id="·非方阵"><a href="#·非方阵" class="headerlink" title="·非方阵"></a>·非方阵</h3><p>非方阵的几何意义和之前的方阵稍稍有些不同，先来说之前的方阵，方阵表示将一个向量进行变换，这些变换有旋转这个向量，拉伸压缩这个向量，无论怎么变换这个向量，这个向量都处于原空间中，即变换前是一个n维的向量，变换后还是n维的向量。举一个例子，对于三维空间中的一个向量，当矩阵A的秩为2时，表示将这个向量压缩到一个二维的平面中，尽管是压缩到二维平面中，只是把这个向量限制在二维平面上，但这个向量仍是三维空间中的向量。</p>
<p>而非方阵就得用另一种方式来描述，和之前所提及的函数一样，非方阵可以看作是一个映射，输入一个m维的向量，映射出一个n维的向量，这两个向量分别处于不同的空间中。</p>
<p>例如一个矩阵为 $m\times n$ 维，那么它表示将一个n维空间中的向量映射到m维空间中，矩阵的列向量同样是原空间中的基向量在新空间中的映射</p>
<blockquote>
<p>小结：方阵表示线性变换，指在原有空间中对向量进行变换；非方阵表示线性映射，把原空间中的向量映射到一个新的空间中</p>
</blockquote>
<h2 id="6-向量的点积"><a href="#6-向量的点积" class="headerlink" title="6.向量的点积"></a>6.向量的点积</h2><h3 id="·向量点积的几何意义"><a href="#·向量点积的几何意义" class="headerlink" title="·向量点积的几何意义"></a>·向量点积的几何意义</h3><p>有两个向量 $\vec v$ 和 $\vec w$ ，点积的几何意义表示 $\vec v$ 在 $\vec w$ 方向上的投影的长度和 $\vec w$长度的乘积</p>
<p>点积的结果和向量的顺序无关，即$\vec v ·\vec w=\vec w·\vec v$ </p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020043.png" alt="image-20210716055411474" style="zoom:33%;" /></p>
<p>利用对称性，可以直观证明上述结论，令 $\vec v$ 和 $\vec w$ 的长度相同，根据对称性可以知道， $\vec v$ 在 $\vec w$ 上的投影长度与 $\vec w $  在 $\vec v$ 上的投影长度相同。当 $ \vec v$ 放大两倍后，这种对称性就不再存在了，但此时 $\vec w$ 在 $2\vec v$ 上的投影不变，也可以说  $2\vec v$ 在 $\vec w$ 上的投影长度变为原来的2倍，所以 $(2\vec v)·\vec w=\vec w·(2\vec v)$ </p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020049.png" alt="image-20210716055903784"></p>
<h3 id="·向量点积的矩阵表示"><a href="#·向量点积的矩阵表示" class="headerlink" title="·向量点积的矩阵表示"></a>·向量点积的矩阵表示</h3><p>如果把一个向量当成一个 $n\times1$ 的矩阵来看时，那么对向量的转置就得到了一个 $1\times n$的矩阵，向量的点积可以用向量的转置乘以向量来计算</p>
<p><strong>那么为什么可以这样计算呢？</strong>首先可以想到，既然转置是一个矩阵，就可以表示一个线性变换了，这个线性变换的几何意义就是把多维空间中的向量映射到一个一维空间上。经过映射得到的一维向量是一个数，它表示在多维空间中的一个向量在某一方向上的投影长度。</p>
<p>现在以二维空间为例：</p>
<p>在二维空间中有一单位向量 $\vec u$ ，在该向量的方向上布置一个数轴，这个数轴也就是一个一维空间。如果想把 $\vec u$ ==映射==到这个一维空间中，则需要找到二维空间的基向量在这个一维空间上的位置，我们用投影位置来表示基向量在一维空间上的位置，如下图所示：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020055.png" alt="image-20210716092117757"></p>
<p>根据投影关系和对称关系，可以得到二维空间中的基向量 $\vec i 和 \vec j$ 在一维空间的位置</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020101.png" alt="image-20210716092532170"></p>
<p>则$\vec i 和 \vec j$在一维空间的坐标为：</p>
<script type="math/tex; mode=display">
[u_x \ u_y]</script><p>对于二维空间中任意的向量在这个轴上的投影，可以用这个矩阵乘以向量的坐标来得到</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020106.png" alt="image-20210716092801428"></p>
<p>最终得到的结果为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
u_{x} & u_{y}
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]=u_{x} \cdot x+u_{y} \cdot y</script><p>这与这个任意向量和 $\vec u$ 的点积完全相同</p>
<blockquote>
<p>总结：为什么点积可以用向量的转置乘以向量？向量的转置表示一个矩阵，这个矩阵又代表着一个线性变换，这个线性变换就表示把一个多维空间的向量==投影==到一个一维空间中。</p>
</blockquote>
<p>当 $\vec v=k\vec u$ 是任意的向量时</p>
<script type="math/tex; mode=display">
k\left[\begin{array}{ll}u_{x} & u_{y}\end{array}\right]\left[\begin{array}{l}x \\
y\end{array}\right]=\left[\begin{array}{ll}ku_{x} & ku_{y}\end{array}\right]\left[\begin{array}{l}x \\
y\end{array}\right]=ku_{x} \cdot x+ku_{y} \cdot y</script><p>两个任意向量的点积表示先将一个向量投影到另一向量所在的方向上，然后将投影长度和另一向量的长度相乘</p>
<h2 id="7-向量的叉积"><a href="#7-向量的叉积" class="headerlink" title="7.向量的叉积"></a>7.向量的叉积</h2><h3 id="·什么是叉积"><a href="#·什么是叉积" class="headerlink" title="·什么是叉积"></a>·什么是叉积</h3><p>两个向量的叉积会产生一个与这两个向量都垂直的新向量，并且其长度等于这两个向量所围成的四边形的面积，而且它们的方向满足右手定则。</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020113.png" alt="image-20210716095942997"></p>
<p>既然是表示面积，这就与之前说过的行列式有关系，但这只对二维向量成立（因为只有两个向量，只有二维向量才能满足方阵，才有行列式）</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020117.png" alt="image-20210716095517110"></p>
<p>两个向量所组成的矩阵对应着一个线性变换，线性变换的度量就是矩阵的行列式，也就是基向量所围成的四边形面积</p>
<h3 id="·关于三维空间中的叉积的计算"><a href="#·关于三维空间中的叉积的计算" class="headerlink" title="·关于三维空间中的叉积的计算"></a>·关于三维空间中的叉积的计算</h3><p>对于三维空间中的叉积，可以用下面的计算公式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
v_{1} \\
v_{2} \\
v_{3}
\end{array}\right] \times\left[\begin{array}{l}
w_{1} \\
w_{2} \\
w_{3}
\end{array}\right]=\operatorname{det}\left(\left[\begin{array}{ccc}
\vec{\imath} & v_{1} & w_{1} \\
\vec{\jmath} & v_{2} & w_{2} \\
\vec{k} & v_{3} & w_{3}
\end{array}\right]\right)</script><p>现在就来说明一下为什么可以用这个公式来计算叉积</p>
<p>由第4节可知，矩阵的行列式表示列向量所张成的平行六面体的体积，而上面行列式的第一列不是一个向量，而是三个基向量，下面先来定义一个线性映射 $L(\vec a)$</p>
<script type="math/tex; mode=display">
L(\vec a)=\operatorname{\det}\left(\left[\begin{array}{c}
{x} & v_{1} & w_{1} \\
{y} & v_{2} & w_{2} \\
{z} & v_{3} & w_{3}
\end{array}\right]\right)\quad(\vec a=\left[\begin{array}{l}\ x\\
y\\
z\end{array}\right])</script><p>这个线性映射将一个三维向量映射到一维空间中，表示一个数，于是可以写成这种形式：</p>
<script type="math/tex; mode=display">
L(\vec a)=[\begin{array}{}p_1&p_2&p_3\end{array}]\cdot\left[\begin{array}{}x\\
y\\
z\end{array}\right]=\operatorname{det}\left(\left[\begin{array}{ccc}
{x} & v_{1} & w_{1} \\
{y} & v_{2} & w_{2} \\
{z} & v_{3} & w_{3}
\end{array}\right]\right)</script><p>于是展开有：</p>
<script type="math/tex; mode=display">
\begin{array}{r}
\quad x\left(v_{2} \cdot w_{3}-v_{3} \cdot w_{2}\right)+ \\
p_{1} \cdot x+p_{2} \cdot y+p_{3} \cdot z=y\left(v_{3} \cdot w_{1}-v_{1} \cdot w_{3}\right)+ \\
z\left(v_{1} \cdot w_{2}-v_{2} \cdot w_{1}\right)
\end{array}</script><p>即：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&p_{1}=v_{2} \cdot w_{3}-v_{3} \cdot w_{2} \\
&p_{2}=v_{3} \cdot w_{1}-v_{1} \cdot w_{3} \\
&p_{3}=v_{1} \cdot w_{2}-v_{2} \cdot w_{1}
\end{aligned}</script><p>现在用 $\vec p=[p_1\ p_2\ p_3]^T$，然后来谈几何意义</p>
<p>行列式表示三个列向量所张成的平行六面体的体积，而 $\vec p$ 和 $\vec a$ 的点积就等于这个体积，那么 $\vec p$ 是一个什么向量才能满足它们两个的点积等于体积呢。对于$\vec a$来说，它是任意一个向量，而 $\vec v$ 和 $\vec w$ 向量是固定的，平行六面体的体积等于面积乘以高，也就是说，当面积确定后，只需要知道高就可以了</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020123.png" alt="image-20210716111418718"></p>
<p>这个高就是 $\vec a$ 在垂直于 $\vec v$ 和 $\vec w$ 的方向上的投影，于是现在就可以知道 $\vec p$ 的意义了，$\vec p$ 的方向垂直于$\vec v$ 和 $\vec w$ ，它的长度是$\vec v$ 和 $\vec w$ 所张成平行四边形的面积</p>
<h2 id="8-基变换"><a href="#8-基变换" class="headerlink" title="8.基变换"></a>8.基变换</h2><p>现在有两个二维世界中的人，猪猪侠和包包侠，在猪猪侠的世界中，基向量是这样的：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020127.png" alt="image-20210716112957364"></p>
<p>在包包侠的世界中，基向量是这样的：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020130.png" alt="image-20210716114150696"></p>
<p>当有同一个向量时，在两个人的眼中，描述是不同的</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020134.png" alt="image-20210716114326652"></p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
\vec{e}_{i} & \vec{e}_{j}
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\vec{e}_{i}^{\prime}\ \ \ \  \ \vec{e}_{j}^{\prime}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]</script><p>现在包包侠把她所看到的向量的坐标告诉猪猪侠，那么猪猪侠必须要先知道包包侠的基向量在猪猪侠的基向量下的坐标，然后才能知道</p>
<p>于是包包侠的两个基向量在猪猪侠的基向量下的坐标为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{}a&b\\
c&d\end{array}\right]</script><p>所以猪猪侠就知道了这个向量在他的基下的坐标：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\begin{array}{}a&b\\
c&d\end{array}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]=A\vec v^{\prime}</script><p>同理猪猪侠把这个他看到的向量的坐标告诉包包侠，包包侠也得转化到自己的基下来，即：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]
=\left[\begin{array}{}a&b\\
c&d\end{array}\right]^{-1}\left[\begin{array}{l}
x \\
y
\end{array}\right]=A^{-1}\vec v</script><p>现在猪猪侠想把这个向量变一变，比如旋转个90度，于是他用自己世界的基来描述变化后空间的位置，也就是新的坐标轴上单位向量的坐标为：</p>
<script type="math/tex; mode=display">
M=\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]</script><p>于是变化后向量的坐标为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{new} \\
y_{new}
\end{array}\right]=\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]</script><p>现在包包侠也同样想把这个向量变一下，变得和猪猪侠一样，此时她直接乘以猪猪侠的M矩阵是不可以的，因为M是在猪猪侠的基上得到的，她想了一个好办法：</p>
<ul>
<li>她先把想变化的向量告诉猪猪侠，猪猪侠在自己的基下把这个向量表示出来</li>
<li>然后猪猪侠去变，乘以M矩阵</li>
<li>然后她再将猪猪侠变化后的向量换到自己的基下表示</li>
</ul>
<p>上述的过程就用下面的公式来表示：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x_{new}^{\prime} \\
y_{new}^{\prime}
\end{array}\right]=\left[\begin{array}{}a&b\\
c&d\end{array}\right]^{-1}\left[\begin{array}{}
m_1&m_2\\
m_3&m_4
\end{array}\right]\left[\begin{array}{}a&b\\
c&d\end{array}\right]\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]=A^{-1}MA\vec v^{\prime}</script><h2 id="9-特征值和特征向量"><a href="#9-特征值和特征向量" class="headerlink" title="9.特征值和特征向量"></a>9.特征值和特征向量</h2><h3 id="·特征向量"><a href="#·特征向量" class="headerlink" title="·特征向量"></a>·特征向量</h3><p>矩阵乘以一个向量表示对这个向量的线性变换，以二维空间为例：</p>
<p>一个向量所张成的空间，就是这个向量所在的直线，当这个向量被变换后，很可能会离开这个空间，如下图所示</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020142.png" alt="image-20210716121344977"></p>
<p>但是也会有一些向量，没有离开它本身的张成空间，线性变换只是对它进行了拉伸或压缩，此时矩阵的作用如同一个标量</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020148.png" alt="image-20210716121501072"></p>
<p>这两个方向空间中的向量都不会偏离其原来所在的直线，而其他向量都会发生偏转</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020153.png" alt="image-20210716121716491"></p>
<p>这些不发生偏转的向量就叫作特征向量</p>
<h3 id="·特征值"><a href="#·特征值" class="headerlink" title="·特征值"></a>·特征值</h3><p>每一个特征向量都有一个与其对应的特征值，特征值表征这个向量空间上的向量被拉伸和压缩多少</p>
<p>那么特征向量有啥用呢？</p>
<p>考虑一个三维旋转的线性变换，当找到了它的特征向量，就找到了它的旋转轴</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020159.png" alt="image-20210716122229199"></p>
<p>当特征值为0时，表示没有特征向量 </p>
<h2 id="10-抽象向量空间"><a href="#10-抽象向量空间" class="headerlink" title="10.抽象向量空间"></a>10.抽象向量空间</h2><p>无论是什么东西，只要符合以下八条公理，那么这个东西就可以称作向量，它遵循着之前讲过的所用性质</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216020203.png" alt="image-20210716125152513"></p>
<blockquote>
<p>任意向量都能表达为基向量以某种方式进行线性组合，所以求一个向量变换后的结果，就是求变换后基向量以相同方式进行线性组合的结果</p>
</blockquote>
]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮机器视觉学习笔记</title>
    <url>/2021/10/18/%E5%8C%97%E9%82%AE%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习北邮鲁鹏老师《机器视觉》课程笔记。<br><span id="more"></span></p>
<h1 id="0-绪论"><a href="#0-绪论" class="headerlink" title="0.绪论"></a>0.绪论</h1><h2 id="0-1课程介绍"><a href="#0-1课程介绍" class="headerlink" title="0.1课程介绍"></a>0.1课程介绍</h2><p>本课程是斯坦福大学的课程，鲁鹏老师搬运发扬光大。北邮的计算机视觉有研究生和本科两版，本笔记是研究生版。</p>
<p><strong>CS131:Computer Vision:Foundations and Applications</strong></p>
<p>主要介绍了计算机视觉的基础（2012年之前的基础技术方法思路）对应的是北邮本科生的机器视觉课程。</p>
<p><strong>CS231a:Computer Vision,from 3D Reconstruction, segmentation, object recognition</strong></p>
<p>本课程主要介绍了三维重建的相关内容。</p>
<p><strong>CS230:Deep Learning</strong></p>
<p>吴恩达教授的深度学习课程。</p>
<p><strong>CS231n:Convolutional Neural NetWorks for Visual Recognition</strong></p>
<p>2012年以后以卷积神经网络为主的计算机视觉技术，也就是本课程的来源。</p>
<p>本课程具体内容：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000408.png" alt="image-20210914030924958" style="zoom: 67%;" /></p>
<h2 id="0-2什么是计算机视觉和机器视觉"><a href="#0-2什么是计算机视觉和机器视觉" class="headerlink" title="0.2什么是计算机视觉和机器视觉"></a>0.2什么是计算机视觉和机器视觉</h2><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000412.png" alt="image-20210914020613321" style="zoom:50%;" /></p>
<p>对于我们人类来说，我们可以看到一只小狗并知道它是一只小狗，需要以下过程，如上图所示，我们的眼睛先获取光源，在我们的视网膜上成像，然后视网膜上的信号传入到大脑，大脑进行分析，最终解释出这是一只小狗。</p>
<p>计算机视觉也同样是这个道理，由照相机捕获光源，得到图片，然后通过计算机处理计算解释出语义。</p>
<p>另外我们经常可以听到计算机视觉和机器视觉两个概念。实际上，计算机视觉和机器视觉所使用的技术都是相同的，但是用途上有一些区别。机器视觉主要是应用在机器系统上，例如机器人。而计算机视觉应用广泛，如网络上的图像分类，人脸识别等都是计算机视觉。</p>
<h2 id="0-3计算机视觉的目标"><a href="#0-3计算机视觉的目标" class="headerlink" title="0.3计算机视觉的目标"></a>0.3计算机视觉的目标</h2><p>照相机拍出来的图片在计算机上是以矩阵的形式表示的。每个像素点对应着矩阵中的一个元素，如果图片是黑白的，那么该元素就记录着对应像素点的灰度值，如果是彩色的，那么该元素就记录着对应像素点的彩色值（RGB值）。</p>
<p>具体可以如下图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000419.png" alt="image-20210914021716001" style="zoom:50%;" /></p>
<p>可以看出，计算机“看到”的是一个矩阵，这个矩阵人类是看不懂的。也就是用人类的大脑来处理计算机看到的东西，是理解不了的，所以就要用计算机的方式来处理。那么就引出了计算机视觉的目标：<strong>跨越语义鸿沟，建立像素到语义的映射。</strong></p>
<p>例如，当计算机看到这个矩阵时，就知道这是一个出轨的火车。</p>
<p>那么一张图像中究竟有什么信息呢？这大致分为两类信息：</p>
<ul>
<li>空间结构信息</li>
<li>语义信息</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000430.png" alt="image-20210914025224068"></p>
<p>计算机视觉的目标还可以理解为，从图像上获取这两类信息。</p>
<h2 id="0-4计算机视觉的历史"><a href="#0-4计算机视觉的历史" class="headerlink" title="0.4计算机视觉的历史"></a>0.4计算机视觉的历史</h2><ul>
<li><strong>1959年，Hubel 和 Wiesel</strong> </li>
</ul>
<p>两个人率先做了一个实验，让一只小猫来看各种各样的图片，来看小猫的大脑哪个地方来处理这个信号。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000519.png" alt="image-20210914022941515" style="zoom:50%;" /></p>
<p>当给猫看到鱼的图片时，发现小猫的大脑并没有什么反应。看其他的东西的时候，也是没有反应。</p>
<p>但当给小猫看一些简单的图形时，如直线，点，此时小猫的大脑皮层是有反应的。</p>
<p>因此他们得到了一个结论，就是人类视觉系统处理信息是分层的，处理图片的时候是从最简单的图形开始，如图片中物体的边沿。他们的这项工作后来获得了诺贝尔医学奖。</p>
<ul>
<li><strong>1963，Larry Roberts</strong></li>
</ul>
<p>从图片中计算出三维实体。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000523.png" alt="image-20210914023806789" style="zoom:67%;" /></p>
<ul>
<li><strong>1966，MIT暑期视觉项目</strong></li>
</ul>
<p>将计算机视觉和图像处理独立出来。</p>
<ul>
<li><strong>David Marr</strong></li>
</ul>
<p>计算机视觉的先驱，成为计算机视觉之父。</p>
<p>他将计算机问题分为三个层次：</p>
<p>计算理论：计算的目的是什么，该问题的已知和可以施加的约束是什么。</p>
<p>表达和算法：输入、输出和中间信息是如何表达的。使用哪些算法来计算所期望的结果。</p>
<p>硬件实现：表达和算法是如何映射到实际硬件上来进行处理的。</p>
<p>然后他又将视觉表达分为了三个阶段</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000528.png" alt="image-20210914024901001" style="zoom:67%;" /></p>
<p>输入一个图像，先提取出边缘图，然后到2.5D的简图，最后再恢复出3D图。</p>
<ul>
<li><strong>后续的研究</strong></li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000531.png" alt="image-20210914025049485"></p>
<h2 id="0-5计算机视觉的应用"><a href="#0-5计算机视觉的应用" class="headerlink" title="0.5计算机视觉的应用"></a>0.5计算机视觉的应用</h2><ul>
<li><p>动画产业</p>
</li>
<li><p>三维建模</p>
</li>
<li><p>摄影</p>
</li>
<li><p>生物识别（如人脸识别，指纹识别）</p>
</li>
<li><p>光学字符识别（OCR）</p>
</li>
<li><p>机器人和无人驾驶</p>
</li>
<li><p>增强现实</p>
</li>
<li><p>医学图像</p>
<p>……</p>
</li>
</ul>
<h2 id="0-6计算机视觉和其他学科的关系"><a href="#0-6计算机视觉和其他学科的关系" class="headerlink" title="0.6计算机视觉和其他学科的关系"></a>0.6计算机视觉和其他学科的关系</h2><p>此处就要放一张神图了</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000536.png" alt="image-20210914030046225"></p>
<p>计算机视觉和许多学科都有着密不可分的关系。如上图所示。</p>
<p><strong>物理学</strong>：光学传感器的研究设计为计算机视觉提供了图片输入。而图像处理领域也是为计算机视觉提供输入，可以先将照相机拍下来的图片进行预处理。</p>
<p><strong>生物学</strong>：该学科主要通过研究人类的大脑来为计算机视觉的研究提供启发。</p>
<p><strong>计算机科学</strong>：计算机科学为计算机视觉提供方法。如机器学习的方法。</p>
<p><strong>工程学</strong>：给计算机视觉提供应用平台，如计算机视觉可以应用在机器人上，可以用在语义识别上。</p>
<h1 id="1-分类问题"><a href="#1-分类问题" class="headerlink" title="1.分类问题"></a>1.分类问题</h1><h2 id="1-0介绍"><a href="#1-0介绍" class="headerlink" title="1.0介绍"></a>1.0介绍</h2><h3 id="1-0-1什么是图像分类任务"><a href="#1-0-1什么是图像分类任务" class="headerlink" title="1.0.1什么是图像分类任务"></a>1.0.1什么是图像分类任务</h3><p>图像分类任务是计算机视觉中的核心任务，目的是根据图像内容的不同，将图像分为不同的类别。</p>
<p>就是在已知类别标签集合的时候，为给定的输入图片选定一个类别标签。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000541.png" alt="image-20210914031800065"></p>
<h3 id="1-0-2分类任务的难点"><a href="#1-0-2分类任务的难点" class="headerlink" title="1.0.2分类任务的难点"></a>1.0.2分类任务的难点</h3><p>（1）语义鸿沟</p>
<p>跨越语义鸿沟是十分困难的。</p>
<p>（2）视角</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000548.png" alt="image-20210914032031443"></p>
<p>（3）光照</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000633.png" alt="image-20210914032109767"></p>
<p>（4）遮挡</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000630.png" alt="image-20210914032229114"></p>
<p>（5）多形态</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000638.png" alt="image-20210914032301581"></p>
<p>（6）背景杂波</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000641.png" alt="image-20210914032348744" style="zoom:67%;" /></p>
<p>（7）类内形变</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000645.png" alt="image-20210914032430556" style="zoom: 67%;" /></p>
<p>（8）运动模糊</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000651.png" alt="image-20210914032859717" style="zoom: 67%;" /></p>
<p>（9）尺度</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000649.png" alt="image-20210914032931255"></p>
<p>（10）种类众多</p>
<p>成百上千种类别很难区分开来。</p>
<h3 id="1-0-3数据驱动的图像分类方法"><a href="#1-0-3数据驱动的图像分类方法" class="headerlink" title="1.0.3数据驱动的图像分类方法"></a>1.0.3数据驱动的图像分类方法</h3><p>如果基于规则的方法，先进行边缘检测，找到角点，然后计算特征，这是很难实现的。比如一只猫，形态各异，不可能有一个确定的特征，若分为多个特征，那么如此巨大数量的特征，是不可能实现的。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000700.png" alt="image-20210914033722773" style="zoom:67%;" /></p>
<p>所以就要采用数据驱动的方法，通过机器学习来完成。</p>
<h4 id="a-数据驱动分类器的结构"><a href="#a-数据驱动分类器的结构" class="headerlink" title="a.数据驱动分类器的结构"></a>a.数据驱动分类器的结构</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000708.png" alt="image-20210914033547955"></p>
<p>一个数据驱动分类器的结构如上图所示，数据驱动分类器就是需要通过数据训练才能设计出一个分类器。</p>
<h4 id="b-分类器设计过程（有监督条件下）"><a href="#b-分类器设计过程（有监督条件下）" class="headerlink" title="b.分类器设计过程（有监督条件下）"></a>b.分类器设计过程（有监督条件下）</h4><p>在整个分类器的设计中，首先我们要有一个分类器模型，然后使用该模型对输入图像进行预测，得到预测值，再将该预测值和该图像在数据集中对应的真实值进行对比，来计算出损失函数得到损失值。再依据损失值来进行优化，使分类模型的参数得到更新。如此往复，直到所得到的分类器性能达到要求为止。</p>
<p>设计一个分类器，最关键的步骤就是设计分类模型、损失函数和训练过程。</p>
<p>常用的分类模型在后面（2）中列出。损失函数在（3）中列出。</p>
<p>而训练过程比较复杂，包括了训练要用到的数据集的划分，数据的预处理，数据增强，欠拟合和过拟合，超参数调整等问题。在后面会一一说明。</p>
<p>（1）图像表示</p>
<ul>
<li>像素表示（一般该方法就可以）</li>
<li>全局特征表示（如GIST）</li>
<li>局部特征表示（如SIFT特征+词袋模型）</li>
</ul>
<p>（2）分类模型</p>
<ul>
<li>近邻分类器</li>
<li>贝叶斯分类器</li>
<li><u>线性分类器</u></li>
<li>支撑向量机分类器</li>
<li><u>神经网络分类器</u></li>
<li>随机森林</li>
</ul>
<p>（3）损失函数</p>
<ul>
<li>0-1损失</li>
<li>多类支撑向量机损失</li>
<li>交叉熵损失</li>
</ul>
<p>（4）优化方法</p>
<p>一阶优化方法</p>
<ul>
<li>梯度下降</li>
<li>随机梯度下降</li>
<li>小批量随机梯度下降</li>
</ul>
<p>二阶方法</p>
<ul>
<li>牛顿法</li>
<li>BFGS</li>
<li>L-BFGS</li>
</ul>
<h3 id="1-0-4数据集介绍"><a href="#1-0-4数据集介绍" class="headerlink" title="1.0.4数据集介绍"></a>1.0.4数据集介绍</h3><p>CIFAR10数据集：包含50000张训练样本，10000张测试样本，共有10个类别的彩色图像，每张图像的大小是32*32。</p>
<h2 id="1-1线性分类器"><a href="#1-1线性分类器" class="headerlink" title="1.1线性分类器"></a>1.1线性分类器</h2><h3 id="1-1-1图像的表示方法"><a href="#1-1-1图像的表示方法" class="headerlink" title="1.1.1图像的表示方法"></a>1.1.1图像的表示方法</h3><h4 id="a-二进制图像"><a href="#a-二进制图像" class="headerlink" title="a.二进制图像"></a>a.二进制图像</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000716.png" alt="image-20210914142438086" style="zoom: 67%;" /></p>
<h4 id="b-灰度图"><a href="#b-灰度图" class="headerlink" title="b.灰度图"></a>b.灰度图</h4><p>每一个像素点有一个灰度值，其范围为0-255，就是对应二进制的00000000-11111111</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000720.png" alt="image-20210914142610282" style="zoom: 67%;" /></p>
<h4 id="c-彩色图"><a href="#c-彩色图" class="headerlink" title="c.彩色图"></a>c.彩色图</h4><p>每一个像素点由三个深度，分别是红色，绿色和蓝色，每一个深度方向上的数值范围为0-255，也就是用三个颜色叠加来表示出一种颜色。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000724.png" alt="image-20210914142805850" style="zoom:80%;" /></p>
<p>在线性分类器处理的过程中，我们将图片用向量的形式来表示。在CIFAR10数据集中，每一张图片是32*32的彩色图，因此用向量来表示就是将每一个像素点的RGB值依次排列成一个列向量。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000735.png" alt="image-20210914143340669" style="zoom:67%;" /></p>
<h3 id="1-1-2线性分类器模型"><a href="#1-1-2线性分类器模型" class="headerlink" title="1.1.2线性分类器模型"></a>1.1.2线性分类器模型</h3><h4 id="a-线性分类器的定义"><a href="#a-线性分类器的定义" class="headerlink" title="a.线性分类器的定义"></a>a.线性分类器的定义</h4><p><strong>ques：</strong>为什么从线性分类器开始？</p>
<p>因为线性分类器的形式简单易于理解，其次通过层级结构（后面说的神经网络）可以形成功能强大的非线性模型。</p>
<p>线性分类器最主要的就是其分类模型，分类模型如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
f_{i}\left(\boldsymbol{x}, \boldsymbol{w}_{i}\right)=\boldsymbol{w}_{i}^{T} \boldsymbol{x}+b_{i} \\
\mathrm{i}=1, \cdots, c
\end{gathered}\tag{1.1}</script><p>其中， $x$ 表示输入的图像的向量，$c$ 为类别个数，$w_i$ 表示第 $i$ 个类别的权值向量，$b_i$ 为第 $i$ 类的偏置。</p>
<p>决策规则为当输入一个图像后，每一个类通过自己的权值向量对其打分，得到 $f_i(x,w_i)$ ，谁的得分高，就属于哪一个类别。</p>
<p><strong>eg：</strong>$f_i(x)&gt;f_j(x)$ ，那么该图片就属于第 $i$ 类。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000744.png" alt="image-20210914144717161" style="zoom:67%;" /></p>
<p> 通过上图的过程，可以知道该图片为猫类。</p>
<h4 id="b-矩阵表示分类器模型"><a href="#b-矩阵表示分类器模型" class="headerlink" title="b.矩阵表示分类器模型"></a>b.矩阵表示分类器模型</h4><script type="math/tex; mode=display">
f(x,W)=Wx+b\tag{1.2}</script><p>其中，$x$ 为图片向量，其维度为d（例如CIFAR10数据集，$d=32\times32\times3=3072$ ）</p>
<p>W是权值矩阵，它的每一行都是一个类的权值向量，因此W的维数为共有c（类别数）行，d（图片维数）列。</p>
<p>b是一个c维的列向量，每一个元素是每一类的偏置。</p>
<p>最后的得分 $f$ 是一个c维的列向量，它的每一个元素代表着每一类别的得分。</p>
<h4 id="c-线性分类器的权值"><a href="#c-线性分类器的权值" class="headerlink" title="c.线性分类器的权值"></a>c.线性分类器的权值</h4><p>我们将训练好的线性分类器的权值向量 $w_i$ 拿出来，因为其维数和图片向量是一样的，所以我们也将其表现成图像的形式。可以发现一个很有意思的现象。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000749.png" alt="image-20210914150006890"></p>
<p>所以权值向量是有其物理意义的，它可以看作是一个模板，如果输入图像与评估模板的匹配程度越高，那么分类器在该类上的输出分数就越高。</p>
<h4 id="d-线性分类器的决策分界面"><a href="#d-线性分类器的决策分界面" class="headerlink" title="d.线性分类器的决策分界面"></a>d.线性分类器的决策分界面</h4><p>实际上，线性分类器和我们高中学习的线性规划一样，可以用图来表示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000759.png" alt="image-20210914150435415"></p>
<p>当分数为0时，就是决策的分界面，其中权值向量w控制着线的方向，偏置b控制着线的偏移。上图中箭头的方向代表分类器的正方向，沿着箭头的方向距离分界面越远的图片，得分越高，就说明线性分类器越肯定的知道该图片属于哪一类。但由于这个分界面是“直线”，所以，线性分类器并不能完全的将一些特殊的图片区分出来，这就是线性分类器的局限性，但后面会继续说明如何解决这类问题（要用到神经网络）</p>
<h3 id="1-1-3损失函数"><a href="#1-1-3损失函数" class="headerlink" title="1.1.3损失函数"></a>1.1.3损失函数</h3><p>前面我们说了分类器的权值向量，为图片进行打分，但是这个权值向量具体的数值是需要通过训练来得到的。那么如何用数学语言来描述该权值向量的性能呢，这就需要损失函数来描述。</p>
<p>损失函数搭建了模型性能和模型参数之间的桥梁，指导模型参数优化。</p>
<h4 id="a-损失函数的特点"><a href="#a-损失函数的特点" class="headerlink" title="a.损失函数的特点"></a>a.损失函数的特点</h4><ul>
<li>损失函数是一个函数，用于度量给定分类器的预测值和真实值的不一致程度，其输出通常是一个非负实值。</li>
<li>其输出的非负实值可以作为反馈信号，用来对分类器参数进行调整，从而降低当前的损失值，以提高分类效果。</li>
</ul>
<h4 id="b-损失函数的定义"><a href="#b-损失函数的定义" class="headerlink" title="b.损失函数的定义"></a>b.损失函数的定义</h4><script type="math/tex; mode=display">
L=\frac{1}{N} \sum_{i} L_{i}\left(f\left(x_{i}, W\right), y_{i}\right)\tag{1.3}</script><p>N为样本图片数量。</p>
<p>$i$ 表示输入的第 $i$ 张图片，$f(x_i,W)$ 是分类器对第 $i$ 张图片的打分，$y_i$ 是第 $i$ 张图片真实类别标签。</p>
<p>$L_i$ 是对第 $i$ 张图片的损失当前预测值，也就是预测值与真实值之间的差距。</p>
<p><strong>不同的损失函数，其$L_i$ 的具体形式不同。</strong></p>
<h4 id="c-多类支撑向量机损失"><a href="#c-多类支撑向量机损失" class="headerlink" title="c.多类支撑向量机损失"></a>c.多类支撑向量机损失</h4><p>对于同某一个样本图片i，分类器对其打分得到了一个分数向量 $f(x_i,W)=[s_{i1}\ s_{i2} …s_{ij}]^T$ ，那么 $s_{ij}$ 就是第i张图片在第j类上的分数。</p>
<script type="math/tex; mode=display">
s_{i j}=f_{j}\left(x_{\mathrm{i}}, w_{j}, b_{j}\right)=w_{j}^{T} x_{i}+b_{j}\tag{1.4}</script><p>下面定义多类支撑向量机损失：</p>
<script type="math/tex; mode=display">
\begin{aligned}
L_{i}=& \sum_{j \neq y}\left\{\begin{array}{l}
0 & \text { if } s_{iy} \geq s_{i j}+1 \\
s_{ij}-s_{iy}+1 & \text { otherwise }
\end{array}\right.\\
&=\sum_{j \neq y} \max \left(0, s_{i j}-s_{iy}+1\right)
\end{aligned}\tag{1.5}</script><p>这里，$y$ 表示样本图像 i 所在的真实类别。式（1.5）的意义就是，用图片在各个类别上的打分和其所在的真实类别上的打分进行比较，当真实类别上的打分 $s_{iy}$ 比其他类别的打分 $s_{ij}$ 高出1时，损失为0，如果不高出1，则损失 $s_{ij}+1-s_{iy}$ 。该损失函数也称为折页损失（hingeloss）。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000809.png" alt="image-20210914155617783" style="zoom:67%;" /></p>
<p>损失函数的范围是0到无穷，当损失函数很小时就说明所得到的参数性能很好了。</p>
<p>现在再来看一下线性分类器模型，有以下这种情况：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000814.png" alt="image-20210914160319600" style="zoom:67%;" /></p>
<p>这个例子可以看出，可以使最终损失函数为0的参数W并不唯一，那么如何在这些参数之间进行选择呢？</p>
<h4 id="d-正则项"><a href="#d-正则项" class="headerlink" title="d.正则项"></a>d.正则项</h4><p>在损失函数中加入正则项</p>
<script type="math/tex; mode=display">
L(W)=\frac{1}{N} \sum_{i} L_{i}\left(f\left(x_{i}, W\right), y_{i}\right)+\lambda R(W)\tag{1.6}</script><p>前面原来的项，称为数据损失，根据数据损失训练出来的参数和训练集相匹配。</p>
<p>后面的项，称为正则项，它是一个仅与权值有关，而与训练集无关的函数，它的作用就是防止模型在训练集上训练得太好。</p>
<p>如果训练的太好，只能说明对该训练集可以准确的分类，但对于未知的图片，性能可能会很差。</p>
<h5 id="（1）L2正则项"><a href="#（1）L2正则项" class="headerlink" title="（1）L2正则项"></a>（1）L2正则项</h5><script type="math/tex; mode=display">
R(W)=\sum_{k} \sum_{l} W_{k, l}^{2}\tag{1.7}</script><p>L2正则项是将所有的权值的平方相加到一起。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000820.png" alt="image-20210914161749420" style="zoom:67%;" /></p>
<p>由该例子可以看出，分类器所打的分数相同，此时数据损失是相同的，但是正则损失不同，便可以选出更合适的权值参数。</p>
<p>L2正则损失对大数值权值进行惩罚，喜欢分散权值，鼓励分类器将所有维度特征都用起来，而不是强烈的依赖其中少数几维特征。</p>
<h5 id="（2）L1正则项"><a href="#（2）L1正则项" class="headerlink" title="（2）L1正则项"></a>（2）L1正则项</h5><script type="math/tex; mode=display">
R(W)=\sum_{k} \sum_{l}\left|W_{k, l}\right|\tag{1.8}</script><h5 id="（3）Elastic-net-L1-L2"><a href="#（3）Elastic-net-L1-L2" class="headerlink" title="（3）Elastic net(L1+L2)"></a>（3）Elastic net(L1+L2)</h5><script type="math/tex; mode=display">
R(W)=\Sigma_{k} \sum_{l} \beta W_{k, l}^{2}+\left|W_{k, l}\right|\tag{1.9}</script><p>该损失函数就是将L1和L2损失函数结合起来，式中的 $\beta$ 是一个超参数。</p>
<h4 id="e-超参数"><a href="#e-超参数" class="headerlink" title="e.超参数"></a>e.超参数</h4><p>在式（1.6）中的 $\lambda$ 是一个超参数，它控制着正则损失在总损失中所占的比重。</p>
<p>超参数就是在开始学习过程之前，人为设置的参数，而不是学习得到的。</p>
<h3 id="1-1-4优化算法"><a href="#1-1-4优化算法" class="headerlink" title="1.1.4优化算法"></a>1.1.4优化算法</h3><p>损失函数搭建了模型性能和模型参数之间的桥梁，有了这个桥梁就需要用优化算法来进行优化了。</p>
<p>优化算法的目标就是找到使损失函数达到最优的那组参数。</p>
<h4 id="a-直接法"><a href="#a-直接法" class="headerlink" title="a.直接法"></a>a.直接法</h4><p>对损失函数直接求导，一般这种方法用不了，因为很难直接解出W。</p>
<h4 id="b-梯度下降算法"><a href="#b-梯度下降算法" class="headerlink" title="b.梯度下降算法"></a>b.梯度下降算法</h4><p>梯度下降算法是一种简单而高效的迭代优化算法。就是求出损失函数的梯度来，这就确定了参数更新的方向，然后给定一个步长（步长也叫做学习率），来更新参数。</p>
<p>更新后的权值=原权值-学习率*损失函数梯度</p>
<p>梯度下降算法的核心就是如何计算出梯度。</p>
<p>方法有以下两种：</p>
<h5 id="（1）数值法"><a href="#（1）数值法" class="headerlink" title="（1）数值法"></a>（1）数值法</h5><script type="math/tex; mode=display">
\frac{d L(w)}{d w}=\lim _{h \rightarrow 0} \frac{L(w+h)-L(w)}{h}\tag{1.10}</script><p>这种方法计算量大，不精确。</p>
<h5 id="（2）解析法"><a href="#（2）解析法" class="headerlink" title="（2）解析法"></a>（2）解析法</h5><p>对损失函数求导，求出梯度。</p>
<h4 id="c-随机梯度下降算法"><a href="#c-随机梯度下降算法" class="headerlink" title="c.随机梯度下降算法"></a>c.随机梯度下降算法</h4><p>如果把所有的样本图片都代入到分类器中，计算损失函数，然后再求导，计算量过大，速度很慢。因此我们可以只代入一个样本图片。这就是随机梯度下降算法。</p>
<p>每次随机的抽取一个图片 i ，然后计算出损失函数和损失函数的梯度。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&L(W)=L_{i}\left(x_{i}, y_{i}, W\right)+\lambda R(W) \\
&\nabla_{W} L(W)=\nabla_{W} L_{i}\left(x_{i}, y_{i}, W\right)+\lambda \nabla_{W} R(W)
\end{aligned}\tag{1.11}</script><p>更新权值参数，再进行下一轮的训练。</p>
<p>这样速度会大大提升，但是单样本训练会带来很多的噪声，不是每次迭代都向着整体最优化方向的。</p>
<h4 id="d-小批量梯度下降算法"><a href="#d-小批量梯度下降算法" class="headerlink" title="d.小批量梯度下降算法"></a>d.小批量梯度下降算法</h4><p>既然单个样本可能会含有噪声，那么就用一个折中的办法，小批量随机选取m（超参数）个样本，计算损失函数和其梯度。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&L(W)=\frac{1}{N} \sum_{i=1}^{N} L_{i}\left(x_{i}, y_{i}, W\right)+\lambda R(W) \\
&\nabla_{W} L(W)=\frac{1}{N} \sum_{i=1}^{N} \nabla_{W} L_{i}\left(x_{i}, y_{i}, W\right)+\lambda \nabla_{W} R(W)
\end{aligned}\tag{1.12}</script><p>在小批量处理中，有几个名词需要知道：</p>
<ul>
<li>iteration:表示1次迭代</li>
<li>batch-size:1次迭代所使用的样本量</li>
<li>epoch:1个epoch表示过了1遍训练集中的所有样本</li>
</ul>
<p>通常使用2的幂次方来作为样本数量。</p>
<h3 id="1-1-5数据集划分"><a href="#1-1-5数据集划分" class="headerlink" title="1.1.5数据集划分"></a>1.1.5数据集划分</h3><p>通常的数据集划分为两部分</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000827.png" alt="image-20210914170422717" style="zoom: 67%;" /></p>
<p>但当存在超参数时，如何找到泛化能力最好的超参数呢，要用验证集。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000829.png" alt="image-20210914170528769" style="zoom: 67%;" /></p>
<ul>
<li>训练集：用于 <strong>给定</strong> 的超参数时分类器参数的学习。</li>
<li>验证集：用于选择超参数。</li>
<li>测试集：用于评估泛化能力。</li>
</ul>
<p>如果数据很少，那么可能验证集里的样本太少，从而无法在统计上代表数据。接下来介绍一种方法。</p>
<p><strong>K折交叉验证</strong>：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000846.png" alt="image-20210914230810126" style="zoom: 67%;" /></p>
<p>过程是这样的，首先确定一个超参数，然后将数据分为K份（k折就是k份）。如上图所示，先用训练集训练，然后验证，得到一个分数。依此类推，最终得到K个分数，然后将其相加取平均，便得到了在该超参数的分值。</p>
<h3 id="1-1-6数据预处理"><a href="#1-1-6数据预处理" class="headerlink" title="1.1.6数据预处理"></a>1.1.6数据预处理</h3><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000841.png" alt="image-20210915001700872"></p>
<p>就与我们考试一样，看绝对的分数是没有用的，因为不同的题难易程度也不同。而看我们与平均分的差距才能体现出我们的真实水平。</p>
<p>图像也正是如此，例如当有许多张猫和狗的图片，我们可以先将这些向量去均值，只需知道每两张图片间的相对差异即可。</p>
<p>另外为了避免数量级的影响，还需要将数据进行归一化</p>
<script type="math/tex; mode=display">
Z=\frac{X-\bar{X}}{\sigma}\tag{1.13}</script><p>其中 $\bar{X}$ 为数据的均值，$\sigma$ 为数据的方差。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000856.png" alt="image-20210915003423872"></p>
<p>数据去相关可以达到降维的作用。</p>
<h2 id="1-2全连接神经网络分类器"><a href="#1-2全连接神经网络分类器" class="headerlink" title="1.2全连接神经网络分类器"></a>1.2全连接神经网络分类器</h2><h3 id="1-2-1全连接神经网络的提出"><a href="#1-2-1全连接神经网络的提出" class="headerlink" title="1.2.1全连接神经网络的提出"></a>1.2.1全连接神经网络的提出</h3><p>当出现较为复杂的图片时，单纯依靠线性分类器就很难划分分界面了（因为线性分类器的分界面只能是直的），所以需要建立一个非线性模型。那么全连接神经网络模型就是具有代表性的非线性模型。</p>
<p>如下图所示，分为线性可分和线性不可分：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000907.png" alt="image-20210915012437563"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000911.png" alt="image-20210915012535586"></p>
<p><strong>全连接神经网络级联了多个变换来实现输入到输出的映射。</strong></p>
<p>如两层神经网络模型：</p>
<script type="math/tex; mode=display">
f=W_{2} \max \left(0, W_{1} x+b_{1}\right)+b_{2}\tag{1.14}</script><p>两层神经网络结构有一层隐层。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000915.png" alt="image-20210915012838114"></p>
<p>三层神经网络模型：</p>
<script type="math/tex; mode=display">
f=\mathrm{W}_{3} \max \left(0, \mathrm{~W}_{2} \max \left(0, \mathrm{~W}_{1} \mathrm{x}+\mathrm{b}_{1}\right)+\mathrm{b}_{2}\right)\tag{1.15}</script><p>上面两式和线性分类模型形式十分相似，但稍稍有一些不同，其中在线性模型中，是权值向量直接乘以图片向量，而神经网络中出现了一个 $max()$ 函数，这是一个激活函数，我们后面会详细说明，那么为什么要加上激活函数呢？</p>
<p>如果不加上激活函数，如式（1.15），将其一层一层的乘开，最后该模型又会退化到线性模型上去，因此这里的激活函数是关键，正是因为激活函数的存在，才可以使神经网络称为一个非线性模型。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f&=W_{3}\left(W_{2}\left(W_{1} x+b_{1}\right)+b_{2}\right)+b_{3} \\
&=W_{3} W_{2} W_{1} x+\left(W_{3} W_{2} b_{1}+W_{3} b_{2}+b_{3}\right) \\
&=W^{\prime} x+b^{\prime}
\end{aligned}\tag{1.16}</script><p>至于整个神经网络有多少个隐层，每一层隐层有多少个神经元比较合适，这都没有统一的答案，但有一点可以证明：神经元的数量越多，分界面就可以越复杂，在这个集合上的分类能力就越强。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000921.png" alt="image-20210915014336677"></p>
<p>在设计神经网络的时候，所面对的任务越复杂，神经网络结构就应该越深，越宽。但也要注意，并不是越复杂的神经网络越好，因为在真实场景下未必是最好的，只是在训练集上的效果较好（过拟合）。</p>
<h3 id="1-2-2全连接神经网络的物理意义"><a href="#1-2-2全连接神经网络的物理意义" class="headerlink" title="1.2.2全连接神经网络的物理意义"></a>1.2.2全连接神经网络的物理意义</h3><p>通过1.1.2c的学习，我们知道线性分类器的分类模型是通过一个权值向量乘以图片向量加上偏置得出分数。其权值向量的物理意义是每一个权值向量都是一个图片模板。模版数量取决于类别的数量，即假如有10个类别，那么就有10个模板。</p>
<p>用一个模板来筛选一类未免太难了，如下图所示</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000927.png" alt="image-20210915010335392"></p>
<p>可以隐约的看出，这个模板中，有两个马头，这就是因为只用一个模板来表示整个类，那么这个模板就是该类的一个平均。但当有一个极其特殊的马时，那么便识别不出来了。而想要多用几个模板，又用不了，因为线性分类器的结构就是这样，有多少个类就有多少个模板。</p>
<p>然而在神经网络中，模板的数量可以人为的规定，为什么会这样呢？</p>
<script type="math/tex; mode=display">
f=W_{2} \max \left(0, W_{1} x+b_{1}\right)+b_{2}\tag{1.14}</script><p>现在以两层神经网络为例，如果共有10类，那么 $W_2$ 的行数应该为10，而至于 $W_2$ 的列数，等于 $W_1$ 的行数，对于 $W_1$ 的行数，并没有什么限制，我们可以随意的规定。 $W_1$ 的列数，是等于图像向量的维数的。再反过来看，和线性分类器一样，$W_1$ 的行向量也是一个权值向量，它的物理意义也是一样的，转化成图片也是一个模板，我们可以规定 $W_1$ 的某几行都是某一类的模板，然后再通过 $W_2$ 的权值对该类的这几个模板进行叠加。例如我们规定 $W_1$ 的前100行都是马的模板，有站着的马，跑着的马，吃饭的马，汗血宝马等等。当输入一个图像向量后，分别与这一百个模板进行比较打分，得到一个100维的分数向量，然后再将这个分数向量代入到第二层神经网络，进行权值叠加，得出各类的分数。</p>
<p>所以说，全连接神经网络的描述能力更强，因为调整 $W_1$ 行数等于增加模板数量。</p>
<h3 id="1-2-3常用的激活函数"><a href="#1-2-3常用的激活函数" class="headerlink" title="1.2.3常用的激活函数"></a>1.2.3常用的激活函数</h3><h4 id="a-Sigmoid"><a href="#a-Sigmoid" class="headerlink" title="a.Sigmoid"></a>a.Sigmoid</h4><script type="math/tex; mode=display">
1 /\left(1+e^{-x}\right)\tag{1.17}</script><p>函数图像：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000933.png" alt="image-20210915013453615"></p>
<p>值域为0到1。</p>
<h4 id="b-tanh"><a href="#b-tanh" class="headerlink" title="b.tanh"></a>b.tanh</h4><script type="math/tex; mode=display">
\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}\tag{1.18}</script><p>函数图像：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000942.png" alt="image-20210915013653611"></p>
<p>值域为-1到1。</p>
<h4 id="c-ReLU"><a href="#c-ReLU" class="headerlink" title="c.ReLU"></a>c.ReLU</h4><script type="math/tex; mode=display">
max(0,x)\tag{1.19}</script><p>函数图像：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000947.png" alt="image-20210915013904728"></p>
<p>值域为0到正无穷。</p>
<h4 id="d-Leaky-ReLU"><a href="#d-Leaky-ReLU" class="headerlink" title="d.Leaky ReLU"></a>d.Leaky ReLU</h4><script type="math/tex; mode=display">
max(0.1x,x)\tag{1.20}</script><p>函数图像：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215000954.png" alt="image-20210915014020529"></p>
<p>值域负无穷到正无穷。</p>
<h3 id="1-2-4损失函数"><a href="#1-2-4损失函数" class="headerlink" title="1.2.4损失函数"></a>1.2.4损失函数</h3><p>在这里，我们换一种损失函数的定义方法，使用SOFTMAX和交叉熵的方法。</p>
<h4 id="a-SOFTMAX"><a href="#a-SOFTMAX" class="headerlink" title="a.SOFTMAX"></a>a.SOFTMAX</h4><p>我们先对神经网络关于输入图片所打的分数进行一个处理，如下图所示</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001001.png" alt="image-20210915015044697" style="zoom:67%;" /></p>
<p>SOFTMAX就是对神经网络的输出值求指数得到 $t_i$，然后将其求和，再用 $t_i$ 比上这个总和，便得到了 $p_i$ 。</p>
<p>经过这个处理，就可以转化成概率分布的形式，即神经网络分类器对某一张图片进行分类，输出结果是图片为各个类别的概率。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001005.png" alt="image-20210915015406330" style="zoom:67%;" /></p>
<h4 id="b-交叉熵损失"><a href="#b-交叉熵损失" class="headerlink" title="b.交叉熵损失"></a>b.交叉熵损失</h4><p>然后我们来定义损失函数，和线性分类器类似，我们这里也用概率的形式定义真实值，例如一张图片的标签是鸟，那么我们就用其在鸟类的概率为1来定义。如下图所示</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001008.png" alt="image-20210915015639286" style="zoom:67%;" /></p>
<p>这种形式也叫做one-hot形式。</p>
<p>然后我们要想办法来描述预测值和真实值之间的差距，从而构建损失函数。</p>
<p>定义：</p>
<ul>
<li>熵：$H(p)=-\sum_{x} p(x) \log p(x)$</li>
<li>交叉熵：$H(p, q)=-\sum_{x} p(x) \log q(x)$</li>
<li>相对熵：$K L(p | q)=-\sum_{x} p(x) \log \frac{q(x)}{p(x)}$</li>
</ul>
<p>在概率中，用相对熵的概念来度量两个分布间的不相似性。相对熵也叫做KL散度。</p>
<p>这三者之间的关系为：</p>
<script type="math/tex; mode=display">
\begin{aligned} H(p, q) &=-\sum_{x} p(x) \log q(x) \\ &=-\sum_{x} p(x) \log p(x)-\sum_{x} p(x) \log \frac{q(x)}{p(x)} \\ &=H(p)+K L(p \| q) \end{aligned}\tag{1.21}</script><p>即交叉熵等于熵加上相对熵。</p>
<p>那么我们现在想要描述分类器预测的分布 $q(x)$ 和真实的分布 $p(x)$ 间的关系，我们将其带入到式（1.21）中，得到：</p>
<script type="math/tex; mode=display">
H(p, q)=-\sum_{i=1}^{c} \mathrm{p}\left(x_{i}\right) \log \left(\mathrm{q}\left(x_{i}\right)\right)\tag{1.22}</script><p>因为真实值p(x)是one-hot形式，只有x等于真实类别的时候才为1，那么 $H(p)=0$ ，此时P(x)和q(x)的概率分布的交叉熵和相对熵相等。</p>
<p>所以：</p>
<script type="math/tex; mode=display">
L_i=-log(q_j)\tag{1.23}\ \ \ j为真实类别</script><p>式（1.23）表明，在真实值为one-hot的形式时，第i张图片所得到的损失为预测值SOFTMAX形式在真实类别上的负对数。</p>
<p>为什么要引入交叉熵损失呢？看下面这个例子，有三组预测分数，其中第一个元素为真实类别所对应的预测分数</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001016.png" alt="image-20210915022451149" style="zoom:80%;" /></p>
<p>可以看到，此时的多类支撑向量机损失函数都是0，而交叉熵损失并不全是0。可以看出交叉熵损失更加精确。它们的意义是不一样的。多类支撑向量机损失是只要我自己高，那么损失就是0，而交叉熵损失是我自己高的同时，别人还要低。</p>
<h3 id="1-2-5计算图"><a href="#1-2-5计算图" class="headerlink" title="1.2.5计算图"></a>1.2.5计算图</h3><p>计算图是一种有向图，它用来表达输入和输出以及中间变量之间的计算关系，图中的每个节点代表着一种数学运算。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001024.png" alt="image-20210915022849400" style="zoom:80%;" /></p>
<h4 id="a-计算图的前向和反向计算"><a href="#a-计算图的前向和反向计算" class="headerlink" title="a.计算图的前向和反向计算"></a>a.计算图的前向和反向计算</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001029.png" alt="image-20210915023017458" style="zoom:80%;" /></p>
<ul>
<li>任意的复杂函数，都可以用计算图来表示。</li>
<li>在整个计算图中，每个门都会得到一个输入，然后需要计算两个东西，一个是这个门的输出值，另一个是计算这个输出值关于输入值的局部导数</li>
<li>利用链式求导法则，门单元可以将回传梯度和其上一个门单元的梯度进行相乘，从而得到整个网络的输出对每个输入值的梯度。</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001036.png" alt="image-20210915025136595" style="zoom: 33%;" /></p>
<p>反向计算时，先让各个门单元进行求导，得到局部导数，再将各个门单元的输入带入到局部导数中，得到导数具体数值，最后将所有局部导数相乘，便得到最后的输出对出入的导数。</p>
<h4 id="b-计算图的颗粒度"><a href="#b-计算图的颗粒度" class="headerlink" title="b.计算图的颗粒度"></a>b.计算图的颗粒度</h4><p>计算图的各个门单元可以是最基本的数学运算，但也可以由基本的数学运算合成的复杂数学运算，此时就是大颗粒度。当颗粒度较大时，计算速度较快，但是求导比较麻烦。而小颗粒度运算速度慢，但是求导很简单。</p>
<h4 id="c-梯度爆炸和梯度消失"><a href="#c-梯度爆炸和梯度消失" class="headerlink" title="c.梯度爆炸和梯度消失"></a>c.梯度爆炸和梯度消失</h4><p>现在我们再重新看激活函数</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001044.png" alt="image-20210915025950960"></p>
<p>当输入的数值较大时，sigmoid函数的梯度都为0，非常不利于梯度流在计算图中的反向传播，同样tanh函数也是如此。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001047.png" alt="image-20210915030131126"></p>
<p>而ReLU函数在较大时，梯度永远不会为0，比较有利于梯度的反向传播。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001050.png" alt="image-20210915030220960"></p>
<p>Leakly ReLU函数的梯度永远不会为0，但在输入为0处没有导数。</p>
<p>如果某一个门的局部梯度为0或者是某几个门的梯度都很小，此时相乘下去，就会造成输出对输入的梯度为0，这就是梯度消失，这就回造成参数无法获得更新。这就好比，损失函数是一座山，这个山有一个高海拔平原，生活在平原上的人就不知道还有比这个平原低的地方。这就会造成训练失败。</p>
<p>相反，梯度爆炸就是因为链式相乘，梯度越乘越大，这就会导致参数更新时学习率过大，从而导致算法不收敛。如果把步长限制到某一范围内，便可以解决这个问题，这种方法也称为梯度裁剪。</p>
<h3 id="1-2-6改进梯度算法"><a href="#1-2-6改进梯度算法" class="headerlink" title="1.2.6改进梯度算法"></a>1.2.6改进梯度算法</h3><h4 id="a-之前的算法存在的问题"><a href="#a-之前的算法存在的问题" class="headerlink" title="a.之前的算法存在的问题"></a>a.之前的算法存在的问题</h4><p>对于损失函数来说，有可能在一个维度上变化的缓慢，在另一个维度上又震荡，导致不能收敛。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001057.png" alt="image-20210916213136189"></p>
<p>就像这幅图所描述的那样。因此需要将原来的算法进行改进。</p>
<h4 id="b-动量法"><a href="#b-动量法" class="headerlink" title="b.动量法"></a>b.动量法</h4><p>利用累加历史梯度信息更新梯度。</p>
<p>为什么这种方法有效呢？</p>
<p>因为在震荡方向上，梯度可以相互抵消，在平坦方向上，梯度可以累加。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001103.png" alt="image-20210916214949919"></p>
<p>这里的 $\mu$ 是一个超参数，取值范围是0到1。它的作用是，当梯度为0时，它可以作为一个衰减系数，让速度更新值变为0 。</p>
<p>另外，在优化的过程中，经常会遇到局部最小值的问题，动量法还可以使其冲出局部最小值点或者是鞍点。</p>
<h4 id="c-自适应梯度与RMSProp"><a href="#c-自适应梯度与RMSProp" class="headerlink" title="c.自适应梯度与RMSProp"></a>c.自适应梯度与RMSProp</h4><p>自适应梯度法就是<strong>改变学习率</strong>（注意是改变学习率，也就是步长，根据梯度的幅值平方来调整学习率），通过减小震荡方向步长，增大平坦方向步长来使算法收敛的。</p>
<p>是如何区分震荡和平坦方向的呢？</p>
<p>梯度幅值的平方较大的方向是震荡方向，幅值的平方较小的方向是平坦方向。</p>
<p>RMSProp就是一种自适应梯度算法。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001129.png" alt="image-20210916221857515"></p>
<p>对于陡峭的时候，r就会很大，r作为分母，此时会使步长变得很小。对于平坦区域，r就会很小，此时的步长就会变得很大。</p>
<p>此处加上超参数 $\rho$ ，就是防止r无限增大， $\rho$ 的取值范围为0到1，当 $\rho$ 很大时，就表示历史的 r 考虑的较多。当 $\rho$ 很小时，表示历史的r</p>
<p>的影响较少。</p>
<h4 id="d-Adam方法"><a href="#d-Adam方法" class="headerlink" title="d.Adam方法"></a>d.Adam方法</h4><p>将动量法和自适应梯度方法结合在一起。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001134.png" alt="image-20210917000443472" style="zoom: 33%;" /></p>
<p>在这里有一个修正操作，是防止初始的时候的梯度过小。</p>
<h3 id="1-2-7权值初始化"><a href="#1-2-7权值初始化" class="headerlink" title="1.2.7权值初始化"></a>1.2.7权值初始化</h3><h4 id="a-不好的初始化"><a href="#a-不好的初始化" class="headerlink" title="a.不好的初始化"></a>a.不好的初始化</h4><h5 id="（1）全零初始化"><a href="#（1）全零初始化" class="headerlink" title="（1）全零初始化"></a>（1）全零初始化</h5><p>如果将所有权值参数都初始化为0或者是同一个常数，那么所有的神经元都是一样的。这是不可以的。</p>
<h5 id="（2）随机权值初始化"><a href="#（2）随机权值初始化" class="headerlink" title="（2）随机权值初始化"></a>（2）随机权值初始化</h5><p>例如：有10个隐层，1个输出层，每个隐层包含500个神经元，使用双曲正切激活函数。</p>
<p>此时我们采用随机初始化，权值参数的数值采样自 $N(0,0.01)$ 的高斯分布。</p>
<p>我们输入一组符合正态分布的向量。</p>
<p>现在看个层的输出，第一层的时候，还可以看到也是一个正态分布，但是当过了3层之后，每一层的输出都为0。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001212.png" alt="image-20210917001832779"></p>
<p>这就导致了信息无法正确的传到神经网络的最后面，就不会有反向的梯度来更新我们的权值参数。</p>
<p>现在我们把权值参数的采样更改一下，变为 $N(0,1)$ ，但是此时各层的输出如下：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001223.png" alt="image-20210917002841682"></p>
<p>几乎所有的神经元都饱和了，此时神经元的局部梯度都是0，最终参数也得不到更新。</p>
<p>所以初始化不好，网络是没有办法被训练的。有效的初始化方法就是正向的信息流能传到后面，反向的梯度能传回来。</p>
<h4 id="b-Xavier初始化"><a href="#b-Xavier初始化" class="headerlink" title="b.Xavier初始化"></a>b.Xavier初始化</h4><p>我们的目标就是使网络各层的激活值和局部梯度的 <strong>方差</strong> 在传播过程中尽量保持一致，也就是寻找权值 w 的分布，使得输出 y 和输入 z 的方差一致。</p>
<p>现在假设：</p>
<p><strong>一个</strong>神经元的输入为 $z_1,z_2,\cdots,z_n$ ，$z_i$ 是一个数。它们是独立同分布的。</p>
<p>这个神经元的权值 $w_1,w_2,\cdots,w_n$ ，他们也是独立同分布的。且w和z是独立的，均值为0。其激活函数为 $f$ ，最终的输出值为y。</p>
<script type="math/tex; mode=display">
y=f\left(w_{1} * z_{1}+\cdots+w_{n} * z_{n}\right)\tag{1.24}</script><p>继续假设激活函数 $f$ 为tanh，（1.24）括号内的值域为-2到2，此时 $f$ 就是一个正比例函数，即</p>
<script type="math/tex; mode=display">
y=w_{1} * z_{1}+\cdots+w_{n} * z_{n}\tag{1.25}</script><p>那么 y 的方差为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\operatorname{Var}(y) &=\operatorname{Var}\left(\sum_{i=1}^{n} w_{i} z_{i}\right)=\sum_{i=1}^{n} \operatorname{Var}\left(w_{i} z_{i}\right) \\
&=\sum_{i}^{n}\left[E\left(w_{i}\right)\right]^{2} \operatorname{Var}\left(\mathrm{z}_{i}\right)+\left[E\left(z_{i}\right)\right]^{2} \operatorname{Var}\left(w_{i}\right)+\operatorname{Var}\left(w_{i}\right) \operatorname{Var}\left(z_{i}\right) \\
&=\sum_{i}^{n} \operatorname{Var}\left(w_{i}\right) \operatorname{Var}\left(z_{i}\right) \\
&=n \operatorname{Var}\left(\mathrm{w}_{i}\right) \operatorname{Var}\left(z_{i}\right)
\end{aligned}\tag{1.26}</script><p>此时，如果想要使y的方差和输入z一样，就令w的方差为1/n。</p>
<p>所以，我们令权值的采样分布更改为 $N(0,1/n)$ ，那么就可以让输入和输出同分布。这就是Xavier初始化。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001232.png" alt="image-20210917021936600"></p>
<p>但是对ReLU激活函数，Xavier的效果不是很好。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001238.png" alt="image-20210917022213604"></p>
<p>此时用何凯明研究员提出的初始化方法。</p>
<p>权值的采样分布更改为 $N(0,2/n)$ 。效果如下：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001304.png" alt="image-20210917022258281"></p>
<h3 id="1-2-8批归一化（BN）"><a href="#1-2-8批归一化（BN）" class="headerlink" title="1.2.8批归一化（BN）"></a>1.2.8批归一化（BN）</h3><p>之前的权值初始化是为了在训练时，网络可以正常传递输入信息，现在我们试着改变一下网络的结构，来保证信息可以安全的传递。</p>
<p>批归一化的思想不是从权值初始化考虑的，而是对数据输出数据进行处理，因为我们最终的目标是使输出和输入同分布。</p>
<p>批归一化就是对神经元的输出（也就是下一层神经元的输入）直接进行批归一化，批归一化就是对输出减均值，除标准差。</p>
<p>例如，小批量梯度下降算法，每次迭代会输入一批数据，假如有32个样本，经过神经元后，会有32个输出值。我们求出这32个输出值的平均值和标准差，然后对每个输出值进行减平均值，除标准差的操作。然后处理后的数据作为下一层神经元的输入。</p>
<p>批归一化操作通常会插入到全连接层之后，非线性激活之前，这样效果更好。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001315.png" alt="image-20210917023105383" style="zoom:50%;" /></p>
<p>这里的FC就是加权计算，BN是批归一化操作。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001321.png" alt="image-20210917024344165" style="zoom:67%;" /></p>
<p>因为，输入数据经过正常全连接加权后，为进行激活函数计算之前，通常落在上面左图红色的区域，这个区域的数值输入到激活函数中，会得到-1或1，那么此时的局部梯度为0，不利于神经网络的反向梯度传播。而通过批归一化后，数据会落在上面右图中间的红色区域，激活函数在此处的梯度不为0。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001329.png" alt="image-20210917025237882" style="zoom: 50%;" /></p>
<p>上面的 $x_i$ 是上一层神经元的加权输出（还未经过激活函数处理），然后进行批归一化处理，但是请注意还有一步，就是对批归一化后的数据进行平移和放缩（也就是改变其均值和方差），然后通过训练，让神经网络自己找出合适的参数 $\gamma 和\beta$ 。因为0均值，1方差不一定对训练好，让网络自己选择。</p>
<p>上面都是在批量数据的计算时，可以计算出数据的均值和方差，但是当预测的时候，只输入一个样本，均值和方差该如何取呢？</p>
<p>这个均值和方差就是在训练时，每一次迭代所产生的均值和方差，进行累加求平均。</p>
<h3 id="1-2-9欠拟合和过拟合"><a href="#1-2-9欠拟合和过拟合" class="headerlink" title="1.2.9欠拟合和过拟合"></a>1.2.9欠拟合和过拟合</h3><p>欠拟合表示模型太简单，就好比一个小学生，去学大学数学，如果小学生能学明白，就幼儿园小朋友，他的大脑还没有发育完全，所以是学不了的。</p>
<p>而过拟合表示训练的太好，仅对训练集中的数据进行处理，可以获得较准确的数据。这就好比有两个学生，小李只会死记硬背，小蔡会学习做题方法。这样，在考试的时候，如果出了过去出过的题，小李就肯定占优势了，小蔡不一定能考过小李，但是当出过未出过的题，那么小李就傻了，因为他没有见过，所以铁定不会。小李就是过拟合现象，只记下了每张图片的样子，而没有学习到这些图片共同的特征。</p>
<p>在实际的应用中，欠拟合很好解决，只需要提高模型的复杂程度。而过拟合就不那么好解决了。</p>
<p>机器学习最根本的问题就是优化和泛化问题。</p>
<ul>
<li>优化—是指调节模型参数以在训练数据上得到最佳性能。</li>
<li>泛化—是指训练好的模型在未见过的数据上性能好坏。</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001333.png" alt="image-20210917042730226" style="zoom: 67%;" /></p>
<p>通常情况下，在训练初期，优化和泛化是相关的，训练集上的误差越小，验证集上的误差也小。这表明模型的泛化能力在增强。</p>
<p>但是到了后期，模型在验证集上的错误率开始增加，而在训练集上的误差仍在降低。此时就说明模型出现了过拟合，模型开始学习仅和训练数据有关的模式。</p>
<p>那么应对过拟合，从大方向来说有两种办法：</p>
<ul>
<li>最优方案：增加训练集规模。</li>
<li>次优方案：调节模型允许存储信息量或对模型允许存储的信息加以约束，该方法也称为正则化。</li>
</ul>
<h4 id="a-调节模型大小"><a href="#a-调节模型大小" class="headerlink" title="a.调节模型大小"></a>a.调节模型大小</h4><p>比如可以减少神经网络的层数或者是神经元的数量。</p>
<h4 id="b-约束模型权重"><a href="#b-约束模型权重" class="headerlink" title="b.约束模型权重"></a>b.约束模型权重</h4><p>也就是在损失函数中引入正则化项，鼓励模型的权重更加分散。</p>
<h4 id="c-随机失活（Dropout）"><a href="#c-随机失活（Dropout）" class="headerlink" title="c.随机失活（Dropout）"></a>c.随机失活（Dropout）</h4><p>就是在训练的时候，让某一层的一部分神经元不被激活，也就是该神经元的输出值为0。</p>
<p>这里有一个超参数，即随机失活比率，失活神经元所占的比例，通常为0.2—0.5。</p>
<p>那么随机失活为什么可以解决过拟合呢？</p>
<p>（1）随机失活可以使得每次更新梯度时，参与计算的网络参数减少，降低了模型容量，所以防止了过拟合。</p>
<p>（2）随机失活鼓励权重分散，就和损失函数引入正则项一样。当某一些神经元失活后，剩下的神经元就要记住更多的信息。</p>
<p>（3）一块神经网络，相当于多个神经网络。在神经元总数不变的情况下，分别训练不同的组合，使的每一个拿出来都可以起到全部的作用，这样在预测的时候，就相当于多个神经网络在做决策。</p>
<p>但在使用的时候，还需注意一些东西，例如有如下结构：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001339.png" alt="image-20210917044311722" style="zoom:50%;" /></p>
<p>假设失活比率为0.5，那么此时有可能会有x失活，y失活，x和y都失活。那么a的均值就为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E[a]&= \frac{1}{4}\left(w_{1} x+w_{2} y\right)+\frac{1}{4}\left(w_{1} x+0 y\right)+\frac{1}{4}\left(0 x+w_{2} y\right)+\frac{1}{4}(0 x+0 y) \\
&=\frac{1}{2}\left(w_{1} x+w_{2} y\right)
\end{aligned}\tag{1.27}</script><p>此时，在测试的时候，是没有失活的，因此测试的均值为：</p>
<script type="math/tex; mode=display">
E[a]=w_{1} x+w_{2} y
\tag{1.28}</script><p>测试时的输出值和训练时的输出值的范围是不一样的，所以在测试的时候，还需要将输出值乘上0.5。</p>
<h3 id="1-2-10超参数选取"><a href="#1-2-10超参数选取" class="headerlink" title="1.2.10超参数选取"></a>1.2.10超参数选取</h3><p>超参数就是我们需要设置的参数。</p>
<p>对于网络结构—有隐层神经元个数，网络层数，激活函数的选择等参数。</p>
<p>对于优化相关—有学习率，失活比率，正则化强度等参数。</p>
<p>我们就以学习率为例，来说明如何选参数。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001345.png" alt="image-20210917045142451" style="zoom:67%;" /></p>
<p>学习率要适中，才能快速收敛，性能良好。如果太大，不能收敛。偏大，最小值附近震荡。偏小，收敛时间太长。</p>
<h4 id="a-搜索方法"><a href="#a-搜索方法" class="headerlink" title="a.搜索方法"></a>a.搜索方法</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001350.png" alt="image-20210917045323101" style="zoom: 50%;" /></p>
<p>对于两个超参数，可以用规范的网格进行选取。带到模型中，比较性能。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001355.png" alt="image-20210917045450278" style="zoom:50%;" /></p>
<p>也可在某一范围随机选取几个点。</p>
<h4 id="b-搜索策略"><a href="#b-搜索策略" class="headerlink" title="b.搜索策略"></a>b.搜索策略</h4><p>先粗略，后精细。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001400.png" alt="image-20210917045648266" style="zoom:50%;" /></p>
<h4 id="c-参数的标尺空间"><a href="#c-参数的标尺空间" class="headerlink" title="c.参数的标尺空间"></a>c.参数的标尺空间</h4><p>学习率通常在0.00001到1之间，如果在正常的数轴下，由于量级相差太大，意义不大，所以要在log空间中，进行标尺。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001405.png" alt="image-20210917045759168" style="zoom:50%;" /></p>
<h1 id="2-卷积神经网络"><a href="#2-卷积神经网络" class="headerlink" title="2.卷积神经网络"></a>2.卷积神经网络</h1><h2 id="2-0补充知识"><a href="#2-0补充知识" class="headerlink" title="2.0补充知识"></a>2.0补充知识</h2><h3 id="2-0-1卷积与图像去噪"><a href="#2-0-1卷积与图像去噪" class="headerlink" title="2.0.1卷积与图像去噪"></a>2.0.1卷积与图像去噪</h3><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001410.png" alt="image-20210918182752556" style="zoom: 50%;" /></p>
<p>去除图像中的噪点，一个最直接的办法就是和周围的像素点的灰度值进行加权求和。如下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001415.png" alt="image-20210918183118727" style="zoom: 50%;" /></p>
<p>每一个像素点都经过该操作后，就得到了一张新的去噪后的图片。这里的操作就叫作卷积操作。</p>
<p>而卷积操作中的加权的权值，我们将其存储在一个模版中，我们称其为卷积核。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001422.png" alt="image-20210918183530686"></p>
<p>卷积操作的示意图：</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216011650.gif" alt="20211215001528"></p>
<p>其中，下面蓝色的为输入图片，绿色的为卷积后的图片，下面灰色阴影部分即为卷积核。</p>
<h4 id="a-卷积的定义"><a href="#a-卷积的定义" class="headerlink" title="a.卷积的定义"></a>a.卷积的定义</h4><p>H为卷积核，F为输入图像，R为卷积操作后的图像，输出图像每一个像素点的灰度值为：</p>
<script type="math/tex; mode=display">
R_{ij}=\sum_{u,v}H_{i-u,j-v}F_{u,v}\tag{2.1}</script><p>式（2.1）表示，输出图像中的一个像素点的灰度值的计算方法。其中 $i,j$ 为输出图像中的像素点坐标，$u,v$ 为 $i,j$ 点和其周围 $n\times n$ （n为卷积核阶数）个点的坐标。</p>
<p>特别这里要注意的是，卷积操作是将卷积核旋转180度后，在与对应的像素点的灰度值相乘求和，如下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001557.png" alt="image-20210918191307439" style="zoom: 50%;" /></p>
<p>但实际过程中，我们的卷积核往往是对称的，我们常常忽略这个旋转，或者说，我们所说的卷积核是旋转过后的，但实际上是要经过一个旋转的，后面所说的卷积核就都为旋转后的。</p>
<h4 id="b-卷积的性质"><a href="#b-卷积的性质" class="headerlink" title="b.卷积的性质"></a>b.卷积的性质</h4><ul>
<li>叠加性：两个图像求和以后的卷积等于两个图像分别卷积再求和。</li>
<li>平移不变性：对于一张图片先平移再卷积和先卷积再平移的结果是一样的。（所有的平移操作都可以用卷积来实现）</li>
<li>交换律</li>
<li>结合律</li>
<li>分配律</li>
<li>标量</li>
</ul>
<p>卷积是一种基础的图像操作。</p>
<h4 id="c-边界填充"><a href="#c-边界填充" class="headerlink" title="c.边界填充"></a>c.边界填充</h4><p>在计算卷积的时候，边上的像素点的周围没有像素，所以要进行边界填充。如果不进行边界填充，卷积过后的图像会比原图像小一圈。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001602.png" alt="image-20210919014647237" style="zoom:50%;" /></p>
<p>（1）零填充（Zero padding)</p>
<p>填充周围像素点的值为0。在深度学习中常用。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001609.png" alt="image-20210919014817564" style="zoom:50%;" /></p>
<p>（2）拉伸和镜像</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001615.png" alt="image-20210919014942091" style="zoom: 67%;" /></p>
<p>拉伸填充就是把现有的图像边上拉出去一点，让扩充的像素点的值和图像的边缘的值相同。</p>
<p>镜像拉伸就是让左边的扩充像素值等于右边图片边界像素的值，右边和上下也是一样。</p>
<h4 id="d-卷积示例"><a href="#d-卷积示例" class="headerlink" title="d.卷积示例"></a>d.卷积示例</h4><p>（1）单位脉冲核</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001620.png" alt="image-20210919015416632"></p>
<p>（2）移动卷积核</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001626.png" alt="image-20210919015444298"></p>
<p>（3）平滑卷积核</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001632.png" alt="image-20210919015524376"></p>
<p>相当于磨皮，可以去噪，但是边缘也变得不明显了。</p>
<p>（4）锐化卷积核</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001638.png" alt="image-20210919015740224"></p>
<p>因为卷积的性质有分配律，所以该相减的两个卷积核的结果和图像卷积=这两个卷积核分别与图像卷积后再相减。</p>
<p>那么为什么会锐化呢？</p>
<p>我们先来看原图减去平滑图等于什么。</p>
<p>以灰度图为例：假设图像中某一像素点A的灰度值为100，周围其他点的灰度值为25。A点的灰度值相较于周围点明显不同。当卷积核为3*3，那么平滑后的图像A点的灰度值会变为$300\div9=30$，周围其他点的灰度值会稍稍变大，也为30，当原图减去平滑后的图像后，A点的灰度值为 $100-30=70$ ，周围其他点的灰度值为 $25-30=-5$ 。</p>
<p>而一像素点B，灰度值为100，周围点灰度值为90，平滑后B点灰度值为90多，其他点的灰度值也差不多，所以原图减去平滑后的图，B点的灰度值不到10，其他点的灰度值也很小。</p>
<p>此可见，整张图像的灰度值都降低，灰度值相较于周围其他点明显不同的地方，会将周边的灰度值降到很小，而灰度值原本很高的地方稍稍降低。但当灰度值变化不明显的地方，整体的灰度值都降到很低。因此，原图减去平滑后的图像得到的是边缘图像。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001644.png" alt="image-20210919030814947"></p>
<p>当边缘图再加上原图后，就可以让图像边缘的地方再次加深，得到锐化效果。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001652.png" alt="image-20210919030901732"></p>
<p>因此锐化卷积核的过程如下：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001657.png" alt="image-20210919030938561"></p>
<h4 id="e-高斯卷积核"><a href="#e-高斯卷积核" class="headerlink" title="e.高斯卷积核"></a>e.高斯卷积核</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001704.png" alt="image-20210919031204886" style="zoom:67%;" /></p>
<p>左边这幅图经过平滑卷积后，得到右边这幅图，但看右边的图，可以发现有上下左右的横线的感觉，这种现象叫做振铃，造成这种现象的原因是，在加权的时候，各个部分的权值都一样，即使远的地方，权值也一样。为了改变这种情况，引入高斯卷积核。</p>
<p>高斯卷积核就是让中心位置的权值最大，越往边缘，权值越小。</p>
<script type="math/tex; mode=display">
G_{\sigma}=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{\left(x^{2}+y^{2}\right)}{2 \sigma^{2}}}\tag{2.2}</script><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001719.png" alt="image-20210919031504756" style="zoom:67%;" /></p>
<h5 id="（1）生成步骤"><a href="#（1）生成步骤" class="headerlink" title="（1）生成步骤"></a>（1）生成步骤</h5><ul>
<li>确定卷积核的大小</li>
<li>设置高斯函数的标准差</li>
<li>通过式（2.2）计算卷积核各个位置的权值</li>
<li>对权重进行归一化，也就是所有权值之和为1</li>
</ul>
<p><strong>为什么权重要进行归一化？</strong></p>
<p>例如一张图，所有灰度值为255，如果权重没有归一化，之和为0.1，那么会对整张图片的灰度降低为原来的0.1，如果权重和为2，就会对整张图片的灰度值增长为原来的2倍。归一化的目的就是保证图像的灰度值在原来的范围内。</p>
<h5 id="（2）方差变化的影响"><a href="#（2）方差变化的影响" class="headerlink" title="（2）方差变化的影响"></a>（2）方差变化的影响</h5><p>当窗口大小一样时：</p>
<p>方差较小时，中间自身的权重较大，所以平滑的就不厉害。</p>
<p>而方差越大，中间自身的权重值较小，所以平滑的就不厉害。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001726.png" alt="image-20210919032407005"></p>
<h5 id="（3）窗口变化的影响"><a href="#（3）窗口变化的影响" class="headerlink" title="（3）窗口变化的影响"></a>（3）窗口变化的影响</h5><p>当方差一样时：</p>
<p>中间的高斯函数值虽然相同。但是窗口越大，归一化后，中间所占的权重越小，所以周围的影响较大，平滑效果越明显。</p>
<p>反之，窗口越小，归一化后，中间所占的权重越大，周围的影响越小，平滑效果越弱。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001810.png" alt="image-20210919032820648"></p>
<p>有一个经验法则：通常卷积模版的尺寸为 $2\times3\sigma+1$ ，如标准差为1，那么高斯卷积核的大小为 $7\times7$ 。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001816.png" alt="image-20210919033151354"></p>
<h5 id="（4）高斯卷积核的性质"><a href="#（4）高斯卷积核的性质" class="headerlink" title="（4）高斯卷积核的性质"></a>（4）高斯卷积核的性质</h5><ul>
<li>高斯卷积核的功能是一个低通滤波器，低通滤波器的意思就是可以过滤到高频噪声（高频噪声可以理解为噪点）。</li>
<li>两个高斯卷积核卷积后得到的还是高斯卷积核。</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001823.png" alt="image-20210919040224910" style="zoom: 33%;" /></p>
<ul>
<li>可分离性，可分解两个一维高斯的乘积（该性质可以极大减少计算量）。</li>
</ul>
<p>eg：不考虑扩充</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001828.png" alt="image-20210919040540464"></p>
<p><strong>为什么说可以减少计算量呢？</strong></p>
<p>用尺寸为 $m\times m$ 的卷积核卷积一个尺寸为 $n\times n$ 的图像，其计算复杂度为 $n^2m^2$ 。</p>
<p>如果用小方差的小模板来卷积，例如，两个卷积核的标准差为1，模板的尺寸为 $2\times3\times1+1=7$ ，此时的计算复杂度为 $49n^2$。</p>
<p>而如果直接用标准差为 $\sqrt{2}$ 的卷积模板，模板尺寸为 $2\times3\times\sqrt{2}+1=9$ ，此时计算复杂度为 $81n^2$ 。这两个卷积核的计算效果完全一样。</p>
<p>另外，如果将卷积核分离为两个一维的核，计算复杂度为  $n^2m$ 。</p>
<h4 id="f-图像噪声"><a href="#f-图像噪声" class="headerlink" title="f.图像噪声"></a>f.图像噪声</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001837.png" alt="image-20210919043141458" style="zoom:67%;" /></p>
<p>椒盐噪声：黑色像素核白色像素随机出现。</p>
<p>脉冲噪声：白色像素随机出现。</p>
<p>高斯噪声：噪声强度变化服从高斯分布。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001847.png" alt="image-20210919043430628"></p>
<script type="math/tex; mode=display">
\hat f(x,y)=f(x,y)+\eta(x,y)\quad\quad其中\eta(x,y)\rightarrow N(\mu,\sigma)\tag{2.3}</script><p>那么如何减少高斯噪声呢，当然是用高斯卷积核卷它了。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001857.png" alt="image-20210919044129815"></p>
<p>通过上图可以看出，方差越大，高斯噪声越明显。所以也需要方差更大的卷积核来平滑（当然方差增大，窗口也变大）。</p>
<h4 id="g-中值滤波"><a href="#g-中值滤波" class="headerlink" title="g.中值滤波"></a>g.中值滤波</h4><p>但是对于椒盐噪声和脉冲噪声，高斯卷积核的去噪效果就不好了。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001903.png" alt="image-20210919044510071"></p>
<p>此时需要使用中值滤波来处理。</p>
<p>中值滤波卷积核是空的，它是将窗口大小的数据都取出来，从小到大排列，然后取中间值为该像素点的灰度值。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001909.png" alt="image-20210919045017763"></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001916.png" alt="image-20210919045055087" style="zoom:67%;" /></p>
<h3 id="2-0-2卷积与边缘提取"><a href="#2-0-2卷积与边缘提取" class="headerlink" title="2.0.2卷积与边缘提取"></a>2.0.2卷积与边缘提取</h3><p>边缘是图像中亮度明显而急剧变化的点。</p>
<p>为什么要研究边缘呢？</p>
<ul>
<li>是图像中的语义与形状信息。</li>
<li>相对于像素表示，边缘表示显然更加紧凑。</li>
</ul>
<h4 id="a-边缘的种类"><a href="#a-边缘的种类" class="headerlink" title="a.边缘的种类"></a>a.边缘的种类</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001923.png" alt="image-20210919045422994"></p>
<h4 id="b-图像的导数"><a href="#b-图像的导数" class="headerlink" title="b.图像的导数"></a>b.图像的导数</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001929.png" alt="image-20210919045646382" style="zoom: 67%;" /></p>
<p>2维函数的求偏导公式为：</p>
<script type="math/tex; mode=display">
\frac{\partial f(x, y)}{\partial x}=\lim _{\varepsilon \rightarrow 0} \frac{f(x+\varepsilon, y)-f(x, y)}{\varepsilon}\tag{2.4}</script><p>因为这样求比较麻烦，要考虑无穷小量，所以图像求导公式为：</p>
<script type="math/tex; mode=display">
\frac{\partial f(x, y)}{\partial x}= \frac{f(x+1, y)-f(x, y)}{1}\tag{2.5}</script><p>也就是右边的像素值减去左边的像素值。也可以用卷积核来表示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001935.png" alt="image-20211018070901776" style="zoom:50%;" /></p>
<p>对x方向求导，得到的是y方向的边，对y方向求导，得到的是x方向的边。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001941.png" alt="image-20210919050343783" style="zoom:67%;" /></p>
<h4 id="c-图像的梯度"><a href="#c-图像的梯度" class="headerlink" title="c.图像的梯度"></a>c.图像的梯度</h4><p>图像的梯度指向灰度变化最快的方向（也就是从暗到亮）。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001948.png" alt="image-20210919050616424" style="zoom:67%;" /></p>
<p>梯度方向和边缘垂直。</p>
<p>梯度的模值越大，该点为边缘点的可能性越高。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001952.png" alt="image-20210919050743227" style="zoom:67%;" /></p>
<p>我们用梯度的模值来表示边缘信息，也就是边缘检测。</p>
<h4 id="d-噪声的影响"><a href="#d-噪声的影响" class="headerlink" title="d.噪声的影响"></a>d.噪声的影响</h4><p>如果图像存在噪声，边缘检测就会很难。所以需要先将图像平滑。根据噪声的种类选择平滑方法。</p>
<p>例如，如果是高斯噪声，就用高斯卷积核来处理。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215001959.png" alt="image-20210919051151686" style="zoom:67%;" /></p>
<p>因为图像的微分操作也是一个卷积，卷积符合交换律，所以可以将其处理顺序颠倒一下。</p>
<script type="math/tex; mode=display">
\frac{d(f*g)}{dx}=f*\frac{dg}{dx}\tag{2.6}</script><h4 id="e-高斯一阶偏导卷积核"><a href="#e-高斯一阶偏导卷积核" class="headerlink" title="e.高斯一阶偏导卷积核"></a>e.高斯一阶偏导卷积核</h4><p>（2.6）也叫做高斯一阶偏导卷积核。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002004.png" alt="image-20210919051605961" style="zoom:67%;" /></p>
<p>高斯一阶导只有一个参数，即标准差 $\sigma$ ，下面来看该参数对边缘提取的影响。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002011.png" alt="image-20210919051821817" style="zoom: 67%;" /></p>
<p>当标准差不同时，提取的边缘的粒度不同，如果小粒度细节，就采用标准差小的卷积核。</p>
<p>但是高斯一阶卷积核所提取的边缘有一个缺点，就是边缘过粗，这是因为像素灰度值变化通常是连续的，因此求导后，在一定范围内都有较大的导数值。如下图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002018.png" alt="image-20210919052444298" style="zoom: 50%;" /></p>
<p>此时引入一种方法，非最大值抑制。</p>
<h4 id="f-非最大值抑制"><a href="#f-非最大值抑制" class="headerlink" title="f.非最大值抑制"></a>f.非最大值抑制</h4><p>沿着边缘的梯度方向，保留边缘上值最大的点。</p>
<p>例如：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002025.png" alt="image-20210919052910609" style="zoom: 67%;" /></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002029.png" alt="image-20211111162057626" style="zoom: 25%;" /></p>
<p>找到边缘上的三个点p，q，r。现在就比较这三个点的梯度强度，保留梯度强度最大的点。</p>
<p>注意：通常情况下，q，r的坐标不是整数，需要插值。</p>
<h4 id="g-Canny边缘检测器"><a href="#g-Canny边缘检测器" class="headerlink" title="g.Canny边缘检测器"></a>g.Canny边缘检测器</h4><p>非最大值抑制以后，还有一个问题。</p>
<p>如果存在噪声，我们需要设置一个门限来过滤一下，如果门限过高， 许多细节边就显现不出来了；如果门限过低，就有太多的细节都出来。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002037.png" alt="image-20210919054109124" style="zoom:67%;" /></p>
<p>所以这个门限不太好设置。Canny算法选取双域值，先用高域值提取出主要的边缘，在用低域值，找出细节，保留和之前高域值提取出的边缘相连的边缘。</p>
<h3 id="2-0-3纹理表示"><a href="#2-0-3纹理表示" class="headerlink" title="2.0.3纹理表示"></a>2.0.3纹理表示</h3><p>纹理分为规则纹理和随机纹理。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002043.png" alt="image-20210919054648529" style="zoom: 67%;" /></p>
<p>想要表示这些纹理，规则的还好，形状大小都几乎相同。但是对于随机纹理的提取，就十分困难了。</p>
<p>有一个思路，就是用卷积核组来提取图像中的纹理，然后用基元的统计信息来表示图像中的纹理。</p>
<h4 id="a-卷积核组"><a href="#a-卷积核组" class="headerlink" title="a.卷积核组"></a>a.卷积核组</h4><p>由多个卷积核组成的一个卷积核组。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002050.png" alt="image-20210919150435866"></p>
<p>前面学过，高斯一阶卷积核，如上图左边，它可以提取出x方向的边缘。其他的卷积核也类似。特别的，最后一个卷积核可以提取出环形的边缘。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002056.png" alt="image-20210919160306939" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002105.png" alt="image-20211018064610184" style="zoom: 67%;" /></p>
<h4 id="b-基于卷积核组的图像表示"><a href="#b-基于卷积核组的图像表示" class="headerlink" title="b.基于卷积核组的图像表示"></a>b.基于卷积核组的图像表示</h4><p>在设计出一组卷积核组后，我们用这组卷积核来对图像进行卷积操作，获得对应的特征响应图组。然后再用特征响应图组的统计信息，来表示图像中的纹理。</p>
<p>eg：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002112.png" alt="image-20210919160721303"></p>
<p>$r_i$ 是将得到的一幅特征响应图拉成的向量，例如原图为$100\times 100$的尺寸，卷积后得到的特征响应图也为 $100\times 100$ ，拉成向量就是10000维的向量。在这个向量中，包括了提取出的边缘形状信息，也包括边缘所处的位置信息。但是我们是要表现出纹理特征，从而制定一种描述纹理特征的方式，所以位置信息是不重要的。因此采取的办法是将这个10000维的向量各个元素求平均，用平均值来表达该种边缘“有多少”。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002125.png" alt="image-20210919161306955" style="zoom:80%;" /></p>
<p>eg：有下面三幅图，分别用卷积核组进行上述处理，该卷积核组共有7个卷积核。卷积后得到了一个7维的向量。这个向量中的每一个元素都表示对应的边缘有多少。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002133.png" alt="image-20210919161538770" style="zoom:67%;" /></p>
<p>在这里，白色的代表值越大，就说明该种边缘在图中占据最多。</p>
<h4 id="c-卷积核组的设计"><a href="#c-卷积核组的设计" class="headerlink" title="c.卷积核组的设计"></a>c.卷积核组的设计</h4><p>卷积核组的设计要尽量包括各种边缘的类型，各种尺度，还有各个方向。</p>
<p>设计重点：</p>
<ul>
<li>卷积核类型</li>
<li>卷积核尺度</li>
<li>卷积核方向</li>
</ul>
<p>实际的例子：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002140.png" alt="image-20210919161909622" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002146.png" alt="image-20210919161944107" style="zoom:80%;" /></p>
<p>这样我们便可以将一张图的纹理特征表示出来。</p>
<p>从图像的纹理表示可以隐隐的知道，卷积神经网络的原理了，就是通过卷积核组，将一张图片的纹理描述出来（也就是各种边缘的统计信息），然后通过对纹理特征，来进行分类。</p>
<h2 id="2-1卷积神经网络结构"><a href="#2-1卷积神经网络结构" class="headerlink" title="2.1卷积神经网络结构"></a>2.1卷积神经网络结构</h2><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002152.png" alt="image-20210919213159199"></p>
<p>包括四个部分：</p>
<ul>
<li>CONV——卷积层</li>
<li>RELU——激活层</li>
<li>POOL——池化层</li>
<li>FC——全连接层</li>
</ul>
<h3 id="2-1-1全连接神经网络的瓶颈"><a href="#2-1-1全连接神经网络的瓶颈" class="headerlink" title="2.1.1全连接神经网络的瓶颈"></a>2.1.1全连接神经网络的瓶颈</h3><p>当图像太大时，需要训练的权值参数太多。</p>
<p>例如，CIFAR10图像尺寸为 $32\times32\times3$ ,隐层中的每个神经元的权值个数就为 3072个。</p>
<p>如果图像是 $200\times200\times3$ ，那么隐层中的每个神经元的权值个数就为120000个。</p>
<p>如果权值参数过多，计算量大不说，也很容易造成过拟合。</p>
<p>所以全连接神经网络仅适合处理小的图像。</p>
<p>怎么才能获得小图像呢，可以看到，当图像经过卷积核组卷积后，对输出值进行加权，就可以得到一个维度很小的向量，所以我们想将图像先经过卷积核组处理，然后得到一个维数较低的向量，在把这个向量作为全连接神经网络的输入。</p>
<h3 id="2-1-2卷积层"><a href="#2-1-2卷积层" class="headerlink" title="2.1.2卷积层"></a>2.1.2卷积层</h3><h4 id="a-卷积网络中的卷积核"><a href="#a-卷积网络中的卷积核" class="headerlink" title="a.卷积网络中的卷积核"></a>a.卷积网络中的卷积核</h4><p>与前面所学的卷积核不同的是，卷积神经网络中的卷积核是一个“立体的”。</p>
<p>因为图像通常是彩色的，每个像素点有RGB三个通道，所以卷积核需要对每个通道进行卷积操作，因此卷积核是一个立体的。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002158.png" alt="image-20210919165628361" style="zoom:67%;" /></p>
<p>另外一个不同时，卷积核还有一个偏置。也就是卷积过后，对得到的结果再加上一个偏置值。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002202.png" alt="image-20210919165853023" style="zoom:67%;" /></p>
<h4 id="b-卷积网络中的卷积操作"><a href="#b-卷积网络中的卷积操作" class="headerlink" title="b.卷积网络中的卷积操作"></a>b.卷积网络中的卷积操作</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002209.png" alt="image-20210919170339406" style="zoom:80%;" /></p>
<p>一个三通道图经过卷积核卷积后，就得到了一个特征响应图，该响应图为1个通道，在没有边界补充的情况下，得到的特征响应图是 $28\times28\times1$ 。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002215.png" alt="image-20210919171450381" style="zoom:67%;" /></p>
<p>如果用6个卷积核，卷积后就得到6个特征响应图。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002220.png" alt="image-20210919171610690" style="zoom:67%;" /></p>
<p>总结：</p>
<ul>
<li>特征响应图组深度等于卷积核的个数。</li>
<li>不同特征响应图反映了输入图像对不同卷积核的响应结果</li>
<li>同一特征响应图上不同位置的值表示输入图像上不同位置对同一卷积核的响应结果。</li>
</ul>
<h4 id="c-卷积步长"><a href="#c-卷积步长" class="headerlink" title="c.卷积步长"></a>c.卷积步长</h4><p>卷积神经网络中，卷积核可以按照指定的间隔进行卷积操作，这个间隔就是卷积步长。</p>
<p>卷积步长可以影响输出的特征响应图的大小。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002414.png" alt="image-20211215002414442" style="zoom: 33%;" /></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002537.png" alt="image-20211215002537453" style="zoom:33%;" /></p>
<script type="math/tex; mode=display">
\begin{aligned}
&W 2=(W 1-F) / S+1 \\
&H 2=(H 2-F) / S+1
\end{aligned}\tag{2.7}</script><p>其中，输入图片大小为：$W1\times H1$ ，输出图像大小为：$W2\times H2$ 。F为卷积的大小，S为卷积步长。</p>
<p>eg：输入图像为7，卷积核大小为3，步长为1。</p>
<p>输出图像大小=（7-3）/1 +1=5</p>
<h4 id="d-边界填充"><a href="#d-边界填充" class="headerlink" title="d.边界填充"></a>d.边界填充</h4><p>如果没有边界填充，如前面的例子，卷积操作后会使图像变小。</p>
<p>而卷积神经网络中常用的填充方式是零值填充。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002555.png" alt="image-20210919173529384" style="zoom:80%;" /></p>
<p>边界填充与输入输出图像大小还有卷积步长之间的关系为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&W 2=(W 1-F+2 P) / S+1 \\
&H 2=(H 2-F+2 P) / S+1
\end{aligned}\tag{2.8}</script><p>这里P是一边填充的层数，如上图就是填充了1层。</p>
<p>通过式（2.8）还可以已知输入和输出图像，反求出填充层数。</p>
<h4 id="e-特征响应图尺寸计算"><a href="#e-特征响应图尺寸计算" class="headerlink" title="e.特征响应图尺寸计算"></a>e.特征响应图尺寸计算</h4><p>由前面的学习，可知特征响应图的尺寸大小主要与以下几个参数有关：</p>
<ul>
<li>卷积核的宽，高；</li>
<li>是否采用边界填充操作；</li>
<li>卷积步长；</li>
<li>该层的卷积核个数（主要影响特征响应图的深度）</li>
</ul>
<p>以上这四个参数是超参数。</p>
<h3 id="2-1-3池化层"><a href="#2-1-3池化层" class="headerlink" title="2.1.3池化层"></a>2.1.3池化层</h3><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002601.png" alt="image-20210919213159199"></p>
<p>卷积神经网络的结构如上图所示，先一层卷积层，然后接一个RELU激活函数层，就是让卷积后的图像每一个像素点的值都经过RELU激活函数。然后再经过一层POOL层，也就是池化层。</p>
<h4 id="a-池化层的作用"><a href="#a-池化层的作用" class="headerlink" title="a.池化层的作用"></a>a.池化层的作用</h4><p>之前的卷积操作时，每张图片有三个通道，所以一个卷积核也是3维的，对三个通道一同处理。当有n个卷积核组成一个卷积核组时，得到n个特征响应图，因此这个特征响应图是有n个通道的。</p>
<p>池化操作是对每一个特征响应图独立进行，降低特征响应图组中每个特征响应图的宽度和高度，减少后续卷积层的参数的数量，降低计算资源耗费，控制过拟合。因此池化操作后，仍然有n个特征响应图。</p>
<p>另外一点，缩小图像，卷积核大小不变，此时就相当于卷积核变大，就可以看到更大的纹理。</p>
<h4 id="b-池化操作"><a href="#b-池化操作" class="headerlink" title="b.池化操作"></a>b.池化操作</h4><p>对特征响应图某个区域进行池化就是在该区域上指定一个值来代表整个区域。</p>
<p><strong>常见的池化操作：</strong></p>
<p>最大池化：使用区域内的最大值来代表这个区域。</p>
<p>平均池化：采用区域内所有值的均值作为代表。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002615.png" alt="image-20210920004702991" style="zoom:80%;" /></p>
<p>最大池化就相当于之前讲的非最大化值抑制，我们只保留一个区域的最大值，就是把最明显的特征表示出来。因此上图的最大池化操作后，特征响应图中的75%的响应信息都丢掉，但不改变特征响应图的个数。</p>
<p>在池化操作中，池化的步长和窗口大小是两个超参数。</p>
<p>在训练后的卷积神经网络中，前面的卷积层记录的是纹理基元信息，如边缘，圆环等等形状基元。越往后的卷积层记录的是高层的基元，可能是一个人脸的模版，只要图片中有人脸，它就会响应。</p>
<h2 id="2-2图像增强"><a href="#2-2图像增强" class="headerlink" title="2.2图像增强"></a>2.2图像增强</h2><h3 id="2-2-1图像增强的提出"><a href="#2-2-1图像增强的提出" class="headerlink" title="2.2.1图像增强的提出"></a>2.2.1图像增强的提出</h3><p>存在问题：过拟合的原因是学习样本太少，导致无法训练出能够泛化到新数据的模型。</p>
<p>于是采用数据增强的办法，就是从现有的训练样本中生成更多的训练数据，其方法是利用多种能够生成可信图片的随机变换来增加样本。</p>
<p>数据增强的目标：模型在训练时不会两次查看完全相同的图像。这能够让模型观察到数据的更多内容，从而具有更好的泛化能力。</p>
<h3 id="2-2-2样本增强的方法"><a href="#2-2-2样本增强的方法" class="headerlink" title="2.2.2样本增强的方法"></a>2.2.2样本增强的方法</h3><h4 id="a-翻转"><a href="#a-翻转" class="headerlink" title="a.翻转"></a>a.翻转</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002626.png" alt="image-20210920010950446" style="zoom: 67%;" /></p>
<h4 id="b-随机缩放和抠图"><a href="#b-随机缩放和抠图" class="headerlink" title="b.随机缩放和抠图"></a>b.随机缩放和抠图</h4><p>得到一张图以后，对其进行缩放再截取抠图。相当于从多个视角看原有的图像中的内容。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002632.png" alt="image-20210920012602034"></p>
<p><strong>以残差网络中的样本增强方法为例：</strong></p>
<p>输入要求：$224\times224$ 的彩色图片。</p>
<p>在训练的时候：在不同尺度、不同区域随机扣取。</p>
<p>对于现有的训练数据集，有很多的图片，我们这样做：</p>
<ul>
<li>先在[256,480]之间随机选择一个尺寸L。</li>
<li>将训练数据集中的图拍呢缩放至短边为L的图像。</li>
<li>在该缩放后的样本图像中，随机采样一个$224\times224$ 的图像区域。</li>
</ul>
<p>在测试的时候：按照一套预先定义的方式扣取</p>
<ul>
<li>将图像缩放成5种尺寸：{224,256,384,480,640}。</li>
<li>对每一个尺度的图像及其镜像图片，分别在四个角和中间位置扣取$224\times224$ 区域。</li>
</ul>
<h4 id="c-色彩抖动"><a href="#c-色彩抖动" class="headerlink" title="c.色彩抖动"></a>c.色彩抖动</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002638.png" alt="image-20210920012629968"></p>
<h1 id="3-经典网络分析"><a href="#3-经典网络分析" class="headerlink" title="3.经典网络分析"></a>3.经典网络分析</h1><p>按照时间的顺序，介绍5种经典的卷积神经网络。这5种卷积神经网络在ImageNet大赛上都取得了跨越式的成绩。</p>
<h2 id="3-1AlexNet"><a href="#3-1AlexNet" class="headerlink" title="3.1AlexNet"></a>3.1AlexNet</h2><p>2012年提出的该网络。其主要贡献有：</p>
<ul>
<li>提出了一种卷积层和全连接层的神经网络结构</li>
<li>首次使用ReLU函数作为激活函数</li>
<li>首次提出Dropout正则化来控制过拟合</li>
<li>使用加入动量的小批量梯度下降算法加速了训练过程的收敛</li>
<li>使用数据增强策略极大的抑制了训练过程的过拟合</li>
<li>利用GPU并行计算，加速了网络的训练和推断</li>
</ul>
<p>网络结构</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002645.png" alt="image-20210921162339688" style="zoom:50%;" /></p>
<p>AlexNet共有卷积层，池化层，局部响应归一化层，全连接层四部分组成，如上图所示。</p>
<blockquote>
<p>补充：在计算神经网络层数时，仅统计卷积层和全连接层，因为池化层与归一化层仅对前面的卷积层的输出的特征图进行后处理，不单独算做一层。</p>
</blockquote>
<p>AlexNet共有5个卷积层和3个全连接层。</p>
<h3 id="3-1-1卷积层"><a href="#3-1-1卷积层" class="headerlink" title="3.1.1卷积层"></a>3.1.1卷积层</h3><p>第一层卷积（CONV1）：96个 $11\times11$ 的卷积核，步长为4，没有零填充。</p>
<p><strong>ques：如果输入的是 $227\times227\times3$ 的图像，输出的特征响应图的个数和尺寸？</strong></p>
<p>$(227-11)/4+1=96$ 个，因此输出的特征响应图是 $96\times96\times1$ ，共有96个。</p>
<p><strong>ques：这层共有多少个参数？</strong></p>
<p>$96\times(11\times11\times3+1)=35k$ ，因为每一个卷积核还有一个偏置。</p>
<p>所以经过该层卷积后，得到96个 $96\times96$ 的特征响应图，然后特征响应图的每一个元素经过ReLU激活函数处理。</p>
<p>第二层卷积（CONV2）：256个 $5\times5$ 的卷积核，步长为1，使用零填充p=2。</p>
<p>另外需要注意的是，第二层卷积层处理的图像大小相对于第一层处理的图像大小，小了很多，这样就好比第二层的卷积层在原图上有着更大的视野。</p>
<p>第三层和第四层（CONV3，CONV4）：384个 $3\times3$ 卷积核，步长为1，使用零填充p=1。</p>
<p>第五层卷积（CONV5）：256个 $3\times3$ 的卷积核，步长为1，使用零填充p=1。</p>
<p>然后通过最大池化层进一步缩小特征图尺寸。</p>
<h3 id="3-1-2池化层"><a href="#3-1-2池化层" class="headerlink" title="3.1.2池化层"></a>3.1.2池化层</h3><p>Max POOL1:窗口大小为 $3\times3$ ，步长为2</p>
<p>它的作用是降低特征响应图的尺寸，对抗轻微的目标偏移带来的影响。这个对抗目标偏移就是在一定的区域内，选择数值最大的数作为该像素点的值，因为即使这个最大值偏移到该区域的别的像素，也会被采集，作为该点的值。</p>
<p>还要注意的是，窗口大小为  $3\times3$ ，步长是2，这在池化的过程中，会使窗口产生重叠，这样能够对抗过拟合。</p>
<p>ques:输入图片为 $55\times55$ ，池化后的尺寸？<br>$(55-3)/2+1=27$ ,特征响应图的个数不变。</p>
<p>该层的参数个数为0。</p>
<h3 id="3-1-3局部归一化层"><a href="#3-1-3局部归一化层" class="headerlink" title="3.1.3局部归一化层"></a>3.1.3局部归一化层</h3><p>作用：</p>
<ul>
<li>对局部神经元的活动创建竞争机制</li>
<li>响应比较大的值变得相对更大</li>
<li>抑制其他反馈小的神经元</li>
<li>增强模型的泛化能力</li>
</ul>
<p>该方法现在的网络通常不用。</p>
<h3 id="3-1-4全连接层"><a href="#3-1-4全连接层" class="headerlink" title="3.1.4全连接层"></a>3.1.4全连接层</h3><p>全连接神经网络分类器。</p>
<p>输入是特征响应图组，输出为图像类别概率。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002651.png" alt="image-20210921165054112" style="zoom: 67%;" /></p>
<p>将特征响应图组中的每一个特征响应图展开成一个向量，然后作为输入，输入到全连接层。</p>
<p>注意：卷积层和全连接层是共同训练的</p>
<h3 id="3-1-5卷积层的作用"><a href="#3-1-5卷积层的作用" class="headerlink" title="3.1.5卷积层的作用"></a>3.1.5卷积层的作用</h3><p>卷积层的作用就是提取图像的特征，低层的卷积层提取的是低等的结构基元，越高层的卷积层越具有语义信息，将这些基元进行组合，得到某种类别的结构信息。然后输入到全连接层进行分类。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002656.png" alt="image-20210921165633179" style="zoom:67%;" /></p>
<h2 id="3-2-ZFNet"><a href="#3-2-ZFNet" class="headerlink" title="3.2 ZFNet"></a>3.2 ZFNet</h2><p>ZFNet神经网络的结构与AlexNet的结构基本一致。</p>
<p>主要的改进有：</p>
<ul>
<li>将第一个卷积层的卷积核大小改为7</li>
<li>将第二和第三个卷积层的卷积步长都设置为2</li>
<li>增加了第三和第四个卷积层的卷积核数量</li>
</ul>
<p>第一层的卷积核改小，是防止细粒度信息丢失。</p>
<p>步长改小，防止图像的尺寸降低过快。</p>
<p>因为在后面的卷积层已经出现了语义信息，所以增加卷积核个数，有助于增强描述能力。</p>
<h2 id="3-3-VGG"><a href="#3-3-VGG" class="headerlink" title="3.3 VGG"></a>3.3 VGG</h2><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002702.png" alt="image-20210921170404131" style="zoom:67%;" /></p>
<p>VGG卷积神经网络主要有两种结构，一个是16层，一个是19层。19层的精度略高，但是会占用计算资源，所以VGG16常用。</p>
<p>VGG16共有13个卷积层，3个全连接层。</p>
<p>共分为5段，CONV1——CONV5，每段的卷积层的卷积核个数都相同。</p>
<p>卷积层均采用大小为3的卷积核核ReLU激活函数。</p>
<p>池化层采用最大池化，窗口大小为2，步长为2。</p>
<p>每经过一次池化，后层的卷积核个数就增大一倍，直到512。</p>
<p>全连接层中采用了Dropout策略。</p>
<p><strong>ques：小卷积核有哪些优势？</strong></p>
<p>多个小尺寸卷积核串联可以得到与大尺寸卷积核相同的感受野。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002707.png" alt="image-20210921173002501" style="zoom: 67%;" /></p>
<p>同时，使用小卷积核串联，构建的神经网络更深，非线性更强，参数也更少。</p>
<p>假设，输入和输出的图像的个数均为C，这个C也就是深度值。</p>
<p>那么3个小卷积核串联的总参数为：$(3\times3\times C)\times C\times3=27C^2$ ，就是尺寸 $\times$ 尺寸 $\times$ 深度 $\times$ 卷积核个数 $\times$ 3。</p>
<p>而用一个尺寸为7的大卷积核的参数个数为：$(7\times7\times C)\times C=49C^2$ 。</p>
<p><strong>ques：为什么前四段的卷积层，每经过一次池化操作，卷积核个数就增加一倍？</strong></p>
<p> 池化操作可以减少特征图尺寸，降低显存占用。</p>
<p>增加卷积核个数有助于学习更多的结构特征，但会增加网络参数数量以及内存消耗。</p>
<p>一增一减的设计平衡了识别精度与存储计算的开销。</p>
<p><strong>ques：为什么卷积核个数增加到512后就不再增加了？</strong></p>
<p>最后一层卷积层与全连接层相连，第一层全连接层的参数个数为102M，占总参数的75%。</p>
<p>全连接网络第一层的参数个数是最后一层卷积层输出的特征图尺寸乘以个数。</p>
<h2 id="3-4-GoogleNet"><a href="#3-4-GoogleNet" class="headerlink" title="3.4 GoogleNet"></a>3.4 GoogleNet</h2><p>GoogleNet的创新点：</p>
<ul>
<li><p>提出了一种Inception结构，它能保留输入信号中的更多特征信息。</p>
</li>
<li><p>去掉了AlexNet的前两个全连接层，并采用了平均池化，这一设计可以使参数大大减少。</p>
</li>
<li>在网络中引入辅助分类器，克服了训练过程中的梯度消失问题。</li>
</ul>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002713.png" alt="image-20210921174439835" style="zoom:67%;" /></p>
<p>首先说一下纯串联结构的问题：</p>
<p>就是后层的卷积层只能处理前层输出的特征响应图，前层可能因为某些原因（比如感受野受限）丢失重要的信息，后层无法找回。</p>
<p>所以GoogleNet提出的Inception结构可以尽量保留输入信号更多的信息。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002718.png" alt="image-20210921174802435" style="zoom:67%;" /></p>
<p>这个模块就是在该层设置不同尺寸大小的卷积核组，对输入图像进行处理，来提取不同尺度的特征，从而获得更多的信息。而MaxPOOL的作用是对原图数值比较大的地方进行扩张，就是让那一像素点周围的像素值都和它相同。</p>
<p>在该网络中，这个模块的结构如下图所示：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002723.png" alt="image-20210921175222312" style="zoom:67%;" /></p>
<p>在大尺寸的卷积核前加上一层尺寸为1的卷积核组，对图像进行压缩处理，使图像的深度变为1。如下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002731.png" alt="image-20210921175625286" style="zoom:67%;" /></p>
<p>可以看出，参数数量大约下降3倍。所以该结构的优点是<strong>层数更深，参数更少，计算效率更高，非线性表达能力更强。</strong></p>
<p>GoogleNet共堆叠了9个Inception  V1模块。</p>
<p>然后再卷积层核全连接层链接的地方，加入了一个平均池化模块，可以有效的降低全连接层的参数。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002754.png" alt="image-20210921180124503" style="zoom:67%;" /></p>
<p>另外，在该神经网络中，还加入了辅助分类损失。如下图：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002800.png" alt="image-20210921180315580" style="zoom:67%;" /></p>
<p>虽然ReLU激活函数可以一定程度的解决梯度消失的问题，但并不能完全解决深层网络难以训练的问题。离输出远的层就不如离输出近的层训练得好。所以让低层的卷积层也有损失函数，可以让低层的卷积层更好的被训练，也能加速整个网络的收敛速度。</p>
<p>在预测时，仅利用网络的最后的输出作为预测结果，忽略辅助分类器的输出。</p>
<p><strong>ques：平均池化向量核直接展开向量化有什么区别？</strong></p>
<p>特征响应图上的每个位置的值反映了图像对应位置的结构与卷积核记录的语义结构的相似程度。平均池化丢失了语义结构的空间位置信息。这样有利于提升卷积层提取到的特征的平移不变性。</p>
<p><strong>ques：利用尺寸为1的卷积核进行压缩会损失信息么？</strong></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002806.png" alt="image-20210921181011718" style="zoom:67%;" /></p>
<h2 id="3-5-ResNet"><a href="#3-5-ResNet" class="headerlink" title="3.5 ResNet"></a>3.5 ResNet</h2><p>首先考虑一个问题：持续的向一个基础的神经网络结构上面叠加更深的层数会发生什么？</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002811.png" alt="image-20210921181415315" style="zoom:67%;" /></p>
<p>如上图所示：测试集的误差增多，是因为过拟合造成的。但是训练集的误差不应该增加呀。</p>
<p>原因是当网络的层数增加，会造成正向信息流核反向梯度流传播不顺畅，使一些参数得不到训练。</p>
<p>ResNet卷积神经网络就是主要解决这样一个问题。</p>
<p>主要贡献：</p>
<ul>
<li>提出了一种残差模块，通过堆叠残差模块可以构建任意深度的神经网络，而不会出现退化的情况。</li>
<li>提出了批归一化方法来对抗梯度消失，该方法降低了网络训练过程对于权重初始化的依赖。</li>
<li>提出了一种针对ReLU激活函数的初始化方法。</li>
</ul>
<p>后两个问题前面都已经讲过，现在主要说第一点。</p>
<p>研究人员考虑这样一个问题，就是浅层网络学习了有效的分类模式后，如何有效的向上堆积新层来建立更深的网络，使其满足即使不能提升浅层网络的性能，深层网络也不应该降低性能。</p>
<p>这就引出了残差模块：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002816.png" alt="image-20210921182150081" style="zoom:67%;" /></p>
<p>就是对输入图像进行卷积处理，然后与未经处理的输入图像进行叠加，这样做即使卷积操作后的输出是0，但是仍可以保证X继续输入到下一层。这样就保证了信息流的正向传递。这就有点像锐化操作，在保留原图的基础上，把感兴趣的特征再次叠加到原图上。</p>
<p>卷积层学习的变换为F(X)，残差结构的输出为 H(X)。</p>
<script type="math/tex; mode=display">
H(X)=F(X)+X\tag{3.1}</script><p>在反向梯度传递时：</p>
<script type="math/tex; mode=display">
\frac{\partial{H(X)}}{\partial{X}}=\frac{\partial{F(X)}}{\partial X}+1\tag{3.2}</script><p>即使前面一项为0，但是梯度也不为0。</p>
<script type="math/tex; mode=display">
F(X)=H(X)-X\tag{3.3}</script><p>其中 F(X) 为残差项，训练就是对该项进行训练。所以叫做残差模块。</p>
<p><strong>ques：残差网络为什么性能这么好？</strong></p>
<p>残差网络可以看作是一种集成模型。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002823.png" alt="image-20210921182857292" style="zoom:67%;" /></p>
<p>残差网络和Inception V4是公认的推广性能最好的两个分类模型</p>
<h1 id="4-其他任务"><a href="#4-其他任务" class="headerlink" title="4.其他任务"></a>4.其他任务</h1><p>前面我们学习的都是针对图像分类任务提出的解决方案，现在讨论在应对其他任务时的解决方案。</p>
<ul>
<li>分类问题：分类问题是对每一张图片进行分类，是整张图片的类别。</li>
<li>语义分割：本质上也是分类问题，与分类问题不同的是，需要对一张图片上的每一个像素点都进行分类，是像素级别的分类问题。</li>
<li>目标检测：是一个区域级别的分类问题。</li>
<li>实例分割： 对实例进行分割。类似于语义分割，但不同的是语义分割中，同一个类别的东西，标签都一样，例如有两只猫，这两只猫的标签是一样的。而实例分割中，这两只猫的标签是不同的。</li>
</ul>
<h2 id="4-1语义分割"><a href="#4-1语义分割" class="headerlink" title="4.1语义分割"></a>4.1语义分割</h2><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002830.png" alt="image-20210922235321815" style="zoom:67%;" /></p>
<h3 id="4-1-1滑动窗口"><a href="#4-1-1滑动窗口" class="headerlink" title="4.1.1滑动窗口"></a>4.1.1滑动窗口</h3><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002838.png" alt="image-20210922235444838" style="zoom:67%;" /></p>
<p>该方法是，取一个滑动窗口，让每一个像素点和其周围的像素点作为一张图片，进行分类。</p>
<p>但是该方法有一个问题，就是滑动窗口，有很多重叠的区域的特征被反复计算，因此效率太低。</p>
<h3 id="4-1-2-全卷积"><a href="#4-1-2-全卷积" class="headerlink" title="4.1.2 全卷积"></a>4.1.2 全卷积</h3><p>采用全卷积神经网络进行学习。在卷积层中，卷积操作不改变图像的大小，即对每个像素点都进行分类，特征响应图的深度等于类别的数量。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002845.png" alt="image-20210923000057185" style="zoom:67%;" /></p>
<p>但是该方法也存在一个弊端，那就是在卷积操作中，因为不改变图像的大小，所以会占用大量的显存，导致硬件条件不允许。</p>
<p>改进的方法就是改变卷积的结构，采用下采样和上采样过程。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002852.png" alt="image-20210923000227495" style="zoom:67%;" /></p>
<p>所谓下采样，就是我们之前所说的，每经过一次卷积或者是池化，都会使图像的尺寸减小。</p>
<p>而上采样，与这个过程正好相反。上采样就是经过一次这样的处理，使图像尺寸变大。</p>
<p>经过这样的操作，就可以在中间层减小图像尺寸，从而降低显存的占用。而有可以满足对每个像素点进行分类。</p>
<h3 id="4-1-3上采样方法"><a href="#4-1-3上采样方法" class="headerlink" title="4.1.3上采样方法"></a>4.1.3上采样方法</h3><h4 id="a-反池化操作"><a href="#a-反池化操作" class="headerlink" title="a.反池化操作"></a>a.反池化操作</h4><p>（1）Nearest Neighbor</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002857.png" alt="image-20210923001003199" style="zoom:67%;" /></p>
<p>就是对周围的像素赋予一样的值。</p>
<p>（2）Bed of Nails</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002902.png" alt="image-20210923001044839" style="zoom:67%;" /></p>
<p>对周围像素补0。</p>
<p>（3）Max Unpooling</p>
<p>这个与（2）不同的是，在池化时，记住每一个值的位置。反池化时，把这个值填到原来的位置上，其余的补0。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002910.png" alt="image-20210923001325387" style="zoom: 67%;" /></p>
<p>以上的方法在程序中，程序是固定的，也没有什么参数。</p>
<p>我们就想，可不可以通过加权的方式对周围的像素赋值，使其尺寸变大呢？加权的参数可不可以通过训练的方法得到呢？</p>
<p>这就引出了转置卷积的方法。</p>
<h4 id="b-转置卷积"><a href="#b-转置卷积" class="headerlink" title="b.转置卷积"></a>b.转置卷积</h4><p>现在我们回顾一下卷积操作：<br>尺寸为3的卷积核，步长为2，零填充为1，输入一个尺寸为4的图像。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002916.png" alt="image-20210923002017235" style="zoom:67%;" /></p>
<p>可以看到中间有两个窗口重叠的地方。</p>
<p>那么现在反过来，输入图像尺寸为2，输出为4。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002921.png" alt="image-20210923002202360" style="zoom:67%;" /></p>
<p>可以知道，在卷积中，红色方块的值是从红色窗口中来的，蓝色方框的值是从蓝色窗口来的。重叠部分就表明，该部分的值既参与了红色方块值的计算，也参加了蓝色方块的计算。</p>
<p>所以重叠部分的值要经过这两个方块值的加权，才能还原回来，这个加权的参数就可以通过训练得到。</p>
<p><strong>eg：一个一维的例子</strong></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002926.png" alt="image-20210923002921998" style="zoom:67%;" /></p>
<p>还是一维的例子，假设有一个向量 $[a,b,c,d]^T$ ，现在有一个一维的卷积核 $\vec x=[x,y,z]$ ，步长为1，零填充为1， 对其卷积，写成矩阵的形式为</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccccc}
x & y & z & 0 & 0 & 0 \\
0 & x & y & z& 0 & 0 \\
0 & 0 & x & y & z & 0 \\
0 & 0 & 0 & x & y & z
\end{array}\right]\left[\begin{array}{l}
0 \\
a \\
b \\
c \\
d \\
0
\end{array}\right]=\left[\begin{array}{c}
a y+b z \\
a x+b y+c z \\
b x+c y+d z \\
c x+d y
\end{array}\right]\tag{4.1}</script><p>（4.1）还可以写成：</p>
<script type="math/tex; mode=display">
X*\vec a=\vec b\tag{4.2}</script><p>当我们想上采样时，只需要将（4.1）左边的矩阵进行转置，就可以得到大尺寸的图像。</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccc}
x & 0 & 0 & 0 \\
y & x & 0 & 0 \\
z & y & x & 0 \\
0 & z & y & x \\
0 & 0 & z & y \\
0 & 0 & 0 & z
\end{array}\right]\left[\begin{array}{c}
a \\
b \\
c \\
d
\end{array}\right]=\left[\begin{array}{c}
a x \\
a y+b x \\
a z+b y+c x \\
b z+c y+d x \\
c z+d y \\
d z
\end{array}\right]\tag{4.3}</script><p><strong>eg：二维的例子</strong></p>
<p>就是我们图像处理的卷积核，有一个图像大小为4，卷积核大小为3，步长为1，零填充为1。</p>
<p>卷积核可以写成：</p>
<script type="math/tex; mode=display">
C=\left[\begin{array}{ccc}
x_1&x_2&x_3\\
y_1&y_2&y_3\\
z_1&z_2&z_3
\end{array}\right]=[\vec v_1\ \vec v_2\ \vec v_3]\tag{4.4}</script><p>零填充后的图像可以写成：</p>
<script type="math/tex; mode=display">
I=\left[\begin{array}{cccccc}
0&0&0&0&0&0 \\
0&a_1&a_2&a_3&a_4&0 \\
0&b_1&b_2&b_3&b_4&0 \\
0&c_1&c_2&c_3&c_4&0 \\
0&d_1&d_2&d_3&d_4&0 \\
0&0&0&0&0&0
\end{array}\right]=[\vec i_1\ \vec i_2\ \vec i_3\ \vec i_4\ \vec i_5\ \vec i_6]\tag{4.5}</script><p>那么卷积核中的向量 $\vec v_i$ 对应的卷积矩阵为 $X_i是{4\times 6}$维 ，所以图像的卷积可以表示成：</p>
<script type="math/tex; mode=display">
\begin{aligned}{}
C*I&=[X_1\vec i_n+X_2\vec i_{n+1}+X_3\vec i_{n+2}]_{4\times4}\\
&=[X_1\quad X_2\quad X_3]_{4\times 18}
\left[\begin{array}{l}
\vec i_n\\\vec i_{n+1}\\ \vec i_{n+2}
\end{array}\right]_{18\times1}
\end{aligned}
\quad n=1,2,3,4\tag{4.6}</script><h2 id="4-2目标检测"><a href="#4-2目标检测" class="headerlink" title="4.2目标检测"></a>4.2目标检测</h2><h3 id="4-2-1单目标检测"><a href="#4-2-1单目标检测" class="headerlink" title="4.2.1单目标检测"></a>4.2.1单目标检测</h3><p>目标检测包含了两个问题，一个是分类问题，就是知道图像中有什么东西，另一个是定位问题，确定这个东西在哪。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002935.png" alt="image-20210923014451462" style="zoom:67%;" /></p>
<p>如上图的例子，卷积层输出一个4096维的向量，将其连接在全连接层，输出一个1000维的向量，进行分类。</p>
<p>另外一个方向，将4096维向量映射为一个4维的向量，进行定位，和标出方框大小。</p>
<p>在这里，损失函数由两部分组成，一个是分类的损失函数，另一个是预测坐标和正确坐标的损失函数。</p>
<h3 id="4-2-2多目标检测"><a href="#4-2-2多目标检测" class="headerlink" title="4.2.2多目标检测"></a>4.2.2多目标检测</h3><p>目标个数不确定，不知道输出多少个坐标。所以不能提前给定神经网络应该输出多少维的向量。</p>
<p>所以采用滑动窗口的思路，把每个窗口都当成一张图片。就相当于穷举一张图片所有的区域，分别进行计算。但是这种方法计算了巨大，神经网络不能正常运行。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002941.png" alt="image-20210923015722221" style="zoom:67%;" /></p>
<h4 id="a-区域建议"><a href="#a-区域建议" class="headerlink" title="a.区域建议"></a>a.区域建议</h4><p>提前对图像处理，找出所有潜在可能包含目标的区域。然后再进行分类。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002947.png" alt="image-20210923020227305" style="zoom:67%;" /></p>
<p>区域建议的方法叫做<strong>Selective Search</strong> 。这种方法的主要思想如下：</p>
<ul>
<li>使用一种过分割手段，将图像分割成小区域（1k-2k个）</li>
<li>查看现有的小区域，按照合并规则合并出可能性最高的相邻的两个区域。直至合并成整张图大小的一个区域。</li>
<li>输出所有曾经合并过程的区域，成为候选区域。</li>
</ul>
<h4 id="b-R-CNN"><a href="#b-R-CNN" class="headerlink" title="b.R-CNN"></a>b.R-CNN</h4><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002953.png" alt="image-20210923034448871" style="zoom:67%;" /></p>
<p>主要思路如上图所示：</p>
<ul>
<li>先通过Selective Search方法选出候选区域，大约2k左右个。</li>
<li>由于各个区域大小不同，对各个区域进行缩放，得到尺寸为224的图片。</li>
<li>将尺寸一样的各区域图片输入到卷积神经网络中，进行特征提取。</li>
<li>卷积输出的特征图输入到SVMs线性分类器中进行分类。</li>
<li>特征图还输入到Bbox reg中，可以对之前Selective Search得到的特征框进行修正，从而输出正确的特征框。</li>
</ul>
<p>但是R-CNN的弊病就是计算效率低下，在一张图像中，需要对许多区域都进行特征提取。</p>
<p>所以后来进行改进。</p>
<h4 id="c-Fast-R-CNN"><a href="#c-Fast-R-CNN" class="headerlink" title="c.Fast R-CNN"></a>c.Fast R-CNN</h4><p>与之前的R-CNN不同，该方法是先提取图像的特征，然后再进行Selective Search。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215002959.png" alt="image-20210923040423808" style="zoom:67%;" /></p>
<p>这样就可以避免多次进行特征提取。将特征进行裁剪缩放后，输入到全连接层，进行分类和特征框修正。</p>
<p>在这里需要对特征进行裁剪缩放，是很重要的，为了保证整个神经网络前向信息和反向信息正常传递。全连接层的输入大小应该是一样的。</p>
<h5 id="（1）区域裁剪：Rol-Pool"><a href="#（1）区域裁剪：Rol-Pool" class="headerlink" title="（1）区域裁剪：Rol Pool"></a>（1）区域裁剪：Rol Pool</h5><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003004.png" alt="image-20210923041011020" style="zoom:67%;" /></p>
<p>首先将候选区域映射到特征图上（此处也可以理解为在特征图上直接选择候选区域）</p>
<p>但是候选区域往往不是在整数像素点上，可能是在两个像素点之间。Rol Pool方法就是将这些区域进行微调，调整到像素点上。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003008.png" alt="image-20210923041208609" style="zoom:67%;" /></p>
<p>然后将候选区域粗略的分成面积相等的 $2\times2$ 个子区域。然后对每个子区域做最大池化。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003016.png" alt="image-20210923041414784" style="zoom:67%;" /></p>
<p>最终可以使所有区域的特征尺寸一样。</p>
<p>但是该方法会使特征区域有一点对不齐，会影响效率。</p>
<h5 id="（2）区域裁剪：Rol-Align"><a href="#（2）区域裁剪：Rol-Align" class="headerlink" title="（2）区域裁剪：Rol Align"></a>（2）区域裁剪：Rol Align</h5><p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003026.png" alt="image-20210923041715989" style="zoom:67%;" /></p>
<p>与Rol Pool方法不同的是，不进行归整，利用插值求出个点的值。</p>
<p>也是平均分成4块，每块选取4个点，每个点的值利用插值来计算，在每个点周围选取四个整数像素点，然后通过下面公式进行计算：</p>
<script type="math/tex; mode=display">
f_{x y}=\sum_{i, j=1}^{2} f_{i, j} \max \left(0,1-\left|x-x_{i}\right|\right) \max \left(0,1-\left|y-y_{j}\right|\right)\tag{4.7}</script><p>然后在进行最大池化。</p>
<h4 id="d-Faster-R-CNN"><a href="#d-Faster-R-CNN" class="headerlink" title="d.Faster R-CNN"></a>d.Faster R-CNN</h4><p>在中间特征层后加入区域建议网络RPN（Region Proposal Network），产生候选区域。其他部分保持不变。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003033.png" alt="image-20210923043240791" style="zoom:67%;" /></p>
<p>区域建议：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003039.png" alt="image-20210923043409441" style="zoom:67%;" /></p>
<p>一个直接的思路是，在特征图上直接进行分类。因为特征图尺寸很小，即使每个点都计算，也就是对 $20\times15=300$ 个位置进行分类。但是又有一个问题，就是这个框选取多大。</p>
<p>在每一个位置选取k个不同的尺寸框，共有 $20\times 15k$ 个，分别进行预测，然后对这300k个区域进行是不是目标打分，选取前300个区域作为输入，再输入到全连接层，得到分类结果和预测位置。</p>
<p>这个过程就可以用不同尺寸的卷积核来完成。对特征图的各个锚点进行不同尺度的卷积，得到一个高维的向量，然后将这个高维的向量输入到另一个全连接层，进行打分，判断是否是目标区域。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003044.png" alt="image-20210923045506180" style="zoom:67%;" /></p>
<p>在该网络结构中，共有四个损失：</p>
<ul>
<li>RPN分类损失（目标/非目标）</li>
<li>RPN边界框坐标回归损失</li>
<li>候选区域分类损失</li>
<li>最终边界框坐标回归损失</li>
</ul>
<h3 id="4-2-3总结"><a href="#4-2-3总结" class="headerlink" title="4.2.3总结"></a>4.2.3总结</h3><p>主干网络（特征提取）：</p>
<ul>
<li>VGG</li>
<li>ResNet-101</li>
<li>Inception V2</li>
<li>Inception V3</li>
<li>Iception </li>
<li>ResNet</li>
<li>MobileNet</li>
</ul>
<p>基础框架：</p>
<ul>
<li>两阶段：Faster R-CNN</li>
<li>一阶段：YOLO，SSD</li>
<li>混合：R-FCN</li>
</ul>
<p>一些经验结论：</p>
<ul>
<li>Faster R-CNN的速度偏慢，但精度更高</li>
<li>SSD速度快，相对于Faster R-CNN精度较低</li>
<li>主干网络越宽，深度越深，对性能帮助就越大</li>
</ul>
<h2 id="4-3实例分割"><a href="#4-3实例分割" class="headerlink" title="4.3实例分割"></a>4.3实例分割</h2><p>相对于目标检测，更精确。相对于语义分割，多了实例的概念。</p>
<p>Mask R-CNN</p>
<p>就是对目标检测的区域再进行一次卷积，然后上采样，对每一个像素点进行分类。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003052.png" alt="image-20210923051730140" style="zoom:67%;" /></p>
<h1 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5.可视化"></a>5.可视化</h1><p>本章是弄清楚卷积神经网络在干什么。</p>
<h2 id="5-1第一层卷积核"><a href="#5-1第一层卷积核" class="headerlink" title="5.1第一层卷积核"></a>5.1第一层卷积核</h2><p>第一层卷积核从图像上抽取了许多基元。</p>
<p>由于网络第一层的卷积核深度是3维的，因此我们可以将其作为RGB图来看待，而对于深层的网络，卷积核深度不止是3维，那么我们只能将其作为灰度图处理，对于高维特征，我们可能就比较难看出它在原图中寻找什么东西了，因为它是许多低维特征的集合</p>
<p>第一层卷积核可视化：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003059.png" alt="image-20210923052225841" style="zoom: 50%;" /></p>
<h2 id="5-2最后一层"><a href="#5-2最后一层" class="headerlink" title="5.2最后一层"></a>5.2最后一层</h2><p>对于网络的最后一层的特征往往就是一副图像整体的特征，如果我们对于一副测试的图片，寻找在特征空间最相近的图，那么我们一般能得到同一类的物体。假设卷积网络最后一层输出的是一个4096维的向量，然后我们在数据集中，把和一张图片向量相近的图片放在一起，如下图所示</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216014144.png" alt="20211018065310.png"></p>
<p>可以看到都是同一类东西。然后再通过降维的方法，把这个4096向量降为2维，在平面上用坐标轴表示出来</p>
<p><img src="https://piggyhero.gitee.io/pic/img/20211216013644.png" alt="20211018065323.png?raw=true"></p>
<p>我们可以看出色调偏绿的图像都集中在了左下角，偏蓝的图像都集中在了右上角，这也意味着网络确实学习到了图像中的某些特征，并能利用特征进行分类。</p>
<h2 id="5-3-探究中间层的卷积"><a href="#5-3-探究中间层的卷积" class="headerlink" title="5.3 探究中间层的卷积"></a>5.3 探究中间层的卷积</h2><p>如果我们取网络中某一层某一个特征图的某一个特定神经元比较大的值，那么它会对应一个作用域，如果我们将这个作用域对应在原图的部分取出来，我们会发现这些部分是类似的，原因就是这个神经元是在图像中寻找某些特定的特征</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003134.png" alt="image-20210923163638688" style="zoom:67%;" /></p>
<p>除此以外我们还能做遮挡实验，将一副图像进行遮挡，然后观察最后分类值的变化。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003148.png" alt="image-20210923054405208" style="zoom: 33%;" /></p>
<p>不同的卷积核关注图像中不同的部分。上面这幅图说明了，卷积核是感受大象的面部信息。</p>
<h3 id="5-3-1输出对输入求导"><a href="#5-3-1输出对输入求导" class="headerlink" title="5.3.1输出对输入求导"></a>5.3.1输出对输入求导</h3><p>为了求得不同像素对图像分类的影响，我们可以求显著图，也就是改变一个像素点，看其对分类结果有多大的影响（实际的方法是求出分类输出值对每个像素的梯度），然后将这些点用二值化图标注出来。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003208.png" alt="image-20210923054841282" style="zoom:33%;" /></p>
<p>我们不仅可以求最终分类值对每个像素的梯度，还可以求某个神经元对作用域内所有像素的梯度，代表着像素对神经元输出值的影响程度。</p>
<h3 id="5-3-2改变输入值"><a href="#5-3-2改变输入值" class="headerlink" title="5.3.2改变输入值"></a>5.3.2改变输入值</h3><p>前面的方法是求输出值对输入值的梯度，来可视化梯度。但是这种方法的可视化还是不那么明显。现在我们用输出值对输入值求导，得到梯度，然后按照梯度方向改变输入值，这样可以得到当某个神经元输出最大值时，输入图像的样子。</p>
<p>具体的方法是应用梯度上升：输出函数是某个神经元的输出值加上正则项，求出它对每个像素的梯度，然后按梯度上升的方向改变像素的值。正则化的作用是使得图像能更加像真实的图。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003219.png" alt="image-20210923164436588" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003409.png" alt="image-20211018071615381" style="zoom: 33%;" /></p>
<p>如果我们最大化最终的分类值，可以得到以下结果，我们可以看到图像确实具有一些该分类的形状。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003225.png" alt="image-20210923164650811" style="zoom:67%;" /></p>
<h2 id="5-4改变图像风格"><a href="#5-4改变图像风格" class="headerlink" title="5.4改变图像风格"></a>5.4改变图像风格</h2><p>另外我们还可以求出一副图像的分类，然后改变像素值，最大化其他分类的值，我们期望的是图像能够由一个分类变为另外一个分类。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003237.png" alt="image-20210923164939985" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003232.png" alt="image-20211018065441124" style="zoom:67%;" /></p>
<p>如上图所示，最大化其他分类，就是让这幅图像中包含其他类别的信息，在原图的基础上，就可以得到上图的效果。</p>
<p>想变成这种效果有两种方法。</p>
<h3 id="5-4-1特征反演"><a href="#5-4-1特征反演" class="headerlink" title="5.4.1特征反演"></a>5.4.1特征反演</h3><p>特征反演与上述方法不同，这种方法针对某个特定特征，会寻找一副图像，使得其特征向量与给定的特征向量距离最小。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003243.png" alt="image-20210923165416169" style="zoom:50%;" /></p>
<p>下面是这种方法的结果。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003248.png" alt="image-20210923165450104" style="zoom:67%;" /></p>
<h3 id="5-4-2纹理合成"><a href="#5-4-2纹理合成" class="headerlink" title="5.4.2纹理合成"></a>5.4.2纹理合成</h3><p>纹理合成是计算机视觉中一个经典的算法，随着深度学习的发展，我们也有了更好的解决方案，我们取某一层网络中纵向的两个向量，每个向量代表同一个位置的不同特征，再将这两个向量相乘得到一个矩阵。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003256.png" alt="img" style="zoom:67%;" /></p>
<p>我们两两遍历特征图中的向量，再取平均值，得到的矩阵叫做Gram矩阵，由于我们的矩阵是所有位置的向量相乘取平均的结果，因此我们消除了空间位置信息，保留了特征之间的相关关系（特征数为C）。</p>
<p>人工纹理合成算法与特征反演不同的地方就在此。特征转换的目标是让两个图像的特定层特征最相似，而人工纹理合成是将特征转换为Gram矩阵，然后使得两张图像Gram矩阵最相似。在实际应用的过程中，我们往往会将多层网络的Gram矩阵相似性都考虑进最终结果。</p>
<p>一旦有了神经网络上进行纹理合成，就可以通过梯度上升来合成与原始图像纹理相匹配的新的图像。</p>
<h3 id="5-4-3风格转换"><a href="#5-4-3风格转换" class="headerlink" title="5.4.3风格转换"></a>5.4.3风格转换</h3><p>结合了以上两点我们就能做风格转换了。</p>
<p>当把格拉姆矩阵匹配的纹理合成方法与特征匹配的特征反演法结合起来会产生非常棒的风格迁移算法；在风格迁移中，把两张图像作为输入图像，第一步选取其中一张图像作为内容图像，它引导我们生成图像的主体，同样的风格图像负责生成图像的纹理或风格，然后共同做特征识别，通过最小化内容图像的特征重构损失以及风格图像的格拉姆矩阵损失，就能得到非常棒的图像。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003304.png" alt="image-20210923235300467" style="zoom:67%;" /></p>
<h1 id="6-生成网络"><a href="#6-生成网络" class="headerlink" title="6.生成网络"></a>6.生成网络</h1><h2 id="6-1有监督学习与无监督学习"><a href="#6-1有监督学习与无监督学习" class="headerlink" title="6.1有监督学习与无监督学习"></a>6.1有监督学习与无监督学习</h2><p>有监督学习我们都很熟悉了，我们有数据x和标签y，我们在有监督学习中学习到一个函数可以将数据x映射到标签y，标签可以有很多形式。典型的监督学习有：分类问题中输入一张图片，输出图片的分类；目标检测中输入一张图片，输出目标物体的边框；语义分割中，给每个像素都打上标签。下面说一下无监督学习。</p>
<p>无监督学习在我们只有一些没有标签的训练数据的情况下，学习数据中隐含的结构。</p>
<h3 id="6-1-1聚类"><a href="#6-1-1聚类" class="headerlink" title="6.1.1聚类"></a>6.1.1聚类</h3><p>聚类是找到数据的分组，组内数据在某种度量方式下是相似的。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003310.png" alt="image-20210924014900654" style="zoom:67%;" /></p>
<h3 id="6-1-2降维"><a href="#6-1-2降维" class="headerlink" title="6.1.2降维"></a>6.1.2降维</h3><p>把高维数据降到低维。在低维空间中保留高维空间中的主要信息。</p>
<p>常用方法，主成分分析：</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003317.png" alt="image-20210924015151567" style="zoom:67%;" /></p>
<p>左图可以看见，在3D空间中，有一些数据在平面垂直方向变化不大。因此可以将该方向的数据忽略掉，仅保留一些显著变化的数据。</p>
<p>另一种方法，特征学习，采用自编码器的结构</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003323.png" alt="image-20210924015451169" style="zoom:67%;" /></p>
<p>在这里前半部分和神经网络类似，提取出特征。不同的是，还可以把低维数据还原回去。该方法可以进行非线性的降维，之前主成分分析是线性的降维。</p>
<h3 id="6-1-3密度估计"><a href="#6-1-3密度估计" class="headerlink" title="6.1.3密度估计"></a>6.1.3密度估计</h3><p>通过样本数据，来估计数据的内在概率分布情况。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003328.png" alt="image-20210924020048964" style="zoom:67%;" /></p>
<h2 id="6-2生成模型"><a href="#6-2生成模型" class="headerlink" title="6.2生成模型"></a>6.2生成模型</h2><p>给定训练集，产生与训练集同分布的新样本。</p>
<p><img src="https://gitee.com/piggyhero/pic/raw/master/img/20211215003334.png" alt="image-20210924020532869" style="zoom:67%;" /></p>
<p>我们希望可以学到一个模型 $p_{model}(x)$ ，其与样本的分布 $p_{data}(x)$ 相近。</p>
<p>无监督学习里的一个核心问题就是<strong>密度估计</strong>问题。</p>
<p>有两种思路：</p>
<ul>
<li>显示的密度估计：显示的定义并求解分布 $p_{model}(x)$ 。</li>
<li>隐式的密度估计：学习一个模型 $p_{model}(x)$ ，而无需显示的定义它。</li>
</ul>
<h2 id="6-3PixelRNN与PixelCNN"><a href="#6-3PixelRNN与PixelCNN" class="headerlink" title="6.3PixelRNN与PixelCNN"></a>6.3PixelRNN与PixelCNN</h2><h2 id="6-4变分自编码器"><a href="#6-4变分自编码器" class="headerlink" title="6.4变分自编码器"></a>6.4变分自编码器</h2><h2 id="6-5GAN"><a href="#6-5GAN" class="headerlink" title="6.5GAN"></a>6.5GAN</h2>]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
</search>
